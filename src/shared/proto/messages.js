/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @exports google.protobuf
         * @namespace
         */
        var protobuf = {};

        protobuf.Duration = (function() {

            /**
             * Properties of a Duration.
             * @typedef google.protobuf.Duration$Properties
             * @type {Object}
             * @property {number|Long} [seconds] Duration seconds.
             * @property {number} [nanos] Duration nanos.
             */

            /**
             * Constructs a new Duration.
             * @exports google.protobuf.Duration
             * @constructor
             * @param {google.protobuf.Duration$Properties=} [properties] Properties to set
             */
            function Duration(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Duration seconds.
             * @type {number|Long}
             */
            Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Duration nanos.
             * @type {number}
             */
            Duration.prototype.nanos = 0;

            /**
             * Creates a new Duration instance using the specified properties.
             * @param {google.protobuf.Duration$Properties=} [properties] Properties to set
             * @returns {google.protobuf.Duration} Duration instance
             */
            Duration.create = function create(properties) {
                return new Duration(properties);
            };

            /**
             * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @param {google.protobuf.Duration$Properties} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @param {google.protobuf.Duration$Properties} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Duration message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Duration();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Duration message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Duration message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Duration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Duration message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Duration} Duration
             */
            Duration.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Duration)
                    return object;
                var message = new $root.google.protobuf.Duration();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a Duration message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.Duration.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Duration} Duration
             */
            Duration.from = Duration.fromObject;

            /**
             * Creates a plain object from a Duration message. Also converts values to other types if specified.
             * @param {google.protobuf.Duration} message Duration
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Duration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Creates a plain object from this Duration message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Duration.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Duration to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Duration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Duration;
        })();

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @typedef google.protobuf.Timestamp$Properties
             * @type {Object}
             * @property {number|Long} [seconds] Timestamp seconds.
             * @property {number} [nanos] Timestamp nanos.
             */

            /**
             * Constructs a new Timestamp.
             * @exports google.protobuf.Timestamp
             * @constructor
             * @param {google.protobuf.Timestamp$Properties=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @type {number|Long}
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @type {number}
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @param {google.protobuf.Timestamp$Properties=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */
            Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @param {google.protobuf.Timestamp$Properties} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @param {google.protobuf.Timestamp$Properties} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Timestamp message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp)
                    return object;
                var message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.Timestamp.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.from = Timestamp.fromObject;

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Creates a plain object from this Timestamp message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Timestamp to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Timestamp;
        })();

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @typedef google.protobuf.FileDescriptorSet$Properties
             * @type {Object}
             * @property {Array.<google.protobuf.FileDescriptorProto$Properties>} [file] FileDescriptorSet file.
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @exports google.protobuf.FileDescriptorSet
             * @constructor
             * @param {google.protobuf.FileDescriptorSet$Properties=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @type {Array.<google.protobuf.FileDescriptorProto$Properties>}
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @param {google.protobuf.FileDescriptorSet$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            FileDescriptorSet.create = function create(properties) {
                return new FileDescriptorSet(properties);
            };

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @param {google.protobuf.FileDescriptorSet$Properties} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (var i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @param {google.protobuf.FileDescriptorSet$Properties} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.file && message.file.length))
                            message.file = [];
                        message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorSet message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (var i = 0; i < message.file.length; ++i) {
                        var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                var message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (var i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FileDescriptorSet.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.from = FileDescriptorSet.fromObject;

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (var j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this FileDescriptorSet message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @typedef google.protobuf.FileDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] FileDescriptorProto name.
             * @property {string} ["package"] FileDescriptorProto package.
             * @property {Array.<string>} [dependency] FileDescriptorProto dependency.
             * @property {Array.<number>} [publicDependency] FileDescriptorProto publicDependency.
             * @property {Array.<number>} [weakDependency] FileDescriptorProto weakDependency.
             * @property {Array.<google.protobuf.DescriptorProto$Properties>} [messageType] FileDescriptorProto messageType.
             * @property {Array.<google.protobuf.EnumDescriptorProto$Properties>} [enumType] FileDescriptorProto enumType.
             * @property {Array.<google.protobuf.ServiceDescriptorProto$Properties>} [service] FileDescriptorProto service.
             * @property {Array.<google.protobuf.FieldDescriptorProto$Properties>} [extension] FileDescriptorProto extension.
             * @property {google.protobuf.FileOptions$Properties} [options] FileDescriptorProto options.
             * @property {google.protobuf.SourceCodeInfo$Properties} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo.
             * @property {string} [syntax] FileDescriptorProto syntax.
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @exports google.protobuf.FileDescriptorProto
             * @constructor
             * @param {google.protobuf.FileDescriptorProto$Properties=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @type {string}
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @type {string}
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @type {Array.<string>}
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @type {Array.<number>}
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @type {Array.<number>}
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @type {Array.<google.protobuf.DescriptorProto$Properties>}
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @type {Array.<google.protobuf.EnumDescriptorProto$Properties>}
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @type {Array.<google.protobuf.ServiceDescriptorProto$Properties>}
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @type {Array.<google.protobuf.FieldDescriptorProto$Properties>}
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @type {(google.protobuf.FileOptions$Properties|null)}
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @type {(google.protobuf.SourceCodeInfo$Properties|null)}
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @type {string}
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @param {google.protobuf.FileDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            FileDescriptorProto.create = function create(properties) {
                return new FileDescriptorProto(properties);
            };

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.FileDescriptorProto$Properties} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && message.hasOwnProperty("package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (var i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.messageType != null && message.messageType.length)
                    for (var i = 0; i < message.messageType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (var i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (var i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (var i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.publicDependency != null && message.publicDependency.length)
                    for (var i = 0; i < message.publicDependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                if (message.weakDependency != null && message.weakDependency.length)
                    for (var i = 0; i < message.weakDependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.FileDescriptorProto$Properties} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message["package"] = reader.string();
                        break;
                    case 3:
                        if (!(message.dependency && message.dependency.length))
                            message.dependency = [];
                        message.dependency.push(reader.string());
                        break;
                    case 10:
                        if (!(message.publicDependency && message.publicDependency.length))
                            message.publicDependency = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.publicDependency.push(reader.int32());
                        } else
                            message.publicDependency.push(reader.int32());
                        break;
                    case 11:
                        if (!(message.weakDependency && message.weakDependency.length))
                            message.weakDependency = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weakDependency.push(reader.int32());
                        } else
                            message.weakDependency.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.messageType && message.messageType.length))
                            message.messageType = [];
                        message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.syntax = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (var i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (var i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (var i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (var i = 0; i < message.messageType.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (var i = 0; i < message.enumType.length; ++i) {
                        var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (var i = 0; i < message.service.length; ++i) {
                        var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (var i = 0; i < message.extension.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    var error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (var i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.publicDependency) {
                    if (!Array.isArray(object.publicDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                    message.publicDependency = [];
                    for (var i = 0; i < object.publicDependency.length; ++i)
                        message.publicDependency[i] = object.publicDependency[i] | 0;
                }
                if (object.weakDependency) {
                    if (!Array.isArray(object.weakDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                    message.weakDependency = [];
                    for (var i = 0; i < object.weakDependency.length; ++i)
                        message.weakDependency[i] = object.weakDependency[i] | 0;
                }
                if (object.messageType) {
                    if (!Array.isArray(object.messageType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                    message.messageType = [];
                    for (var i = 0; i < object.messageType.length; ++i) {
                        if (typeof object.messageType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                        message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (var i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (var i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (var i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.sourceCodeInfo != null) {
                    if (typeof object.sourceCodeInfo !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                    message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                return message;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FileDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.from = FileDescriptorProto.fromObject;

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.messageType = [];
                    object.enumType = [];
                    object.service = [];
                    object.extension = [];
                    object.publicDependency = [];
                    object.weakDependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.sourceCodeInfo = null;
                    object.syntax = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (var j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.messageType && message.messageType.length) {
                    object.messageType = [];
                    for (var j = 0; j < message.messageType.length; ++j)
                        object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (var j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (var j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (var j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                if (message.publicDependency && message.publicDependency.length) {
                    object.publicDependency = [];
                    for (var j = 0; j < message.publicDependency.length; ++j)
                        object.publicDependency[j] = message.publicDependency[j];
                }
                if (message.weakDependency && message.weakDependency.length) {
                    object.weakDependency = [];
                    for (var j = 0; j < message.weakDependency.length; ++j)
                        object.weakDependency[j] = message.weakDependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                return object;
            };

            /**
             * Creates a plain object from this FileDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @typedef google.protobuf.DescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] DescriptorProto name.
             * @property {Array.<google.protobuf.FieldDescriptorProto$Properties>} [field] DescriptorProto field.
             * @property {Array.<google.protobuf.FieldDescriptorProto$Properties>} [extension] DescriptorProto extension.
             * @property {Array.<google.protobuf.DescriptorProto$Properties>} [nestedType] DescriptorProto nestedType.
             * @property {Array.<google.protobuf.EnumDescriptorProto$Properties>} [enumType] DescriptorProto enumType.
             * @property {Array.<google.protobuf.DescriptorProto.ExtensionRange$Properties>} [extensionRange] DescriptorProto extensionRange.
             * @property {Array.<google.protobuf.OneofDescriptorProto$Properties>} [oneofDecl] DescriptorProto oneofDecl.
             * @property {google.protobuf.MessageOptions$Properties} [options] DescriptorProto options.
             * @property {Array.<google.protobuf.DescriptorProto.ReservedRange$Properties>} [reservedRange] DescriptorProto reservedRange.
             * @property {Array.<string>} [reservedName] DescriptorProto reservedName.
             */

            /**
             * Constructs a new DescriptorProto.
             * @exports google.protobuf.DescriptorProto
             * @constructor
             * @param {google.protobuf.DescriptorProto$Properties=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @type {string}
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @type {Array.<google.protobuf.FieldDescriptorProto$Properties>}
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @type {Array.<google.protobuf.FieldDescriptorProto$Properties>}
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @type {Array.<google.protobuf.DescriptorProto$Properties>}
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @type {Array.<google.protobuf.EnumDescriptorProto$Properties>}
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @type {Array.<google.protobuf.DescriptorProto.ExtensionRange$Properties>}
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @type {Array.<google.protobuf.OneofDescriptorProto$Properties>}
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @type {(google.protobuf.MessageOptions$Properties|null)}
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @type {Array.<google.protobuf.DescriptorProto.ReservedRange$Properties>}
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @type {Array.<string>}
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @param {google.protobuf.DescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            DescriptorProto.create = function create(properties) {
                return new DescriptorProto(properties);
            };

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @param {google.protobuf.DescriptorProto$Properties} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (var i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nestedType != null && message.nestedType.length)
                    for (var i = 0; i < message.nestedType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (var i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extensionRange != null && message.extensionRange.length)
                    for (var i = 0; i < message.extensionRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (var i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneofDecl != null && message.oneofDecl.length)
                    for (var i = 0; i < message.oneofDecl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (var i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (var i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                return writer;
            };

            /**
             * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @param {google.protobuf.DescriptorProto$Properties} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.field && message.field.length))
                            message.field = [];
                        message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.nestedType && message.nestedType.length))
                            message.nestedType = [];
                        message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.extensionRange && message.extensionRange.length))
                            message.extensionRange = [];
                        message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.oneofDecl && message.oneofDecl.length))
                            message.oneofDecl = [];
                        message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.reservedRange && message.reservedRange.length))
                            message.reservedRange = [];
                        message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.reservedName && message.reservedName.length))
                            message.reservedName = [];
                        message.reservedName.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (var i = 0; i < message.field.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (var i = 0; i < message.extension.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (var i = 0; i < message.nestedType.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (var i = 0; i < message.enumType.length; ++i) {
                        var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (var i = 0; i < message.extensionRange.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (var i = 0; i < message.oneofDecl.length; ++i) {
                        var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (var i = 0; i < message.reservedRange.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (var i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                var message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (var i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (var i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nestedType) {
                    if (!Array.isArray(object.nestedType))
                        throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                    message.nestedType = [];
                    for (var i = 0; i < object.nestedType.length; ++i) {
                        if (typeof object.nestedType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                        message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (var i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.extensionRange) {
                    if (!Array.isArray(object.extensionRange))
                        throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                    message.extensionRange = [];
                    for (var i = 0; i < object.extensionRange.length; ++i) {
                        if (typeof object.extensionRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                        message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                    }
                }
                if (object.oneofDecl) {
                    if (!Array.isArray(object.oneofDecl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                    message.oneofDecl = [];
                    for (var i = 0; i < object.oneofDecl.length; ++i) {
                        if (typeof object.oneofDecl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                        message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (var i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (var i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.DescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.from = DescriptorProto.fromObject;

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nestedType = [];
                    object.enumType = [];
                    object.extensionRange = [];
                    object.extension = [];
                    object.oneofDecl = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (var j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nestedType && message.nestedType.length) {
                    object.nestedType = [];
                    for (var j = 0; j < message.nestedType.length; ++j)
                        object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (var j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.extensionRange && message.extensionRange.length) {
                    object.extensionRange = [];
                    for (var j = 0; j < message.extensionRange.length; ++j)
                        object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (var j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneofDecl && message.oneofDecl.length) {
                    object.oneofDecl = [];
                    for (var j = 0; j < message.oneofDecl.length; ++j)
                        object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                }
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (var j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (var j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Creates a plain object from this DescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @typedef google.protobuf.DescriptorProto.ExtensionRange$Properties
                 * @type {Object}
                 * @property {number} [start] ExtensionRange start.
                 * @property {number} [end] ExtensionRange end.
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @exports google.protobuf.DescriptorProto.ExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.ExtensionRange$Properties=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @type {number}
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @type {number}
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @param {google.protobuf.DescriptorProto.ExtensionRange$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                ExtensionRange.create = function create(properties) {
                    return new ExtensionRange(properties);
                };

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @param {google.protobuf.DescriptorProto.ExtensionRange$Properties} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @param {google.protobuf.DescriptorProto.ExtensionRange$Properties} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExtensionRange message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.DescriptorProto.ExtensionRange.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.from = ExtensionRange.fromObject;

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Creates a plain object from this ExtensionRange message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @typedef google.protobuf.DescriptorProto.ReservedRange$Properties
                 * @type {Object}
                 * @property {number} [start] ReservedRange start.
                 * @property {number} [end] ReservedRange end.
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @exports google.protobuf.DescriptorProto.ReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.ReservedRange$Properties=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @type {number}
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @type {number}
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @param {google.protobuf.DescriptorProto.ReservedRange$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                ReservedRange.create = function create(properties) {
                    return new ReservedRange(properties);
                };

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @param {google.protobuf.DescriptorProto.ReservedRange$Properties} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @param {google.protobuf.DescriptorProto.ReservedRange$Properties} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReservedRange message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.DescriptorProto.ReservedRange.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.from = ReservedRange.fromObject;

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Creates a plain object from this ReservedRange message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @typedef google.protobuf.FieldDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] FieldDescriptorProto name.
             * @property {number} [number] FieldDescriptorProto number.
             * @property {google.protobuf.FieldDescriptorProto.Label} [label] FieldDescriptorProto label.
             * @property {google.protobuf.FieldDescriptorProto.Type} [type] FieldDescriptorProto type.
             * @property {string} [typeName] FieldDescriptorProto typeName.
             * @property {string} [extendee] FieldDescriptorProto extendee.
             * @property {string} [defaultValue] FieldDescriptorProto defaultValue.
             * @property {number} [oneofIndex] FieldDescriptorProto oneofIndex.
             * @property {string} [jsonName] FieldDescriptorProto jsonName.
             * @property {google.protobuf.FieldOptions$Properties} [options] FieldDescriptorProto options.
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @exports google.protobuf.FieldDescriptorProto
             * @constructor
             * @param {google.protobuf.FieldDescriptorProto$Properties=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @type {string}
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @type {number}
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @type {google.protobuf.FieldDescriptorProto.Label}
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @type {google.protobuf.FieldDescriptorProto.Type}
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @type {string}
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @type {string}
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @type {string}
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @type {number}
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @type {string}
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @type {(google.protobuf.FieldOptions$Properties|null)}
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @param {google.protobuf.FieldDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            FieldDescriptorProto.create = function create(properties) {
                return new FieldDescriptorProto(properties);
            };

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.FieldDescriptorProto$Properties} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && message.hasOwnProperty("label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.label);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.type);
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                return writer;
            };

            /**
             * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.FieldDescriptorProto$Properties} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.number = reader.int32();
                        break;
                    case 4:
                        message.label = reader.uint32();
                        break;
                    case 5:
                        message.type = reader.uint32();
                        break;
                    case 6:
                        message.typeName = reader.string();
                        break;
                    case 2:
                        message.extendee = reader.string();
                        break;
                    case 7:
                        message.defaultValue = reader.string();
                        break;
                    case 9:
                        message.oneofIndex = reader.int32();
                        break;
                    case 10:
                        message.jsonName = reader.string();
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                }
                switch (object.type) {
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.typeName != null)
                    message.typeName = String(object.typeName);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.defaultValue != null)
                    message.defaultValue = String(object.defaultValue);
                if (object.oneofIndex != null)
                    message.oneofIndex = object.oneofIndex | 0;
                if (object.jsonName != null)
                    message.jsonName = String(object.jsonName);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FieldDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.from = FieldDescriptorProto.fromObject;

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.typeName = "";
                    object.defaultValue = "";
                    object.options = null;
                    object.oneofIndex = 0;
                    object.jsonName = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    object.typeName = message.typeName;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = message.defaultValue;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    object.oneofIndex = message.oneofIndex;
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    object.jsonName = message.jsonName;
                return object;
            };

            /**
             * Creates a plain object from this FieldDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name Type
             * @memberof google.protobuf.FieldDescriptorProto
             * @enum {number}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name Label
             * @memberof google.protobuf.FieldDescriptorProto
             * @enum {number}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @typedef google.protobuf.OneofDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] OneofDescriptorProto name.
             * @property {google.protobuf.OneofOptions$Properties} [options] OneofDescriptorProto options.
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @exports google.protobuf.OneofDescriptorProto
             * @constructor
             * @param {google.protobuf.OneofDescriptorProto$Properties=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @type {string}
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @type {(google.protobuf.OneofOptions$Properties|null)}
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @param {google.protobuf.OneofDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            OneofDescriptorProto.create = function create(properties) {
                return new OneofDescriptorProto(properties);
            };

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.OneofDescriptorProto$Properties} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.OneofDescriptorProto$Properties} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.OneofDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.from = OneofDescriptorProto.fromObject;

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Creates a plain object from this OneofDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @typedef google.protobuf.EnumDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] EnumDescriptorProto name.
             * @property {Array.<google.protobuf.EnumValueDescriptorProto$Properties>} [value] EnumDescriptorProto value.
             * @property {google.protobuf.EnumOptions$Properties} [options] EnumDescriptorProto options.
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @exports google.protobuf.EnumDescriptorProto
             * @constructor
             * @param {google.protobuf.EnumDescriptorProto$Properties=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @type {string}
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @type {Array.<google.protobuf.EnumValueDescriptorProto$Properties>}
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @type {(google.protobuf.EnumOptions$Properties|null)}
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @param {google.protobuf.EnumDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            EnumDescriptorProto.create = function create(properties) {
                return new EnumDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.EnumDescriptorProto$Properties} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (var i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.EnumDescriptorProto$Properties} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i) {
                        var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.EnumDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.from = EnumDescriptorProto.fromObject;

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Creates a plain object from this EnumDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @typedef google.protobuf.EnumValueDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] EnumValueDescriptorProto name.
             * @property {number} [number] EnumValueDescriptorProto number.
             * @property {google.protobuf.EnumValueOptions$Properties} [options] EnumValueDescriptorProto options.
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @exports google.protobuf.EnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.EnumValueDescriptorProto$Properties=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @type {string}
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @type {number}
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @type {(google.protobuf.EnumValueOptions$Properties|null)}
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @param {google.protobuf.EnumValueDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            EnumValueDescriptorProto.create = function create(properties) {
                return new EnumValueDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.EnumValueDescriptorProto$Properties} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.EnumValueDescriptorProto$Properties} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.number = reader.int32();
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.EnumValueDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.from = EnumValueDescriptorProto.fromObject;

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Creates a plain object from this EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @typedef google.protobuf.ServiceDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] ServiceDescriptorProto name.
             * @property {Array.<google.protobuf.MethodDescriptorProto$Properties>} [method] ServiceDescriptorProto method.
             * @property {google.protobuf.ServiceOptions$Properties} [options] ServiceDescriptorProto options.
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @exports google.protobuf.ServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.ServiceDescriptorProto$Properties=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @type {string}
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @type {Array.<google.protobuf.MethodDescriptorProto$Properties>}
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @type {(google.protobuf.ServiceOptions$Properties|null)}
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @param {google.protobuf.ServiceDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            ServiceDescriptorProto.create = function create(properties) {
                return new ServiceDescriptorProto(properties);
            };

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.ServiceDescriptorProto$Properties} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (var i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.ServiceDescriptorProto$Properties} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.method && message.method.length))
                            message.method = [];
                        message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (var i = 0; i < message.method.length; ++i) {
                        var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (var i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.ServiceDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.from = ServiceDescriptorProto.fromObject;

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (var j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Creates a plain object from this ServiceDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @typedef google.protobuf.MethodDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] MethodDescriptorProto name.
             * @property {string} [inputType] MethodDescriptorProto inputType.
             * @property {string} [outputType] MethodDescriptorProto outputType.
             * @property {google.protobuf.MethodOptions$Properties} [options] MethodDescriptorProto options.
             * @property {boolean} [clientStreaming] MethodDescriptorProto clientStreaming.
             * @property {boolean} [serverStreaming] MethodDescriptorProto serverStreaming.
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @exports google.protobuf.MethodDescriptorProto
             * @constructor
             * @param {google.protobuf.MethodDescriptorProto$Properties=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @type {string}
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @type {string}
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @type {string}
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @type {(google.protobuf.MethodOptions$Properties|null)}
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @type {boolean}
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @type {boolean}
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @param {google.protobuf.MethodDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            MethodDescriptorProto.create = function create(properties) {
                return new MethodDescriptorProto(properties);
            };

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.MethodDescriptorProto$Properties} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                return writer;
            };

            /**
             * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.MethodDescriptorProto$Properties} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.inputType = reader.string();
                        break;
                    case 3:
                        message.outputType = reader.string();
                        break;
                    case 4:
                        message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.clientStreaming = reader.bool();
                        break;
                    case 6:
                        message.serverStreaming = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.inputType != null)
                    message.inputType = String(object.inputType);
                if (object.outputType != null)
                    message.outputType = String(object.outputType);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.clientStreaming != null)
                    message.clientStreaming = Boolean(object.clientStreaming);
                if (object.serverStreaming != null)
                    message.serverStreaming = Boolean(object.serverStreaming);
                return message;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.MethodDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.from = MethodDescriptorProto.fromObject;

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.inputType = "";
                    object.outputType = "";
                    object.options = null;
                    object.clientStreaming = false;
                    object.serverStreaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    object.inputType = message.inputType;
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = message.outputType;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    object.clientStreaming = message.clientStreaming;
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    object.serverStreaming = message.serverStreaming;
                return object;
            };

            /**
             * Creates a plain object from this MethodDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @typedef google.protobuf.FileOptions$Properties
             * @type {Object}
             * @property {string} [javaPackage] FileOptions javaPackage.
             * @property {string} [javaOuterClassname] FileOptions javaOuterClassname.
             * @property {boolean} [javaMultipleFiles] FileOptions javaMultipleFiles.
             * @property {boolean} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash.
             * @property {boolean} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8.
             * @property {google.protobuf.FileOptions.OptimizeMode} [optimizeFor] FileOptions optimizeFor.
             * @property {string} [goPackage] FileOptions goPackage.
             * @property {boolean} [ccGenericServices] FileOptions ccGenericServices.
             * @property {boolean} [javaGenericServices] FileOptions javaGenericServices.
             * @property {boolean} [pyGenericServices] FileOptions pyGenericServices.
             * @property {boolean} [deprecated] FileOptions deprecated.
             * @property {boolean} [ccEnableArenas] FileOptions ccEnableArenas.
             * @property {string} [objcClassPrefix] FileOptions objcClassPrefix.
             * @property {string} [csharpNamespace] FileOptions csharpNamespace.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpretedOption] FileOptions uninterpretedOption.
             */

            /**
             * Constructs a new FileOptions.
             * @exports google.protobuf.FileOptions
             * @constructor
             * @param {google.protobuf.FileOptions$Properties=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @type {string}
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @type {string}
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @type {boolean}
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @type {boolean}
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @type {boolean}
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @type {google.protobuf.FileOptions.OptimizeMode}
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @type {string}
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @type {boolean}
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @type {boolean}
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @type {boolean}
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions deprecated.
             * @type {boolean}
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @type {boolean}
             */
            FileOptions.prototype.ccEnableArenas = false;

            /**
             * FileOptions objcClassPrefix.
             * @type {string}
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @type {string}
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @param {google.protobuf.FileOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            FileOptions.create = function create(properties) {
                return new FileOptions(properties);
            };

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @param {google.protobuf.FileOptions$Properties} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.optimizeFor);
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @param {google.protobuf.FileOptions$Properties} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.javaPackage = reader.string();
                        break;
                    case 8:
                        message.javaOuterClassname = reader.string();
                        break;
                    case 10:
                        message.javaMultipleFiles = reader.bool();
                        break;
                    case 20:
                        message.javaGenerateEqualsAndHash = reader.bool();
                        break;
                    case 27:
                        message.javaStringCheckUtf8 = reader.bool();
                        break;
                    case 9:
                        message.optimizeFor = reader.uint32();
                        break;
                    case 11:
                        message.goPackage = reader.string();
                        break;
                    case 16:
                        message.ccGenericServices = reader.bool();
                        break;
                    case 17:
                        message.javaGenericServices = reader.bool();
                        break;
                    case 18:
                        message.pyGenericServices = reader.bool();
                        break;
                    case 23:
                        message.deprecated = reader.bool();
                        break;
                    case 31:
                        message.ccEnableArenas = reader.bool();
                        break;
                    case 36:
                        message.objcClassPrefix = reader.string();
                        break;
                    case 37:
                        message.csharpNamespace = reader.string();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                var message = new $root.google.protobuf.FileOptions();
                if (object.javaPackage != null)
                    message.javaPackage = String(object.javaPackage);
                if (object.javaOuterClassname != null)
                    message.javaOuterClassname = String(object.javaOuterClassname);
                if (object.javaMultipleFiles != null)
                    message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                if (object.javaGenerateEqualsAndHash != null)
                    message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                if (object.javaStringCheckUtf8 != null)
                    message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                switch (object.optimizeFor) {
                case "SPEED":
                case 1:
                    message.optimizeFor = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimizeFor = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimizeFor = 3;
                    break;
                }
                if (object.goPackage != null)
                    message.goPackage = String(object.goPackage);
                if (object.ccGenericServices != null)
                    message.ccGenericServices = Boolean(object.ccGenericServices);
                if (object.javaGenericServices != null)
                    message.javaGenericServices = Boolean(object.javaGenericServices);
                if (object.pyGenericServices != null)
                    message.pyGenericServices = Boolean(object.pyGenericServices);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.ccEnableArenas != null)
                    message.ccEnableArenas = Boolean(object.ccEnableArenas);
                if (object.objcClassPrefix != null)
                    message.objcClassPrefix = String(object.objcClassPrefix);
                if (object.csharpNamespace != null)
                    message.csharpNamespace = String(object.csharpNamespace);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FileOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.from = FileOptions.fromObject;

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.javaPackage = "";
                    object.javaOuterClassname = "";
                    object.optimizeFor = options.enums === String ? "SPEED" : 1;
                    object.javaMultipleFiles = false;
                    object.goPackage = "";
                    object.ccGenericServices = false;
                    object.javaGenericServices = false;
                    object.pyGenericServices = false;
                    object.javaGenerateEqualsAndHash = false;
                    object.deprecated = false;
                    object.javaStringCheckUtf8 = false;
                    object.ccEnableArenas = false;
                    object.objcClassPrefix = "";
                    object.csharpNamespace = "";
                }
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    object.javaPackage = message.javaPackage;
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    object.javaOuterClassname = message.javaOuterClassname;
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    object.javaMultipleFiles = message.javaMultipleFiles;
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    object.goPackage = message.goPackage;
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    object.ccGenericServices = message.ccGenericServices;
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    object.javaGenericServices = message.javaGenericServices;
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    object.pyGenericServices = message.pyGenericServices;
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    object.ccEnableArenas = message.ccEnableArenas;
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    object.objcClassPrefix = message.objcClassPrefix;
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    object.csharpNamespace = message.csharpNamespace;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this FileOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FileOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OptimizeMode enum.
             * @name OptimizeMode
             * @memberof google.protobuf.FileOptions
             * @enum {number}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @typedef google.protobuf.MessageOptions$Properties
             * @type {Object}
             * @property {boolean} [messageSetWireFormat] MessageOptions messageSetWireFormat.
             * @property {boolean} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor.
             * @property {boolean} [deprecated] MessageOptions deprecated.
             * @property {boolean} [mapEntry] MessageOptions mapEntry.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpretedOption] MessageOptions uninterpretedOption.
             */

            /**
             * Constructs a new MessageOptions.
             * @exports google.protobuf.MessageOptions
             * @constructor
             * @param {google.protobuf.MessageOptions$Properties=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @type {boolean}
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @type {boolean}
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @type {boolean}
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @type {boolean}
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @param {google.protobuf.MessageOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            MessageOptions.create = function create(properties) {
                return new MessageOptions(properties);
            };

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @param {google.protobuf.MessageOptions$Properties} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @param {google.protobuf.MessageOptions$Properties} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageSetWireFormat = reader.bool();
                        break;
                    case 2:
                        message.noStandardDescriptorAccessor = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 7:
                        message.mapEntry = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                var message = new $root.google.protobuf.MessageOptions();
                if (object.messageSetWireFormat != null)
                    message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                if (object.noStandardDescriptorAccessor != null)
                    message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.mapEntry != null)
                    message.mapEntry = Boolean(object.mapEntry);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.MessageOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.from = MessageOptions.fromObject;

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.messageSetWireFormat = false;
                    object.noStandardDescriptorAccessor = false;
                    object.deprecated = false;
                    object.mapEntry = false;
                }
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    object.messageSetWireFormat = message.messageSetWireFormat;
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    object.mapEntry = message.mapEntry;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this MessageOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this MessageOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @typedef google.protobuf.FieldOptions$Properties
             * @type {Object}
             * @property {google.protobuf.FieldOptions.CType} [ctype] FieldOptions ctype.
             * @property {boolean} [packed] FieldOptions packed.
             * @property {google.protobuf.FieldOptions.JSType} [jstype] FieldOptions jstype.
             * @property {boolean} [lazy] FieldOptions lazy.
             * @property {boolean} [deprecated] FieldOptions deprecated.
             * @property {boolean} [weak] FieldOptions weak.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpretedOption] FieldOptions uninterpretedOption.
             * @property {PointerType} [".pointer"] FieldOptions .pointer.
             * @property {number} [".arraySize"] FieldOptions .arraySize.
             */

            /**
             * Constructs a new FieldOptions.
             * @exports google.protobuf.FieldOptions
             * @constructor
             * @param {google.protobuf.FieldOptions$Properties=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @type {google.protobuf.FieldOptions.CType}
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @type {boolean}
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @type {google.protobuf.FieldOptions.JSType}
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @type {boolean}
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @type {boolean}
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @type {boolean}
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * FieldOptions .pointer.
             * @type {PointerType}
             */
            FieldOptions.prototype[".pointer"] = 0;

            /**
             * FieldOptions .arraySize.
             * @type {number}
             */
            FieldOptions.prototype[".arraySize"] = 0;

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @param {google.protobuf.FieldOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            FieldOptions.create = function create(properties) {
                return new FieldOptions(properties);
            };

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @param {google.protobuf.FieldOptions$Properties} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ctype);
                if (message.packed != null && message.hasOwnProperty("packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.jstype);
                if (message.weak != null && message.hasOwnProperty("weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".pointer"] != null && message.hasOwnProperty(".pointer"))
                    writer.uint32(/* id 50000, wireType 0 =*/400000).uint32(message[".pointer"]);
                if (message[".arraySize"] != null && message.hasOwnProperty(".arraySize"))
                    writer.uint32(/* id 50001, wireType 0 =*/400008).uint32(message[".arraySize"]);
                return writer;
            };

            /**
             * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @param {google.protobuf.FieldOptions$Properties} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ctype = reader.uint32();
                        break;
                    case 2:
                        message.packed = reader.bool();
                        break;
                    case 6:
                        message.jstype = reader.uint32();
                        break;
                    case 5:
                        message.lazy = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 10:
                        message.weak = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 50000:
                        message[".pointer"] = reader.uint32();
                        break;
                    case 50001:
                        message[".arraySize"] = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".pointer"] != null && message.hasOwnProperty(".pointer"))
                    switch (message[".pointer"]) {
                    default:
                        return ".pointer: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message[".arraySize"] != null && message.hasOwnProperty(".arraySize"))
                    if (!$util.isInteger(message[".arraySize"]))
                        return ".arraySize: integer expected";
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                var message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                switch (object[".pointer"]) {
                case "NONE":
                case 0:
                    message[".pointer"] = 0;
                    break;
                case "RAW":
                case 1:
                    message[".pointer"] = 1;
                    break;
                case "SHARED":
                case 2:
                    message[".pointer"] = 2;
                    break;
                case "UNIQUE":
                case 3:
                    message[".pointer"] = 3;
                    break;
                }
                if (object[".arraySize"] != null)
                    message[".arraySize"] = object[".arraySize"] >>> 0;
                return message;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FieldOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.from = FieldOptions.fromObject;

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                    object[".pointer"] = options.enums === String ? "NONE" : 0;
                    object[".arraySize"] = 0;
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".pointer"] != null && message.hasOwnProperty(".pointer"))
                    object[".pointer"] = options.enums === String ? $root.PointerType[message[".pointer"]] : message[".pointer"];
                if (message[".arraySize"] != null && message.hasOwnProperty(".arraySize"))
                    object[".arraySize"] = message[".arraySize"];
                return object;
            };

            /**
             * Creates a plain object from this FieldOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FieldOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * CType enum.
             * @name CType
             * @memberof google.protobuf.FieldOptions
             * @enum {number}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name JSType
             * @memberof google.protobuf.FieldOptions
             * @enum {number}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @typedef google.protobuf.OneofOptions$Properties
             * @type {Object}
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpretedOption] OneofOptions uninterpretedOption.
             */

            /**
             * Constructs a new OneofOptions.
             * @exports google.protobuf.OneofOptions
             * @constructor
             * @param {google.protobuf.OneofOptions$Properties=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @param {google.protobuf.OneofOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            OneofOptions.create = function create(properties) {
                return new OneofOptions(properties);
            };

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @param {google.protobuf.OneofOptions$Properties} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @param {google.protobuf.OneofOptions$Properties} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                var message = new $root.google.protobuf.OneofOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.OneofOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.from = OneofOptions.fromObject;

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this OneofOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this OneofOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @typedef google.protobuf.EnumOptions$Properties
             * @type {Object}
             * @property {boolean} [allowAlias] EnumOptions allowAlias.
             * @property {boolean} [deprecated] EnumOptions deprecated.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpretedOption] EnumOptions uninterpretedOption.
             */

            /**
             * Constructs a new EnumOptions.
             * @exports google.protobuf.EnumOptions
             * @constructor
             * @param {google.protobuf.EnumOptions$Properties=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @type {boolean}
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @type {boolean}
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @param {google.protobuf.EnumOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            EnumOptions.create = function create(properties) {
                return new EnumOptions(properties);
            };

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @param {google.protobuf.EnumOptions$Properties} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @param {google.protobuf.EnumOptions$Properties} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.allowAlias = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                var message = new $root.google.protobuf.EnumOptions();
                if (object.allowAlias != null)
                    message.allowAlias = Boolean(object.allowAlias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.EnumOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.from = EnumOptions.fromObject;

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.allowAlias = false;
                    object.deprecated = false;
                }
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    object.allowAlias = message.allowAlias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this EnumOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this EnumOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @typedef google.protobuf.EnumValueOptions$Properties
             * @type {Object}
             * @property {boolean} [deprecated] EnumValueOptions deprecated.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpretedOption] EnumValueOptions uninterpretedOption.
             */

            /**
             * Constructs a new EnumValueOptions.
             * @exports google.protobuf.EnumValueOptions
             * @constructor
             * @param {google.protobuf.EnumValueOptions$Properties=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @type {boolean}
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @param {google.protobuf.EnumValueOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            EnumValueOptions.create = function create(properties) {
                return new EnumValueOptions(properties);
            };

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @param {google.protobuf.EnumValueOptions$Properties} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @param {google.protobuf.EnumValueOptions$Properties} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                var message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.EnumValueOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.from = EnumValueOptions.fromObject;

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this EnumValueOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @typedef google.protobuf.ServiceOptions$Properties
             * @type {Object}
             * @property {boolean} [deprecated] ServiceOptions deprecated.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpretedOption] ServiceOptions uninterpretedOption.
             */

            /**
             * Constructs a new ServiceOptions.
             * @exports google.protobuf.ServiceOptions
             * @constructor
             * @param {google.protobuf.ServiceOptions$Properties=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @type {boolean}
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @param {google.protobuf.ServiceOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            ServiceOptions.create = function create(properties) {
                return new ServiceOptions(properties);
            };

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @param {google.protobuf.ServiceOptions$Properties} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @param {google.protobuf.ServiceOptions$Properties} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                var message = new $root.google.protobuf.ServiceOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.ServiceOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.from = ServiceOptions.fromObject;

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this ServiceOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @typedef google.protobuf.MethodOptions$Properties
             * @type {Object}
             * @property {boolean} [deprecated] MethodOptions deprecated.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpretedOption] MethodOptions uninterpretedOption.
             */

            /**
             * Constructs a new MethodOptions.
             * @exports google.protobuf.MethodOptions
             * @constructor
             * @param {google.protobuf.MethodOptions$Properties=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @type {boolean}
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @param {google.protobuf.MethodOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            MethodOptions.create = function create(properties) {
                return new MethodOptions(properties);
            };

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @param {google.protobuf.MethodOptions$Properties} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @param {google.protobuf.MethodOptions$Properties} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                var message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.MethodOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.from = MethodOptions.fromObject;

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this MethodOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this MethodOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @typedef google.protobuf.UninterpretedOption$Properties
             * @type {Object}
             * @property {Array.<google.protobuf.UninterpretedOption.NamePart$Properties>} [name] UninterpretedOption name.
             * @property {string} [identifierValue] UninterpretedOption identifierValue.
             * @property {number|Long} [positiveIntValue] UninterpretedOption positiveIntValue.
             * @property {number|Long} [negativeIntValue] UninterpretedOption negativeIntValue.
             * @property {number} [doubleValue] UninterpretedOption doubleValue.
             * @property {Uint8Array} [stringValue] UninterpretedOption stringValue.
             * @property {string} [aggregateValue] UninterpretedOption aggregateValue.
             */

            /**
             * Constructs a new UninterpretedOption.
             * @exports google.protobuf.UninterpretedOption
             * @constructor
             * @param {google.protobuf.UninterpretedOption$Properties=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @type {Array.<google.protobuf.UninterpretedOption.NamePart$Properties>}
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @type {string}
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @type {number|Long}
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @type {number|Long}
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @type {number}
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @type {Uint8Array}
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @type {string}
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @param {google.protobuf.UninterpretedOption$Properties=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            UninterpretedOption.create = function create(properties) {
                return new UninterpretedOption(properties);
            };

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @param {google.protobuf.UninterpretedOption$Properties} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (var i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                return writer;
            };

            /**
             * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @param {google.protobuf.UninterpretedOption$Properties} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.name && message.name.length))
                            message.name = [];
                        message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.identifierValue = reader.string();
                        break;
                    case 4:
                        message.positiveIntValue = reader.uint64();
                        break;
                    case 5:
                        message.negativeIntValue = reader.int64();
                        break;
                    case 6:
                        message.doubleValue = reader.double();
                        break;
                    case 7:
                        message.stringValue = reader.bytes();
                        break;
                    case 8:
                        message.aggregateValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UninterpretedOption message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (var i = 0; i < message.name.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                var message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (var i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifierValue != null)
                    message.identifierValue = String(object.identifierValue);
                if (object.positiveIntValue != null)
                    if ($util.Long)
                        (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                    else if (typeof object.positiveIntValue === "string")
                        message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                    else if (typeof object.positiveIntValue === "number")
                        message.positiveIntValue = object.positiveIntValue;
                    else if (typeof object.positiveIntValue === "object")
                        message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                if (object.negativeIntValue != null)
                    if ($util.Long)
                        (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                    else if (typeof object.negativeIntValue === "string")
                        message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                    else if (typeof object.negativeIntValue === "number")
                        message.negativeIntValue = object.negativeIntValue;
                    else if (typeof object.negativeIntValue === "object")
                        message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.stringValue != null)
                    if (typeof object.stringValue === "string")
                        $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                    else if (object.stringValue.length)
                        message.stringValue = object.stringValue;
                if (object.aggregateValue != null)
                    message.aggregateValue = String(object.aggregateValue);
                return message;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.UninterpretedOption.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.from = UninterpretedOption.fromObject;

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifierValue = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positiveIntValue = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negativeIntValue = options.longs === String ? "0" : 0;
                    object.doubleValue = 0;
                    object.stringValue = options.bytes === String ? "" : [];
                    object.aggregateValue = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (var j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    object.identifierValue = message.identifierValue;
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (typeof message.positiveIntValue === "number")
                        object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                    else
                        object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (typeof message.negativeIntValue === "number")
                        object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                    else
                        object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    object.doubleValue = message.doubleValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    object.aggregateValue = message.aggregateValue;
                return object;
            };

            /**
             * Creates a plain object from this UninterpretedOption message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @typedef google.protobuf.UninterpretedOption.NamePart$Properties
                 * @type {Object}
                 * @property {string} namePart NamePart namePart.
                 * @property {boolean} isExtension NamePart isExtension.
                 */

                /**
                 * Constructs a new NamePart.
                 * @exports google.protobuf.UninterpretedOption.NamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.NamePart$Properties=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @type {string}
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @type {boolean}
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @param {google.protobuf.UninterpretedOption.NamePart$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                NamePart.create = function create(properties) {
                    return new NamePart(properties);
                };

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @param {google.protobuf.UninterpretedOption.NamePart$Properties} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                    return writer;
                };

                /**
                 * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @param {google.protobuf.UninterpretedOption.NamePart$Properties} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.namePart = reader.string();
                            break;
                        case 2:
                            message.isExtension = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NamePart message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.namePart != null)
                        message.namePart = String(object.namePart);
                    if (object.isExtension != null)
                        message.isExtension = Boolean(object.isExtension);
                    return message;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.UninterpretedOption.NamePart.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.from = NamePart.fromObject;

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.namePart = "";
                        object.isExtension = false;
                    }
                    if (message.namePart != null && message.hasOwnProperty("namePart"))
                        object.namePart = message.namePart;
                    if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                        object.isExtension = message.isExtension;
                    return object;
                };

                /**
                 * Creates a plain object from this NamePart message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this NamePart to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @typedef google.protobuf.SourceCodeInfo$Properties
             * @type {Object}
             * @property {Array.<google.protobuf.SourceCodeInfo.Location$Properties>} [location] SourceCodeInfo location.
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @exports google.protobuf.SourceCodeInfo
             * @constructor
             * @param {google.protobuf.SourceCodeInfo$Properties=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @type {Array.<google.protobuf.SourceCodeInfo.Location$Properties>}
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @param {google.protobuf.SourceCodeInfo$Properties=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            SourceCodeInfo.create = function create(properties) {
                return new SourceCodeInfo(properties);
            };

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @param {google.protobuf.SourceCodeInfo$Properties} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (var i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @param {google.protobuf.SourceCodeInfo$Properties} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceCodeInfo message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (var i = 0; i < message.location.length; ++i) {
                        var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                var message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (var i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.SourceCodeInfo.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.from = SourceCodeInfo.fromObject;

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (var j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this SourceCodeInfo message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @typedef google.protobuf.SourceCodeInfo.Location$Properties
                 * @type {Object}
                 * @property {Array.<number>} [path] Location path.
                 * @property {Array.<number>} [span] Location span.
                 * @property {string} [leadingComments] Location leadingComments.
                 * @property {string} [trailingComments] Location trailingComments.
                 * @property {Array.<string>} [leadingDetachedComments] Location leadingDetachedComments.
                 */

                /**
                 * Constructs a new Location.
                 * @exports google.protobuf.SourceCodeInfo.Location
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.Location$Properties=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @type {Array.<number>}
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @type {Array.<number>}
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @type {string}
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @type {string}
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @type {Array.<string>}
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @param {google.protobuf.SourceCodeInfo.Location$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @param {google.protobuf.SourceCodeInfo.Location$Properties} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                    if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                        for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @param {google.protobuf.SourceCodeInfo.Location$Properties} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            if (!(message.span && message.span.length))
                                message.span = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.span.push(reader.int32());
                            } else
                                message.span.push(reader.int32());
                            break;
                        case 3:
                            message.leadingComments = reader.string();
                            break;
                        case 4:
                            message.trailingComments = reader.string();
                            break;
                        case 6:
                            if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                message.leadingDetachedComments = [];
                            message.leadingDetachedComments.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (var i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (var i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leadingComments != null)
                        message.leadingComments = String(object.leadingComments);
                    if (object.trailingComments != null)
                        message.trailingComments = String(object.trailingComments);
                    if (object.leadingDetachedComments) {
                        if (!Array.isArray(object.leadingDetachedComments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                        message.leadingDetachedComments = [];
                        for (var i = 0; i < object.leadingDetachedComments.length; ++i)
                            message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.SourceCodeInfo.Location.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.from = Location.fromObject;

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leadingDetachedComments = [];
                    }
                    if (options.defaults) {
                        object.leadingComments = "";
                        object.trailingComments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (var j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        object.leadingComments = message.leadingComments;
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        object.trailingComments = message.trailingComments;
                    if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                        object.leadingDetachedComments = [];
                        for (var j = 0; j < message.leadingDetachedComments.length; ++j)
                            object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this Location message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Location to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @typedef google.protobuf.GeneratedCodeInfo$Properties
             * @type {Object}
             * @property {Array.<google.protobuf.GeneratedCodeInfo.Annotation$Properties>} [annotation] GeneratedCodeInfo annotation.
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @exports google.protobuf.GeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.GeneratedCodeInfo$Properties=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @type {Array.<google.protobuf.GeneratedCodeInfo.Annotation$Properties>}
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @param {google.protobuf.GeneratedCodeInfo$Properties=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            GeneratedCodeInfo.create = function create(properties) {
                return new GeneratedCodeInfo(properties);
            };

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @param {google.protobuf.GeneratedCodeInfo$Properties} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (var i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @param {google.protobuf.GeneratedCodeInfo$Properties} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.annotation && message.annotation.length))
                            message.annotation = [];
                        message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeneratedCodeInfo message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (var i = 0; i < message.annotation.length; ++i) {
                        var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                var message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (var i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.GeneratedCodeInfo.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.from = GeneratedCodeInfo.fromObject;

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (var j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this GeneratedCodeInfo message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @typedef google.protobuf.GeneratedCodeInfo.Annotation$Properties
                 * @type {Object}
                 * @property {Array.<number>} [path] Annotation path.
                 * @property {string} [sourceFile] Annotation sourceFile.
                 * @property {number} [begin] Annotation begin.
                 * @property {number} [end] Annotation end.
                 */

                /**
                 * Constructs a new Annotation.
                 * @exports google.protobuf.GeneratedCodeInfo.Annotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation$Properties=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @type {Array.<number>}
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @type {string}
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @type {number}
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @type {number}
                 */
                Annotation.prototype.end = 0;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                Annotation.create = function create(properties) {
                    return new Annotation(properties);
                };

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation$Properties} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation$Properties} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            message.sourceFile = reader.string();
                            break;
                        case 3:
                            message.begin = reader.int32();
                            break;
                        case 4:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Annotation message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.sourceFile != null)
                        message.sourceFile = String(object.sourceFile);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.GeneratedCodeInfo.Annotation.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.from = Annotation.fromObject;

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.sourceFile = "";
                        object.begin = 0;
                        object.end = 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        object.sourceFile = message.sourceFile;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Creates a plain object from this Annotation message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Annotation to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        return protobuf;
    })();

    return google;
})();

$root.mat = (function() {

    /**
     * Properties of a mat.
     * @typedef mat$Properties
     * @type {Object}
     * @property {number} [rows] mat rows.
     * @property {number} [cols] mat cols.
     * @property {Array.<number>} [v] mat v.
     */

    /**
     * Constructs a new mat.
     * @exports mat
     * @constructor
     * @param {mat$Properties=} [properties] Properties to set
     */
    function mat(properties) {
        this.v = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat rows.
     * @type {number}
     */
    mat.prototype.rows = 0;

    /**
     * mat cols.
     * @type {number}
     */
    mat.prototype.cols = 0;

    /**
     * mat v.
     * @type {Array.<number>}
     */
    mat.prototype.v = $util.emptyArray;

    /**
     * Creates a new mat instance using the specified properties.
     * @param {mat$Properties=} [properties] Properties to set
     * @returns {mat} mat instance
     */
    mat.create = function create(properties) {
        return new mat(properties);
    };

    /**
     * Encodes the specified mat message. Does not implicitly {@link mat.verify|verify} messages.
     * @param {mat$Properties} message mat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.rows != null && message.hasOwnProperty("rows"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rows);
        if (message.cols != null && message.hasOwnProperty("cols"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cols);
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 3, wireType 2 =*/26).fork();
            for (var i = 0; i < message.v.length; ++i)
                writer.double(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Encodes the specified mat message, length delimited. Does not implicitly {@link mat.verify|verify} messages.
     * @param {mat$Properties} message mat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a mat message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat} mat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.rows = reader.uint32();
                break;
            case 2:
                message.cols = reader.uint32();
                break;
            case 3:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.double());
                } else
                    message.v.push(reader.double());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a mat message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {mat} mat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a mat message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    mat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.rows != null && message.hasOwnProperty("rows"))
            if (!$util.isInteger(message.rows))
                return "rows: integer expected";
        if (message.cols != null && message.hasOwnProperty("cols"))
            if (!$util.isInteger(message.cols))
                return "cols: integer expected";
        if (message.v != null && message.hasOwnProperty("v")) {
            if (!Array.isArray(message.v))
                return "v: array expected";
            for (var i = 0; i < message.v.length; ++i)
                if (typeof message.v[i] !== "number")
                    return "v: number[] expected";
        }
        return null;
    };

    /**
     * Creates a mat message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {mat} mat
     */
    mat.fromObject = function fromObject(object) {
        if (object instanceof $root.mat)
            return object;
        var message = new $root.mat();
        if (object.rows != null)
            message.rows = object.rows >>> 0;
        if (object.cols != null)
            message.cols = object.cols >>> 0;
        if (object.v) {
            if (!Array.isArray(object.v))
                throw TypeError(".mat.v: array expected");
            message.v = [];
            for (var i = 0; i < object.v.length; ++i)
                message.v[i] = Number(object.v[i]);
        }
        return message;
    };

    /**
     * Creates a mat message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link mat.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {mat} mat
     */
    mat.from = mat.fromObject;

    /**
     * Creates a plain object from a mat message. Also converts values to other types if specified.
     * @param {mat} message mat
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    mat.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.v = [];
        if (options.defaults) {
            object.rows = 0;
            object.cols = 0;
        }
        if (message.rows != null && message.hasOwnProperty("rows"))
            object.rows = message.rows;
        if (message.cols != null && message.hasOwnProperty("cols"))
            object.cols = message.cols;
        if (message.v && message.v.length) {
            object.v = [];
            for (var j = 0; j < message.v.length; ++j)
                object.v[j] = message.v[j];
        }
        return object;
    };

    /**
     * Creates a plain object from this mat message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    mat.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this mat to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    mat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return mat;
})();

$root.fmat = (function() {

    /**
     * Properties of a fmat.
     * @typedef fmat$Properties
     * @type {Object}
     * @property {number} [rows] fmat rows.
     * @property {number} [cols] fmat cols.
     * @property {Array.<number>} [v] fmat v.
     */

    /**
     * Constructs a new fmat.
     * @exports fmat
     * @constructor
     * @param {fmat$Properties=} [properties] Properties to set
     */
    function fmat(properties) {
        this.v = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat rows.
     * @type {number}
     */
    fmat.prototype.rows = 0;

    /**
     * fmat cols.
     * @type {number}
     */
    fmat.prototype.cols = 0;

    /**
     * fmat v.
     * @type {Array.<number>}
     */
    fmat.prototype.v = $util.emptyArray;

    /**
     * Creates a new fmat instance using the specified properties.
     * @param {fmat$Properties=} [properties] Properties to set
     * @returns {fmat} fmat instance
     */
    fmat.create = function create(properties) {
        return new fmat(properties);
    };

    /**
     * Encodes the specified fmat message. Does not implicitly {@link fmat.verify|verify} messages.
     * @param {fmat$Properties} message fmat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.rows != null && message.hasOwnProperty("rows"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rows);
        if (message.cols != null && message.hasOwnProperty("cols"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cols);
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 3, wireType 2 =*/26).fork();
            for (var i = 0; i < message.v.length; ++i)
                writer.float(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Encodes the specified fmat message, length delimited. Does not implicitly {@link fmat.verify|verify} messages.
     * @param {fmat$Properties} message fmat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a fmat message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat} fmat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.rows = reader.uint32();
                break;
            case 2:
                message.cols = reader.uint32();
                break;
            case 3:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.float());
                } else
                    message.v.push(reader.float());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a fmat message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fmat} fmat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a fmat message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    fmat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.rows != null && message.hasOwnProperty("rows"))
            if (!$util.isInteger(message.rows))
                return "rows: integer expected";
        if (message.cols != null && message.hasOwnProperty("cols"))
            if (!$util.isInteger(message.cols))
                return "cols: integer expected";
        if (message.v != null && message.hasOwnProperty("v")) {
            if (!Array.isArray(message.v))
                return "v: array expected";
            for (var i = 0; i < message.v.length; ++i)
                if (typeof message.v[i] !== "number")
                    return "v: number[] expected";
        }
        return null;
    };

    /**
     * Creates a fmat message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat} fmat
     */
    fmat.fromObject = function fromObject(object) {
        if (object instanceof $root.fmat)
            return object;
        var message = new $root.fmat();
        if (object.rows != null)
            message.rows = object.rows >>> 0;
        if (object.cols != null)
            message.cols = object.cols >>> 0;
        if (object.v) {
            if (!Array.isArray(object.v))
                throw TypeError(".fmat.v: array expected");
            message.v = [];
            for (var i = 0; i < object.v.length; ++i)
                message.v[i] = Number(object.v[i]);
        }
        return message;
    };

    /**
     * Creates a fmat message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fmat.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat} fmat
     */
    fmat.from = fmat.fromObject;

    /**
     * Creates a plain object from a fmat message. Also converts values to other types if specified.
     * @param {fmat} message fmat
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fmat.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.v = [];
        if (options.defaults) {
            object.rows = 0;
            object.cols = 0;
        }
        if (message.rows != null && message.hasOwnProperty("rows"))
            object.rows = message.rows;
        if (message.cols != null && message.hasOwnProperty("cols"))
            object.cols = message.cols;
        if (message.v && message.v.length) {
            object.v = [];
            for (var j = 0; j < message.v.length; ++j)
                object.v[j] = message.v[j];
        }
        return object;
    };

    /**
     * Creates a plain object from this fmat message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fmat.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this fmat to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    fmat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return fmat;
})();

$root.imat = (function() {

    /**
     * Properties of an imat.
     * @typedef imat$Properties
     * @type {Object}
     * @property {number} [rows] imat rows.
     * @property {number} [cols] imat cols.
     * @property {Array.<number>} [v] imat v.
     */

    /**
     * Constructs a new imat.
     * @exports imat
     * @constructor
     * @param {imat$Properties=} [properties] Properties to set
     */
    function imat(properties) {
        this.v = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat rows.
     * @type {number}
     */
    imat.prototype.rows = 0;

    /**
     * imat cols.
     * @type {number}
     */
    imat.prototype.cols = 0;

    /**
     * imat v.
     * @type {Array.<number>}
     */
    imat.prototype.v = $util.emptyArray;

    /**
     * Creates a new imat instance using the specified properties.
     * @param {imat$Properties=} [properties] Properties to set
     * @returns {imat} imat instance
     */
    imat.create = function create(properties) {
        return new imat(properties);
    };

    /**
     * Encodes the specified imat message. Does not implicitly {@link imat.verify|verify} messages.
     * @param {imat$Properties} message imat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.rows != null && message.hasOwnProperty("rows"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rows);
        if (message.cols != null && message.hasOwnProperty("cols"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cols);
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 3, wireType 2 =*/26).fork();
            for (var i = 0; i < message.v.length; ++i)
                writer.sint32(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Encodes the specified imat message, length delimited. Does not implicitly {@link imat.verify|verify} messages.
     * @param {imat$Properties} message imat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an imat message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat} imat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.rows = reader.uint32();
                break;
            case 2:
                message.cols = reader.uint32();
                break;
            case 3:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.sint32());
                } else
                    message.v.push(reader.sint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an imat message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {imat} imat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an imat message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    imat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.rows != null && message.hasOwnProperty("rows"))
            if (!$util.isInteger(message.rows))
                return "rows: integer expected";
        if (message.cols != null && message.hasOwnProperty("cols"))
            if (!$util.isInteger(message.cols))
                return "cols: integer expected";
        if (message.v != null && message.hasOwnProperty("v")) {
            if (!Array.isArray(message.v))
                return "v: array expected";
            for (var i = 0; i < message.v.length; ++i)
                if (!$util.isInteger(message.v[i]))
                    return "v: integer[] expected";
        }
        return null;
    };

    /**
     * Creates an imat message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {imat} imat
     */
    imat.fromObject = function fromObject(object) {
        if (object instanceof $root.imat)
            return object;
        var message = new $root.imat();
        if (object.rows != null)
            message.rows = object.rows >>> 0;
        if (object.cols != null)
            message.cols = object.cols >>> 0;
        if (object.v) {
            if (!Array.isArray(object.v))
                throw TypeError(".imat.v: array expected");
            message.v = [];
            for (var i = 0; i < object.v.length; ++i)
                message.v[i] = object.v[i] | 0;
        }
        return message;
    };

    /**
     * Creates an imat message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link imat.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {imat} imat
     */
    imat.from = imat.fromObject;

    /**
     * Creates a plain object from an imat message. Also converts values to other types if specified.
     * @param {imat} message imat
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    imat.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.v = [];
        if (options.defaults) {
            object.rows = 0;
            object.cols = 0;
        }
        if (message.rows != null && message.hasOwnProperty("rows"))
            object.rows = message.rows;
        if (message.cols != null && message.hasOwnProperty("cols"))
            object.cols = message.cols;
        if (message.v && message.v.length) {
            object.v = [];
            for (var j = 0; j < message.v.length; ++j)
                object.v[j] = message.v[j];
        }
        return object;
    };

    /**
     * Creates a plain object from this imat message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    imat.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this imat to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    imat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return imat;
})();

$root.umat = (function() {

    /**
     * Properties of an umat.
     * @typedef umat$Properties
     * @type {Object}
     * @property {number} [rows] umat rows.
     * @property {number} [cols] umat cols.
     * @property {Array.<number>} [v] umat v.
     */

    /**
     * Constructs a new umat.
     * @exports umat
     * @constructor
     * @param {umat$Properties=} [properties] Properties to set
     */
    function umat(properties) {
        this.v = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat rows.
     * @type {number}
     */
    umat.prototype.rows = 0;

    /**
     * umat cols.
     * @type {number}
     */
    umat.prototype.cols = 0;

    /**
     * umat v.
     * @type {Array.<number>}
     */
    umat.prototype.v = $util.emptyArray;

    /**
     * Creates a new umat instance using the specified properties.
     * @param {umat$Properties=} [properties] Properties to set
     * @returns {umat} umat instance
     */
    umat.create = function create(properties) {
        return new umat(properties);
    };

    /**
     * Encodes the specified umat message. Does not implicitly {@link umat.verify|verify} messages.
     * @param {umat$Properties} message umat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.rows != null && message.hasOwnProperty("rows"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rows);
        if (message.cols != null && message.hasOwnProperty("cols"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cols);
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 3, wireType 2 =*/26).fork();
            for (var i = 0; i < message.v.length; ++i)
                writer.uint32(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Encodes the specified umat message, length delimited. Does not implicitly {@link umat.verify|verify} messages.
     * @param {umat$Properties} message umat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an umat message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat} umat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.rows = reader.uint32();
                break;
            case 2:
                message.cols = reader.uint32();
                break;
            case 3:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.uint32());
                } else
                    message.v.push(reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an umat message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {umat} umat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an umat message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    umat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.rows != null && message.hasOwnProperty("rows"))
            if (!$util.isInteger(message.rows))
                return "rows: integer expected";
        if (message.cols != null && message.hasOwnProperty("cols"))
            if (!$util.isInteger(message.cols))
                return "cols: integer expected";
        if (message.v != null && message.hasOwnProperty("v")) {
            if (!Array.isArray(message.v))
                return "v: array expected";
            for (var i = 0; i < message.v.length; ++i)
                if (!$util.isInteger(message.v[i]))
                    return "v: integer[] expected";
        }
        return null;
    };

    /**
     * Creates an umat message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {umat} umat
     */
    umat.fromObject = function fromObject(object) {
        if (object instanceof $root.umat)
            return object;
        var message = new $root.umat();
        if (object.rows != null)
            message.rows = object.rows >>> 0;
        if (object.cols != null)
            message.cols = object.cols >>> 0;
        if (object.v) {
            if (!Array.isArray(object.v))
                throw TypeError(".umat.v: array expected");
            message.v = [];
            for (var i = 0; i < object.v.length; ++i)
                message.v[i] = object.v[i] >>> 0;
        }
        return message;
    };

    /**
     * Creates an umat message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link umat.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {umat} umat
     */
    umat.from = umat.fromObject;

    /**
     * Creates a plain object from an umat message. Also converts values to other types if specified.
     * @param {umat} message umat
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    umat.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.v = [];
        if (options.defaults) {
            object.rows = 0;
            object.cols = 0;
        }
        if (message.rows != null && message.hasOwnProperty("rows"))
            object.rows = message.rows;
        if (message.cols != null && message.hasOwnProperty("cols"))
            object.cols = message.cols;
        if (message.v && message.v.length) {
            object.v = [];
            for (var j = 0; j < message.v.length; ++j)
                object.v[j] = message.v[j];
        }
        return object;
    };

    /**
     * Creates a plain object from this umat message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    umat.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this umat to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    umat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return umat;
})();

$root.cmat = (function() {

    /**
     * Properties of a cmat.
     * @typedef cmat$Properties
     * @type {Object}
     * @property {number} [rows] cmat rows.
     * @property {number} [cols] cmat cols.
     * @property {Uint8Array} [v] cmat v.
     */

    /**
     * Constructs a new cmat.
     * @exports cmat
     * @constructor
     * @param {cmat$Properties=} [properties] Properties to set
     */
    function cmat(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * cmat rows.
     * @type {number}
     */
    cmat.prototype.rows = 0;

    /**
     * cmat cols.
     * @type {number}
     */
    cmat.prototype.cols = 0;

    /**
     * cmat v.
     * @type {Uint8Array}
     */
    cmat.prototype.v = $util.newBuffer([]);

    /**
     * Creates a new cmat instance using the specified properties.
     * @param {cmat$Properties=} [properties] Properties to set
     * @returns {cmat} cmat instance
     */
    cmat.create = function create(properties) {
        return new cmat(properties);
    };

    /**
     * Encodes the specified cmat message. Does not implicitly {@link cmat.verify|verify} messages.
     * @param {cmat$Properties} message cmat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    cmat.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.rows != null && message.hasOwnProperty("rows"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rows);
        if (message.cols != null && message.hasOwnProperty("cols"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cols);
        if (message.v != null && message.hasOwnProperty("v"))
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.v);
        return writer;
    };

    /**
     * Encodes the specified cmat message, length delimited. Does not implicitly {@link cmat.verify|verify} messages.
     * @param {cmat$Properties} message cmat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    cmat.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a cmat message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {cmat} cmat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    cmat.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cmat();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.rows = reader.uint32();
                break;
            case 2:
                message.cols = reader.uint32();
                break;
            case 3:
                message.v = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a cmat message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {cmat} cmat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    cmat.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a cmat message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    cmat.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.rows != null && message.hasOwnProperty("rows"))
            if (!$util.isInteger(message.rows))
                return "rows: integer expected";
        if (message.cols != null && message.hasOwnProperty("cols"))
            if (!$util.isInteger(message.cols))
                return "cols: integer expected";
        if (message.v != null && message.hasOwnProperty("v"))
            if (!(message.v && typeof message.v.length === "number" || $util.isString(message.v)))
                return "v: buffer expected";
        return null;
    };

    /**
     * Creates a cmat message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {cmat} cmat
     */
    cmat.fromObject = function fromObject(object) {
        if (object instanceof $root.cmat)
            return object;
        var message = new $root.cmat();
        if (object.rows != null)
            message.rows = object.rows >>> 0;
        if (object.cols != null)
            message.cols = object.cols >>> 0;
        if (object.v != null)
            if (typeof object.v === "string")
                $util.base64.decode(object.v, message.v = $util.newBuffer($util.base64.length(object.v)), 0);
            else if (object.v.length)
                message.v = object.v;
        return message;
    };

    /**
     * Creates a cmat message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link cmat.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {cmat} cmat
     */
    cmat.from = cmat.fromObject;

    /**
     * Creates a plain object from a cmat message. Also converts values to other types if specified.
     * @param {cmat} message cmat
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    cmat.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.rows = 0;
            object.cols = 0;
            object.v = options.bytes === String ? "" : [];
        }
        if (message.rows != null && message.hasOwnProperty("rows"))
            object.rows = message.rows;
        if (message.cols != null && message.hasOwnProperty("cols"))
            object.cols = message.cols;
        if (message.v != null && message.hasOwnProperty("v"))
            object.v = options.bytes === String ? $util.base64.encode(message.v, 0, message.v.length) : options.bytes === Array ? Array.prototype.slice.call(message.v) : message.v;
        return object;
    };

    /**
     * Creates a plain object from this cmat message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    cmat.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this cmat to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    cmat.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return cmat;
})();

$root.mat22 = (function() {

    /**
     * Properties of a mat22.
     * @typedef mat22$Properties
     * @type {Object}
     * @property {vec2$Properties} [x] mat22 x.
     * @property {vec2$Properties} [y] mat22 y.
     */

    /**
     * Constructs a new mat22.
     * @exports mat22
     * @constructor
     * @param {mat22$Properties=} [properties] Properties to set
     */
    function mat22(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat22 x.
     * @type {(vec2$Properties|null)}
     */
    mat22.prototype.x = null;

    /**
     * mat22 y.
     * @type {(vec2$Properties|null)}
     */
    mat22.prototype.y = null;

    /**
     * Creates a new mat22 instance using the specified properties.
     * @param {mat22$Properties=} [properties] Properties to set
     * @returns {mat22} mat22 instance
     */
    mat22.create = function create(properties) {
        return new mat22(properties);
    };

    /**
     * Encodes the specified mat22 message. Does not implicitly {@link mat22.verify|verify} messages.
     * @param {mat22$Properties} message mat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat22.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            $root.vec2.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && message.hasOwnProperty("y"))
            $root.vec2.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified mat22 message, length delimited. Does not implicitly {@link mat22.verify|verify} messages.
     * @param {mat22$Properties} message mat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat22.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a mat22 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat22} mat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat22.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat22();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.vec2.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.vec2.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a mat22 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {mat22} mat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat22.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a mat22 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    mat22.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x")) {
            var error = $root.vec2.verify(message.x);
            if (error)
                return "x." + error;
        }
        if (message.y != null && message.hasOwnProperty("y")) {
            var error = $root.vec2.verify(message.y);
            if (error)
                return "y." + error;
        }
        return null;
    };

    /**
     * Creates a mat22 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {mat22} mat22
     */
    mat22.fromObject = function fromObject(object) {
        if (object instanceof $root.mat22)
            return object;
        var message = new $root.mat22();
        if (object.x != null) {
            if (typeof object.x !== "object")
                throw TypeError(".mat22.x: object expected");
            message.x = $root.vec2.fromObject(object.x);
        }
        if (object.y != null) {
            if (typeof object.y !== "object")
                throw TypeError(".mat22.y: object expected");
            message.y = $root.vec2.fromObject(object.y);
        }
        return message;
    };

    /**
     * Creates a mat22 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link mat22.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {mat22} mat22
     */
    mat22.from = mat22.fromObject;

    /**
     * Creates a plain object from a mat22 message. Also converts values to other types if specified.
     * @param {mat22} message mat22
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    mat22.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = null;
            object.y = null;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = $root.vec2.toObject(message.x, options);
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = $root.vec2.toObject(message.y, options);
        return object;
    };

    /**
     * Creates a plain object from this mat22 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    mat22.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this mat22 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    mat22.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return mat22;
})();

$root.fmat22 = (function() {

    /**
     * Properties of a fmat22.
     * @typedef fmat22$Properties
     * @type {Object}
     * @property {fvec2$Properties} [x] fmat22 x.
     * @property {fvec2$Properties} [y] fmat22 y.
     */

    /**
     * Constructs a new fmat22.
     * @exports fmat22
     * @constructor
     * @param {fmat22$Properties=} [properties] Properties to set
     */
    function fmat22(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat22 x.
     * @type {(fvec2$Properties|null)}
     */
    fmat22.prototype.x = null;

    /**
     * fmat22 y.
     * @type {(fvec2$Properties|null)}
     */
    fmat22.prototype.y = null;

    /**
     * Creates a new fmat22 instance using the specified properties.
     * @param {fmat22$Properties=} [properties] Properties to set
     * @returns {fmat22} fmat22 instance
     */
    fmat22.create = function create(properties) {
        return new fmat22(properties);
    };

    /**
     * Encodes the specified fmat22 message. Does not implicitly {@link fmat22.verify|verify} messages.
     * @param {fmat22$Properties} message fmat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat22.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            $root.fvec2.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && message.hasOwnProperty("y"))
            $root.fvec2.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified fmat22 message, length delimited. Does not implicitly {@link fmat22.verify|verify} messages.
     * @param {fmat22$Properties} message fmat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat22.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a fmat22 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat22} fmat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat22.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat22();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.fvec2.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.fvec2.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a fmat22 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fmat22} fmat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat22.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a fmat22 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    fmat22.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x")) {
            var error = $root.fvec2.verify(message.x);
            if (error)
                return "x." + error;
        }
        if (message.y != null && message.hasOwnProperty("y")) {
            var error = $root.fvec2.verify(message.y);
            if (error)
                return "y." + error;
        }
        return null;
    };

    /**
     * Creates a fmat22 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat22} fmat22
     */
    fmat22.fromObject = function fromObject(object) {
        if (object instanceof $root.fmat22)
            return object;
        var message = new $root.fmat22();
        if (object.x != null) {
            if (typeof object.x !== "object")
                throw TypeError(".fmat22.x: object expected");
            message.x = $root.fvec2.fromObject(object.x);
        }
        if (object.y != null) {
            if (typeof object.y !== "object")
                throw TypeError(".fmat22.y: object expected");
            message.y = $root.fvec2.fromObject(object.y);
        }
        return message;
    };

    /**
     * Creates a fmat22 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fmat22.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat22} fmat22
     */
    fmat22.from = fmat22.fromObject;

    /**
     * Creates a plain object from a fmat22 message. Also converts values to other types if specified.
     * @param {fmat22} message fmat22
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fmat22.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = null;
            object.y = null;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = $root.fvec2.toObject(message.x, options);
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = $root.fvec2.toObject(message.y, options);
        return object;
    };

    /**
     * Creates a plain object from this fmat22 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fmat22.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this fmat22 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    fmat22.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return fmat22;
})();

$root.imat22 = (function() {

    /**
     * Properties of an imat22.
     * @typedef imat22$Properties
     * @type {Object}
     * @property {ivec2$Properties} [x] imat22 x.
     * @property {ivec2$Properties} [y] imat22 y.
     */

    /**
     * Constructs a new imat22.
     * @exports imat22
     * @constructor
     * @param {imat22$Properties=} [properties] Properties to set
     */
    function imat22(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat22 x.
     * @type {(ivec2$Properties|null)}
     */
    imat22.prototype.x = null;

    /**
     * imat22 y.
     * @type {(ivec2$Properties|null)}
     */
    imat22.prototype.y = null;

    /**
     * Creates a new imat22 instance using the specified properties.
     * @param {imat22$Properties=} [properties] Properties to set
     * @returns {imat22} imat22 instance
     */
    imat22.create = function create(properties) {
        return new imat22(properties);
    };

    /**
     * Encodes the specified imat22 message. Does not implicitly {@link imat22.verify|verify} messages.
     * @param {imat22$Properties} message imat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat22.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            $root.ivec2.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && message.hasOwnProperty("y"))
            $root.ivec2.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified imat22 message, length delimited. Does not implicitly {@link imat22.verify|verify} messages.
     * @param {imat22$Properties} message imat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat22.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an imat22 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat22} imat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat22.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat22();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.ivec2.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.ivec2.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an imat22 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {imat22} imat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat22.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an imat22 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    imat22.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x")) {
            var error = $root.ivec2.verify(message.x);
            if (error)
                return "x." + error;
        }
        if (message.y != null && message.hasOwnProperty("y")) {
            var error = $root.ivec2.verify(message.y);
            if (error)
                return "y." + error;
        }
        return null;
    };

    /**
     * Creates an imat22 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {imat22} imat22
     */
    imat22.fromObject = function fromObject(object) {
        if (object instanceof $root.imat22)
            return object;
        var message = new $root.imat22();
        if (object.x != null) {
            if (typeof object.x !== "object")
                throw TypeError(".imat22.x: object expected");
            message.x = $root.ivec2.fromObject(object.x);
        }
        if (object.y != null) {
            if (typeof object.y !== "object")
                throw TypeError(".imat22.y: object expected");
            message.y = $root.ivec2.fromObject(object.y);
        }
        return message;
    };

    /**
     * Creates an imat22 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link imat22.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {imat22} imat22
     */
    imat22.from = imat22.fromObject;

    /**
     * Creates a plain object from an imat22 message. Also converts values to other types if specified.
     * @param {imat22} message imat22
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    imat22.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = null;
            object.y = null;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = $root.ivec2.toObject(message.x, options);
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = $root.ivec2.toObject(message.y, options);
        return object;
    };

    /**
     * Creates a plain object from this imat22 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    imat22.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this imat22 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    imat22.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return imat22;
})();

$root.umat22 = (function() {

    /**
     * Properties of an umat22.
     * @typedef umat22$Properties
     * @type {Object}
     * @property {uvec2$Properties} [x] umat22 x.
     * @property {uvec2$Properties} [y] umat22 y.
     */

    /**
     * Constructs a new umat22.
     * @exports umat22
     * @constructor
     * @param {umat22$Properties=} [properties] Properties to set
     */
    function umat22(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat22 x.
     * @type {(uvec2$Properties|null)}
     */
    umat22.prototype.x = null;

    /**
     * umat22 y.
     * @type {(uvec2$Properties|null)}
     */
    umat22.prototype.y = null;

    /**
     * Creates a new umat22 instance using the specified properties.
     * @param {umat22$Properties=} [properties] Properties to set
     * @returns {umat22} umat22 instance
     */
    umat22.create = function create(properties) {
        return new umat22(properties);
    };

    /**
     * Encodes the specified umat22 message. Does not implicitly {@link umat22.verify|verify} messages.
     * @param {umat22$Properties} message umat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat22.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            $root.uvec2.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && message.hasOwnProperty("y"))
            $root.uvec2.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified umat22 message, length delimited. Does not implicitly {@link umat22.verify|verify} messages.
     * @param {umat22$Properties} message umat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat22.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an umat22 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat22} umat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat22.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat22();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.uvec2.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.uvec2.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an umat22 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {umat22} umat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat22.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an umat22 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    umat22.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x")) {
            var error = $root.uvec2.verify(message.x);
            if (error)
                return "x." + error;
        }
        if (message.y != null && message.hasOwnProperty("y")) {
            var error = $root.uvec2.verify(message.y);
            if (error)
                return "y." + error;
        }
        return null;
    };

    /**
     * Creates an umat22 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {umat22} umat22
     */
    umat22.fromObject = function fromObject(object) {
        if (object instanceof $root.umat22)
            return object;
        var message = new $root.umat22();
        if (object.x != null) {
            if (typeof object.x !== "object")
                throw TypeError(".umat22.x: object expected");
            message.x = $root.uvec2.fromObject(object.x);
        }
        if (object.y != null) {
            if (typeof object.y !== "object")
                throw TypeError(".umat22.y: object expected");
            message.y = $root.uvec2.fromObject(object.y);
        }
        return message;
    };

    /**
     * Creates an umat22 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link umat22.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {umat22} umat22
     */
    umat22.from = umat22.fromObject;

    /**
     * Creates a plain object from an umat22 message. Also converts values to other types if specified.
     * @param {umat22} message umat22
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    umat22.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = null;
            object.y = null;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = $root.uvec2.toObject(message.x, options);
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = $root.uvec2.toObject(message.y, options);
        return object;
    };

    /**
     * Creates a plain object from this umat22 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    umat22.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this umat22 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    umat22.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return umat22;
})();

$root.mat33 = (function() {

    /**
     * Properties of a mat33.
     * @typedef mat33$Properties
     * @type {Object}
     * @property {vec3$Properties} [x] mat33 x.
     * @property {vec3$Properties} [y] mat33 y.
     * @property {vec3$Properties} [z] mat33 z.
     */

    /**
     * Constructs a new mat33.
     * @exports mat33
     * @constructor
     * @param {mat33$Properties=} [properties] Properties to set
     */
    function mat33(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat33 x.
     * @type {(vec3$Properties|null)}
     */
    mat33.prototype.x = null;

    /**
     * mat33 y.
     * @type {(vec3$Properties|null)}
     */
    mat33.prototype.y = null;

    /**
     * mat33 z.
     * @type {(vec3$Properties|null)}
     */
    mat33.prototype.z = null;

    /**
     * Creates a new mat33 instance using the specified properties.
     * @param {mat33$Properties=} [properties] Properties to set
     * @returns {mat33} mat33 instance
     */
    mat33.create = function create(properties) {
        return new mat33(properties);
    };

    /**
     * Encodes the specified mat33 message. Does not implicitly {@link mat33.verify|verify} messages.
     * @param {mat33$Properties} message mat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat33.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            $root.vec3.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && message.hasOwnProperty("y"))
            $root.vec3.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && message.hasOwnProperty("z"))
            $root.vec3.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified mat33 message, length delimited. Does not implicitly {@link mat33.verify|verify} messages.
     * @param {mat33$Properties} message mat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat33.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a mat33 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat33} mat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat33.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat33();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.vec3.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.vec3.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.vec3.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a mat33 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {mat33} mat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat33.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a mat33 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    mat33.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x")) {
            var error = $root.vec3.verify(message.x);
            if (error)
                return "x." + error;
        }
        if (message.y != null && message.hasOwnProperty("y")) {
            var error = $root.vec3.verify(message.y);
            if (error)
                return "y." + error;
        }
        if (message.z != null && message.hasOwnProperty("z")) {
            var error = $root.vec3.verify(message.z);
            if (error)
                return "z." + error;
        }
        return null;
    };

    /**
     * Creates a mat33 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {mat33} mat33
     */
    mat33.fromObject = function fromObject(object) {
        if (object instanceof $root.mat33)
            return object;
        var message = new $root.mat33();
        if (object.x != null) {
            if (typeof object.x !== "object")
                throw TypeError(".mat33.x: object expected");
            message.x = $root.vec3.fromObject(object.x);
        }
        if (object.y != null) {
            if (typeof object.y !== "object")
                throw TypeError(".mat33.y: object expected");
            message.y = $root.vec3.fromObject(object.y);
        }
        if (object.z != null) {
            if (typeof object.z !== "object")
                throw TypeError(".mat33.z: object expected");
            message.z = $root.vec3.fromObject(object.z);
        }
        return message;
    };

    /**
     * Creates a mat33 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link mat33.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {mat33} mat33
     */
    mat33.from = mat33.fromObject;

    /**
     * Creates a plain object from a mat33 message. Also converts values to other types if specified.
     * @param {mat33} message mat33
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    mat33.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = null;
            object.y = null;
            object.z = null;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = $root.vec3.toObject(message.x, options);
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = $root.vec3.toObject(message.y, options);
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = $root.vec3.toObject(message.z, options);
        return object;
    };

    /**
     * Creates a plain object from this mat33 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    mat33.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this mat33 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    mat33.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return mat33;
})();

$root.fmat33 = (function() {

    /**
     * Properties of a fmat33.
     * @typedef fmat33$Properties
     * @type {Object}
     * @property {fvec3$Properties} [x] fmat33 x.
     * @property {fvec3$Properties} [y] fmat33 y.
     * @property {fvec3$Properties} [z] fmat33 z.
     */

    /**
     * Constructs a new fmat33.
     * @exports fmat33
     * @constructor
     * @param {fmat33$Properties=} [properties] Properties to set
     */
    function fmat33(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat33 x.
     * @type {(fvec3$Properties|null)}
     */
    fmat33.prototype.x = null;

    /**
     * fmat33 y.
     * @type {(fvec3$Properties|null)}
     */
    fmat33.prototype.y = null;

    /**
     * fmat33 z.
     * @type {(fvec3$Properties|null)}
     */
    fmat33.prototype.z = null;

    /**
     * Creates a new fmat33 instance using the specified properties.
     * @param {fmat33$Properties=} [properties] Properties to set
     * @returns {fmat33} fmat33 instance
     */
    fmat33.create = function create(properties) {
        return new fmat33(properties);
    };

    /**
     * Encodes the specified fmat33 message. Does not implicitly {@link fmat33.verify|verify} messages.
     * @param {fmat33$Properties} message fmat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat33.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            $root.fvec3.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && message.hasOwnProperty("y"))
            $root.fvec3.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && message.hasOwnProperty("z"))
            $root.fvec3.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified fmat33 message, length delimited. Does not implicitly {@link fmat33.verify|verify} messages.
     * @param {fmat33$Properties} message fmat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat33.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a fmat33 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat33} fmat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat33.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat33();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.fvec3.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.fvec3.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.fvec3.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a fmat33 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fmat33} fmat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat33.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a fmat33 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    fmat33.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x")) {
            var error = $root.fvec3.verify(message.x);
            if (error)
                return "x." + error;
        }
        if (message.y != null && message.hasOwnProperty("y")) {
            var error = $root.fvec3.verify(message.y);
            if (error)
                return "y." + error;
        }
        if (message.z != null && message.hasOwnProperty("z")) {
            var error = $root.fvec3.verify(message.z);
            if (error)
                return "z." + error;
        }
        return null;
    };

    /**
     * Creates a fmat33 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat33} fmat33
     */
    fmat33.fromObject = function fromObject(object) {
        if (object instanceof $root.fmat33)
            return object;
        var message = new $root.fmat33();
        if (object.x != null) {
            if (typeof object.x !== "object")
                throw TypeError(".fmat33.x: object expected");
            message.x = $root.fvec3.fromObject(object.x);
        }
        if (object.y != null) {
            if (typeof object.y !== "object")
                throw TypeError(".fmat33.y: object expected");
            message.y = $root.fvec3.fromObject(object.y);
        }
        if (object.z != null) {
            if (typeof object.z !== "object")
                throw TypeError(".fmat33.z: object expected");
            message.z = $root.fvec3.fromObject(object.z);
        }
        return message;
    };

    /**
     * Creates a fmat33 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fmat33.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat33} fmat33
     */
    fmat33.from = fmat33.fromObject;

    /**
     * Creates a plain object from a fmat33 message. Also converts values to other types if specified.
     * @param {fmat33} message fmat33
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fmat33.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = null;
            object.y = null;
            object.z = null;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = $root.fvec3.toObject(message.x, options);
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = $root.fvec3.toObject(message.y, options);
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = $root.fvec3.toObject(message.z, options);
        return object;
    };

    /**
     * Creates a plain object from this fmat33 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fmat33.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this fmat33 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    fmat33.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return fmat33;
})();

$root.imat33 = (function() {

    /**
     * Properties of an imat33.
     * @typedef imat33$Properties
     * @type {Object}
     * @property {ivec3$Properties} [x] imat33 x.
     * @property {ivec3$Properties} [y] imat33 y.
     * @property {ivec3$Properties} [z] imat33 z.
     */

    /**
     * Constructs a new imat33.
     * @exports imat33
     * @constructor
     * @param {imat33$Properties=} [properties] Properties to set
     */
    function imat33(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat33 x.
     * @type {(ivec3$Properties|null)}
     */
    imat33.prototype.x = null;

    /**
     * imat33 y.
     * @type {(ivec3$Properties|null)}
     */
    imat33.prototype.y = null;

    /**
     * imat33 z.
     * @type {(ivec3$Properties|null)}
     */
    imat33.prototype.z = null;

    /**
     * Creates a new imat33 instance using the specified properties.
     * @param {imat33$Properties=} [properties] Properties to set
     * @returns {imat33} imat33 instance
     */
    imat33.create = function create(properties) {
        return new imat33(properties);
    };

    /**
     * Encodes the specified imat33 message. Does not implicitly {@link imat33.verify|verify} messages.
     * @param {imat33$Properties} message imat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat33.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            $root.ivec3.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && message.hasOwnProperty("y"))
            $root.ivec3.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && message.hasOwnProperty("z"))
            $root.ivec3.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified imat33 message, length delimited. Does not implicitly {@link imat33.verify|verify} messages.
     * @param {imat33$Properties} message imat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat33.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an imat33 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat33} imat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat33.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat33();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.ivec3.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.ivec3.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.ivec3.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an imat33 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {imat33} imat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat33.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an imat33 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    imat33.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x")) {
            var error = $root.ivec3.verify(message.x);
            if (error)
                return "x." + error;
        }
        if (message.y != null && message.hasOwnProperty("y")) {
            var error = $root.ivec3.verify(message.y);
            if (error)
                return "y." + error;
        }
        if (message.z != null && message.hasOwnProperty("z")) {
            var error = $root.ivec3.verify(message.z);
            if (error)
                return "z." + error;
        }
        return null;
    };

    /**
     * Creates an imat33 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {imat33} imat33
     */
    imat33.fromObject = function fromObject(object) {
        if (object instanceof $root.imat33)
            return object;
        var message = new $root.imat33();
        if (object.x != null) {
            if (typeof object.x !== "object")
                throw TypeError(".imat33.x: object expected");
            message.x = $root.ivec3.fromObject(object.x);
        }
        if (object.y != null) {
            if (typeof object.y !== "object")
                throw TypeError(".imat33.y: object expected");
            message.y = $root.ivec3.fromObject(object.y);
        }
        if (object.z != null) {
            if (typeof object.z !== "object")
                throw TypeError(".imat33.z: object expected");
            message.z = $root.ivec3.fromObject(object.z);
        }
        return message;
    };

    /**
     * Creates an imat33 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link imat33.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {imat33} imat33
     */
    imat33.from = imat33.fromObject;

    /**
     * Creates a plain object from an imat33 message. Also converts values to other types if specified.
     * @param {imat33} message imat33
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    imat33.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = null;
            object.y = null;
            object.z = null;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = $root.ivec3.toObject(message.x, options);
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = $root.ivec3.toObject(message.y, options);
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = $root.ivec3.toObject(message.z, options);
        return object;
    };

    /**
     * Creates a plain object from this imat33 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    imat33.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this imat33 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    imat33.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return imat33;
})();

$root.umat33 = (function() {

    /**
     * Properties of an umat33.
     * @typedef umat33$Properties
     * @type {Object}
     * @property {uvec3$Properties} [x] umat33 x.
     * @property {uvec3$Properties} [y] umat33 y.
     * @property {uvec3$Properties} [z] umat33 z.
     */

    /**
     * Constructs a new umat33.
     * @exports umat33
     * @constructor
     * @param {umat33$Properties=} [properties] Properties to set
     */
    function umat33(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat33 x.
     * @type {(uvec3$Properties|null)}
     */
    umat33.prototype.x = null;

    /**
     * umat33 y.
     * @type {(uvec3$Properties|null)}
     */
    umat33.prototype.y = null;

    /**
     * umat33 z.
     * @type {(uvec3$Properties|null)}
     */
    umat33.prototype.z = null;

    /**
     * Creates a new umat33 instance using the specified properties.
     * @param {umat33$Properties=} [properties] Properties to set
     * @returns {umat33} umat33 instance
     */
    umat33.create = function create(properties) {
        return new umat33(properties);
    };

    /**
     * Encodes the specified umat33 message. Does not implicitly {@link umat33.verify|verify} messages.
     * @param {umat33$Properties} message umat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat33.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            $root.uvec3.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && message.hasOwnProperty("y"))
            $root.uvec3.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && message.hasOwnProperty("z"))
            $root.uvec3.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified umat33 message, length delimited. Does not implicitly {@link umat33.verify|verify} messages.
     * @param {umat33$Properties} message umat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat33.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an umat33 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat33} umat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat33.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat33();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.uvec3.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.uvec3.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.uvec3.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an umat33 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {umat33} umat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat33.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an umat33 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    umat33.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x")) {
            var error = $root.uvec3.verify(message.x);
            if (error)
                return "x." + error;
        }
        if (message.y != null && message.hasOwnProperty("y")) {
            var error = $root.uvec3.verify(message.y);
            if (error)
                return "y." + error;
        }
        if (message.z != null && message.hasOwnProperty("z")) {
            var error = $root.uvec3.verify(message.z);
            if (error)
                return "z." + error;
        }
        return null;
    };

    /**
     * Creates an umat33 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {umat33} umat33
     */
    umat33.fromObject = function fromObject(object) {
        if (object instanceof $root.umat33)
            return object;
        var message = new $root.umat33();
        if (object.x != null) {
            if (typeof object.x !== "object")
                throw TypeError(".umat33.x: object expected");
            message.x = $root.uvec3.fromObject(object.x);
        }
        if (object.y != null) {
            if (typeof object.y !== "object")
                throw TypeError(".umat33.y: object expected");
            message.y = $root.uvec3.fromObject(object.y);
        }
        if (object.z != null) {
            if (typeof object.z !== "object")
                throw TypeError(".umat33.z: object expected");
            message.z = $root.uvec3.fromObject(object.z);
        }
        return message;
    };

    /**
     * Creates an umat33 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link umat33.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {umat33} umat33
     */
    umat33.from = umat33.fromObject;

    /**
     * Creates a plain object from an umat33 message. Also converts values to other types if specified.
     * @param {umat33} message umat33
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    umat33.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = null;
            object.y = null;
            object.z = null;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = $root.uvec3.toObject(message.x, options);
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = $root.uvec3.toObject(message.y, options);
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = $root.uvec3.toObject(message.z, options);
        return object;
    };

    /**
     * Creates a plain object from this umat33 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    umat33.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this umat33 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    umat33.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return umat33;
})();

$root.mat44 = (function() {

    /**
     * Properties of a mat44.
     * @typedef mat44$Properties
     * @type {Object}
     * @property {vec4$Properties} [x] mat44 x.
     * @property {vec4$Properties} [y] mat44 y.
     * @property {vec4$Properties} [z] mat44 z.
     * @property {vec4$Properties} [t] mat44 t.
     */

    /**
     * Constructs a new mat44.
     * @exports mat44
     * @constructor
     * @param {mat44$Properties=} [properties] Properties to set
     */
    function mat44(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * mat44 x.
     * @type {(vec4$Properties|null)}
     */
    mat44.prototype.x = null;

    /**
     * mat44 y.
     * @type {(vec4$Properties|null)}
     */
    mat44.prototype.y = null;

    /**
     * mat44 z.
     * @type {(vec4$Properties|null)}
     */
    mat44.prototype.z = null;

    /**
     * mat44 t.
     * @type {(vec4$Properties|null)}
     */
    mat44.prototype.t = null;

    /**
     * Creates a new mat44 instance using the specified properties.
     * @param {mat44$Properties=} [properties] Properties to set
     * @returns {mat44} mat44 instance
     */
    mat44.create = function create(properties) {
        return new mat44(properties);
    };

    /**
     * Encodes the specified mat44 message. Does not implicitly {@link mat44.verify|verify} messages.
     * @param {mat44$Properties} message mat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat44.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            $root.vec4.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && message.hasOwnProperty("y"))
            $root.vec4.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && message.hasOwnProperty("z"))
            $root.vec4.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.t != null && message.hasOwnProperty("t"))
            $root.vec4.encode(message.t, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified mat44 message, length delimited. Does not implicitly {@link mat44.verify|verify} messages.
     * @param {mat44$Properties} message mat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    mat44.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a mat44 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat44} mat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat44.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mat44();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.vec4.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.vec4.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.vec4.decode(reader, reader.uint32());
                break;
            case 4:
                message.t = $root.vec4.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a mat44 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {mat44} mat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    mat44.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a mat44 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    mat44.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x")) {
            var error = $root.vec4.verify(message.x);
            if (error)
                return "x." + error;
        }
        if (message.y != null && message.hasOwnProperty("y")) {
            var error = $root.vec4.verify(message.y);
            if (error)
                return "y." + error;
        }
        if (message.z != null && message.hasOwnProperty("z")) {
            var error = $root.vec4.verify(message.z);
            if (error)
                return "z." + error;
        }
        if (message.t != null && message.hasOwnProperty("t")) {
            var error = $root.vec4.verify(message.t);
            if (error)
                return "t." + error;
        }
        return null;
    };

    /**
     * Creates a mat44 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {mat44} mat44
     */
    mat44.fromObject = function fromObject(object) {
        if (object instanceof $root.mat44)
            return object;
        var message = new $root.mat44();
        if (object.x != null) {
            if (typeof object.x !== "object")
                throw TypeError(".mat44.x: object expected");
            message.x = $root.vec4.fromObject(object.x);
        }
        if (object.y != null) {
            if (typeof object.y !== "object")
                throw TypeError(".mat44.y: object expected");
            message.y = $root.vec4.fromObject(object.y);
        }
        if (object.z != null) {
            if (typeof object.z !== "object")
                throw TypeError(".mat44.z: object expected");
            message.z = $root.vec4.fromObject(object.z);
        }
        if (object.t != null) {
            if (typeof object.t !== "object")
                throw TypeError(".mat44.t: object expected");
            message.t = $root.vec4.fromObject(object.t);
        }
        return message;
    };

    /**
     * Creates a mat44 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link mat44.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {mat44} mat44
     */
    mat44.from = mat44.fromObject;

    /**
     * Creates a plain object from a mat44 message. Also converts values to other types if specified.
     * @param {mat44} message mat44
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    mat44.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = null;
            object.y = null;
            object.z = null;
            object.t = null;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = $root.vec4.toObject(message.x, options);
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = $root.vec4.toObject(message.y, options);
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = $root.vec4.toObject(message.z, options);
        if (message.t != null && message.hasOwnProperty("t"))
            object.t = $root.vec4.toObject(message.t, options);
        return object;
    };

    /**
     * Creates a plain object from this mat44 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    mat44.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this mat44 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    mat44.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return mat44;
})();

$root.fmat44 = (function() {

    /**
     * Properties of a fmat44.
     * @typedef fmat44$Properties
     * @type {Object}
     * @property {fvec4$Properties} [x] fmat44 x.
     * @property {fvec4$Properties} [y] fmat44 y.
     * @property {fvec4$Properties} [z] fmat44 z.
     * @property {fvec4$Properties} [t] fmat44 t.
     */

    /**
     * Constructs a new fmat44.
     * @exports fmat44
     * @constructor
     * @param {fmat44$Properties=} [properties] Properties to set
     */
    function fmat44(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fmat44 x.
     * @type {(fvec4$Properties|null)}
     */
    fmat44.prototype.x = null;

    /**
     * fmat44 y.
     * @type {(fvec4$Properties|null)}
     */
    fmat44.prototype.y = null;

    /**
     * fmat44 z.
     * @type {(fvec4$Properties|null)}
     */
    fmat44.prototype.z = null;

    /**
     * fmat44 t.
     * @type {(fvec4$Properties|null)}
     */
    fmat44.prototype.t = null;

    /**
     * Creates a new fmat44 instance using the specified properties.
     * @param {fmat44$Properties=} [properties] Properties to set
     * @returns {fmat44} fmat44 instance
     */
    fmat44.create = function create(properties) {
        return new fmat44(properties);
    };

    /**
     * Encodes the specified fmat44 message. Does not implicitly {@link fmat44.verify|verify} messages.
     * @param {fmat44$Properties} message fmat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat44.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            $root.fvec4.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && message.hasOwnProperty("y"))
            $root.fvec4.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && message.hasOwnProperty("z"))
            $root.fvec4.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.t != null && message.hasOwnProperty("t"))
            $root.fvec4.encode(message.t, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified fmat44 message, length delimited. Does not implicitly {@link fmat44.verify|verify} messages.
     * @param {fmat44$Properties} message fmat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fmat44.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a fmat44 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat44} fmat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat44.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.fmat44();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.fvec4.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.fvec4.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.fvec4.decode(reader, reader.uint32());
                break;
            case 4:
                message.t = $root.fvec4.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a fmat44 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fmat44} fmat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fmat44.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a fmat44 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    fmat44.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x")) {
            var error = $root.fvec4.verify(message.x);
            if (error)
                return "x." + error;
        }
        if (message.y != null && message.hasOwnProperty("y")) {
            var error = $root.fvec4.verify(message.y);
            if (error)
                return "y." + error;
        }
        if (message.z != null && message.hasOwnProperty("z")) {
            var error = $root.fvec4.verify(message.z);
            if (error)
                return "z." + error;
        }
        if (message.t != null && message.hasOwnProperty("t")) {
            var error = $root.fvec4.verify(message.t);
            if (error)
                return "t." + error;
        }
        return null;
    };

    /**
     * Creates a fmat44 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat44} fmat44
     */
    fmat44.fromObject = function fromObject(object) {
        if (object instanceof $root.fmat44)
            return object;
        var message = new $root.fmat44();
        if (object.x != null) {
            if (typeof object.x !== "object")
                throw TypeError(".fmat44.x: object expected");
            message.x = $root.fvec4.fromObject(object.x);
        }
        if (object.y != null) {
            if (typeof object.y !== "object")
                throw TypeError(".fmat44.y: object expected");
            message.y = $root.fvec4.fromObject(object.y);
        }
        if (object.z != null) {
            if (typeof object.z !== "object")
                throw TypeError(".fmat44.z: object expected");
            message.z = $root.fvec4.fromObject(object.z);
        }
        if (object.t != null) {
            if (typeof object.t !== "object")
                throw TypeError(".fmat44.t: object expected");
            message.t = $root.fvec4.fromObject(object.t);
        }
        return message;
    };

    /**
     * Creates a fmat44 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fmat44.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat44} fmat44
     */
    fmat44.from = fmat44.fromObject;

    /**
     * Creates a plain object from a fmat44 message. Also converts values to other types if specified.
     * @param {fmat44} message fmat44
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fmat44.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = null;
            object.y = null;
            object.z = null;
            object.t = null;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = $root.fvec4.toObject(message.x, options);
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = $root.fvec4.toObject(message.y, options);
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = $root.fvec4.toObject(message.z, options);
        if (message.t != null && message.hasOwnProperty("t"))
            object.t = $root.fvec4.toObject(message.t, options);
        return object;
    };

    /**
     * Creates a plain object from this fmat44 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fmat44.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this fmat44 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    fmat44.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return fmat44;
})();

$root.imat44 = (function() {

    /**
     * Properties of an imat44.
     * @typedef imat44$Properties
     * @type {Object}
     * @property {ivec4$Properties} [x] imat44 x.
     * @property {ivec4$Properties} [y] imat44 y.
     * @property {ivec4$Properties} [z] imat44 z.
     * @property {ivec4$Properties} [t] imat44 t.
     */

    /**
     * Constructs a new imat44.
     * @exports imat44
     * @constructor
     * @param {imat44$Properties=} [properties] Properties to set
     */
    function imat44(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * imat44 x.
     * @type {(ivec4$Properties|null)}
     */
    imat44.prototype.x = null;

    /**
     * imat44 y.
     * @type {(ivec4$Properties|null)}
     */
    imat44.prototype.y = null;

    /**
     * imat44 z.
     * @type {(ivec4$Properties|null)}
     */
    imat44.prototype.z = null;

    /**
     * imat44 t.
     * @type {(ivec4$Properties|null)}
     */
    imat44.prototype.t = null;

    /**
     * Creates a new imat44 instance using the specified properties.
     * @param {imat44$Properties=} [properties] Properties to set
     * @returns {imat44} imat44 instance
     */
    imat44.create = function create(properties) {
        return new imat44(properties);
    };

    /**
     * Encodes the specified imat44 message. Does not implicitly {@link imat44.verify|verify} messages.
     * @param {imat44$Properties} message imat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat44.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            $root.ivec4.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && message.hasOwnProperty("y"))
            $root.ivec4.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && message.hasOwnProperty("z"))
            $root.ivec4.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.t != null && message.hasOwnProperty("t"))
            $root.ivec4.encode(message.t, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified imat44 message, length delimited. Does not implicitly {@link imat44.verify|verify} messages.
     * @param {imat44$Properties} message imat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    imat44.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an imat44 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat44} imat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat44.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.imat44();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.ivec4.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.ivec4.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.ivec4.decode(reader, reader.uint32());
                break;
            case 4:
                message.t = $root.ivec4.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an imat44 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {imat44} imat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    imat44.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an imat44 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    imat44.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x")) {
            var error = $root.ivec4.verify(message.x);
            if (error)
                return "x." + error;
        }
        if (message.y != null && message.hasOwnProperty("y")) {
            var error = $root.ivec4.verify(message.y);
            if (error)
                return "y." + error;
        }
        if (message.z != null && message.hasOwnProperty("z")) {
            var error = $root.ivec4.verify(message.z);
            if (error)
                return "z." + error;
        }
        if (message.t != null && message.hasOwnProperty("t")) {
            var error = $root.ivec4.verify(message.t);
            if (error)
                return "t." + error;
        }
        return null;
    };

    /**
     * Creates an imat44 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {imat44} imat44
     */
    imat44.fromObject = function fromObject(object) {
        if (object instanceof $root.imat44)
            return object;
        var message = new $root.imat44();
        if (object.x != null) {
            if (typeof object.x !== "object")
                throw TypeError(".imat44.x: object expected");
            message.x = $root.ivec4.fromObject(object.x);
        }
        if (object.y != null) {
            if (typeof object.y !== "object")
                throw TypeError(".imat44.y: object expected");
            message.y = $root.ivec4.fromObject(object.y);
        }
        if (object.z != null) {
            if (typeof object.z !== "object")
                throw TypeError(".imat44.z: object expected");
            message.z = $root.ivec4.fromObject(object.z);
        }
        if (object.t != null) {
            if (typeof object.t !== "object")
                throw TypeError(".imat44.t: object expected");
            message.t = $root.ivec4.fromObject(object.t);
        }
        return message;
    };

    /**
     * Creates an imat44 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link imat44.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {imat44} imat44
     */
    imat44.from = imat44.fromObject;

    /**
     * Creates a plain object from an imat44 message. Also converts values to other types if specified.
     * @param {imat44} message imat44
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    imat44.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = null;
            object.y = null;
            object.z = null;
            object.t = null;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = $root.ivec4.toObject(message.x, options);
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = $root.ivec4.toObject(message.y, options);
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = $root.ivec4.toObject(message.z, options);
        if (message.t != null && message.hasOwnProperty("t"))
            object.t = $root.ivec4.toObject(message.t, options);
        return object;
    };

    /**
     * Creates a plain object from this imat44 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    imat44.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this imat44 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    imat44.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return imat44;
})();

$root.umat44 = (function() {

    /**
     * Properties of an umat44.
     * @typedef umat44$Properties
     * @type {Object}
     * @property {uvec4$Properties} [x] umat44 x.
     * @property {uvec4$Properties} [y] umat44 y.
     * @property {uvec4$Properties} [z] umat44 z.
     * @property {uvec4$Properties} [t] umat44 t.
     */

    /**
     * Constructs a new umat44.
     * @exports umat44
     * @constructor
     * @param {umat44$Properties=} [properties] Properties to set
     */
    function umat44(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * umat44 x.
     * @type {(uvec4$Properties|null)}
     */
    umat44.prototype.x = null;

    /**
     * umat44 y.
     * @type {(uvec4$Properties|null)}
     */
    umat44.prototype.y = null;

    /**
     * umat44 z.
     * @type {(uvec4$Properties|null)}
     */
    umat44.prototype.z = null;

    /**
     * umat44 t.
     * @type {(uvec4$Properties|null)}
     */
    umat44.prototype.t = null;

    /**
     * Creates a new umat44 instance using the specified properties.
     * @param {umat44$Properties=} [properties] Properties to set
     * @returns {umat44} umat44 instance
     */
    umat44.create = function create(properties) {
        return new umat44(properties);
    };

    /**
     * Encodes the specified umat44 message. Does not implicitly {@link umat44.verify|verify} messages.
     * @param {umat44$Properties} message umat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat44.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            $root.uvec4.encode(message.x, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.y != null && message.hasOwnProperty("y"))
            $root.uvec4.encode(message.y, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.z != null && message.hasOwnProperty("z"))
            $root.uvec4.encode(message.z, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.t != null && message.hasOwnProperty("t"))
            $root.uvec4.encode(message.t, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified umat44 message, length delimited. Does not implicitly {@link umat44.verify|verify} messages.
     * @param {umat44$Properties} message umat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    umat44.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an umat44 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat44} umat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat44.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.umat44();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = $root.uvec4.decode(reader, reader.uint32());
                break;
            case 2:
                message.y = $root.uvec4.decode(reader, reader.uint32());
                break;
            case 3:
                message.z = $root.uvec4.decode(reader, reader.uint32());
                break;
            case 4:
                message.t = $root.uvec4.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an umat44 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {umat44} umat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    umat44.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an umat44 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    umat44.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x")) {
            var error = $root.uvec4.verify(message.x);
            if (error)
                return "x." + error;
        }
        if (message.y != null && message.hasOwnProperty("y")) {
            var error = $root.uvec4.verify(message.y);
            if (error)
                return "y." + error;
        }
        if (message.z != null && message.hasOwnProperty("z")) {
            var error = $root.uvec4.verify(message.z);
            if (error)
                return "z." + error;
        }
        if (message.t != null && message.hasOwnProperty("t")) {
            var error = $root.uvec4.verify(message.t);
            if (error)
                return "t." + error;
        }
        return null;
    };

    /**
     * Creates an umat44 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {umat44} umat44
     */
    umat44.fromObject = function fromObject(object) {
        if (object instanceof $root.umat44)
            return object;
        var message = new $root.umat44();
        if (object.x != null) {
            if (typeof object.x !== "object")
                throw TypeError(".umat44.x: object expected");
            message.x = $root.uvec4.fromObject(object.x);
        }
        if (object.y != null) {
            if (typeof object.y !== "object")
                throw TypeError(".umat44.y: object expected");
            message.y = $root.uvec4.fromObject(object.y);
        }
        if (object.z != null) {
            if (typeof object.z !== "object")
                throw TypeError(".umat44.z: object expected");
            message.z = $root.uvec4.fromObject(object.z);
        }
        if (object.t != null) {
            if (typeof object.t !== "object")
                throw TypeError(".umat44.t: object expected");
            message.t = $root.uvec4.fromObject(object.t);
        }
        return message;
    };

    /**
     * Creates an umat44 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link umat44.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {umat44} umat44
     */
    umat44.from = umat44.fromObject;

    /**
     * Creates a plain object from an umat44 message. Also converts values to other types if specified.
     * @param {umat44} message umat44
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    umat44.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = null;
            object.y = null;
            object.z = null;
            object.t = null;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = $root.uvec4.toObject(message.x, options);
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = $root.uvec4.toObject(message.y, options);
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = $root.uvec4.toObject(message.z, options);
        if (message.t != null && message.hasOwnProperty("t"))
            object.t = $root.uvec4.toObject(message.t, options);
        return object;
    };

    /**
     * Creates a plain object from this umat44 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    umat44.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this umat44 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    umat44.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return umat44;
})();

$root.vec = (function() {

    /**
     * Properties of a vec.
     * @typedef vec$Properties
     * @type {Object}
     * @property {Array.<number>} [v] vec v.
     */

    /**
     * Constructs a new vec.
     * @exports vec
     * @constructor
     * @param {vec$Properties=} [properties] Properties to set
     */
    function vec(properties) {
        this.v = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec v.
     * @type {Array.<number>}
     */
    vec.prototype.v = $util.emptyArray;

    /**
     * Creates a new vec instance using the specified properties.
     * @param {vec$Properties=} [properties] Properties to set
     * @returns {vec} vec instance
     */
    vec.create = function create(properties) {
        return new vec(properties);
    };

    /**
     * Encodes the specified vec message. Does not implicitly {@link vec.verify|verify} messages.
     * @param {vec$Properties} message vec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 1, wireType 2 =*/10).fork();
            for (var i = 0; i < message.v.length; ++i)
                writer.double(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Encodes the specified vec message, length delimited. Does not implicitly {@link vec.verify|verify} messages.
     * @param {vec$Properties} message vec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a vec message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec} vec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.double());
                } else
                    message.v.push(reader.double());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a vec message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {vec} vec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a vec message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    vec.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.v != null && message.hasOwnProperty("v")) {
            if (!Array.isArray(message.v))
                return "v: array expected";
            for (var i = 0; i < message.v.length; ++i)
                if (typeof message.v[i] !== "number")
                    return "v: number[] expected";
        }
        return null;
    };

    /**
     * Creates a vec message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {vec} vec
     */
    vec.fromObject = function fromObject(object) {
        if (object instanceof $root.vec)
            return object;
        var message = new $root.vec();
        if (object.v) {
            if (!Array.isArray(object.v))
                throw TypeError(".vec.v: array expected");
            message.v = [];
            for (var i = 0; i < object.v.length; ++i)
                message.v[i] = Number(object.v[i]);
        }
        return message;
    };

    /**
     * Creates a vec message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link vec.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {vec} vec
     */
    vec.from = vec.fromObject;

    /**
     * Creates a plain object from a vec message. Also converts values to other types if specified.
     * @param {vec} message vec
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    vec.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.v = [];
        if (message.v && message.v.length) {
            object.v = [];
            for (var j = 0; j < message.v.length; ++j)
                object.v[j] = message.v[j];
        }
        return object;
    };

    /**
     * Creates a plain object from this vec message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    vec.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this vec to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    vec.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return vec;
})();

$root.fvec = (function() {

    /**
     * Properties of a fvec.
     * @typedef fvec$Properties
     * @type {Object}
     * @property {Array.<number>} [v] fvec v.
     */

    /**
     * Constructs a new fvec.
     * @exports fvec
     * @constructor
     * @param {fvec$Properties=} [properties] Properties to set
     */
    function fvec(properties) {
        this.v = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec v.
     * @type {Array.<number>}
     */
    fvec.prototype.v = $util.emptyArray;

    /**
     * Creates a new fvec instance using the specified properties.
     * @param {fvec$Properties=} [properties] Properties to set
     * @returns {fvec} fvec instance
     */
    fvec.create = function create(properties) {
        return new fvec(properties);
    };

    /**
     * Encodes the specified fvec message. Does not implicitly {@link fvec.verify|verify} messages.
     * @param {fvec$Properties} message fvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 1, wireType 2 =*/10).fork();
            for (var i = 0; i < message.v.length; ++i)
                writer.float(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Encodes the specified fvec message, length delimited. Does not implicitly {@link fvec.verify|verify} messages.
     * @param {fvec$Properties} message fvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a fvec message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec} fvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.float());
                } else
                    message.v.push(reader.float());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a fvec message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fvec} fvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a fvec message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    fvec.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.v != null && message.hasOwnProperty("v")) {
            if (!Array.isArray(message.v))
                return "v: array expected";
            for (var i = 0; i < message.v.length; ++i)
                if (typeof message.v[i] !== "number")
                    return "v: number[] expected";
        }
        return null;
    };

    /**
     * Creates a fvec message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec} fvec
     */
    fvec.fromObject = function fromObject(object) {
        if (object instanceof $root.fvec)
            return object;
        var message = new $root.fvec();
        if (object.v) {
            if (!Array.isArray(object.v))
                throw TypeError(".fvec.v: array expected");
            message.v = [];
            for (var i = 0; i < object.v.length; ++i)
                message.v[i] = Number(object.v[i]);
        }
        return message;
    };

    /**
     * Creates a fvec message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fvec.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec} fvec
     */
    fvec.from = fvec.fromObject;

    /**
     * Creates a plain object from a fvec message. Also converts values to other types if specified.
     * @param {fvec} message fvec
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fvec.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.v = [];
        if (message.v && message.v.length) {
            object.v = [];
            for (var j = 0; j < message.v.length; ++j)
                object.v[j] = message.v[j];
        }
        return object;
    };

    /**
     * Creates a plain object from this fvec message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fvec.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this fvec to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    fvec.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return fvec;
})();

$root.ivec = (function() {

    /**
     * Properties of an ivec.
     * @typedef ivec$Properties
     * @type {Object}
     * @property {Array.<number>} [v] ivec v.
     */

    /**
     * Constructs a new ivec.
     * @exports ivec
     * @constructor
     * @param {ivec$Properties=} [properties] Properties to set
     */
    function ivec(properties) {
        this.v = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec v.
     * @type {Array.<number>}
     */
    ivec.prototype.v = $util.emptyArray;

    /**
     * Creates a new ivec instance using the specified properties.
     * @param {ivec$Properties=} [properties] Properties to set
     * @returns {ivec} ivec instance
     */
    ivec.create = function create(properties) {
        return new ivec(properties);
    };

    /**
     * Encodes the specified ivec message. Does not implicitly {@link ivec.verify|verify} messages.
     * @param {ivec$Properties} message ivec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 1, wireType 2 =*/10).fork();
            for (var i = 0; i < message.v.length; ++i)
                writer.sint32(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Encodes the specified ivec message, length delimited. Does not implicitly {@link ivec.verify|verify} messages.
     * @param {ivec$Properties} message ivec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ivec message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec} ivec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.sint32());
                } else
                    message.v.push(reader.sint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ivec message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ivec} ivec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ivec message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    ivec.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.v != null && message.hasOwnProperty("v")) {
            if (!Array.isArray(message.v))
                return "v: array expected";
            for (var i = 0; i < message.v.length; ++i)
                if (!$util.isInteger(message.v[i]))
                    return "v: integer[] expected";
        }
        return null;
    };

    /**
     * Creates an ivec message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec} ivec
     */
    ivec.fromObject = function fromObject(object) {
        if (object instanceof $root.ivec)
            return object;
        var message = new $root.ivec();
        if (object.v) {
            if (!Array.isArray(object.v))
                throw TypeError(".ivec.v: array expected");
            message.v = [];
            for (var i = 0; i < object.v.length; ++i)
                message.v[i] = object.v[i] | 0;
        }
        return message;
    };

    /**
     * Creates an ivec message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link ivec.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec} ivec
     */
    ivec.from = ivec.fromObject;

    /**
     * Creates a plain object from an ivec message. Also converts values to other types if specified.
     * @param {ivec} message ivec
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ivec.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.v = [];
        if (message.v && message.v.length) {
            object.v = [];
            for (var j = 0; j < message.v.length; ++j)
                object.v[j] = message.v[j];
        }
        return object;
    };

    /**
     * Creates a plain object from this ivec message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ivec.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this ivec to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    ivec.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ivec;
})();

$root.uvec = (function() {

    /**
     * Properties of an uvec.
     * @typedef uvec$Properties
     * @type {Object}
     * @property {Array.<number>} [v] uvec v.
     */

    /**
     * Constructs a new uvec.
     * @exports uvec
     * @constructor
     * @param {uvec$Properties=} [properties] Properties to set
     */
    function uvec(properties) {
        this.v = [];
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec v.
     * @type {Array.<number>}
     */
    uvec.prototype.v = $util.emptyArray;

    /**
     * Creates a new uvec instance using the specified properties.
     * @param {uvec$Properties=} [properties] Properties to set
     * @returns {uvec} uvec instance
     */
    uvec.create = function create(properties) {
        return new uvec(properties);
    };

    /**
     * Encodes the specified uvec message. Does not implicitly {@link uvec.verify|verify} messages.
     * @param {uvec$Properties} message uvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.v != null && message.v.length) {
            writer.uint32(/* id 1, wireType 2 =*/10).fork();
            for (var i = 0; i < message.v.length; ++i)
                writer.uint32(message.v[i]);
            writer.ldelim();
        }
        return writer;
    };

    /**
     * Encodes the specified uvec message, length delimited. Does not implicitly {@link uvec.verify|verify} messages.
     * @param {uvec$Properties} message uvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an uvec message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec} uvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.v && message.v.length))
                    message.v = [];
                if ((tag & 7) === 2) {
                    var end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.v.push(reader.uint32());
                } else
                    message.v.push(reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an uvec message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {uvec} uvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an uvec message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    uvec.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.v != null && message.hasOwnProperty("v")) {
            if (!Array.isArray(message.v))
                return "v: array expected";
            for (var i = 0; i < message.v.length; ++i)
                if (!$util.isInteger(message.v[i]))
                    return "v: integer[] expected";
        }
        return null;
    };

    /**
     * Creates an uvec message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec} uvec
     */
    uvec.fromObject = function fromObject(object) {
        if (object instanceof $root.uvec)
            return object;
        var message = new $root.uvec();
        if (object.v) {
            if (!Array.isArray(object.v))
                throw TypeError(".uvec.v: array expected");
            message.v = [];
            for (var i = 0; i < object.v.length; ++i)
                message.v[i] = object.v[i] >>> 0;
        }
        return message;
    };

    /**
     * Creates an uvec message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link uvec.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec} uvec
     */
    uvec.from = uvec.fromObject;

    /**
     * Creates a plain object from an uvec message. Also converts values to other types if specified.
     * @param {uvec} message uvec
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    uvec.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.arrays || options.defaults)
            object.v = [];
        if (message.v && message.v.length) {
            object.v = [];
            for (var j = 0; j < message.v.length; ++j)
                object.v[j] = message.v[j];
        }
        return object;
    };

    /**
     * Creates a plain object from this uvec message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    uvec.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this uvec to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    uvec.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return uvec;
})();

$root.cvec = (function() {

    /**
     * Properties of a cvec.
     * @typedef cvec$Properties
     * @type {Object}
     * @property {Uint8Array} [v] cvec v.
     */

    /**
     * Constructs a new cvec.
     * @exports cvec
     * @constructor
     * @param {cvec$Properties=} [properties] Properties to set
     */
    function cvec(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * cvec v.
     * @type {Uint8Array}
     */
    cvec.prototype.v = $util.newBuffer([]);

    /**
     * Creates a new cvec instance using the specified properties.
     * @param {cvec$Properties=} [properties] Properties to set
     * @returns {cvec} cvec instance
     */
    cvec.create = function create(properties) {
        return new cvec(properties);
    };

    /**
     * Encodes the specified cvec message. Does not implicitly {@link cvec.verify|verify} messages.
     * @param {cvec$Properties} message cvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    cvec.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.v != null && message.hasOwnProperty("v"))
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.v);
        return writer;
    };

    /**
     * Encodes the specified cvec message, length delimited. Does not implicitly {@link cvec.verify|verify} messages.
     * @param {cvec$Properties} message cvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    cvec.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a cvec message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {cvec} cvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    cvec.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cvec();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.v = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a cvec message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {cvec} cvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    cvec.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a cvec message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    cvec.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.v != null && message.hasOwnProperty("v"))
            if (!(message.v && typeof message.v.length === "number" || $util.isString(message.v)))
                return "v: buffer expected";
        return null;
    };

    /**
     * Creates a cvec message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {cvec} cvec
     */
    cvec.fromObject = function fromObject(object) {
        if (object instanceof $root.cvec)
            return object;
        var message = new $root.cvec();
        if (object.v != null)
            if (typeof object.v === "string")
                $util.base64.decode(object.v, message.v = $util.newBuffer($util.base64.length(object.v)), 0);
            else if (object.v.length)
                message.v = object.v;
        return message;
    };

    /**
     * Creates a cvec message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link cvec.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {cvec} cvec
     */
    cvec.from = cvec.fromObject;

    /**
     * Creates a plain object from a cvec message. Also converts values to other types if specified.
     * @param {cvec} message cvec
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    cvec.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults)
            object.v = options.bytes === String ? "" : [];
        if (message.v != null && message.hasOwnProperty("v"))
            object.v = options.bytes === String ? $util.base64.encode(message.v, 0, message.v.length) : options.bytes === Array ? Array.prototype.slice.call(message.v) : message.v;
        return object;
    };

    /**
     * Creates a plain object from this cvec message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    cvec.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this cvec to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    cvec.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return cvec;
})();

$root.vec2 = (function() {

    /**
     * Properties of a vec2.
     * @typedef vec2$Properties
     * @type {Object}
     * @property {number} [x] vec2 x.
     * @property {number} [y] vec2 y.
     */

    /**
     * Constructs a new vec2.
     * @exports vec2
     * @constructor
     * @param {vec2$Properties=} [properties] Properties to set
     */
    function vec2(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec2 x.
     * @type {number}
     */
    vec2.prototype.x = 0;

    /**
     * vec2 y.
     * @type {number}
     */
    vec2.prototype.y = 0;

    /**
     * Creates a new vec2 instance using the specified properties.
     * @param {vec2$Properties=} [properties] Properties to set
     * @returns {vec2} vec2 instance
     */
    vec2.create = function create(properties) {
        return new vec2(properties);
    };

    /**
     * Encodes the specified vec2 message. Does not implicitly {@link vec2.verify|verify} messages.
     * @param {vec2$Properties} message vec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec2.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
        if (message.y != null && message.hasOwnProperty("y"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
        return writer;
    };

    /**
     * Encodes the specified vec2 message, length delimited. Does not implicitly {@link vec2.verify|verify} messages.
     * @param {vec2$Properties} message vec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec2.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a vec2 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec2} vec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec2();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.double();
                break;
            case 2:
                message.y = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a vec2 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {vec2} vec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec2.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a vec2 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    vec2.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x"))
            if (typeof message.x !== "number")
                return "x: number expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (typeof message.y !== "number")
                return "y: number expected";
        return null;
    };

    /**
     * Creates a vec2 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {vec2} vec2
     */
    vec2.fromObject = function fromObject(object) {
        if (object instanceof $root.vec2)
            return object;
        var message = new $root.vec2();
        if (object.x != null)
            message.x = Number(object.x);
        if (object.y != null)
            message.y = Number(object.y);
        return message;
    };

    /**
     * Creates a vec2 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link vec2.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {vec2} vec2
     */
    vec2.from = vec2.fromObject;

    /**
     * Creates a plain object from a vec2 message. Also converts values to other types if specified.
     * @param {vec2} message vec2
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    vec2.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = message.y;
        return object;
    };

    /**
     * Creates a plain object from this vec2 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    vec2.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this vec2 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    vec2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return vec2;
})();

$root.fvec2 = (function() {

    /**
     * Properties of a fvec2.
     * @typedef fvec2$Properties
     * @type {Object}
     * @property {number} [x] fvec2 x.
     * @property {number} [y] fvec2 y.
     */

    /**
     * Constructs a new fvec2.
     * @exports fvec2
     * @constructor
     * @param {fvec2$Properties=} [properties] Properties to set
     */
    function fvec2(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec2 x.
     * @type {number}
     */
    fvec2.prototype.x = 0;

    /**
     * fvec2 y.
     * @type {number}
     */
    fvec2.prototype.y = 0;

    /**
     * Creates a new fvec2 instance using the specified properties.
     * @param {fvec2$Properties=} [properties] Properties to set
     * @returns {fvec2} fvec2 instance
     */
    fvec2.create = function create(properties) {
        return new fvec2(properties);
    };

    /**
     * Encodes the specified fvec2 message. Does not implicitly {@link fvec2.verify|verify} messages.
     * @param {fvec2$Properties} message fvec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec2.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
        if (message.y != null && message.hasOwnProperty("y"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
        return writer;
    };

    /**
     * Encodes the specified fvec2 message, length delimited. Does not implicitly {@link fvec2.verify|verify} messages.
     * @param {fvec2$Properties} message fvec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec2.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a fvec2 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec2} fvec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec2();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.float();
                break;
            case 2:
                message.y = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a fvec2 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fvec2} fvec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec2.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a fvec2 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    fvec2.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x"))
            if (typeof message.x !== "number")
                return "x: number expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (typeof message.y !== "number")
                return "y: number expected";
        return null;
    };

    /**
     * Creates a fvec2 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec2} fvec2
     */
    fvec2.fromObject = function fromObject(object) {
        if (object instanceof $root.fvec2)
            return object;
        var message = new $root.fvec2();
        if (object.x != null)
            message.x = Number(object.x);
        if (object.y != null)
            message.y = Number(object.y);
        return message;
    };

    /**
     * Creates a fvec2 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fvec2.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec2} fvec2
     */
    fvec2.from = fvec2.fromObject;

    /**
     * Creates a plain object from a fvec2 message. Also converts values to other types if specified.
     * @param {fvec2} message fvec2
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fvec2.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = message.y;
        return object;
    };

    /**
     * Creates a plain object from this fvec2 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fvec2.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this fvec2 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    fvec2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return fvec2;
})();

$root.ivec2 = (function() {

    /**
     * Properties of an ivec2.
     * @typedef ivec2$Properties
     * @type {Object}
     * @property {number} [x] ivec2 x.
     * @property {number} [y] ivec2 y.
     */

    /**
     * Constructs a new ivec2.
     * @exports ivec2
     * @constructor
     * @param {ivec2$Properties=} [properties] Properties to set
     */
    function ivec2(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec2 x.
     * @type {number}
     */
    ivec2.prototype.x = 0;

    /**
     * ivec2 y.
     * @type {number}
     */
    ivec2.prototype.y = 0;

    /**
     * Creates a new ivec2 instance using the specified properties.
     * @param {ivec2$Properties=} [properties] Properties to set
     * @returns {ivec2} ivec2 instance
     */
    ivec2.create = function create(properties) {
        return new ivec2(properties);
    };

    /**
     * Encodes the specified ivec2 message. Does not implicitly {@link ivec2.verify|verify} messages.
     * @param {ivec2$Properties} message ivec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec2.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.x);
        if (message.y != null && message.hasOwnProperty("y"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.y);
        return writer;
    };

    /**
     * Encodes the specified ivec2 message, length delimited. Does not implicitly {@link ivec2.verify|verify} messages.
     * @param {ivec2$Properties} message ivec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec2.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ivec2 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec2} ivec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec2();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.sint32();
                break;
            case 2:
                message.y = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ivec2 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ivec2} ivec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec2.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ivec2 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    ivec2.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x"))
            if (!$util.isInteger(message.x))
                return "x: integer expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (!$util.isInteger(message.y))
                return "y: integer expected";
        return null;
    };

    /**
     * Creates an ivec2 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec2} ivec2
     */
    ivec2.fromObject = function fromObject(object) {
        if (object instanceof $root.ivec2)
            return object;
        var message = new $root.ivec2();
        if (object.x != null)
            message.x = object.x | 0;
        if (object.y != null)
            message.y = object.y | 0;
        return message;
    };

    /**
     * Creates an ivec2 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link ivec2.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec2} ivec2
     */
    ivec2.from = ivec2.fromObject;

    /**
     * Creates a plain object from an ivec2 message. Also converts values to other types if specified.
     * @param {ivec2} message ivec2
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ivec2.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = message.y;
        return object;
    };

    /**
     * Creates a plain object from this ivec2 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ivec2.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this ivec2 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    ivec2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ivec2;
})();

$root.uvec2 = (function() {

    /**
     * Properties of an uvec2.
     * @typedef uvec2$Properties
     * @type {Object}
     * @property {number} [x] uvec2 x.
     * @property {number} [y] uvec2 y.
     */

    /**
     * Constructs a new uvec2.
     * @exports uvec2
     * @constructor
     * @param {uvec2$Properties=} [properties] Properties to set
     */
    function uvec2(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec2 x.
     * @type {number}
     */
    uvec2.prototype.x = 0;

    /**
     * uvec2 y.
     * @type {number}
     */
    uvec2.prototype.y = 0;

    /**
     * Creates a new uvec2 instance using the specified properties.
     * @param {uvec2$Properties=} [properties] Properties to set
     * @returns {uvec2} uvec2 instance
     */
    uvec2.create = function create(properties) {
        return new uvec2(properties);
    };

    /**
     * Encodes the specified uvec2 message. Does not implicitly {@link uvec2.verify|verify} messages.
     * @param {uvec2$Properties} message uvec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec2.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.x);
        if (message.y != null && message.hasOwnProperty("y"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.y);
        return writer;
    };

    /**
     * Encodes the specified uvec2 message, length delimited. Does not implicitly {@link uvec2.verify|verify} messages.
     * @param {uvec2$Properties} message uvec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec2.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an uvec2 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec2} uvec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec2();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.uint32();
                break;
            case 2:
                message.y = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an uvec2 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {uvec2} uvec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec2.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an uvec2 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    uvec2.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x"))
            if (!$util.isInteger(message.x))
                return "x: integer expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (!$util.isInteger(message.y))
                return "y: integer expected";
        return null;
    };

    /**
     * Creates an uvec2 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec2} uvec2
     */
    uvec2.fromObject = function fromObject(object) {
        if (object instanceof $root.uvec2)
            return object;
        var message = new $root.uvec2();
        if (object.x != null)
            message.x = object.x >>> 0;
        if (object.y != null)
            message.y = object.y >>> 0;
        return message;
    };

    /**
     * Creates an uvec2 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link uvec2.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec2} uvec2
     */
    uvec2.from = uvec2.fromObject;

    /**
     * Creates a plain object from an uvec2 message. Also converts values to other types if specified.
     * @param {uvec2} message uvec2
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    uvec2.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = message.y;
        return object;
    };

    /**
     * Creates a plain object from this uvec2 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    uvec2.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this uvec2 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    uvec2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return uvec2;
})();

$root.vec3 = (function() {

    /**
     * Properties of a vec3.
     * @typedef vec3$Properties
     * @type {Object}
     * @property {number} [x] vec3 x.
     * @property {number} [y] vec3 y.
     * @property {number} [z] vec3 z.
     */

    /**
     * Constructs a new vec3.
     * @exports vec3
     * @constructor
     * @param {vec3$Properties=} [properties] Properties to set
     */
    function vec3(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec3 x.
     * @type {number}
     */
    vec3.prototype.x = 0;

    /**
     * vec3 y.
     * @type {number}
     */
    vec3.prototype.y = 0;

    /**
     * vec3 z.
     * @type {number}
     */
    vec3.prototype.z = 0;

    /**
     * Creates a new vec3 instance using the specified properties.
     * @param {vec3$Properties=} [properties] Properties to set
     * @returns {vec3} vec3 instance
     */
    vec3.create = function create(properties) {
        return new vec3(properties);
    };

    /**
     * Encodes the specified vec3 message. Does not implicitly {@link vec3.verify|verify} messages.
     * @param {vec3$Properties} message vec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec3.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
        if (message.y != null && message.hasOwnProperty("y"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
        if (message.z != null && message.hasOwnProperty("z"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.z);
        return writer;
    };

    /**
     * Encodes the specified vec3 message, length delimited. Does not implicitly {@link vec3.verify|verify} messages.
     * @param {vec3$Properties} message vec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec3.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a vec3 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec3} vec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec3.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec3();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.double();
                break;
            case 2:
                message.y = reader.double();
                break;
            case 3:
                message.z = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a vec3 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {vec3} vec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec3.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a vec3 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    vec3.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x"))
            if (typeof message.x !== "number")
                return "x: number expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (typeof message.y !== "number")
                return "y: number expected";
        if (message.z != null && message.hasOwnProperty("z"))
            if (typeof message.z !== "number")
                return "z: number expected";
        return null;
    };

    /**
     * Creates a vec3 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {vec3} vec3
     */
    vec3.fromObject = function fromObject(object) {
        if (object instanceof $root.vec3)
            return object;
        var message = new $root.vec3();
        if (object.x != null)
            message.x = Number(object.x);
        if (object.y != null)
            message.y = Number(object.y);
        if (object.z != null)
            message.z = Number(object.z);
        return message;
    };

    /**
     * Creates a vec3 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link vec3.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {vec3} vec3
     */
    vec3.from = vec3.fromObject;

    /**
     * Creates a plain object from a vec3 message. Also converts values to other types if specified.
     * @param {vec3} message vec3
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    vec3.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
            object.z = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = message.y;
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = message.z;
        return object;
    };

    /**
     * Creates a plain object from this vec3 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    vec3.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this vec3 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    vec3.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return vec3;
})();

$root.fvec3 = (function() {

    /**
     * Properties of a fvec3.
     * @typedef fvec3$Properties
     * @type {Object}
     * @property {number} [x] fvec3 x.
     * @property {number} [y] fvec3 y.
     * @property {number} [z] fvec3 z.
     */

    /**
     * Constructs a new fvec3.
     * @exports fvec3
     * @constructor
     * @param {fvec3$Properties=} [properties] Properties to set
     */
    function fvec3(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec3 x.
     * @type {number}
     */
    fvec3.prototype.x = 0;

    /**
     * fvec3 y.
     * @type {number}
     */
    fvec3.prototype.y = 0;

    /**
     * fvec3 z.
     * @type {number}
     */
    fvec3.prototype.z = 0;

    /**
     * Creates a new fvec3 instance using the specified properties.
     * @param {fvec3$Properties=} [properties] Properties to set
     * @returns {fvec3} fvec3 instance
     */
    fvec3.create = function create(properties) {
        return new fvec3(properties);
    };

    /**
     * Encodes the specified fvec3 message. Does not implicitly {@link fvec3.verify|verify} messages.
     * @param {fvec3$Properties} message fvec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec3.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
        if (message.y != null && message.hasOwnProperty("y"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
        if (message.z != null && message.hasOwnProperty("z"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
        return writer;
    };

    /**
     * Encodes the specified fvec3 message, length delimited. Does not implicitly {@link fvec3.verify|verify} messages.
     * @param {fvec3$Properties} message fvec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec3.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a fvec3 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec3} fvec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec3.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec3();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.float();
                break;
            case 2:
                message.y = reader.float();
                break;
            case 3:
                message.z = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a fvec3 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fvec3} fvec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec3.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a fvec3 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    fvec3.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x"))
            if (typeof message.x !== "number")
                return "x: number expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (typeof message.y !== "number")
                return "y: number expected";
        if (message.z != null && message.hasOwnProperty("z"))
            if (typeof message.z !== "number")
                return "z: number expected";
        return null;
    };

    /**
     * Creates a fvec3 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec3} fvec3
     */
    fvec3.fromObject = function fromObject(object) {
        if (object instanceof $root.fvec3)
            return object;
        var message = new $root.fvec3();
        if (object.x != null)
            message.x = Number(object.x);
        if (object.y != null)
            message.y = Number(object.y);
        if (object.z != null)
            message.z = Number(object.z);
        return message;
    };

    /**
     * Creates a fvec3 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fvec3.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec3} fvec3
     */
    fvec3.from = fvec3.fromObject;

    /**
     * Creates a plain object from a fvec3 message. Also converts values to other types if specified.
     * @param {fvec3} message fvec3
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fvec3.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
            object.z = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = message.y;
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = message.z;
        return object;
    };

    /**
     * Creates a plain object from this fvec3 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fvec3.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this fvec3 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    fvec3.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return fvec3;
})();

$root.ivec3 = (function() {

    /**
     * Properties of an ivec3.
     * @typedef ivec3$Properties
     * @type {Object}
     * @property {number} [x] ivec3 x.
     * @property {number} [y] ivec3 y.
     * @property {number} [z] ivec3 z.
     */

    /**
     * Constructs a new ivec3.
     * @exports ivec3
     * @constructor
     * @param {ivec3$Properties=} [properties] Properties to set
     */
    function ivec3(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec3 x.
     * @type {number}
     */
    ivec3.prototype.x = 0;

    /**
     * ivec3 y.
     * @type {number}
     */
    ivec3.prototype.y = 0;

    /**
     * ivec3 z.
     * @type {number}
     */
    ivec3.prototype.z = 0;

    /**
     * Creates a new ivec3 instance using the specified properties.
     * @param {ivec3$Properties=} [properties] Properties to set
     * @returns {ivec3} ivec3 instance
     */
    ivec3.create = function create(properties) {
        return new ivec3(properties);
    };

    /**
     * Encodes the specified ivec3 message. Does not implicitly {@link ivec3.verify|verify} messages.
     * @param {ivec3$Properties} message ivec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec3.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.x);
        if (message.y != null && message.hasOwnProperty("y"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.y);
        if (message.z != null && message.hasOwnProperty("z"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.z);
        return writer;
    };

    /**
     * Encodes the specified ivec3 message, length delimited. Does not implicitly {@link ivec3.verify|verify} messages.
     * @param {ivec3$Properties} message ivec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec3.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ivec3 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec3} ivec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec3.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec3();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.sint32();
                break;
            case 2:
                message.y = reader.sint32();
                break;
            case 3:
                message.z = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ivec3 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ivec3} ivec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec3.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ivec3 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    ivec3.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x"))
            if (!$util.isInteger(message.x))
                return "x: integer expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (!$util.isInteger(message.y))
                return "y: integer expected";
        if (message.z != null && message.hasOwnProperty("z"))
            if (!$util.isInteger(message.z))
                return "z: integer expected";
        return null;
    };

    /**
     * Creates an ivec3 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec3} ivec3
     */
    ivec3.fromObject = function fromObject(object) {
        if (object instanceof $root.ivec3)
            return object;
        var message = new $root.ivec3();
        if (object.x != null)
            message.x = object.x | 0;
        if (object.y != null)
            message.y = object.y | 0;
        if (object.z != null)
            message.z = object.z | 0;
        return message;
    };

    /**
     * Creates an ivec3 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link ivec3.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec3} ivec3
     */
    ivec3.from = ivec3.fromObject;

    /**
     * Creates a plain object from an ivec3 message. Also converts values to other types if specified.
     * @param {ivec3} message ivec3
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ivec3.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
            object.z = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = message.y;
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = message.z;
        return object;
    };

    /**
     * Creates a plain object from this ivec3 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ivec3.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this ivec3 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    ivec3.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ivec3;
})();

$root.uvec3 = (function() {

    /**
     * Properties of an uvec3.
     * @typedef uvec3$Properties
     * @type {Object}
     * @property {number} [x] uvec3 x.
     * @property {number} [y] uvec3 y.
     * @property {number} [z] uvec3 z.
     */

    /**
     * Constructs a new uvec3.
     * @exports uvec3
     * @constructor
     * @param {uvec3$Properties=} [properties] Properties to set
     */
    function uvec3(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec3 x.
     * @type {number}
     */
    uvec3.prototype.x = 0;

    /**
     * uvec3 y.
     * @type {number}
     */
    uvec3.prototype.y = 0;

    /**
     * uvec3 z.
     * @type {number}
     */
    uvec3.prototype.z = 0;

    /**
     * Creates a new uvec3 instance using the specified properties.
     * @param {uvec3$Properties=} [properties] Properties to set
     * @returns {uvec3} uvec3 instance
     */
    uvec3.create = function create(properties) {
        return new uvec3(properties);
    };

    /**
     * Encodes the specified uvec3 message. Does not implicitly {@link uvec3.verify|verify} messages.
     * @param {uvec3$Properties} message uvec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec3.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.x);
        if (message.y != null && message.hasOwnProperty("y"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.y);
        if (message.z != null && message.hasOwnProperty("z"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.z);
        return writer;
    };

    /**
     * Encodes the specified uvec3 message, length delimited. Does not implicitly {@link uvec3.verify|verify} messages.
     * @param {uvec3$Properties} message uvec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec3.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an uvec3 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec3} uvec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec3.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec3();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.uint32();
                break;
            case 2:
                message.y = reader.uint32();
                break;
            case 3:
                message.z = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an uvec3 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {uvec3} uvec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec3.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an uvec3 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    uvec3.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x"))
            if (!$util.isInteger(message.x))
                return "x: integer expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (!$util.isInteger(message.y))
                return "y: integer expected";
        if (message.z != null && message.hasOwnProperty("z"))
            if (!$util.isInteger(message.z))
                return "z: integer expected";
        return null;
    };

    /**
     * Creates an uvec3 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec3} uvec3
     */
    uvec3.fromObject = function fromObject(object) {
        if (object instanceof $root.uvec3)
            return object;
        var message = new $root.uvec3();
        if (object.x != null)
            message.x = object.x >>> 0;
        if (object.y != null)
            message.y = object.y >>> 0;
        if (object.z != null)
            message.z = object.z >>> 0;
        return message;
    };

    /**
     * Creates an uvec3 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link uvec3.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec3} uvec3
     */
    uvec3.from = uvec3.fromObject;

    /**
     * Creates a plain object from an uvec3 message. Also converts values to other types if specified.
     * @param {uvec3} message uvec3
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    uvec3.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
            object.z = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = message.y;
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = message.z;
        return object;
    };

    /**
     * Creates a plain object from this uvec3 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    uvec3.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this uvec3 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    uvec3.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return uvec3;
})();

$root.vec4 = (function() {

    /**
     * Properties of a vec4.
     * @typedef vec4$Properties
     * @type {Object}
     * @property {number} [x] vec4 x.
     * @property {number} [y] vec4 y.
     * @property {number} [z] vec4 z.
     * @property {number} [t] vec4 t.
     */

    /**
     * Constructs a new vec4.
     * @exports vec4
     * @constructor
     * @param {vec4$Properties=} [properties] Properties to set
     */
    function vec4(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * vec4 x.
     * @type {number}
     */
    vec4.prototype.x = 0;

    /**
     * vec4 y.
     * @type {number}
     */
    vec4.prototype.y = 0;

    /**
     * vec4 z.
     * @type {number}
     */
    vec4.prototype.z = 0;

    /**
     * vec4 t.
     * @type {number}
     */
    vec4.prototype.t = 0;

    /**
     * Creates a new vec4 instance using the specified properties.
     * @param {vec4$Properties=} [properties] Properties to set
     * @returns {vec4} vec4 instance
     */
    vec4.create = function create(properties) {
        return new vec4(properties);
    };

    /**
     * Encodes the specified vec4 message. Does not implicitly {@link vec4.verify|verify} messages.
     * @param {vec4$Properties} message vec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec4.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
        if (message.y != null && message.hasOwnProperty("y"))
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
        if (message.z != null && message.hasOwnProperty("z"))
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.z);
        if (message.t != null && message.hasOwnProperty("t"))
            writer.uint32(/* id 4, wireType 1 =*/33).double(message.t);
        return writer;
    };

    /**
     * Encodes the specified vec4 message, length delimited. Does not implicitly {@link vec4.verify|verify} messages.
     * @param {vec4$Properties} message vec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    vec4.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a vec4 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec4} vec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec4.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.vec4();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.double();
                break;
            case 2:
                message.y = reader.double();
                break;
            case 3:
                message.z = reader.double();
                break;
            case 4:
                message.t = reader.double();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a vec4 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {vec4} vec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    vec4.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a vec4 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    vec4.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x"))
            if (typeof message.x !== "number")
                return "x: number expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (typeof message.y !== "number")
                return "y: number expected";
        if (message.z != null && message.hasOwnProperty("z"))
            if (typeof message.z !== "number")
                return "z: number expected";
        if (message.t != null && message.hasOwnProperty("t"))
            if (typeof message.t !== "number")
                return "t: number expected";
        return null;
    };

    /**
     * Creates a vec4 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {vec4} vec4
     */
    vec4.fromObject = function fromObject(object) {
        if (object instanceof $root.vec4)
            return object;
        var message = new $root.vec4();
        if (object.x != null)
            message.x = Number(object.x);
        if (object.y != null)
            message.y = Number(object.y);
        if (object.z != null)
            message.z = Number(object.z);
        if (object.t != null)
            message.t = Number(object.t);
        return message;
    };

    /**
     * Creates a vec4 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link vec4.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {vec4} vec4
     */
    vec4.from = vec4.fromObject;

    /**
     * Creates a plain object from a vec4 message. Also converts values to other types if specified.
     * @param {vec4} message vec4
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    vec4.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
            object.z = 0;
            object.t = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = message.y;
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = message.z;
        if (message.t != null && message.hasOwnProperty("t"))
            object.t = message.t;
        return object;
    };

    /**
     * Creates a plain object from this vec4 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    vec4.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this vec4 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    vec4.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return vec4;
})();

$root.fvec4 = (function() {

    /**
     * Properties of a fvec4.
     * @typedef fvec4$Properties
     * @type {Object}
     * @property {number} [x] fvec4 x.
     * @property {number} [y] fvec4 y.
     * @property {number} [z] fvec4 z.
     * @property {number} [t] fvec4 t.
     */

    /**
     * Constructs a new fvec4.
     * @exports fvec4
     * @constructor
     * @param {fvec4$Properties=} [properties] Properties to set
     */
    function fvec4(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * fvec4 x.
     * @type {number}
     */
    fvec4.prototype.x = 0;

    /**
     * fvec4 y.
     * @type {number}
     */
    fvec4.prototype.y = 0;

    /**
     * fvec4 z.
     * @type {number}
     */
    fvec4.prototype.z = 0;

    /**
     * fvec4 t.
     * @type {number}
     */
    fvec4.prototype.t = 0;

    /**
     * Creates a new fvec4 instance using the specified properties.
     * @param {fvec4$Properties=} [properties] Properties to set
     * @returns {fvec4} fvec4 instance
     */
    fvec4.create = function create(properties) {
        return new fvec4(properties);
    };

    /**
     * Encodes the specified fvec4 message. Does not implicitly {@link fvec4.verify|verify} messages.
     * @param {fvec4$Properties} message fvec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec4.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
        if (message.y != null && message.hasOwnProperty("y"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
        if (message.z != null && message.hasOwnProperty("z"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
        if (message.t != null && message.hasOwnProperty("t"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.t);
        return writer;
    };

    /**
     * Encodes the specified fvec4 message, length delimited. Does not implicitly {@link fvec4.verify|verify} messages.
     * @param {fvec4$Properties} message fvec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    fvec4.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a fvec4 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec4} fvec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec4.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.fvec4();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.float();
                break;
            case 2:
                message.y = reader.float();
                break;
            case 3:
                message.z = reader.float();
                break;
            case 4:
                message.t = reader.float();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a fvec4 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fvec4} fvec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    fvec4.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a fvec4 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    fvec4.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x"))
            if (typeof message.x !== "number")
                return "x: number expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (typeof message.y !== "number")
                return "y: number expected";
        if (message.z != null && message.hasOwnProperty("z"))
            if (typeof message.z !== "number")
                return "z: number expected";
        if (message.t != null && message.hasOwnProperty("t"))
            if (typeof message.t !== "number")
                return "t: number expected";
        return null;
    };

    /**
     * Creates a fvec4 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec4} fvec4
     */
    fvec4.fromObject = function fromObject(object) {
        if (object instanceof $root.fvec4)
            return object;
        var message = new $root.fvec4();
        if (object.x != null)
            message.x = Number(object.x);
        if (object.y != null)
            message.y = Number(object.y);
        if (object.z != null)
            message.z = Number(object.z);
        if (object.t != null)
            message.t = Number(object.t);
        return message;
    };

    /**
     * Creates a fvec4 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fvec4.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec4} fvec4
     */
    fvec4.from = fvec4.fromObject;

    /**
     * Creates a plain object from a fvec4 message. Also converts values to other types if specified.
     * @param {fvec4} message fvec4
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fvec4.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
            object.z = 0;
            object.t = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = message.y;
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = message.z;
        if (message.t != null && message.hasOwnProperty("t"))
            object.t = message.t;
        return object;
    };

    /**
     * Creates a plain object from this fvec4 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    fvec4.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this fvec4 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    fvec4.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return fvec4;
})();

$root.ivec4 = (function() {

    /**
     * Properties of an ivec4.
     * @typedef ivec4$Properties
     * @type {Object}
     * @property {number} [x] ivec4 x.
     * @property {number} [y] ivec4 y.
     * @property {number} [z] ivec4 z.
     * @property {number} [t] ivec4 t.
     */

    /**
     * Constructs a new ivec4.
     * @exports ivec4
     * @constructor
     * @param {ivec4$Properties=} [properties] Properties to set
     */
    function ivec4(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ivec4 x.
     * @type {number}
     */
    ivec4.prototype.x = 0;

    /**
     * ivec4 y.
     * @type {number}
     */
    ivec4.prototype.y = 0;

    /**
     * ivec4 z.
     * @type {number}
     */
    ivec4.prototype.z = 0;

    /**
     * ivec4 t.
     * @type {number}
     */
    ivec4.prototype.t = 0;

    /**
     * Creates a new ivec4 instance using the specified properties.
     * @param {ivec4$Properties=} [properties] Properties to set
     * @returns {ivec4} ivec4 instance
     */
    ivec4.create = function create(properties) {
        return new ivec4(properties);
    };

    /**
     * Encodes the specified ivec4 message. Does not implicitly {@link ivec4.verify|verify} messages.
     * @param {ivec4$Properties} message ivec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec4.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.x);
        if (message.y != null && message.hasOwnProperty("y"))
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.y);
        if (message.z != null && message.hasOwnProperty("z"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.z);
        if (message.t != null && message.hasOwnProperty("t"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.t);
        return writer;
    };

    /**
     * Encodes the specified ivec4 message, length delimited. Does not implicitly {@link ivec4.verify|verify} messages.
     * @param {ivec4$Properties} message ivec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ivec4.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ivec4 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec4} ivec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec4.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ivec4();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.sint32();
                break;
            case 2:
                message.y = reader.sint32();
                break;
            case 3:
                message.z = reader.sint32();
                break;
            case 4:
                message.t = reader.sint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ivec4 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ivec4} ivec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ivec4.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ivec4 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    ivec4.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x"))
            if (!$util.isInteger(message.x))
                return "x: integer expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (!$util.isInteger(message.y))
                return "y: integer expected";
        if (message.z != null && message.hasOwnProperty("z"))
            if (!$util.isInteger(message.z))
                return "z: integer expected";
        if (message.t != null && message.hasOwnProperty("t"))
            if (!$util.isInteger(message.t))
                return "t: integer expected";
        return null;
    };

    /**
     * Creates an ivec4 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec4} ivec4
     */
    ivec4.fromObject = function fromObject(object) {
        if (object instanceof $root.ivec4)
            return object;
        var message = new $root.ivec4();
        if (object.x != null)
            message.x = object.x | 0;
        if (object.y != null)
            message.y = object.y | 0;
        if (object.z != null)
            message.z = object.z | 0;
        if (object.t != null)
            message.t = object.t | 0;
        return message;
    };

    /**
     * Creates an ivec4 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link ivec4.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec4} ivec4
     */
    ivec4.from = ivec4.fromObject;

    /**
     * Creates a plain object from an ivec4 message. Also converts values to other types if specified.
     * @param {ivec4} message ivec4
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ivec4.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
            object.z = 0;
            object.t = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = message.y;
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = message.z;
        if (message.t != null && message.hasOwnProperty("t"))
            object.t = message.t;
        return object;
    };

    /**
     * Creates a plain object from this ivec4 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ivec4.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this ivec4 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    ivec4.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ivec4;
})();

$root.uvec4 = (function() {

    /**
     * Properties of an uvec4.
     * @typedef uvec4$Properties
     * @type {Object}
     * @property {number} [x] uvec4 x.
     * @property {number} [y] uvec4 y.
     * @property {number} [z] uvec4 z.
     * @property {number} [t] uvec4 t.
     */

    /**
     * Constructs a new uvec4.
     * @exports uvec4
     * @constructor
     * @param {uvec4$Properties=} [properties] Properties to set
     */
    function uvec4(properties) {
        if (properties)
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * uvec4 x.
     * @type {number}
     */
    uvec4.prototype.x = 0;

    /**
     * uvec4 y.
     * @type {number}
     */
    uvec4.prototype.y = 0;

    /**
     * uvec4 z.
     * @type {number}
     */
    uvec4.prototype.z = 0;

    /**
     * uvec4 t.
     * @type {number}
     */
    uvec4.prototype.t = 0;

    /**
     * Creates a new uvec4 instance using the specified properties.
     * @param {uvec4$Properties=} [properties] Properties to set
     * @returns {uvec4} uvec4 instance
     */
    uvec4.create = function create(properties) {
        return new uvec4(properties);
    };

    /**
     * Encodes the specified uvec4 message. Does not implicitly {@link uvec4.verify|verify} messages.
     * @param {uvec4$Properties} message uvec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec4.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && message.hasOwnProperty("x"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.x);
        if (message.y != null && message.hasOwnProperty("y"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.y);
        if (message.z != null && message.hasOwnProperty("z"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.z);
        if (message.t != null && message.hasOwnProperty("t"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.t);
        return writer;
    };

    /**
     * Encodes the specified uvec4 message, length delimited. Does not implicitly {@link uvec4.verify|verify} messages.
     * @param {uvec4$Properties} message uvec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    uvec4.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an uvec4 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec4} uvec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec4.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.uvec4();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.x = reader.uint32();
                break;
            case 2:
                message.y = reader.uint32();
                break;
            case 3:
                message.z = reader.uint32();
                break;
            case 4:
                message.t = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an uvec4 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {uvec4} uvec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    uvec4.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an uvec4 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    uvec4.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x"))
            if (!$util.isInteger(message.x))
                return "x: integer expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (!$util.isInteger(message.y))
                return "y: integer expected";
        if (message.z != null && message.hasOwnProperty("z"))
            if (!$util.isInteger(message.z))
                return "z: integer expected";
        if (message.t != null && message.hasOwnProperty("t"))
            if (!$util.isInteger(message.t))
                return "t: integer expected";
        return null;
    };

    /**
     * Creates an uvec4 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec4} uvec4
     */
    uvec4.fromObject = function fromObject(object) {
        if (object instanceof $root.uvec4)
            return object;
        var message = new $root.uvec4();
        if (object.x != null)
            message.x = object.x >>> 0;
        if (object.y != null)
            message.y = object.y >>> 0;
        if (object.z != null)
            message.z = object.z >>> 0;
        if (object.t != null)
            message.t = object.t >>> 0;
        return message;
    };

    /**
     * Creates an uvec4 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link uvec4.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec4} uvec4
     */
    uvec4.from = uvec4.fromObject;

    /**
     * Creates a plain object from an uvec4 message. Also converts values to other types if specified.
     * @param {uvec4} message uvec4
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    uvec4.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        var object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
            object.z = 0;
            object.t = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = message.y;
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = message.z;
        if (message.t != null && message.hasOwnProperty("t"))
            object.t = message.t;
        return object;
    };

    /**
     * Creates a plain object from this uvec4 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    uvec4.prototype.toObject = function toObject(options) {
        return this.constructor.toObject(this, options);
    };

    /**
     * Converts this uvec4 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    uvec4.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return uvec4;
})();

$root.message = (function() {

    /**
     * Namespace message.
     * @exports message
     * @namespace
     */
    var message = {};

    message.behaviour = (function() {

        /**
         * Namespace behaviour.
         * @exports message.behaviour
         * @namespace
         */
        var behaviour = {};

        behaviour.Behaviour = (function() {

            /**
             * Properties of a Behaviour.
             * @typedef message.behaviour.Behaviour$Properties
             * @type {Object}
             * @property {message.behaviour.Behaviour.State} [state] Behaviour state.
             */

            /**
             * Constructs a new Behaviour.
             * @exports message.behaviour.Behaviour
             * @constructor
             * @param {message.behaviour.Behaviour$Properties=} [properties] Properties to set
             */
            function Behaviour(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Behaviour state.
             * @type {message.behaviour.Behaviour.State}
             */
            Behaviour.prototype.state = 0;

            /**
             * Creates a new Behaviour instance using the specified properties.
             * @param {message.behaviour.Behaviour$Properties=} [properties] Properties to set
             * @returns {message.behaviour.Behaviour} Behaviour instance
             */
            Behaviour.create = function create(properties) {
                return new Behaviour(properties);
            };

            /**
             * Encodes the specified Behaviour message. Does not implicitly {@link message.behaviour.Behaviour.verify|verify} messages.
             * @param {message.behaviour.Behaviour$Properties} message Behaviour message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Behaviour.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.state != null && message.hasOwnProperty("state"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.state);
                return writer;
            };

            /**
             * Encodes the specified Behaviour message, length delimited. Does not implicitly {@link message.behaviour.Behaviour.verify|verify} messages.
             * @param {message.behaviour.Behaviour$Properties} message Behaviour message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Behaviour.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Behaviour message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.Behaviour} Behaviour
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Behaviour.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Behaviour();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.state = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Behaviour message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.Behaviour} Behaviour
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Behaviour.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Behaviour message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Behaviour.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                        break;
                    }
                return null;
            };

            /**
             * Creates a Behaviour message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Behaviour} Behaviour
             */
            Behaviour.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.Behaviour)
                    return object;
                var message = new $root.message.behaviour.Behaviour();
                switch (object.state) {
                case "UNKNOWN":
                case 0:
                    message.state = 0;
                    break;
                case "INIT":
                case 1:
                    message.state = 1;
                    break;
                case "SEARCH_FOR_BALL":
                case 2:
                    message.state = 2;
                    break;
                case "SEARCH_FOR_GOALS":
                case 3:
                    message.state = 3;
                    break;
                case "WALK_TO_BALL":
                case 4:
                    message.state = 4;
                    break;
                case "PICKED_UP":
                case 5:
                    message.state = 5;
                    break;
                case "INITIAL":
                case 6:
                    message.state = 6;
                    break;
                case "READY":
                case 7:
                    message.state = 7;
                    break;
                case "SET":
                case 8:
                    message.state = 8;
                    break;
                case "TIMEOUT":
                case 9:
                    message.state = 9;
                    break;
                case "FINISHED":
                case 10:
                    message.state = 10;
                    break;
                case "PENALISED":
                case 11:
                    message.state = 11;
                    break;
                case "GOALIE_WALK":
                case 12:
                    message.state = 12;
                    break;
                case "MOVE_TO_CENTRE":
                case 13:
                    message.state = 13;
                    break;
                case "LOCALISING":
                case 14:
                    message.state = 14;
                    break;
                }
                return message;
            };

            /**
             * Creates a Behaviour message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.Behaviour.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Behaviour} Behaviour
             */
            Behaviour.from = Behaviour.fromObject;

            /**
             * Creates a plain object from a Behaviour message. Also converts values to other types if specified.
             * @param {message.behaviour.Behaviour} message Behaviour
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Behaviour.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.state = options.enums === String ? "UNKNOWN" : 0;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.message.behaviour.Behaviour.State[message.state] : message.state;
                return object;
            };

            /**
             * Creates a plain object from this Behaviour message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Behaviour.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Behaviour to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Behaviour.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * State enum.
             * @name State
             * @memberof message.behaviour.Behaviour
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} INIT=1 INIT value
             * @property {number} SEARCH_FOR_BALL=2 SEARCH_FOR_BALL value
             * @property {number} SEARCH_FOR_GOALS=3 SEARCH_FOR_GOALS value
             * @property {number} WALK_TO_BALL=4 WALK_TO_BALL value
             * @property {number} PICKED_UP=5 PICKED_UP value
             * @property {number} INITIAL=6 INITIAL value
             * @property {number} READY=7 READY value
             * @property {number} SET=8 SET value
             * @property {number} TIMEOUT=9 TIMEOUT value
             * @property {number} FINISHED=10 FINISHED value
             * @property {number} PENALISED=11 PENALISED value
             * @property {number} GOALIE_WALK=12 GOALIE_WALK value
             * @property {number} MOVE_TO_CENTRE=13 MOVE_TO_CENTRE value
             * @property {number} LOCALISING=14 LOCALISING value
             */
            Behaviour.State = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "INIT"] = 1;
                values[valuesById[2] = "SEARCH_FOR_BALL"] = 2;
                values[valuesById[3] = "SEARCH_FOR_GOALS"] = 3;
                values[valuesById[4] = "WALK_TO_BALL"] = 4;
                values[valuesById[5] = "PICKED_UP"] = 5;
                values[valuesById[6] = "INITIAL"] = 6;
                values[valuesById[7] = "READY"] = 7;
                values[valuesById[8] = "SET"] = 8;
                values[valuesById[9] = "TIMEOUT"] = 9;
                values[valuesById[10] = "FINISHED"] = 10;
                values[valuesById[11] = "PENALISED"] = 11;
                values[valuesById[12] = "GOALIE_WALK"] = 12;
                values[valuesById[13] = "MOVE_TO_CENTRE"] = 13;
                values[valuesById[14] = "LOCALISING"] = 14;
                return values;
            })();

            return Behaviour;
        })();

        behaviour.FieldTarget = (function() {

            /**
             * Properties of a FieldTarget.
             * @typedef message.behaviour.FieldTarget$Properties
             * @type {Object}
             * @property {message.behaviour.FieldTarget.Target} [target] FieldTarget target.
             */

            /**
             * Constructs a new FieldTarget.
             * @exports message.behaviour.FieldTarget
             * @constructor
             * @param {message.behaviour.FieldTarget$Properties=} [properties] Properties to set
             */
            function FieldTarget(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldTarget target.
             * @type {message.behaviour.FieldTarget.Target}
             */
            FieldTarget.prototype.target = 0;

            /**
             * Creates a new FieldTarget instance using the specified properties.
             * @param {message.behaviour.FieldTarget$Properties=} [properties] Properties to set
             * @returns {message.behaviour.FieldTarget} FieldTarget instance
             */
            FieldTarget.create = function create(properties) {
                return new FieldTarget(properties);
            };

            /**
             * Encodes the specified FieldTarget message. Does not implicitly {@link message.behaviour.FieldTarget.verify|verify} messages.
             * @param {message.behaviour.FieldTarget$Properties} message FieldTarget message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldTarget.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target != null && message.hasOwnProperty("target"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.target);
                return writer;
            };

            /**
             * Encodes the specified FieldTarget message, length delimited. Does not implicitly {@link message.behaviour.FieldTarget.verify|verify} messages.
             * @param {message.behaviour.FieldTarget$Properties} message FieldTarget message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldTarget.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldTarget message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.FieldTarget} FieldTarget
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldTarget.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.FieldTarget();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.target = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldTarget message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.FieldTarget} FieldTarget
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldTarget.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldTarget message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FieldTarget.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target != null && message.hasOwnProperty("target"))
                    switch (message.target) {
                    default:
                        return "target: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a FieldTarget message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.FieldTarget} FieldTarget
             */
            FieldTarget.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.FieldTarget)
                    return object;
                var message = new $root.message.behaviour.FieldTarget();
                switch (object.target) {
                case "SELF":
                case 0:
                    message.target = 0;
                    break;
                case "BALL":
                case 1:
                    message.target = 1;
                    break;
                case "GOAL":
                case 2:
                    message.target = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a FieldTarget message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.FieldTarget.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.FieldTarget} FieldTarget
             */
            FieldTarget.from = FieldTarget.fromObject;

            /**
             * Creates a plain object from a FieldTarget message. Also converts values to other types if specified.
             * @param {message.behaviour.FieldTarget} message FieldTarget
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldTarget.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.target = options.enums === String ? "SELF" : 0;
                if (message.target != null && message.hasOwnProperty("target"))
                    object.target = options.enums === String ? $root.message.behaviour.FieldTarget.Target[message.target] : message.target;
                return object;
            };

            /**
             * Creates a plain object from this FieldTarget message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldTarget.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FieldTarget to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FieldTarget.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Target enum.
             * @name Target
             * @memberof message.behaviour.FieldTarget
             * @enum {number}
             * @property {number} SELF=0 SELF value
             * @property {number} BALL=1 BALL value
             * @property {number} GOAL=2 GOAL value
             */
            FieldTarget.Target = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SELF"] = 0;
                values[valuesById[1] = "BALL"] = 1;
                values[valuesById[2] = "GOAL"] = 2;
                return values;
            })();

            return FieldTarget;
        })();

        behaviour.FixedWalkFinished = (function() {

            /**
             * Properties of a FixedWalkFinished.
             * @typedef message.behaviour.FixedWalkFinished$Properties
             * @type {Object}
             */

            /**
             * Constructs a new FixedWalkFinished.
             * @exports message.behaviour.FixedWalkFinished
             * @constructor
             * @param {message.behaviour.FixedWalkFinished$Properties=} [properties] Properties to set
             */
            function FixedWalkFinished(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new FixedWalkFinished instance using the specified properties.
             * @param {message.behaviour.FixedWalkFinished$Properties=} [properties] Properties to set
             * @returns {message.behaviour.FixedWalkFinished} FixedWalkFinished instance
             */
            FixedWalkFinished.create = function create(properties) {
                return new FixedWalkFinished(properties);
            };

            /**
             * Encodes the specified FixedWalkFinished message. Does not implicitly {@link message.behaviour.FixedWalkFinished.verify|verify} messages.
             * @param {message.behaviour.FixedWalkFinished$Properties} message FixedWalkFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FixedWalkFinished.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified FixedWalkFinished message, length delimited. Does not implicitly {@link message.behaviour.FixedWalkFinished.verify|verify} messages.
             * @param {message.behaviour.FixedWalkFinished$Properties} message FixedWalkFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FixedWalkFinished.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FixedWalkFinished message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.FixedWalkFinished} FixedWalkFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FixedWalkFinished.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.FixedWalkFinished();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FixedWalkFinished message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.FixedWalkFinished} FixedWalkFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FixedWalkFinished.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FixedWalkFinished message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FixedWalkFinished.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a FixedWalkFinished message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.FixedWalkFinished} FixedWalkFinished
             */
            FixedWalkFinished.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.FixedWalkFinished)
                    return object;
                return new $root.message.behaviour.FixedWalkFinished();
            };

            /**
             * Creates a FixedWalkFinished message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.FixedWalkFinished.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.FixedWalkFinished} FixedWalkFinished
             */
            FixedWalkFinished.from = FixedWalkFinished.fromObject;

            /**
             * Creates a plain object from a FixedWalkFinished message. Also converts values to other types if specified.
             * @param {message.behaviour.FixedWalkFinished} message FixedWalkFinished
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FixedWalkFinished.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this FixedWalkFinished message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FixedWalkFinished.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FixedWalkFinished to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FixedWalkFinished.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FixedWalkFinished;
        })();

        behaviour.WalkConfigSaved = (function() {

            /**
             * Properties of a WalkConfigSaved.
             * @typedef message.behaviour.WalkConfigSaved$Properties
             * @type {Object}
             */

            /**
             * Constructs a new WalkConfigSaved.
             * @exports message.behaviour.WalkConfigSaved
             * @constructor
             * @param {message.behaviour.WalkConfigSaved$Properties=} [properties] Properties to set
             */
            function WalkConfigSaved(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new WalkConfigSaved instance using the specified properties.
             * @param {message.behaviour.WalkConfigSaved$Properties=} [properties] Properties to set
             * @returns {message.behaviour.WalkConfigSaved} WalkConfigSaved instance
             */
            WalkConfigSaved.create = function create(properties) {
                return new WalkConfigSaved(properties);
            };

            /**
             * Encodes the specified WalkConfigSaved message. Does not implicitly {@link message.behaviour.WalkConfigSaved.verify|verify} messages.
             * @param {message.behaviour.WalkConfigSaved$Properties} message WalkConfigSaved message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkConfigSaved.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified WalkConfigSaved message, length delimited. Does not implicitly {@link message.behaviour.WalkConfigSaved.verify|verify} messages.
             * @param {message.behaviour.WalkConfigSaved$Properties} message WalkConfigSaved message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkConfigSaved.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WalkConfigSaved message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.WalkConfigSaved} WalkConfigSaved
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkConfigSaved.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.WalkConfigSaved();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WalkConfigSaved message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.WalkConfigSaved} WalkConfigSaved
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkConfigSaved.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WalkConfigSaved message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            WalkConfigSaved.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a WalkConfigSaved message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WalkConfigSaved} WalkConfigSaved
             */
            WalkConfigSaved.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.WalkConfigSaved)
                    return object;
                return new $root.message.behaviour.WalkConfigSaved();
            };

            /**
             * Creates a WalkConfigSaved message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.WalkConfigSaved.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WalkConfigSaved} WalkConfigSaved
             */
            WalkConfigSaved.from = WalkConfigSaved.fromObject;

            /**
             * Creates a plain object from a WalkConfigSaved message. Also converts values to other types if specified.
             * @param {message.behaviour.WalkConfigSaved} message WalkConfigSaved
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkConfigSaved.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this WalkConfigSaved message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkConfigSaved.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this WalkConfigSaved to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            WalkConfigSaved.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WalkConfigSaved;
        })();

        behaviour.CancelFixedWalk = (function() {

            /**
             * Properties of a CancelFixedWalk.
             * @typedef message.behaviour.CancelFixedWalk$Properties
             * @type {Object}
             */

            /**
             * Constructs a new CancelFixedWalk.
             * @exports message.behaviour.CancelFixedWalk
             * @constructor
             * @param {message.behaviour.CancelFixedWalk$Properties=} [properties] Properties to set
             */
            function CancelFixedWalk(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new CancelFixedWalk instance using the specified properties.
             * @param {message.behaviour.CancelFixedWalk$Properties=} [properties] Properties to set
             * @returns {message.behaviour.CancelFixedWalk} CancelFixedWalk instance
             */
            CancelFixedWalk.create = function create(properties) {
                return new CancelFixedWalk(properties);
            };

            /**
             * Encodes the specified CancelFixedWalk message. Does not implicitly {@link message.behaviour.CancelFixedWalk.verify|verify} messages.
             * @param {message.behaviour.CancelFixedWalk$Properties} message CancelFixedWalk message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelFixedWalk.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified CancelFixedWalk message, length delimited. Does not implicitly {@link message.behaviour.CancelFixedWalk.verify|verify} messages.
             * @param {message.behaviour.CancelFixedWalk$Properties} message CancelFixedWalk message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelFixedWalk.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CancelFixedWalk message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.CancelFixedWalk} CancelFixedWalk
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelFixedWalk.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.CancelFixedWalk();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CancelFixedWalk message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.CancelFixedWalk} CancelFixedWalk
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelFixedWalk.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CancelFixedWalk message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            CancelFixedWalk.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a CancelFixedWalk message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.CancelFixedWalk} CancelFixedWalk
             */
            CancelFixedWalk.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.CancelFixedWalk)
                    return object;
                return new $root.message.behaviour.CancelFixedWalk();
            };

            /**
             * Creates a CancelFixedWalk message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.CancelFixedWalk.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.CancelFixedWalk} CancelFixedWalk
             */
            CancelFixedWalk.from = CancelFixedWalk.fromObject;

            /**
             * Creates a plain object from a CancelFixedWalk message. Also converts values to other types if specified.
             * @param {message.behaviour.CancelFixedWalk} message CancelFixedWalk
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CancelFixedWalk.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this CancelFixedWalk message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CancelFixedWalk.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this CancelFixedWalk to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            CancelFixedWalk.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CancelFixedWalk;
        })();

        behaviour.WalkOptimiserCommand = (function() {

            /**
             * Properties of a WalkOptimiserCommand.
             * @typedef message.behaviour.WalkOptimiserCommand$Properties
             * @type {Object}
             * @property {string} [walkConfig] WalkOptimiserCommand walkConfig.
             */

            /**
             * Constructs a new WalkOptimiserCommand.
             * @exports message.behaviour.WalkOptimiserCommand
             * @constructor
             * @param {message.behaviour.WalkOptimiserCommand$Properties=} [properties] Properties to set
             */
            function WalkOptimiserCommand(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WalkOptimiserCommand walkConfig.
             * @type {string}
             */
            WalkOptimiserCommand.prototype.walkConfig = "";

            /**
             * Creates a new WalkOptimiserCommand instance using the specified properties.
             * @param {message.behaviour.WalkOptimiserCommand$Properties=} [properties] Properties to set
             * @returns {message.behaviour.WalkOptimiserCommand} WalkOptimiserCommand instance
             */
            WalkOptimiserCommand.create = function create(properties) {
                return new WalkOptimiserCommand(properties);
            };

            /**
             * Encodes the specified WalkOptimiserCommand message. Does not implicitly {@link message.behaviour.WalkOptimiserCommand.verify|verify} messages.
             * @param {message.behaviour.WalkOptimiserCommand$Properties} message WalkOptimiserCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkOptimiserCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.walkConfig != null && message.hasOwnProperty("walkConfig"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.walkConfig);
                return writer;
            };

            /**
             * Encodes the specified WalkOptimiserCommand message, length delimited. Does not implicitly {@link message.behaviour.WalkOptimiserCommand.verify|verify} messages.
             * @param {message.behaviour.WalkOptimiserCommand$Properties} message WalkOptimiserCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkOptimiserCommand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WalkOptimiserCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.WalkOptimiserCommand} WalkOptimiserCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkOptimiserCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.WalkOptimiserCommand();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.walkConfig = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WalkOptimiserCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.WalkOptimiserCommand} WalkOptimiserCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkOptimiserCommand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WalkOptimiserCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            WalkOptimiserCommand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.walkConfig != null && message.hasOwnProperty("walkConfig"))
                    if (!$util.isString(message.walkConfig))
                        return "walkConfig: string expected";
                return null;
            };

            /**
             * Creates a WalkOptimiserCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WalkOptimiserCommand} WalkOptimiserCommand
             */
            WalkOptimiserCommand.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.WalkOptimiserCommand)
                    return object;
                var message = new $root.message.behaviour.WalkOptimiserCommand();
                if (object.walkConfig != null)
                    message.walkConfig = String(object.walkConfig);
                return message;
            };

            /**
             * Creates a WalkOptimiserCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.WalkOptimiserCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WalkOptimiserCommand} WalkOptimiserCommand
             */
            WalkOptimiserCommand.from = WalkOptimiserCommand.fromObject;

            /**
             * Creates a plain object from a WalkOptimiserCommand message. Also converts values to other types if specified.
             * @param {message.behaviour.WalkOptimiserCommand} message WalkOptimiserCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkOptimiserCommand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.walkConfig = "";
                if (message.walkConfig != null && message.hasOwnProperty("walkConfig"))
                    object.walkConfig = message.walkConfig;
                return object;
            };

            /**
             * Creates a plain object from this WalkOptimiserCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkOptimiserCommand.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this WalkOptimiserCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            WalkOptimiserCommand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WalkOptimiserCommand;
        })();

        behaviour.FixedWalkCommand = (function() {

            /**
             * Properties of a FixedWalkCommand.
             * @typedef message.behaviour.FixedWalkCommand$Properties
             * @type {Object}
             * @property {Array.<message.behaviour.FixedWalkCommand.WalkSegment$Properties>} [segments] FixedWalkCommand segments.
             */

            /**
             * Constructs a new FixedWalkCommand.
             * @exports message.behaviour.FixedWalkCommand
             * @constructor
             * @param {message.behaviour.FixedWalkCommand$Properties=} [properties] Properties to set
             */
            function FixedWalkCommand(properties) {
                this.segments = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FixedWalkCommand segments.
             * @type {Array.<message.behaviour.FixedWalkCommand.WalkSegment$Properties>}
             */
            FixedWalkCommand.prototype.segments = $util.emptyArray;

            /**
             * Creates a new FixedWalkCommand instance using the specified properties.
             * @param {message.behaviour.FixedWalkCommand$Properties=} [properties] Properties to set
             * @returns {message.behaviour.FixedWalkCommand} FixedWalkCommand instance
             */
            FixedWalkCommand.create = function create(properties) {
                return new FixedWalkCommand(properties);
            };

            /**
             * Encodes the specified FixedWalkCommand message. Does not implicitly {@link message.behaviour.FixedWalkCommand.verify|verify} messages.
             * @param {message.behaviour.FixedWalkCommand$Properties} message FixedWalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FixedWalkCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.segments != null && message.segments.length)
                    for (var i = 0; i < message.segments.length; ++i)
                        $root.message.behaviour.FixedWalkCommand.WalkSegment.encode(message.segments[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FixedWalkCommand message, length delimited. Does not implicitly {@link message.behaviour.FixedWalkCommand.verify|verify} messages.
             * @param {message.behaviour.FixedWalkCommand$Properties} message FixedWalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FixedWalkCommand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FixedWalkCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.FixedWalkCommand} FixedWalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FixedWalkCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.FixedWalkCommand();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.segments && message.segments.length))
                            message.segments = [];
                        message.segments.push($root.message.behaviour.FixedWalkCommand.WalkSegment.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FixedWalkCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.FixedWalkCommand} FixedWalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FixedWalkCommand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FixedWalkCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FixedWalkCommand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.segments != null && message.hasOwnProperty("segments")) {
                    if (!Array.isArray(message.segments))
                        return "segments: array expected";
                    for (var i = 0; i < message.segments.length; ++i) {
                        var error = $root.message.behaviour.FixedWalkCommand.WalkSegment.verify(message.segments[i]);
                        if (error)
                            return "segments." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FixedWalkCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.FixedWalkCommand} FixedWalkCommand
             */
            FixedWalkCommand.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.FixedWalkCommand)
                    return object;
                var message = new $root.message.behaviour.FixedWalkCommand();
                if (object.segments) {
                    if (!Array.isArray(object.segments))
                        throw TypeError(".message.behaviour.FixedWalkCommand.segments: array expected");
                    message.segments = [];
                    for (var i = 0; i < object.segments.length; ++i) {
                        if (typeof object.segments[i] !== "object")
                            throw TypeError(".message.behaviour.FixedWalkCommand.segments: object expected");
                        message.segments[i] = $root.message.behaviour.FixedWalkCommand.WalkSegment.fromObject(object.segments[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a FixedWalkCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.FixedWalkCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.FixedWalkCommand} FixedWalkCommand
             */
            FixedWalkCommand.from = FixedWalkCommand.fromObject;

            /**
             * Creates a plain object from a FixedWalkCommand message. Also converts values to other types if specified.
             * @param {message.behaviour.FixedWalkCommand} message FixedWalkCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FixedWalkCommand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.segments = [];
                if (message.segments && message.segments.length) {
                    object.segments = [];
                    for (var j = 0; j < message.segments.length; ++j)
                        object.segments[j] = $root.message.behaviour.FixedWalkCommand.WalkSegment.toObject(message.segments[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this FixedWalkCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FixedWalkCommand.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FixedWalkCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FixedWalkCommand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            FixedWalkCommand.WalkSegment = (function() {

                /**
                 * Properties of a WalkSegment.
                 * @typedef message.behaviour.FixedWalkCommand.WalkSegment$Properties
                 * @type {Object}
                 * @property {vec2$Properties} [direction] WalkSegment direction.
                 * @property {number} [curvePeriod] WalkSegment curvePeriod.
                 * @property {number} [normalisedVelocity] WalkSegment normalisedVelocity.
                 * @property {number} [normalisedAngularVelocity] WalkSegment normalisedAngularVelocity.
                 * @property {google.protobuf.Duration$Properties} [duration] WalkSegment duration.
                 */

                /**
                 * Constructs a new WalkSegment.
                 * @exports message.behaviour.FixedWalkCommand.WalkSegment
                 * @constructor
                 * @param {message.behaviour.FixedWalkCommand.WalkSegment$Properties=} [properties] Properties to set
                 */
                function WalkSegment(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * WalkSegment direction.
                 * @type {(vec2$Properties|null)}
                 */
                WalkSegment.prototype.direction = null;

                /**
                 * WalkSegment curvePeriod.
                 * @type {number}
                 */
                WalkSegment.prototype.curvePeriod = 0;

                /**
                 * WalkSegment normalisedVelocity.
                 * @type {number}
                 */
                WalkSegment.prototype.normalisedVelocity = 0;

                /**
                 * WalkSegment normalisedAngularVelocity.
                 * @type {number}
                 */
                WalkSegment.prototype.normalisedAngularVelocity = 0;

                /**
                 * WalkSegment duration.
                 * @type {(google.protobuf.Duration$Properties|null)}
                 */
                WalkSegment.prototype.duration = null;

                /**
                 * Creates a new WalkSegment instance using the specified properties.
                 * @param {message.behaviour.FixedWalkCommand.WalkSegment$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.FixedWalkCommand.WalkSegment} WalkSegment instance
                 */
                WalkSegment.create = function create(properties) {
                    return new WalkSegment(properties);
                };

                /**
                 * Encodes the specified WalkSegment message. Does not implicitly {@link message.behaviour.FixedWalkCommand.WalkSegment.verify|verify} messages.
                 * @param {message.behaviour.FixedWalkCommand.WalkSegment$Properties} message WalkSegment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WalkSegment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.direction != null && message.hasOwnProperty("direction"))
                        $root.vec2.encode(message.direction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.curvePeriod != null && message.hasOwnProperty("curvePeriod"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.curvePeriod);
                    if (message.normalisedVelocity != null && message.hasOwnProperty("normalisedVelocity"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.normalisedVelocity);
                    if (message.normalisedAngularVelocity != null && message.hasOwnProperty("normalisedAngularVelocity"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.normalisedAngularVelocity);
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        $root.google.protobuf.Duration.encode(message.duration, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified WalkSegment message, length delimited. Does not implicitly {@link message.behaviour.FixedWalkCommand.WalkSegment.verify|verify} messages.
                 * @param {message.behaviour.FixedWalkCommand.WalkSegment$Properties} message WalkSegment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WalkSegment.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a WalkSegment message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.FixedWalkCommand.WalkSegment} WalkSegment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WalkSegment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.FixedWalkCommand.WalkSegment();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.direction = $root.vec2.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.curvePeriod = reader.double();
                            break;
                        case 3:
                            message.normalisedVelocity = reader.double();
                            break;
                        case 4:
                            message.normalisedAngularVelocity = reader.double();
                            break;
                        case 5:
                            message.duration = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a WalkSegment message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.FixedWalkCommand.WalkSegment} WalkSegment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WalkSegment.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a WalkSegment message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                WalkSegment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.direction != null && message.hasOwnProperty("direction")) {
                        var error = $root.vec2.verify(message.direction);
                        if (error)
                            return "direction." + error;
                    }
                    if (message.curvePeriod != null && message.hasOwnProperty("curvePeriod"))
                        if (typeof message.curvePeriod !== "number")
                            return "curvePeriod: number expected";
                    if (message.normalisedVelocity != null && message.hasOwnProperty("normalisedVelocity"))
                        if (typeof message.normalisedVelocity !== "number")
                            return "normalisedVelocity: number expected";
                    if (message.normalisedAngularVelocity != null && message.hasOwnProperty("normalisedAngularVelocity"))
                        if (typeof message.normalisedAngularVelocity !== "number")
                            return "normalisedAngularVelocity: number expected";
                    if (message.duration != null && message.hasOwnProperty("duration")) {
                        var error = $root.google.protobuf.Duration.verify(message.duration);
                        if (error)
                            return "duration." + error;
                    }
                    return null;
                };

                /**
                 * Creates a WalkSegment message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.FixedWalkCommand.WalkSegment} WalkSegment
                 */
                WalkSegment.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.behaviour.FixedWalkCommand.WalkSegment)
                        return object;
                    var message = new $root.message.behaviour.FixedWalkCommand.WalkSegment();
                    if (object.direction != null) {
                        if (typeof object.direction !== "object")
                            throw TypeError(".message.behaviour.FixedWalkCommand.WalkSegment.direction: object expected");
                        message.direction = $root.vec2.fromObject(object.direction);
                    }
                    if (object.curvePeriod != null)
                        message.curvePeriod = Number(object.curvePeriod);
                    if (object.normalisedVelocity != null)
                        message.normalisedVelocity = Number(object.normalisedVelocity);
                    if (object.normalisedAngularVelocity != null)
                        message.normalisedAngularVelocity = Number(object.normalisedAngularVelocity);
                    if (object.duration != null) {
                        if (typeof object.duration !== "object")
                            throw TypeError(".message.behaviour.FixedWalkCommand.WalkSegment.duration: object expected");
                        message.duration = $root.google.protobuf.Duration.fromObject(object.duration);
                    }
                    return message;
                };

                /**
                 * Creates a WalkSegment message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.FixedWalkCommand.WalkSegment.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.FixedWalkCommand.WalkSegment} WalkSegment
                 */
                WalkSegment.from = WalkSegment.fromObject;

                /**
                 * Creates a plain object from a WalkSegment message. Also converts values to other types if specified.
                 * @param {message.behaviour.FixedWalkCommand.WalkSegment} message WalkSegment
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                WalkSegment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.direction = null;
                        object.curvePeriod = 0;
                        object.normalisedVelocity = 0;
                        object.normalisedAngularVelocity = 0;
                        object.duration = null;
                    }
                    if (message.direction != null && message.hasOwnProperty("direction"))
                        object.direction = $root.vec2.toObject(message.direction, options);
                    if (message.curvePeriod != null && message.hasOwnProperty("curvePeriod"))
                        object.curvePeriod = message.curvePeriod;
                    if (message.normalisedVelocity != null && message.hasOwnProperty("normalisedVelocity"))
                        object.normalisedVelocity = message.normalisedVelocity;
                    if (message.normalisedAngularVelocity != null && message.hasOwnProperty("normalisedAngularVelocity"))
                        object.normalisedAngularVelocity = message.normalisedAngularVelocity;
                    if (message.duration != null && message.hasOwnProperty("duration"))
                        object.duration = $root.google.protobuf.Duration.toObject(message.duration, options);
                    return object;
                };

                /**
                 * Creates a plain object from this WalkSegment message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                WalkSegment.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this WalkSegment to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                WalkSegment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return WalkSegment;
            })();

            return FixedWalkCommand;
        })();

        behaviour.KickPlan = (function() {

            /**
             * Properties of a KickPlan.
             * @typedef message.behaviour.KickPlan$Properties
             * @type {Object}
             * @property {vec2$Properties} [target] KickPlan target.
             * @property {message.behaviour.KickPlan.KickType} [kickType] KickPlan kickType.
             */

            /**
             * Constructs a new KickPlan.
             * @exports message.behaviour.KickPlan
             * @constructor
             * @param {message.behaviour.KickPlan$Properties=} [properties] Properties to set
             */
            function KickPlan(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KickPlan target.
             * @type {(vec2$Properties|null)}
             */
            KickPlan.prototype.target = null;

            /**
             * KickPlan kickType.
             * @type {message.behaviour.KickPlan.KickType}
             */
            KickPlan.prototype.kickType = 0;

            /**
             * Creates a new KickPlan instance using the specified properties.
             * @param {message.behaviour.KickPlan$Properties=} [properties] Properties to set
             * @returns {message.behaviour.KickPlan} KickPlan instance
             */
            KickPlan.create = function create(properties) {
                return new KickPlan(properties);
            };

            /**
             * Encodes the specified KickPlan message. Does not implicitly {@link message.behaviour.KickPlan.verify|verify} messages.
             * @param {message.behaviour.KickPlan$Properties} message KickPlan message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickPlan.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target != null && message.hasOwnProperty("target"))
                    $root.vec2.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.kickType != null && message.hasOwnProperty("kickType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.kickType);
                return writer;
            };

            /**
             * Encodes the specified KickPlan message, length delimited. Does not implicitly {@link message.behaviour.KickPlan.verify|verify} messages.
             * @param {message.behaviour.KickPlan$Properties} message KickPlan message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickPlan.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickPlan message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.KickPlan} KickPlan
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickPlan.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.KickPlan();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.target = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.kickType = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KickPlan message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.KickPlan} KickPlan
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickPlan.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickPlan message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            KickPlan.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target != null && message.hasOwnProperty("target")) {
                    var error = $root.vec2.verify(message.target);
                    if (error)
                        return "target." + error;
                }
                if (message.kickType != null && message.hasOwnProperty("kickType"))
                    switch (message.kickType) {
                    default:
                        return "kickType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a KickPlan message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.KickPlan} KickPlan
             */
            KickPlan.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.KickPlan)
                    return object;
                var message = new $root.message.behaviour.KickPlan();
                if (object.target != null) {
                    if (typeof object.target !== "object")
                        throw TypeError(".message.behaviour.KickPlan.target: object expected");
                    message.target = $root.vec2.fromObject(object.target);
                }
                switch (object.kickType) {
                case "SCRIPTED":
                case 0:
                    message.kickType = 0;
                    break;
                case "IK_KICK":
                case 1:
                    message.kickType = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a KickPlan message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.KickPlan.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.KickPlan} KickPlan
             */
            KickPlan.from = KickPlan.fromObject;

            /**
             * Creates a plain object from a KickPlan message. Also converts values to other types if specified.
             * @param {message.behaviour.KickPlan} message KickPlan
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickPlan.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.target = null;
                    object.kickType = options.enums === String ? "SCRIPTED" : 0;
                }
                if (message.target != null && message.hasOwnProperty("target"))
                    object.target = $root.vec2.toObject(message.target, options);
                if (message.kickType != null && message.hasOwnProperty("kickType"))
                    object.kickType = options.enums === String ? $root.message.behaviour.KickPlan.KickType[message.kickType] : message.kickType;
                return object;
            };

            /**
             * Creates a plain object from this KickPlan message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickPlan.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this KickPlan to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            KickPlan.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * KickType enum.
             * @name KickType
             * @memberof message.behaviour.KickPlan
             * @enum {number}
             * @property {number} SCRIPTED=0 SCRIPTED value
             * @property {number} IK_KICK=1 IK_KICK value
             */
            KickPlan.KickType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SCRIPTED"] = 0;
                values[valuesById[1] = "IK_KICK"] = 1;
                return values;
            })();

            return KickPlan;
        })();

        behaviour.WantsToKick = (function() {

            /**
             * Properties of a WantsToKick.
             * @typedef message.behaviour.WantsToKick$Properties
             * @type {Object}
             * @property {boolean} [kick] WantsToKick kick.
             */

            /**
             * Constructs a new WantsToKick.
             * @exports message.behaviour.WantsToKick
             * @constructor
             * @param {message.behaviour.WantsToKick$Properties=} [properties] Properties to set
             */
            function WantsToKick(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WantsToKick kick.
             * @type {boolean}
             */
            WantsToKick.prototype.kick = false;

            /**
             * Creates a new WantsToKick instance using the specified properties.
             * @param {message.behaviour.WantsToKick$Properties=} [properties] Properties to set
             * @returns {message.behaviour.WantsToKick} WantsToKick instance
             */
            WantsToKick.create = function create(properties) {
                return new WantsToKick(properties);
            };

            /**
             * Encodes the specified WantsToKick message. Does not implicitly {@link message.behaviour.WantsToKick.verify|verify} messages.
             * @param {message.behaviour.WantsToKick$Properties} message WantsToKick message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WantsToKick.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kick != null && message.hasOwnProperty("kick"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.kick);
                return writer;
            };

            /**
             * Encodes the specified WantsToKick message, length delimited. Does not implicitly {@link message.behaviour.WantsToKick.verify|verify} messages.
             * @param {message.behaviour.WantsToKick$Properties} message WantsToKick message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WantsToKick.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WantsToKick message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.WantsToKick} WantsToKick
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WantsToKick.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.WantsToKick();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.kick = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WantsToKick message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.WantsToKick} WantsToKick
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WantsToKick.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WantsToKick message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            WantsToKick.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kick != null && message.hasOwnProperty("kick"))
                    if (typeof message.kick !== "boolean")
                        return "kick: boolean expected";
                return null;
            };

            /**
             * Creates a WantsToKick message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WantsToKick} WantsToKick
             */
            WantsToKick.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.WantsToKick)
                    return object;
                var message = new $root.message.behaviour.WantsToKick();
                if (object.kick != null)
                    message.kick = Boolean(object.kick);
                return message;
            };

            /**
             * Creates a WantsToKick message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.WantsToKick.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WantsToKick} WantsToKick
             */
            WantsToKick.from = WantsToKick.fromObject;

            /**
             * Creates a plain object from a WantsToKick message. Also converts values to other types if specified.
             * @param {message.behaviour.WantsToKick} message WantsToKick
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WantsToKick.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.kick = false;
                if (message.kick != null && message.hasOwnProperty("kick"))
                    object.kick = message.kick;
                return object;
            };

            /**
             * Creates a plain object from this WantsToKick message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WantsToKick.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this WantsToKick to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            WantsToKick.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WantsToKick;
        })();

        behaviour.Look = (function() {

            /**
             * Properties of a Look.
             * @typedef message.behaviour.Look$Properties
             * @type {Object}
             */

            /**
             * Constructs a new Look.
             * @exports message.behaviour.Look
             * @constructor
             * @param {message.behaviour.Look$Properties=} [properties] Properties to set
             */
            function Look(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Look instance using the specified properties.
             * @param {message.behaviour.Look$Properties=} [properties] Properties to set
             * @returns {message.behaviour.Look} Look instance
             */
            Look.create = function create(properties) {
                return new Look(properties);
            };

            /**
             * Encodes the specified Look message. Does not implicitly {@link message.behaviour.Look.verify|verify} messages.
             * @param {message.behaviour.Look$Properties} message Look message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Look.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Look message, length delimited. Does not implicitly {@link message.behaviour.Look.verify|verify} messages.
             * @param {message.behaviour.Look$Properties} message Look message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Look.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Look message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.Look} Look
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Look.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Look();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Look message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.Look} Look
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Look.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Look message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Look.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Look message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Look} Look
             */
            Look.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.Look)
                    return object;
                return new $root.message.behaviour.Look();
            };

            /**
             * Creates a Look message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.Look.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Look} Look
             */
            Look.from = Look.fromObject;

            /**
             * Creates a plain object from a Look message. Also converts values to other types if specified.
             * @param {message.behaviour.Look} message Look
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Look.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this Look message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Look.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Look to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Look.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Look.Fixation = (function() {

                /**
                 * Properties of a Fixation.
                 * @typedef message.behaviour.Look.Fixation$Properties
                 * @type {Object}
                 * @property {vec2$Properties} [angle] Fixation angle.
                 * @property {vec2$Properties} [arcSize] Fixation arcSize.
                 */

                /**
                 * Constructs a new Fixation.
                 * @exports message.behaviour.Look.Fixation
                 * @constructor
                 * @param {message.behaviour.Look.Fixation$Properties=} [properties] Properties to set
                 */
                function Fixation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Fixation angle.
                 * @type {(vec2$Properties|null)}
                 */
                Fixation.prototype.angle = null;

                /**
                 * Fixation arcSize.
                 * @type {(vec2$Properties|null)}
                 */
                Fixation.prototype.arcSize = null;

                /**
                 * Creates a new Fixation instance using the specified properties.
                 * @param {message.behaviour.Look.Fixation$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Look.Fixation} Fixation instance
                 */
                Fixation.create = function create(properties) {
                    return new Fixation(properties);
                };

                /**
                 * Encodes the specified Fixation message. Does not implicitly {@link message.behaviour.Look.Fixation.verify|verify} messages.
                 * @param {message.behaviour.Look.Fixation$Properties} message Fixation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Fixation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.angle != null && message.hasOwnProperty("angle"))
                        $root.vec2.encode(message.angle, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.arcSize != null && message.hasOwnProperty("arcSize"))
                        $root.vec2.encode(message.arcSize, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Fixation message, length delimited. Does not implicitly {@link message.behaviour.Look.Fixation.verify|verify} messages.
                 * @param {message.behaviour.Look.Fixation$Properties} message Fixation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Fixation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Fixation message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Look.Fixation} Fixation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Fixation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Look.Fixation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.angle = $root.vec2.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.arcSize = $root.vec2.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Fixation message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Look.Fixation} Fixation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Fixation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Fixation message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Fixation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.angle != null && message.hasOwnProperty("angle")) {
                        var error = $root.vec2.verify(message.angle);
                        if (error)
                            return "angle." + error;
                    }
                    if (message.arcSize != null && message.hasOwnProperty("arcSize")) {
                        var error = $root.vec2.verify(message.arcSize);
                        if (error)
                            return "arcSize." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Fixation message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.Fixation} Fixation
                 */
                Fixation.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.behaviour.Look.Fixation)
                        return object;
                    var message = new $root.message.behaviour.Look.Fixation();
                    if (object.angle != null) {
                        if (typeof object.angle !== "object")
                            throw TypeError(".message.behaviour.Look.Fixation.angle: object expected");
                        message.angle = $root.vec2.fromObject(object.angle);
                    }
                    if (object.arcSize != null) {
                        if (typeof object.arcSize !== "object")
                            throw TypeError(".message.behaviour.Look.Fixation.arcSize: object expected");
                        message.arcSize = $root.vec2.fromObject(object.arcSize);
                    }
                    return message;
                };

                /**
                 * Creates a Fixation message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Look.Fixation.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.Fixation} Fixation
                 */
                Fixation.from = Fixation.fromObject;

                /**
                 * Creates a plain object from a Fixation message. Also converts values to other types if specified.
                 * @param {message.behaviour.Look.Fixation} message Fixation
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Fixation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.angle = null;
                        object.arcSize = null;
                    }
                    if (message.angle != null && message.hasOwnProperty("angle"))
                        object.angle = $root.vec2.toObject(message.angle, options);
                    if (message.arcSize != null && message.hasOwnProperty("arcSize"))
                        object.arcSize = $root.vec2.toObject(message.arcSize, options);
                    return object;
                };

                /**
                 * Creates a plain object from this Fixation message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Fixation.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Fixation to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Fixation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Fixation;
            })();

            Look.Saccade = (function() {

                /**
                 * Properties of a Saccade.
                 * @typedef message.behaviour.Look.Saccade$Properties
                 * @type {Object}
                 * @property {google.protobuf.Duration$Properties} [dwellTime] Saccade dwellTime.
                 * @property {vec2$Properties} [angle] Saccade angle.
                 * @property {vec2$Properties} [arcSize] Saccade arcSize.
                 */

                /**
                 * Constructs a new Saccade.
                 * @exports message.behaviour.Look.Saccade
                 * @constructor
                 * @param {message.behaviour.Look.Saccade$Properties=} [properties] Properties to set
                 */
                function Saccade(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Saccade dwellTime.
                 * @type {(google.protobuf.Duration$Properties|null)}
                 */
                Saccade.prototype.dwellTime = null;

                /**
                 * Saccade angle.
                 * @type {(vec2$Properties|null)}
                 */
                Saccade.prototype.angle = null;

                /**
                 * Saccade arcSize.
                 * @type {(vec2$Properties|null)}
                 */
                Saccade.prototype.arcSize = null;

                /**
                 * Creates a new Saccade instance using the specified properties.
                 * @param {message.behaviour.Look.Saccade$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Look.Saccade} Saccade instance
                 */
                Saccade.create = function create(properties) {
                    return new Saccade(properties);
                };

                /**
                 * Encodes the specified Saccade message. Does not implicitly {@link message.behaviour.Look.Saccade.verify|verify} messages.
                 * @param {message.behaviour.Look.Saccade$Properties} message Saccade message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Saccade.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.dwellTime != null && message.hasOwnProperty("dwellTime"))
                        $root.google.protobuf.Duration.encode(message.dwellTime, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.angle != null && message.hasOwnProperty("angle"))
                        $root.vec2.encode(message.angle, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.arcSize != null && message.hasOwnProperty("arcSize"))
                        $root.vec2.encode(message.arcSize, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Saccade message, length delimited. Does not implicitly {@link message.behaviour.Look.Saccade.verify|verify} messages.
                 * @param {message.behaviour.Look.Saccade$Properties} message Saccade message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Saccade.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Saccade message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Look.Saccade} Saccade
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Saccade.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Look.Saccade();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.dwellTime = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.angle = $root.vec2.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.arcSize = $root.vec2.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Saccade message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Look.Saccade} Saccade
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Saccade.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Saccade message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Saccade.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.dwellTime != null && message.hasOwnProperty("dwellTime")) {
                        var error = $root.google.protobuf.Duration.verify(message.dwellTime);
                        if (error)
                            return "dwellTime." + error;
                    }
                    if (message.angle != null && message.hasOwnProperty("angle")) {
                        var error = $root.vec2.verify(message.angle);
                        if (error)
                            return "angle." + error;
                    }
                    if (message.arcSize != null && message.hasOwnProperty("arcSize")) {
                        var error = $root.vec2.verify(message.arcSize);
                        if (error)
                            return "arcSize." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Saccade message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.Saccade} Saccade
                 */
                Saccade.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.behaviour.Look.Saccade)
                        return object;
                    var message = new $root.message.behaviour.Look.Saccade();
                    if (object.dwellTime != null) {
                        if (typeof object.dwellTime !== "object")
                            throw TypeError(".message.behaviour.Look.Saccade.dwellTime: object expected");
                        message.dwellTime = $root.google.protobuf.Duration.fromObject(object.dwellTime);
                    }
                    if (object.angle != null) {
                        if (typeof object.angle !== "object")
                            throw TypeError(".message.behaviour.Look.Saccade.angle: object expected");
                        message.angle = $root.vec2.fromObject(object.angle);
                    }
                    if (object.arcSize != null) {
                        if (typeof object.arcSize !== "object")
                            throw TypeError(".message.behaviour.Look.Saccade.arcSize: object expected");
                        message.arcSize = $root.vec2.fromObject(object.arcSize);
                    }
                    return message;
                };

                /**
                 * Creates a Saccade message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Look.Saccade.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.Saccade} Saccade
                 */
                Saccade.from = Saccade.fromObject;

                /**
                 * Creates a plain object from a Saccade message. Also converts values to other types if specified.
                 * @param {message.behaviour.Look.Saccade} message Saccade
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Saccade.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.dwellTime = null;
                        object.angle = null;
                        object.arcSize = null;
                    }
                    if (message.dwellTime != null && message.hasOwnProperty("dwellTime"))
                        object.dwellTime = $root.google.protobuf.Duration.toObject(message.dwellTime, options);
                    if (message.angle != null && message.hasOwnProperty("angle"))
                        object.angle = $root.vec2.toObject(message.angle, options);
                    if (message.arcSize != null && message.hasOwnProperty("arcSize"))
                        object.arcSize = $root.vec2.toObject(message.arcSize, options);
                    return object;
                };

                /**
                 * Creates a plain object from this Saccade message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Saccade.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Saccade to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Saccade.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Saccade;
            })();

            Look.Pan = (function() {

                /**
                 * Properties of a Pan.
                 * @typedef message.behaviour.Look.Pan$Properties
                 * @type {Object}
                 * @property {vec2$Properties} [angle] Pan angle.
                 * @property {vec2$Properties} [arcSize] Pan arcSize.
                 */

                /**
                 * Constructs a new Pan.
                 * @exports message.behaviour.Look.Pan
                 * @constructor
                 * @param {message.behaviour.Look.Pan$Properties=} [properties] Properties to set
                 */
                function Pan(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Pan angle.
                 * @type {(vec2$Properties|null)}
                 */
                Pan.prototype.angle = null;

                /**
                 * Pan arcSize.
                 * @type {(vec2$Properties|null)}
                 */
                Pan.prototype.arcSize = null;

                /**
                 * Creates a new Pan instance using the specified properties.
                 * @param {message.behaviour.Look.Pan$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Look.Pan} Pan instance
                 */
                Pan.create = function create(properties) {
                    return new Pan(properties);
                };

                /**
                 * Encodes the specified Pan message. Does not implicitly {@link message.behaviour.Look.Pan.verify|verify} messages.
                 * @param {message.behaviour.Look.Pan$Properties} message Pan message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pan.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.angle != null && message.hasOwnProperty("angle"))
                        $root.vec2.encode(message.angle, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.arcSize != null && message.hasOwnProperty("arcSize"))
                        $root.vec2.encode(message.arcSize, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Pan message, length delimited. Does not implicitly {@link message.behaviour.Look.Pan.verify|verify} messages.
                 * @param {message.behaviour.Look.Pan$Properties} message Pan message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pan.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Pan message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Look.Pan} Pan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pan.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Look.Pan();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.angle = $root.vec2.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.arcSize = $root.vec2.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Pan message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Look.Pan} Pan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pan.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Pan message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Pan.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.angle != null && message.hasOwnProperty("angle")) {
                        var error = $root.vec2.verify(message.angle);
                        if (error)
                            return "angle." + error;
                    }
                    if (message.arcSize != null && message.hasOwnProperty("arcSize")) {
                        var error = $root.vec2.verify(message.arcSize);
                        if (error)
                            return "arcSize." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Pan message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.Pan} Pan
                 */
                Pan.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.behaviour.Look.Pan)
                        return object;
                    var message = new $root.message.behaviour.Look.Pan();
                    if (object.angle != null) {
                        if (typeof object.angle !== "object")
                            throw TypeError(".message.behaviour.Look.Pan.angle: object expected");
                        message.angle = $root.vec2.fromObject(object.angle);
                    }
                    if (object.arcSize != null) {
                        if (typeof object.arcSize !== "object")
                            throw TypeError(".message.behaviour.Look.Pan.arcSize: object expected");
                        message.arcSize = $root.vec2.fromObject(object.arcSize);
                    }
                    return message;
                };

                /**
                 * Creates a Pan message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Look.Pan.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.Pan} Pan
                 */
                Pan.from = Pan.fromObject;

                /**
                 * Creates a plain object from a Pan message. Also converts values to other types if specified.
                 * @param {message.behaviour.Look.Pan} message Pan
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Pan.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.angle = null;
                        object.arcSize = null;
                    }
                    if (message.angle != null && message.hasOwnProperty("angle"))
                        object.angle = $root.vec2.toObject(message.angle, options);
                    if (message.arcSize != null && message.hasOwnProperty("arcSize"))
                        object.arcSize = $root.vec2.toObject(message.arcSize, options);
                    return object;
                };

                /**
                 * Creates a plain object from this Pan message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Pan.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Pan to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Pan.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Pan;
            })();

            Look.PanSelection = (function() {

                /**
                 * Properties of a PanSelection.
                 * @typedef message.behaviour.Look.PanSelection$Properties
                 * @type {Object}
                 * @property {boolean} [lookAtGoalInsteadOfBall] PanSelection lookAtGoalInsteadOfBall.
                 */

                /**
                 * Constructs a new PanSelection.
                 * @exports message.behaviour.Look.PanSelection
                 * @constructor
                 * @param {message.behaviour.Look.PanSelection$Properties=} [properties] Properties to set
                 */
                function PanSelection(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PanSelection lookAtGoalInsteadOfBall.
                 * @type {boolean}
                 */
                PanSelection.prototype.lookAtGoalInsteadOfBall = false;

                /**
                 * Creates a new PanSelection instance using the specified properties.
                 * @param {message.behaviour.Look.PanSelection$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Look.PanSelection} PanSelection instance
                 */
                PanSelection.create = function create(properties) {
                    return new PanSelection(properties);
                };

                /**
                 * Encodes the specified PanSelection message. Does not implicitly {@link message.behaviour.Look.PanSelection.verify|verify} messages.
                 * @param {message.behaviour.Look.PanSelection$Properties} message PanSelection message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PanSelection.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.lookAtGoalInsteadOfBall != null && message.hasOwnProperty("lookAtGoalInsteadOfBall"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.lookAtGoalInsteadOfBall);
                    return writer;
                };

                /**
                 * Encodes the specified PanSelection message, length delimited. Does not implicitly {@link message.behaviour.Look.PanSelection.verify|verify} messages.
                 * @param {message.behaviour.Look.PanSelection$Properties} message PanSelection message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PanSelection.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PanSelection message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Look.PanSelection} PanSelection
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PanSelection.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Look.PanSelection();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.lookAtGoalInsteadOfBall = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PanSelection message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Look.PanSelection} PanSelection
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PanSelection.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PanSelection message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                PanSelection.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.lookAtGoalInsteadOfBall != null && message.hasOwnProperty("lookAtGoalInsteadOfBall"))
                        if (typeof message.lookAtGoalInsteadOfBall !== "boolean")
                            return "lookAtGoalInsteadOfBall: boolean expected";
                    return null;
                };

                /**
                 * Creates a PanSelection message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.PanSelection} PanSelection
                 */
                PanSelection.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.behaviour.Look.PanSelection)
                        return object;
                    var message = new $root.message.behaviour.Look.PanSelection();
                    if (object.lookAtGoalInsteadOfBall != null)
                        message.lookAtGoalInsteadOfBall = Boolean(object.lookAtGoalInsteadOfBall);
                    return message;
                };

                /**
                 * Creates a PanSelection message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Look.PanSelection.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.PanSelection} PanSelection
                 */
                PanSelection.from = PanSelection.fromObject;

                /**
                 * Creates a plain object from a PanSelection message. Also converts values to other types if specified.
                 * @param {message.behaviour.Look.PanSelection} message PanSelection
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PanSelection.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.lookAtGoalInsteadOfBall = false;
                    if (message.lookAtGoalInsteadOfBall != null && message.hasOwnProperty("lookAtGoalInsteadOfBall"))
                        object.lookAtGoalInsteadOfBall = message.lookAtGoalInsteadOfBall;
                    return object;
                };

                /**
                 * Creates a plain object from this PanSelection message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PanSelection.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this PanSelection to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                PanSelection.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PanSelection;
            })();

            return Look;
        })();

        behaviour.MotionCommand = (function() {

            /**
             * Properties of a MotionCommand.
             * @typedef message.behaviour.MotionCommand$Properties
             * @type {Object}
             * @property {message.behaviour.MotionCommand.Type} [type] MotionCommand type.
             * @property {vec3$Properties} [goalState] MotionCommand goalState.
             * @property {vec2$Properties} [kickTarget] MotionCommand kickTarget.
             * @property {vec3$Properties} [walkCommand] MotionCommand walkCommand.
             */

            /**
             * Constructs a new MotionCommand.
             * @exports message.behaviour.MotionCommand
             * @constructor
             * @param {message.behaviour.MotionCommand$Properties=} [properties] Properties to set
             */
            function MotionCommand(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MotionCommand type.
             * @type {message.behaviour.MotionCommand.Type}
             */
            MotionCommand.prototype.type = 0;

            /**
             * MotionCommand goalState.
             * @type {(vec3$Properties|null)}
             */
            MotionCommand.prototype.goalState = null;

            /**
             * MotionCommand kickTarget.
             * @type {(vec2$Properties|null)}
             */
            MotionCommand.prototype.kickTarget = null;

            /**
             * MotionCommand walkCommand.
             * @type {(vec3$Properties|null)}
             */
            MotionCommand.prototype.walkCommand = null;

            /**
             * Creates a new MotionCommand instance using the specified properties.
             * @param {message.behaviour.MotionCommand$Properties=} [properties] Properties to set
             * @returns {message.behaviour.MotionCommand} MotionCommand instance
             */
            MotionCommand.create = function create(properties) {
                return new MotionCommand(properties);
            };

            /**
             * Encodes the specified MotionCommand message. Does not implicitly {@link message.behaviour.MotionCommand.verify|verify} messages.
             * @param {message.behaviour.MotionCommand$Properties} message MotionCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MotionCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
                if (message.goalState != null && message.hasOwnProperty("goalState"))
                    $root.vec3.encode(message.goalState, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.kickTarget != null && message.hasOwnProperty("kickTarget"))
                    $root.vec2.encode(message.kickTarget, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.walkCommand != null && message.hasOwnProperty("walkCommand"))
                    $root.vec3.encode(message.walkCommand, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MotionCommand message, length delimited. Does not implicitly {@link message.behaviour.MotionCommand.verify|verify} messages.
             * @param {message.behaviour.MotionCommand$Properties} message MotionCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MotionCommand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MotionCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.MotionCommand} MotionCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MotionCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.MotionCommand();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.uint32();
                        break;
                    case 2:
                        message.goalState = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.kickTarget = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.walkCommand = $root.vec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MotionCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.MotionCommand} MotionCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MotionCommand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MotionCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            MotionCommand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goalState != null && message.hasOwnProperty("goalState")) {
                    var error = $root.vec3.verify(message.goalState);
                    if (error)
                        return "goalState." + error;
                }
                if (message.kickTarget != null && message.hasOwnProperty("kickTarget")) {
                    var error = $root.vec2.verify(message.kickTarget);
                    if (error)
                        return "kickTarget." + error;
                }
                if (message.walkCommand != null && message.hasOwnProperty("walkCommand")) {
                    var error = $root.vec3.verify(message.walkCommand);
                    if (error)
                        return "walkCommand." + error;
                }
                return null;
            };

            /**
             * Creates a MotionCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.MotionCommand} MotionCommand
             */
            MotionCommand.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.MotionCommand)
                    return object;
                var message = new $root.message.behaviour.MotionCommand();
                switch (object.type) {
                case "StandStill":
                case 0:
                    message.type = 0;
                    break;
                case "WalkToState":
                case 1:
                    message.type = 1;
                    break;
                case "BallApproach":
                case 2:
                    message.type = 2;
                    break;
                case "DirectCommand":
                case 3:
                    message.type = 3;
                    break;
                }
                if (object.goalState != null) {
                    if (typeof object.goalState !== "object")
                        throw TypeError(".message.behaviour.MotionCommand.goalState: object expected");
                    message.goalState = $root.vec3.fromObject(object.goalState);
                }
                if (object.kickTarget != null) {
                    if (typeof object.kickTarget !== "object")
                        throw TypeError(".message.behaviour.MotionCommand.kickTarget: object expected");
                    message.kickTarget = $root.vec2.fromObject(object.kickTarget);
                }
                if (object.walkCommand != null) {
                    if (typeof object.walkCommand !== "object")
                        throw TypeError(".message.behaviour.MotionCommand.walkCommand: object expected");
                    message.walkCommand = $root.vec3.fromObject(object.walkCommand);
                }
                return message;
            };

            /**
             * Creates a MotionCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.MotionCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.MotionCommand} MotionCommand
             */
            MotionCommand.from = MotionCommand.fromObject;

            /**
             * Creates a plain object from a MotionCommand message. Also converts values to other types if specified.
             * @param {message.behaviour.MotionCommand} message MotionCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MotionCommand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "StandStill" : 0;
                    object.goalState = null;
                    object.kickTarget = null;
                    object.walkCommand = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.message.behaviour.MotionCommand.Type[message.type] : message.type;
                if (message.goalState != null && message.hasOwnProperty("goalState"))
                    object.goalState = $root.vec3.toObject(message.goalState, options);
                if (message.kickTarget != null && message.hasOwnProperty("kickTarget"))
                    object.kickTarget = $root.vec2.toObject(message.kickTarget, options);
                if (message.walkCommand != null && message.hasOwnProperty("walkCommand"))
                    object.walkCommand = $root.vec3.toObject(message.walkCommand, options);
                return object;
            };

            /**
             * Creates a plain object from this MotionCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MotionCommand.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this MotionCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            MotionCommand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name Type
             * @memberof message.behaviour.MotionCommand
             * @enum {number}
             * @property {number} StandStill=0 StandStill value
             * @property {number} WalkToState=1 WalkToState value
             * @property {number} BallApproach=2 BallApproach value
             * @property {number} DirectCommand=3 DirectCommand value
             */
            MotionCommand.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "StandStill"] = 0;
                values[valuesById[1] = "WalkToState"] = 1;
                values[valuesById[2] = "BallApproach"] = 2;
                values[valuesById[3] = "DirectCommand"] = 3;
                return values;
            })();

            return MotionCommand;
        })();

        behaviour.Nod = (function() {

            /**
             * Properties of a Nod.
             * @typedef message.behaviour.Nod$Properties
             * @type {Object}
             * @property {boolean} [value] Nod value.
             */

            /**
             * Constructs a new Nod.
             * @exports message.behaviour.Nod
             * @constructor
             * @param {message.behaviour.Nod$Properties=} [properties] Properties to set
             */
            function Nod(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Nod value.
             * @type {boolean}
             */
            Nod.prototype.value = false;

            /**
             * Creates a new Nod instance using the specified properties.
             * @param {message.behaviour.Nod$Properties=} [properties] Properties to set
             * @returns {message.behaviour.Nod} Nod instance
             */
            Nod.create = function create(properties) {
                return new Nod(properties);
            };

            /**
             * Encodes the specified Nod message. Does not implicitly {@link message.behaviour.Nod.verify|verify} messages.
             * @param {message.behaviour.Nod$Properties} message Nod message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Nod.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                return writer;
            };

            /**
             * Encodes the specified Nod message, length delimited. Does not implicitly {@link message.behaviour.Nod.verify|verify} messages.
             * @param {message.behaviour.Nod$Properties} message Nod message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Nod.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Nod message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.Nod} Nod
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Nod.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Nod();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Nod message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.Nod} Nod
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Nod.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Nod message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Nod.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "boolean")
                        return "value: boolean expected";
                return null;
            };

            /**
             * Creates a Nod message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Nod} Nod
             */
            Nod.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.Nod)
                    return object;
                var message = new $root.message.behaviour.Nod();
                if (object.value != null)
                    message.value = Boolean(object.value);
                return message;
            };

            /**
             * Creates a Nod message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.Nod.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Nod} Nod
             */
            Nod.from = Nod.fromObject;

            /**
             * Creates a plain object from a Nod message. Also converts values to other types if specified.
             * @param {message.behaviour.Nod} message Nod
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Nod.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = false;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Creates a plain object from this Nod message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Nod.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Nod to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Nod.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Nod;
        })();

        behaviour.ServoCommand = (function() {

            /**
             * Properties of a ServoCommand.
             * @typedef message.behaviour.ServoCommand$Properties
             * @type {Object}
             * @property {number|Long} [source] ServoCommand source.
             * @property {google.protobuf.Timestamp$Properties} [time] ServoCommand time.
             * @property {number} [id] ServoCommand id.
             * @property {number} [position] ServoCommand position.
             * @property {number} [gain] ServoCommand gain.
             * @property {number} [torque] ServoCommand torque.
             */

            /**
             * Constructs a new ServoCommand.
             * @exports message.behaviour.ServoCommand
             * @constructor
             * @param {message.behaviour.ServoCommand$Properties=} [properties] Properties to set
             */
            function ServoCommand(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServoCommand source.
             * @type {number|Long}
             */
            ServoCommand.prototype.source = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ServoCommand time.
             * @type {(google.protobuf.Timestamp$Properties|null)}
             */
            ServoCommand.prototype.time = null;

            /**
             * ServoCommand id.
             * @type {number}
             */
            ServoCommand.prototype.id = 0;

            /**
             * ServoCommand position.
             * @type {number}
             */
            ServoCommand.prototype.position = 0;

            /**
             * ServoCommand gain.
             * @type {number}
             */
            ServoCommand.prototype.gain = 0;

            /**
             * ServoCommand torque.
             * @type {number}
             */
            ServoCommand.prototype.torque = 0;

            /**
             * Creates a new ServoCommand instance using the specified properties.
             * @param {message.behaviour.ServoCommand$Properties=} [properties] Properties to set
             * @returns {message.behaviour.ServoCommand} ServoCommand instance
             */
            ServoCommand.create = function create(properties) {
                return new ServoCommand(properties);
            };

            /**
             * Encodes the specified ServoCommand message. Does not implicitly {@link message.behaviour.ServoCommand.verify|verify} messages.
             * @param {message.behaviour.ServoCommand$Properties} message ServoCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.source != null && message.hasOwnProperty("source"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.source);
                if (message.time != null && message.hasOwnProperty("time"))
                    $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.id);
                if (message.position != null && message.hasOwnProperty("position"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.position);
                if (message.gain != null && message.hasOwnProperty("gain"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.gain);
                if (message.torque != null && message.hasOwnProperty("torque"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.torque);
                return writer;
            };

            /**
             * Encodes the specified ServoCommand message, length delimited. Does not implicitly {@link message.behaviour.ServoCommand.verify|verify} messages.
             * @param {message.behaviour.ServoCommand$Properties} message ServoCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoCommand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServoCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.ServoCommand} ServoCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.ServoCommand();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.source = reader.uint64();
                        break;
                    case 2:
                        message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.id = reader.uint32();
                        break;
                    case 4:
                        message.position = reader.float();
                        break;
                    case 5:
                        message.gain = reader.float();
                        break;
                    case 6:
                        message.torque = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServoCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.ServoCommand} ServoCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoCommand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServoCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ServoCommand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.source != null && message.hasOwnProperty("source"))
                    if (!$util.isInteger(message.source) && !(message.source && $util.isInteger(message.source.low) && $util.isInteger(message.source.high)))
                        return "source: integer|Long expected";
                if (message.time != null && message.hasOwnProperty("time")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.time);
                    if (error)
                        return "time." + error;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.position != null && message.hasOwnProperty("position"))
                    if (typeof message.position !== "number")
                        return "position: number expected";
                if (message.gain != null && message.hasOwnProperty("gain"))
                    if (typeof message.gain !== "number")
                        return "gain: number expected";
                if (message.torque != null && message.hasOwnProperty("torque"))
                    if (typeof message.torque !== "number")
                        return "torque: number expected";
                return null;
            };

            /**
             * Creates a ServoCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.ServoCommand} ServoCommand
             */
            ServoCommand.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.ServoCommand)
                    return object;
                var message = new $root.message.behaviour.ServoCommand();
                if (object.source != null)
                    if ($util.Long)
                        (message.source = $util.Long.fromValue(object.source)).unsigned = true;
                    else if (typeof object.source === "string")
                        message.source = parseInt(object.source, 10);
                    else if (typeof object.source === "number")
                        message.source = object.source;
                    else if (typeof object.source === "object")
                        message.source = new $util.LongBits(object.source.low >>> 0, object.source.high >>> 0).toNumber(true);
                if (object.time != null) {
                    if (typeof object.time !== "object")
                        throw TypeError(".message.behaviour.ServoCommand.time: object expected");
                    message.time = $root.google.protobuf.Timestamp.fromObject(object.time);
                }
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.position != null)
                    message.position = Number(object.position);
                if (object.gain != null)
                    message.gain = Number(object.gain);
                if (object.torque != null)
                    message.torque = Number(object.torque);
                return message;
            };

            /**
             * Creates a ServoCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.ServoCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.ServoCommand} ServoCommand
             */
            ServoCommand.from = ServoCommand.fromObject;

            /**
             * Creates a plain object from a ServoCommand message. Also converts values to other types if specified.
             * @param {message.behaviour.ServoCommand} message ServoCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServoCommand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.source = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.source = options.longs === String ? "0" : 0;
                    object.time = null;
                    object.id = 0;
                    object.position = 0;
                    object.gain = 0;
                    object.torque = 0;
                }
                if (message.source != null && message.hasOwnProperty("source"))
                    if (typeof message.source === "number")
                        object.source = options.longs === String ? String(message.source) : message.source;
                    else
                        object.source = options.longs === String ? $util.Long.prototype.toString.call(message.source) : options.longs === Number ? new $util.LongBits(message.source.low >>> 0, message.source.high >>> 0).toNumber(true) : message.source;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = $root.google.protobuf.Timestamp.toObject(message.time, options);
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = message.position;
                if (message.gain != null && message.hasOwnProperty("gain"))
                    object.gain = message.gain;
                if (message.torque != null && message.hasOwnProperty("torque"))
                    object.torque = message.torque;
                return object;
            };

            /**
             * Creates a plain object from this ServoCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServoCommand.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ServoCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ServoCommand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServoCommand;
        })();

        behaviour.SoccerObjectPriority = (function() {

            /**
             * Properties of a SoccerObjectPriority.
             * @typedef message.behaviour.SoccerObjectPriority$Properties
             * @type {Object}
             * @property {number} [ball] SoccerObjectPriority ball.
             * @property {number} [goal] SoccerObjectPriority goal.
             * @property {number} [line] SoccerObjectPriority line.
             * @property {message.behaviour.SoccerObjectPriority.SearchType} [searchType] SoccerObjectPriority searchType.
             */

            /**
             * Constructs a new SoccerObjectPriority.
             * @exports message.behaviour.SoccerObjectPriority
             * @constructor
             * @param {message.behaviour.SoccerObjectPriority$Properties=} [properties] Properties to set
             */
            function SoccerObjectPriority(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SoccerObjectPriority ball.
             * @type {number}
             */
            SoccerObjectPriority.prototype.ball = 0;

            /**
             * SoccerObjectPriority goal.
             * @type {number}
             */
            SoccerObjectPriority.prototype.goal = 0;

            /**
             * SoccerObjectPriority line.
             * @type {number}
             */
            SoccerObjectPriority.prototype.line = 0;

            /**
             * SoccerObjectPriority searchType.
             * @type {message.behaviour.SoccerObjectPriority.SearchType}
             */
            SoccerObjectPriority.prototype.searchType = 0;

            /**
             * Creates a new SoccerObjectPriority instance using the specified properties.
             * @param {message.behaviour.SoccerObjectPriority$Properties=} [properties] Properties to set
             * @returns {message.behaviour.SoccerObjectPriority} SoccerObjectPriority instance
             */
            SoccerObjectPriority.create = function create(properties) {
                return new SoccerObjectPriority(properties);
            };

            /**
             * Encodes the specified SoccerObjectPriority message. Does not implicitly {@link message.behaviour.SoccerObjectPriority.verify|verify} messages.
             * @param {message.behaviour.SoccerObjectPriority$Properties} message SoccerObjectPriority message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SoccerObjectPriority.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ball != null && message.hasOwnProperty("ball"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ball);
                if (message.goal != null && message.hasOwnProperty("goal"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.goal);
                if (message.line != null && message.hasOwnProperty("line"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.line);
                if (message.searchType != null && message.hasOwnProperty("searchType"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.searchType);
                return writer;
            };

            /**
             * Encodes the specified SoccerObjectPriority message, length delimited. Does not implicitly {@link message.behaviour.SoccerObjectPriority.verify|verify} messages.
             * @param {message.behaviour.SoccerObjectPriority$Properties} message SoccerObjectPriority message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SoccerObjectPriority.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SoccerObjectPriority message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.SoccerObjectPriority} SoccerObjectPriority
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SoccerObjectPriority.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.SoccerObjectPriority();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ball = reader.int32();
                        break;
                    case 2:
                        message.goal = reader.int32();
                        break;
                    case 3:
                        message.line = reader.int32();
                        break;
                    case 4:
                        message.searchType = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SoccerObjectPriority message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.SoccerObjectPriority} SoccerObjectPriority
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SoccerObjectPriority.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SoccerObjectPriority message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            SoccerObjectPriority.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ball != null && message.hasOwnProperty("ball"))
                    if (!$util.isInteger(message.ball))
                        return "ball: integer expected";
                if (message.goal != null && message.hasOwnProperty("goal"))
                    if (!$util.isInteger(message.goal))
                        return "goal: integer expected";
                if (message.line != null && message.hasOwnProperty("line"))
                    if (!$util.isInteger(message.line))
                        return "line: integer expected";
                if (message.searchType != null && message.hasOwnProperty("searchType"))
                    switch (message.searchType) {
                    default:
                        return "searchType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                return null;
            };

            /**
             * Creates a SoccerObjectPriority message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.SoccerObjectPriority} SoccerObjectPriority
             */
            SoccerObjectPriority.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.SoccerObjectPriority)
                    return object;
                var message = new $root.message.behaviour.SoccerObjectPriority();
                if (object.ball != null)
                    message.ball = object.ball | 0;
                if (object.goal != null)
                    message.goal = object.goal | 0;
                if (object.line != null)
                    message.line = object.line | 0;
                switch (object.searchType) {
                case "LOST":
                case 0:
                    message.searchType = 0;
                    break;
                case "FIND_ADDITIONAL_OBJECTS":
                case 1:
                    message.searchType = 1;
                    break;
                case "GOAL_SEARCH":
                case 2:
                    message.searchType = 2;
                    break;
                case "GOAL_LEFT":
                case 3:
                    message.searchType = 3;
                    break;
                case "GOAL_RIGHT":
                case 4:
                    message.searchType = 4;
                    break;
                case "GROUND_LEFT":
                case 5:
                    message.searchType = 5;
                    break;
                case "GROUND_RIGHT":
                case 6:
                    message.searchType = 6;
                    break;
                case "OTHE":
                case 7:
                    message.searchType = 7;
                    break;
                }
                return message;
            };

            /**
             * Creates a SoccerObjectPriority message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.SoccerObjectPriority.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.SoccerObjectPriority} SoccerObjectPriority
             */
            SoccerObjectPriority.from = SoccerObjectPriority.fromObject;

            /**
             * Creates a plain object from a SoccerObjectPriority message. Also converts values to other types if specified.
             * @param {message.behaviour.SoccerObjectPriority} message SoccerObjectPriority
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SoccerObjectPriority.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.ball = 0;
                    object.goal = 0;
                    object.line = 0;
                    object.searchType = options.enums === String ? "LOST" : 0;
                }
                if (message.ball != null && message.hasOwnProperty("ball"))
                    object.ball = message.ball;
                if (message.goal != null && message.hasOwnProperty("goal"))
                    object.goal = message.goal;
                if (message.line != null && message.hasOwnProperty("line"))
                    object.line = message.line;
                if (message.searchType != null && message.hasOwnProperty("searchType"))
                    object.searchType = options.enums === String ? $root.message.behaviour.SoccerObjectPriority.SearchType[message.searchType] : message.searchType;
                return object;
            };

            /**
             * Creates a plain object from this SoccerObjectPriority message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SoccerObjectPriority.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this SoccerObjectPriority to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            SoccerObjectPriority.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * SearchType enum.
             * @name SearchType
             * @memberof message.behaviour.SoccerObjectPriority
             * @enum {number}
             * @property {number} LOST=0 LOST value
             * @property {number} FIND_ADDITIONAL_OBJECTS=1 FIND_ADDITIONAL_OBJECTS value
             * @property {number} GOAL_SEARCH=2 GOAL_SEARCH value
             * @property {number} GOAL_LEFT=3 GOAL_LEFT value
             * @property {number} GOAL_RIGHT=4 GOAL_RIGHT value
             * @property {number} GROUND_LEFT=5 GROUND_LEFT value
             * @property {number} GROUND_RIGHT=6 GROUND_RIGHT value
             * @property {number} OTHE=7 OTHE value
             */
            SoccerObjectPriority.SearchType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "LOST"] = 0;
                values[valuesById[1] = "FIND_ADDITIONAL_OBJECTS"] = 1;
                values[valuesById[2] = "GOAL_SEARCH"] = 2;
                values[valuesById[3] = "GOAL_LEFT"] = 3;
                values[valuesById[4] = "GOAL_RIGHT"] = 4;
                values[valuesById[5] = "GROUND_LEFT"] = 5;
                values[valuesById[6] = "GROUND_RIGHT"] = 6;
                values[valuesById[7] = "OTHE"] = 7;
                return values;
            })();

            return SoccerObjectPriority;
        })();

        behaviour.Subsumption = (function() {

            /**
             * Properties of a Subsumption.
             * @typedef message.behaviour.Subsumption$Properties
             * @type {Object}
             * @property {Array.<message.behaviour.Subsumption.ActionRegister$Properties>} [actionRegister] Subsumption actionRegister.
             * @property {Array.<message.behaviour.Subsumption.ActionStateChange$Properties>} [actionStateChange] Subsumption actionStateChange.
             * @property {Array.<message.behaviour.Subsumption.ActionPriorites$Properties>} [actionPriorityChange] Subsumption actionPriorityChange.
             */

            /**
             * Constructs a new Subsumption.
             * @exports message.behaviour.Subsumption
             * @constructor
             * @param {message.behaviour.Subsumption$Properties=} [properties] Properties to set
             */
            function Subsumption(properties) {
                this.actionRegister = [];
                this.actionStateChange = [];
                this.actionPriorityChange = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Subsumption actionRegister.
             * @type {Array.<message.behaviour.Subsumption.ActionRegister$Properties>}
             */
            Subsumption.prototype.actionRegister = $util.emptyArray;

            /**
             * Subsumption actionStateChange.
             * @type {Array.<message.behaviour.Subsumption.ActionStateChange$Properties>}
             */
            Subsumption.prototype.actionStateChange = $util.emptyArray;

            /**
             * Subsumption actionPriorityChange.
             * @type {Array.<message.behaviour.Subsumption.ActionPriorites$Properties>}
             */
            Subsumption.prototype.actionPriorityChange = $util.emptyArray;

            /**
             * Creates a new Subsumption instance using the specified properties.
             * @param {message.behaviour.Subsumption$Properties=} [properties] Properties to set
             * @returns {message.behaviour.Subsumption} Subsumption instance
             */
            Subsumption.create = function create(properties) {
                return new Subsumption(properties);
            };

            /**
             * Encodes the specified Subsumption message. Does not implicitly {@link message.behaviour.Subsumption.verify|verify} messages.
             * @param {message.behaviour.Subsumption$Properties} message Subsumption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Subsumption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.actionRegister != null && message.actionRegister.length)
                    for (var i = 0; i < message.actionRegister.length; ++i)
                        $root.message.behaviour.Subsumption.ActionRegister.encode(message.actionRegister[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.actionStateChange != null && message.actionStateChange.length)
                    for (var i = 0; i < message.actionStateChange.length; ++i)
                        $root.message.behaviour.Subsumption.ActionStateChange.encode(message.actionStateChange[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.actionPriorityChange != null && message.actionPriorityChange.length)
                    for (var i = 0; i < message.actionPriorityChange.length; ++i)
                        $root.message.behaviour.Subsumption.ActionPriorites.encode(message.actionPriorityChange[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Subsumption message, length delimited. Does not implicitly {@link message.behaviour.Subsumption.verify|verify} messages.
             * @param {message.behaviour.Subsumption$Properties} message Subsumption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Subsumption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Subsumption message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.Subsumption} Subsumption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Subsumption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Subsumption();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.actionRegister && message.actionRegister.length))
                            message.actionRegister = [];
                        message.actionRegister.push($root.message.behaviour.Subsumption.ActionRegister.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.actionStateChange && message.actionStateChange.length))
                            message.actionStateChange = [];
                        message.actionStateChange.push($root.message.behaviour.Subsumption.ActionStateChange.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.actionPriorityChange && message.actionPriorityChange.length))
                            message.actionPriorityChange = [];
                        message.actionPriorityChange.push($root.message.behaviour.Subsumption.ActionPriorites.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Subsumption message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.Subsumption} Subsumption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Subsumption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Subsumption message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Subsumption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.actionRegister != null && message.hasOwnProperty("actionRegister")) {
                    if (!Array.isArray(message.actionRegister))
                        return "actionRegister: array expected";
                    for (var i = 0; i < message.actionRegister.length; ++i) {
                        var error = $root.message.behaviour.Subsumption.ActionRegister.verify(message.actionRegister[i]);
                        if (error)
                            return "actionRegister." + error;
                    }
                }
                if (message.actionStateChange != null && message.hasOwnProperty("actionStateChange")) {
                    if (!Array.isArray(message.actionStateChange))
                        return "actionStateChange: array expected";
                    for (var i = 0; i < message.actionStateChange.length; ++i) {
                        var error = $root.message.behaviour.Subsumption.ActionStateChange.verify(message.actionStateChange[i]);
                        if (error)
                            return "actionStateChange." + error;
                    }
                }
                if (message.actionPriorityChange != null && message.hasOwnProperty("actionPriorityChange")) {
                    if (!Array.isArray(message.actionPriorityChange))
                        return "actionPriorityChange: array expected";
                    for (var i = 0; i < message.actionPriorityChange.length; ++i) {
                        var error = $root.message.behaviour.Subsumption.ActionPriorites.verify(message.actionPriorityChange[i]);
                        if (error)
                            return "actionPriorityChange." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Subsumption message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Subsumption} Subsumption
             */
            Subsumption.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.Subsumption)
                    return object;
                var message = new $root.message.behaviour.Subsumption();
                if (object.actionRegister) {
                    if (!Array.isArray(object.actionRegister))
                        throw TypeError(".message.behaviour.Subsumption.actionRegister: array expected");
                    message.actionRegister = [];
                    for (var i = 0; i < object.actionRegister.length; ++i) {
                        if (typeof object.actionRegister[i] !== "object")
                            throw TypeError(".message.behaviour.Subsumption.actionRegister: object expected");
                        message.actionRegister[i] = $root.message.behaviour.Subsumption.ActionRegister.fromObject(object.actionRegister[i]);
                    }
                }
                if (object.actionStateChange) {
                    if (!Array.isArray(object.actionStateChange))
                        throw TypeError(".message.behaviour.Subsumption.actionStateChange: array expected");
                    message.actionStateChange = [];
                    for (var i = 0; i < object.actionStateChange.length; ++i) {
                        if (typeof object.actionStateChange[i] !== "object")
                            throw TypeError(".message.behaviour.Subsumption.actionStateChange: object expected");
                        message.actionStateChange[i] = $root.message.behaviour.Subsumption.ActionStateChange.fromObject(object.actionStateChange[i]);
                    }
                }
                if (object.actionPriorityChange) {
                    if (!Array.isArray(object.actionPriorityChange))
                        throw TypeError(".message.behaviour.Subsumption.actionPriorityChange: array expected");
                    message.actionPriorityChange = [];
                    for (var i = 0; i < object.actionPriorityChange.length; ++i) {
                        if (typeof object.actionPriorityChange[i] !== "object")
                            throw TypeError(".message.behaviour.Subsumption.actionPriorityChange: object expected");
                        message.actionPriorityChange[i] = $root.message.behaviour.Subsumption.ActionPriorites.fromObject(object.actionPriorityChange[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a Subsumption message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.Subsumption.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Subsumption} Subsumption
             */
            Subsumption.from = Subsumption.fromObject;

            /**
             * Creates a plain object from a Subsumption message. Also converts values to other types if specified.
             * @param {message.behaviour.Subsumption} message Subsumption
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Subsumption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.actionRegister = [];
                    object.actionStateChange = [];
                    object.actionPriorityChange = [];
                }
                if (message.actionRegister && message.actionRegister.length) {
                    object.actionRegister = [];
                    for (var j = 0; j < message.actionRegister.length; ++j)
                        object.actionRegister[j] = $root.message.behaviour.Subsumption.ActionRegister.toObject(message.actionRegister[j], options);
                }
                if (message.actionStateChange && message.actionStateChange.length) {
                    object.actionStateChange = [];
                    for (var j = 0; j < message.actionStateChange.length; ++j)
                        object.actionStateChange[j] = $root.message.behaviour.Subsumption.ActionStateChange.toObject(message.actionStateChange[j], options);
                }
                if (message.actionPriorityChange && message.actionPriorityChange.length) {
                    object.actionPriorityChange = [];
                    for (var j = 0; j < message.actionPriorityChange.length; ++j)
                        object.actionPriorityChange[j] = $root.message.behaviour.Subsumption.ActionPriorites.toObject(message.actionPriorityChange[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this Subsumption message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Subsumption.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Subsumption to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Subsumption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Subsumption.LimbSet = (function() {

                /**
                 * Properties of a LimbSet.
                 * @typedef message.behaviour.Subsumption.LimbSet$Properties
                 * @type {Object}
                 * @property {number} [priority] LimbSet priority.
                 * @property {Array.<number>} [limbs] LimbSet limbs.
                 */

                /**
                 * Constructs a new LimbSet.
                 * @exports message.behaviour.Subsumption.LimbSet
                 * @constructor
                 * @param {message.behaviour.Subsumption.LimbSet$Properties=} [properties] Properties to set
                 */
                function LimbSet(properties) {
                    this.limbs = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LimbSet priority.
                 * @type {number}
                 */
                LimbSet.prototype.priority = 0;

                /**
                 * LimbSet limbs.
                 * @type {Array.<number>}
                 */
                LimbSet.prototype.limbs = $util.emptyArray;

                /**
                 * Creates a new LimbSet instance using the specified properties.
                 * @param {message.behaviour.Subsumption.LimbSet$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Subsumption.LimbSet} LimbSet instance
                 */
                LimbSet.create = function create(properties) {
                    return new LimbSet(properties);
                };

                /**
                 * Encodes the specified LimbSet message. Does not implicitly {@link message.behaviour.Subsumption.LimbSet.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.LimbSet$Properties} message LimbSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LimbSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.priority != null && message.hasOwnProperty("priority"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.priority);
                    if (message.limbs != null && message.limbs.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.limbs.length; ++i)
                            writer.uint32(message.limbs[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified LimbSet message, length delimited. Does not implicitly {@link message.behaviour.Subsumption.LimbSet.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.LimbSet$Properties} message LimbSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LimbSet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LimbSet message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Subsumption.LimbSet} LimbSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LimbSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Subsumption.LimbSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.priority = reader.float();
                            break;
                        case 2:
                            if (!(message.limbs && message.limbs.length))
                                message.limbs = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.limbs.push(reader.uint32());
                            } else
                                message.limbs.push(reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LimbSet message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Subsumption.LimbSet} LimbSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LimbSet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LimbSet message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                LimbSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.priority != null && message.hasOwnProperty("priority"))
                        if (typeof message.priority !== "number")
                            return "priority: number expected";
                    if (message.limbs != null && message.hasOwnProperty("limbs")) {
                        if (!Array.isArray(message.limbs))
                            return "limbs: array expected";
                        for (var i = 0; i < message.limbs.length; ++i)
                            if (!$util.isInteger(message.limbs[i]))
                                return "limbs: integer[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a LimbSet message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.LimbSet} LimbSet
                 */
                LimbSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.behaviour.Subsumption.LimbSet)
                        return object;
                    var message = new $root.message.behaviour.Subsumption.LimbSet();
                    if (object.priority != null)
                        message.priority = Number(object.priority);
                    if (object.limbs) {
                        if (!Array.isArray(object.limbs))
                            throw TypeError(".message.behaviour.Subsumption.LimbSet.limbs: array expected");
                        message.limbs = [];
                        for (var i = 0; i < object.limbs.length; ++i)
                            message.limbs[i] = object.limbs[i] >>> 0;
                    }
                    return message;
                };

                /**
                 * Creates a LimbSet message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Subsumption.LimbSet.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.LimbSet} LimbSet
                 */
                LimbSet.from = LimbSet.fromObject;

                /**
                 * Creates a plain object from a LimbSet message. Also converts values to other types if specified.
                 * @param {message.behaviour.Subsumption.LimbSet} message LimbSet
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LimbSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.limbs = [];
                    if (options.defaults)
                        object.priority = 0;
                    if (message.priority != null && message.hasOwnProperty("priority"))
                        object.priority = message.priority;
                    if (message.limbs && message.limbs.length) {
                        object.limbs = [];
                        for (var j = 0; j < message.limbs.length; ++j)
                            object.limbs[j] = message.limbs[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this LimbSet message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LimbSet.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this LimbSet to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                LimbSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LimbSet;
            })();

            Subsumption.ActionRegister = (function() {

                /**
                 * Properties of an ActionRegister.
                 * @typedef message.behaviour.Subsumption.ActionRegister$Properties
                 * @type {Object}
                 * @property {number} [id] ActionRegister id.
                 * @property {string} [name] ActionRegister name.
                 * @property {Array.<message.behaviour.Subsumption.LimbSet$Properties>} [limbSet] ActionRegister limbSet.
                 */

                /**
                 * Constructs a new ActionRegister.
                 * @exports message.behaviour.Subsumption.ActionRegister
                 * @constructor
                 * @param {message.behaviour.Subsumption.ActionRegister$Properties=} [properties] Properties to set
                 */
                function ActionRegister(properties) {
                    this.limbSet = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ActionRegister id.
                 * @type {number}
                 */
                ActionRegister.prototype.id = 0;

                /**
                 * ActionRegister name.
                 * @type {string}
                 */
                ActionRegister.prototype.name = "";

                /**
                 * ActionRegister limbSet.
                 * @type {Array.<message.behaviour.Subsumption.LimbSet$Properties>}
                 */
                ActionRegister.prototype.limbSet = $util.emptyArray;

                /**
                 * Creates a new ActionRegister instance using the specified properties.
                 * @param {message.behaviour.Subsumption.ActionRegister$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Subsumption.ActionRegister} ActionRegister instance
                 */
                ActionRegister.create = function create(properties) {
                    return new ActionRegister(properties);
                };

                /**
                 * Encodes the specified ActionRegister message. Does not implicitly {@link message.behaviour.Subsumption.ActionRegister.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.ActionRegister$Properties} message ActionRegister message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActionRegister.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.limbSet != null && message.limbSet.length)
                        for (var i = 0; i < message.limbSet.length; ++i)
                            $root.message.behaviour.Subsumption.LimbSet.encode(message.limbSet[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ActionRegister message, length delimited. Does not implicitly {@link message.behaviour.Subsumption.ActionRegister.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.ActionRegister$Properties} message ActionRegister message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActionRegister.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ActionRegister message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Subsumption.ActionRegister} ActionRegister
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActionRegister.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Subsumption.ActionRegister();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            if (!(message.limbSet && message.limbSet.length))
                                message.limbSet = [];
                            message.limbSet.push($root.message.behaviour.Subsumption.LimbSet.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ActionRegister message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Subsumption.ActionRegister} ActionRegister
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActionRegister.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ActionRegister message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ActionRegister.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.limbSet != null && message.hasOwnProperty("limbSet")) {
                        if (!Array.isArray(message.limbSet))
                            return "limbSet: array expected";
                        for (var i = 0; i < message.limbSet.length; ++i) {
                            var error = $root.message.behaviour.Subsumption.LimbSet.verify(message.limbSet[i]);
                            if (error)
                                return "limbSet." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an ActionRegister message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.ActionRegister} ActionRegister
                 */
                ActionRegister.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.behaviour.Subsumption.ActionRegister)
                        return object;
                    var message = new $root.message.behaviour.Subsumption.ActionRegister();
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.limbSet) {
                        if (!Array.isArray(object.limbSet))
                            throw TypeError(".message.behaviour.Subsumption.ActionRegister.limbSet: array expected");
                        message.limbSet = [];
                        for (var i = 0; i < object.limbSet.length; ++i) {
                            if (typeof object.limbSet[i] !== "object")
                                throw TypeError(".message.behaviour.Subsumption.ActionRegister.limbSet: object expected");
                            message.limbSet[i] = $root.message.behaviour.Subsumption.LimbSet.fromObject(object.limbSet[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates an ActionRegister message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Subsumption.ActionRegister.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.ActionRegister} ActionRegister
                 */
                ActionRegister.from = ActionRegister.fromObject;

                /**
                 * Creates a plain object from an ActionRegister message. Also converts values to other types if specified.
                 * @param {message.behaviour.Subsumption.ActionRegister} message ActionRegister
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActionRegister.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.limbSet = [];
                    if (options.defaults) {
                        object.id = 0;
                        object.name = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.limbSet && message.limbSet.length) {
                        object.limbSet = [];
                        for (var j = 0; j < message.limbSet.length; ++j)
                            object.limbSet[j] = $root.message.behaviour.Subsumption.LimbSet.toObject(message.limbSet[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this ActionRegister message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActionRegister.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ActionRegister to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ActionRegister.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ActionRegister;
            })();

            Subsumption.ActionStateChange = (function() {

                /**
                 * Properties of an ActionStateChange.
                 * @typedef message.behaviour.Subsumption.ActionStateChange$Properties
                 * @type {Object}
                 * @property {message.behaviour.Subsumption.ActionStateChange.State} [state] ActionStateChange state.
                 * @property {string} [name] ActionStateChange name.
                 * @property {Array.<number>} [limbs] ActionStateChange limbs.
                 */

                /**
                 * Constructs a new ActionStateChange.
                 * @exports message.behaviour.Subsumption.ActionStateChange
                 * @constructor
                 * @param {message.behaviour.Subsumption.ActionStateChange$Properties=} [properties] Properties to set
                 */
                function ActionStateChange(properties) {
                    this.limbs = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ActionStateChange state.
                 * @type {message.behaviour.Subsumption.ActionStateChange.State}
                 */
                ActionStateChange.prototype.state = 0;

                /**
                 * ActionStateChange name.
                 * @type {string}
                 */
                ActionStateChange.prototype.name = "";

                /**
                 * ActionStateChange limbs.
                 * @type {Array.<number>}
                 */
                ActionStateChange.prototype.limbs = $util.emptyArray;

                /**
                 * Creates a new ActionStateChange instance using the specified properties.
                 * @param {message.behaviour.Subsumption.ActionStateChange$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Subsumption.ActionStateChange} ActionStateChange instance
                 */
                ActionStateChange.create = function create(properties) {
                    return new ActionStateChange(properties);
                };

                /**
                 * Encodes the specified ActionStateChange message. Does not implicitly {@link message.behaviour.Subsumption.ActionStateChange.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.ActionStateChange$Properties} message ActionStateChange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActionStateChange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.state != null && message.hasOwnProperty("state"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.state);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.limbs != null && message.limbs.length) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork();
                        for (var i = 0; i < message.limbs.length; ++i)
                            writer.uint32(message.limbs[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified ActionStateChange message, length delimited. Does not implicitly {@link message.behaviour.Subsumption.ActionStateChange.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.ActionStateChange$Properties} message ActionStateChange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActionStateChange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ActionStateChange message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Subsumption.ActionStateChange} ActionStateChange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActionStateChange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Subsumption.ActionStateChange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.state = reader.uint32();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            if (!(message.limbs && message.limbs.length))
                                message.limbs = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.limbs.push(reader.uint32());
                            } else
                                message.limbs.push(reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ActionStateChange message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Subsumption.ActionStateChange} ActionStateChange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActionStateChange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ActionStateChange message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ActionStateChange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.limbs != null && message.hasOwnProperty("limbs")) {
                        if (!Array.isArray(message.limbs))
                            return "limbs: array expected";
                        for (var i = 0; i < message.limbs.length; ++i)
                            if (!$util.isInteger(message.limbs[i]))
                                return "limbs: integer[] expected";
                    }
                    return null;
                };

                /**
                 * Creates an ActionStateChange message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.ActionStateChange} ActionStateChange
                 */
                ActionStateChange.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.behaviour.Subsumption.ActionStateChange)
                        return object;
                    var message = new $root.message.behaviour.Subsumption.ActionStateChange();
                    switch (object.state) {
                    case "UNKNOWN":
                    case 0:
                        message.state = 0;
                        break;
                    case "START":
                    case 1:
                        message.state = 1;
                        break;
                    case "KILL":
                    case 2:
                        message.state = 2;
                        break;
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.limbs) {
                        if (!Array.isArray(object.limbs))
                            throw TypeError(".message.behaviour.Subsumption.ActionStateChange.limbs: array expected");
                        message.limbs = [];
                        for (var i = 0; i < object.limbs.length; ++i)
                            message.limbs[i] = object.limbs[i] >>> 0;
                    }
                    return message;
                };

                /**
                 * Creates an ActionStateChange message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Subsumption.ActionStateChange.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.ActionStateChange} ActionStateChange
                 */
                ActionStateChange.from = ActionStateChange.fromObject;

                /**
                 * Creates a plain object from an ActionStateChange message. Also converts values to other types if specified.
                 * @param {message.behaviour.Subsumption.ActionStateChange} message ActionStateChange
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActionStateChange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.limbs = [];
                    if (options.defaults) {
                        object.state = options.enums === String ? "UNKNOWN" : 0;
                        object.name = "";
                    }
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = options.enums === String ? $root.message.behaviour.Subsumption.ActionStateChange.State[message.state] : message.state;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.limbs && message.limbs.length) {
                        object.limbs = [];
                        for (var j = 0; j < message.limbs.length; ++j)
                            object.limbs[j] = message.limbs[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this ActionStateChange message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActionStateChange.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ActionStateChange to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ActionStateChange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * State enum.
                 * @name State
                 * @memberof message.behaviour.Subsumption.ActionStateChange
                 * @enum {number}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} START=1 START value
                 * @property {number} KILL=2 KILL value
                 */
                ActionStateChange.State = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "START"] = 1;
                    values[valuesById[2] = "KILL"] = 2;
                    return values;
                })();

                return ActionStateChange;
            })();

            Subsumption.ActionPriorites = (function() {

                /**
                 * Properties of an ActionPriorites.
                 * @typedef message.behaviour.Subsumption.ActionPriorites$Properties
                 * @type {Object}
                 * @property {number} [id] ActionPriorites id.
                 * @property {Array.<number>} [priorities] ActionPriorites priorities.
                 */

                /**
                 * Constructs a new ActionPriorites.
                 * @exports message.behaviour.Subsumption.ActionPriorites
                 * @constructor
                 * @param {message.behaviour.Subsumption.ActionPriorites$Properties=} [properties] Properties to set
                 */
                function ActionPriorites(properties) {
                    this.priorities = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ActionPriorites id.
                 * @type {number}
                 */
                ActionPriorites.prototype.id = 0;

                /**
                 * ActionPriorites priorities.
                 * @type {Array.<number>}
                 */
                ActionPriorites.prototype.priorities = $util.emptyArray;

                /**
                 * Creates a new ActionPriorites instance using the specified properties.
                 * @param {message.behaviour.Subsumption.ActionPriorites$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Subsumption.ActionPriorites} ActionPriorites instance
                 */
                ActionPriorites.create = function create(properties) {
                    return new ActionPriorites(properties);
                };

                /**
                 * Encodes the specified ActionPriorites message. Does not implicitly {@link message.behaviour.Subsumption.ActionPriorites.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.ActionPriorites$Properties} message ActionPriorites message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActionPriorites.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.priorities != null && message.priorities.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.priorities.length; ++i)
                            writer.float(message.priorities[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified ActionPriorites message, length delimited. Does not implicitly {@link message.behaviour.Subsumption.ActionPriorites.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.ActionPriorites$Properties} message ActionPriorites message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActionPriorites.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ActionPriorites message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Subsumption.ActionPriorites} ActionPriorites
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActionPriorites.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.Subsumption.ActionPriorites();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            if (!(message.priorities && message.priorities.length))
                                message.priorities = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.priorities.push(reader.float());
                            } else
                                message.priorities.push(reader.float());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ActionPriorites message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Subsumption.ActionPriorites} ActionPriorites
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActionPriorites.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ActionPriorites message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ActionPriorites.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.priorities != null && message.hasOwnProperty("priorities")) {
                        if (!Array.isArray(message.priorities))
                            return "priorities: array expected";
                        for (var i = 0; i < message.priorities.length; ++i)
                            if (typeof message.priorities[i] !== "number")
                                return "priorities: number[] expected";
                    }
                    return null;
                };

                /**
                 * Creates an ActionPriorites message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.ActionPriorites} ActionPriorites
                 */
                ActionPriorites.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.behaviour.Subsumption.ActionPriorites)
                        return object;
                    var message = new $root.message.behaviour.Subsumption.ActionPriorites();
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.priorities) {
                        if (!Array.isArray(object.priorities))
                            throw TypeError(".message.behaviour.Subsumption.ActionPriorites.priorities: array expected");
                        message.priorities = [];
                        for (var i = 0; i < object.priorities.length; ++i)
                            message.priorities[i] = Number(object.priorities[i]);
                    }
                    return message;
                };

                /**
                 * Creates an ActionPriorites message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Subsumption.ActionPriorites.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.ActionPriorites} ActionPriorites
                 */
                ActionPriorites.from = ActionPriorites.fromObject;

                /**
                 * Creates a plain object from an ActionPriorites message. Also converts values to other types if specified.
                 * @param {message.behaviour.Subsumption.ActionPriorites} message ActionPriorites
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActionPriorites.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.priorities = [];
                    if (options.defaults)
                        object.id = 0;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.priorities && message.priorities.length) {
                        object.priorities = [];
                        for (var j = 0; j < message.priorities.length; ++j)
                            object.priorities[j] = message.priorities[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this ActionPriorites message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActionPriorites.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ActionPriorites to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ActionPriorites.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ActionPriorites;
            })();

            return Subsumption;
        })();

        behaviour.WalkPath = (function() {

            /**
             * Properties of a WalkPath.
             * @typedef message.behaviour.WalkPath$Properties
             * @type {Object}
             * @property {Array.<vec3$Properties>} [states] WalkPath states.
             * @property {vec3$Properties} [ballSpace] WalkPath ballSpace.
             * @property {vec3$Properties} [start] WalkPath start.
             * @property {vec3$Properties} [goal] WalkPath goal.
             * @property {message.behaviour.MotionCommand$Properties} [command] WalkPath command.
             */

            /**
             * Constructs a new WalkPath.
             * @exports message.behaviour.WalkPath
             * @constructor
             * @param {message.behaviour.WalkPath$Properties=} [properties] Properties to set
             */
            function WalkPath(properties) {
                this.states = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WalkPath states.
             * @type {Array.<vec3$Properties>}
             */
            WalkPath.prototype.states = $util.emptyArray;

            /**
             * WalkPath ballSpace.
             * @type {(vec3$Properties|null)}
             */
            WalkPath.prototype.ballSpace = null;

            /**
             * WalkPath start.
             * @type {(vec3$Properties|null)}
             */
            WalkPath.prototype.start = null;

            /**
             * WalkPath goal.
             * @type {(vec3$Properties|null)}
             */
            WalkPath.prototype.goal = null;

            /**
             * WalkPath command.
             * @type {(message.behaviour.MotionCommand$Properties|null)}
             */
            WalkPath.prototype.command = null;

            /**
             * Creates a new WalkPath instance using the specified properties.
             * @param {message.behaviour.WalkPath$Properties=} [properties] Properties to set
             * @returns {message.behaviour.WalkPath} WalkPath instance
             */
            WalkPath.create = function create(properties) {
                return new WalkPath(properties);
            };

            /**
             * Encodes the specified WalkPath message. Does not implicitly {@link message.behaviour.WalkPath.verify|verify} messages.
             * @param {message.behaviour.WalkPath$Properties} message WalkPath message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkPath.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.states != null && message.states.length)
                    for (var i = 0; i < message.states.length; ++i)
                        $root.vec3.encode(message.states[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.ballSpace != null && message.hasOwnProperty("ballSpace"))
                    $root.vec3.encode(message.ballSpace, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.start != null && message.hasOwnProperty("start"))
                    $root.vec3.encode(message.start, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.goal != null && message.hasOwnProperty("goal"))
                    $root.vec3.encode(message.goal, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.command != null && message.hasOwnProperty("command"))
                    $root.message.behaviour.MotionCommand.encode(message.command, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WalkPath message, length delimited. Does not implicitly {@link message.behaviour.WalkPath.verify|verify} messages.
             * @param {message.behaviour.WalkPath$Properties} message WalkPath message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkPath.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WalkPath message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.WalkPath} WalkPath
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkPath.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.behaviour.WalkPath();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.states && message.states.length))
                            message.states = [];
                        message.states.push($root.vec3.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.ballSpace = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.start = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.goal = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.command = $root.message.behaviour.MotionCommand.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WalkPath message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.WalkPath} WalkPath
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkPath.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WalkPath message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            WalkPath.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.states != null && message.hasOwnProperty("states")) {
                    if (!Array.isArray(message.states))
                        return "states: array expected";
                    for (var i = 0; i < message.states.length; ++i) {
                        var error = $root.vec3.verify(message.states[i]);
                        if (error)
                            return "states." + error;
                    }
                }
                if (message.ballSpace != null && message.hasOwnProperty("ballSpace")) {
                    var error = $root.vec3.verify(message.ballSpace);
                    if (error)
                        return "ballSpace." + error;
                }
                if (message.start != null && message.hasOwnProperty("start")) {
                    var error = $root.vec3.verify(message.start);
                    if (error)
                        return "start." + error;
                }
                if (message.goal != null && message.hasOwnProperty("goal")) {
                    var error = $root.vec3.verify(message.goal);
                    if (error)
                        return "goal." + error;
                }
                if (message.command != null && message.hasOwnProperty("command")) {
                    var error = $root.message.behaviour.MotionCommand.verify(message.command);
                    if (error)
                        return "command." + error;
                }
                return null;
            };

            /**
             * Creates a WalkPath message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WalkPath} WalkPath
             */
            WalkPath.fromObject = function fromObject(object) {
                if (object instanceof $root.message.behaviour.WalkPath)
                    return object;
                var message = new $root.message.behaviour.WalkPath();
                if (object.states) {
                    if (!Array.isArray(object.states))
                        throw TypeError(".message.behaviour.WalkPath.states: array expected");
                    message.states = [];
                    for (var i = 0; i < object.states.length; ++i) {
                        if (typeof object.states[i] !== "object")
                            throw TypeError(".message.behaviour.WalkPath.states: object expected");
                        message.states[i] = $root.vec3.fromObject(object.states[i]);
                    }
                }
                if (object.ballSpace != null) {
                    if (typeof object.ballSpace !== "object")
                        throw TypeError(".message.behaviour.WalkPath.ballSpace: object expected");
                    message.ballSpace = $root.vec3.fromObject(object.ballSpace);
                }
                if (object.start != null) {
                    if (typeof object.start !== "object")
                        throw TypeError(".message.behaviour.WalkPath.start: object expected");
                    message.start = $root.vec3.fromObject(object.start);
                }
                if (object.goal != null) {
                    if (typeof object.goal !== "object")
                        throw TypeError(".message.behaviour.WalkPath.goal: object expected");
                    message.goal = $root.vec3.fromObject(object.goal);
                }
                if (object.command != null) {
                    if (typeof object.command !== "object")
                        throw TypeError(".message.behaviour.WalkPath.command: object expected");
                    message.command = $root.message.behaviour.MotionCommand.fromObject(object.command);
                }
                return message;
            };

            /**
             * Creates a WalkPath message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.WalkPath.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WalkPath} WalkPath
             */
            WalkPath.from = WalkPath.fromObject;

            /**
             * Creates a plain object from a WalkPath message. Also converts values to other types if specified.
             * @param {message.behaviour.WalkPath} message WalkPath
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkPath.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.states = [];
                if (options.defaults) {
                    object.ballSpace = null;
                    object.start = null;
                    object.goal = null;
                    object.command = null;
                }
                if (message.states && message.states.length) {
                    object.states = [];
                    for (var j = 0; j < message.states.length; ++j)
                        object.states[j] = $root.vec3.toObject(message.states[j], options);
                }
                if (message.ballSpace != null && message.hasOwnProperty("ballSpace"))
                    object.ballSpace = $root.vec3.toObject(message.ballSpace, options);
                if (message.start != null && message.hasOwnProperty("start"))
                    object.start = $root.vec3.toObject(message.start, options);
                if (message.goal != null && message.hasOwnProperty("goal"))
                    object.goal = $root.vec3.toObject(message.goal, options);
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = $root.message.behaviour.MotionCommand.toObject(message.command, options);
                return object;
            };

            /**
             * Creates a plain object from this WalkPath message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkPath.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this WalkPath to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            WalkPath.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WalkPath;
        })();

        return behaviour;
    })();

    message.Line = (function() {

        /**
         * Properties of a Line.
         * @typedef message.Line$Properties
         * @type {Object}
         * @property {vec2$Properties} [normal] Line normal.
         * @property {number} [distance] Line distance.
         */

        /**
         * Constructs a new Line.
         * @exports message.Line
         * @constructor
         * @param {message.Line$Properties=} [properties] Properties to set
         */
        function Line(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Line normal.
         * @type {(vec2$Properties|null)}
         */
        Line.prototype.normal = null;

        /**
         * Line distance.
         * @type {number}
         */
        Line.prototype.distance = 0;

        /**
         * Creates a new Line instance using the specified properties.
         * @param {message.Line$Properties=} [properties] Properties to set
         * @returns {message.Line} Line instance
         */
        Line.create = function create(properties) {
            return new Line(properties);
        };

        /**
         * Encodes the specified Line message. Does not implicitly {@link message.Line.verify|verify} messages.
         * @param {message.Line$Properties} message Line message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Line.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.normal != null && message.hasOwnProperty("normal"))
                $root.vec2.encode(message.normal, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.distance != null && message.hasOwnProperty("distance"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.distance);
            return writer;
        };

        /**
         * Encodes the specified Line message, length delimited. Does not implicitly {@link message.Line.verify|verify} messages.
         * @param {message.Line$Properties} message Line message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Line.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Line message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Line} Line
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Line.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.Line();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.normal = $root.vec2.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.distance = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Line message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {message.Line} Line
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Line.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Line message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        Line.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.normal != null && message.hasOwnProperty("normal")) {
                var error = $root.vec2.verify(message.normal);
                if (error)
                    return "normal." + error;
            }
            if (message.distance != null && message.hasOwnProperty("distance"))
                if (typeof message.distance !== "number")
                    return "distance: number expected";
            return null;
        };

        /**
         * Creates a Line message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Line} Line
         */
        Line.fromObject = function fromObject(object) {
            if (object instanceof $root.message.Line)
                return object;
            var message = new $root.message.Line();
            if (object.normal != null) {
                if (typeof object.normal !== "object")
                    throw TypeError(".message.Line.normal: object expected");
                message.normal = $root.vec2.fromObject(object.normal);
            }
            if (object.distance != null)
                message.distance = Number(object.distance);
            return message;
        };

        /**
         * Creates a Line message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link message.Line.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Line} Line
         */
        Line.from = Line.fromObject;

        /**
         * Creates a plain object from a Line message. Also converts values to other types if specified.
         * @param {message.Line} message Line
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Line.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.normal = null;
                object.distance = 0;
            }
            if (message.normal != null && message.hasOwnProperty("normal"))
                object.normal = $root.vec2.toObject(message.normal, options);
            if (message.distance != null && message.hasOwnProperty("distance"))
                object.distance = message.distance;
            return object;
        };

        /**
         * Creates a plain object from this Line message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Line.prototype.toObject = function toObject(options) {
            return this.constructor.toObject(this, options);
        };

        /**
         * Converts this Line to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        Line.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Line;
    })();

    message.Circle = (function() {

        /**
         * Properties of a Circle.
         * @typedef message.Circle$Properties
         * @type {Object}
         * @property {number} [radius] Circle radius.
         * @property {vec2$Properties} [centre] Circle centre.
         */

        /**
         * Constructs a new Circle.
         * @exports message.Circle
         * @constructor
         * @param {message.Circle$Properties=} [properties] Properties to set
         */
        function Circle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Circle radius.
         * @type {number}
         */
        Circle.prototype.radius = 0;

        /**
         * Circle centre.
         * @type {(vec2$Properties|null)}
         */
        Circle.prototype.centre = null;

        /**
         * Creates a new Circle instance using the specified properties.
         * @param {message.Circle$Properties=} [properties] Properties to set
         * @returns {message.Circle} Circle instance
         */
        Circle.create = function create(properties) {
            return new Circle(properties);
        };

        /**
         * Encodes the specified Circle message. Does not implicitly {@link message.Circle.verify|verify} messages.
         * @param {message.Circle$Properties} message Circle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Circle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.radius != null && message.hasOwnProperty("radius"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.radius);
            if (message.centre != null && message.hasOwnProperty("centre"))
                $root.vec2.encode(message.centre, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Circle message, length delimited. Does not implicitly {@link message.Circle.verify|verify} messages.
         * @param {message.Circle$Properties} message Circle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Circle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Circle message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Circle} Circle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Circle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.Circle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.radius = reader.double();
                    break;
                case 2:
                    message.centre = $root.vec2.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Circle message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {message.Circle} Circle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Circle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Circle message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        Circle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.radius != null && message.hasOwnProperty("radius"))
                if (typeof message.radius !== "number")
                    return "radius: number expected";
            if (message.centre != null && message.hasOwnProperty("centre")) {
                var error = $root.vec2.verify(message.centre);
                if (error)
                    return "centre." + error;
            }
            return null;
        };

        /**
         * Creates a Circle message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Circle} Circle
         */
        Circle.fromObject = function fromObject(object) {
            if (object instanceof $root.message.Circle)
                return object;
            var message = new $root.message.Circle();
            if (object.radius != null)
                message.radius = Number(object.radius);
            if (object.centre != null) {
                if (typeof object.centre !== "object")
                    throw TypeError(".message.Circle.centre: object expected");
                message.centre = $root.vec2.fromObject(object.centre);
            }
            return message;
        };

        /**
         * Creates a Circle message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link message.Circle.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Circle} Circle
         */
        Circle.from = Circle.fromObject;

        /**
         * Creates a plain object from a Circle message. Also converts values to other types if specified.
         * @param {message.Circle} message Circle
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Circle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.radius = 0;
                object.centre = null;
            }
            if (message.radius != null && message.hasOwnProperty("radius"))
                object.radius = message.radius;
            if (message.centre != null && message.hasOwnProperty("centre"))
                object.centre = $root.vec2.toObject(message.centre, options);
            return object;
        };

        /**
         * Creates a plain object from this Circle message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Circle.prototype.toObject = function toObject(options) {
            return this.constructor.toObject(this, options);
        };

        /**
         * Converts this Circle to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        Circle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Circle;
    })();

    message.Ellipse = (function() {

        /**
         * Properties of an Ellipse.
         * @typedef message.Ellipse$Properties
         * @type {Object}
         * @property {mat33$Properties} [ellipse] Ellipse ellipse.
         */

        /**
         * Constructs a new Ellipse.
         * @exports message.Ellipse
         * @constructor
         * @param {message.Ellipse$Properties=} [properties] Properties to set
         */
        function Ellipse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Ellipse ellipse.
         * @type {(mat33$Properties|null)}
         */
        Ellipse.prototype.ellipse = null;

        /**
         * Creates a new Ellipse instance using the specified properties.
         * @param {message.Ellipse$Properties=} [properties] Properties to set
         * @returns {message.Ellipse} Ellipse instance
         */
        Ellipse.create = function create(properties) {
            return new Ellipse(properties);
        };

        /**
         * Encodes the specified Ellipse message. Does not implicitly {@link message.Ellipse.verify|verify} messages.
         * @param {message.Ellipse$Properties} message Ellipse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ellipse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ellipse != null && message.hasOwnProperty("ellipse"))
                $root.mat33.encode(message.ellipse, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Ellipse message, length delimited. Does not implicitly {@link message.Ellipse.verify|verify} messages.
         * @param {message.Ellipse$Properties} message Ellipse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ellipse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Ellipse message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Ellipse} Ellipse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ellipse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.Ellipse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ellipse = $root.mat33.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Ellipse message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {message.Ellipse} Ellipse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ellipse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Ellipse message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        Ellipse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ellipse != null && message.hasOwnProperty("ellipse")) {
                var error = $root.mat33.verify(message.ellipse);
                if (error)
                    return "ellipse." + error;
            }
            return null;
        };

        /**
         * Creates an Ellipse message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Ellipse} Ellipse
         */
        Ellipse.fromObject = function fromObject(object) {
            if (object instanceof $root.message.Ellipse)
                return object;
            var message = new $root.message.Ellipse();
            if (object.ellipse != null) {
                if (typeof object.ellipse !== "object")
                    throw TypeError(".message.Ellipse.ellipse: object expected");
                message.ellipse = $root.mat33.fromObject(object.ellipse);
            }
            return message;
        };

        /**
         * Creates an Ellipse message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link message.Ellipse.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Ellipse} Ellipse
         */
        Ellipse.from = Ellipse.fromObject;

        /**
         * Creates a plain object from an Ellipse message. Also converts values to other types if specified.
         * @param {message.Ellipse} message Ellipse
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ellipse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.ellipse = null;
            if (message.ellipse != null && message.hasOwnProperty("ellipse"))
                object.ellipse = $root.mat33.toObject(message.ellipse, options);
            return object;
        };

        /**
         * Creates a plain object from this Ellipse message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ellipse.prototype.toObject = function toObject(options) {
            return this.constructor.toObject(this, options);
        };

        /**
         * Converts this Ellipse to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        Ellipse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Ellipse;
    })();

    message.Quad = (function() {

        /**
         * Properties of a Quad.
         * @typedef message.Quad$Properties
         * @type {Object}
         * @property {vec2$Properties} [tl] Quad tl.
         * @property {vec2$Properties} [tr] Quad tr.
         * @property {vec2$Properties} [bl] Quad bl.
         * @property {vec2$Properties} [br] Quad br.
         */

        /**
         * Constructs a new Quad.
         * @exports message.Quad
         * @constructor
         * @param {message.Quad$Properties=} [properties] Properties to set
         */
        function Quad(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Quad tl.
         * @type {(vec2$Properties|null)}
         */
        Quad.prototype.tl = null;

        /**
         * Quad tr.
         * @type {(vec2$Properties|null)}
         */
        Quad.prototype.tr = null;

        /**
         * Quad bl.
         * @type {(vec2$Properties|null)}
         */
        Quad.prototype.bl = null;

        /**
         * Quad br.
         * @type {(vec2$Properties|null)}
         */
        Quad.prototype.br = null;

        /**
         * Creates a new Quad instance using the specified properties.
         * @param {message.Quad$Properties=} [properties] Properties to set
         * @returns {message.Quad} Quad instance
         */
        Quad.create = function create(properties) {
            return new Quad(properties);
        };

        /**
         * Encodes the specified Quad message. Does not implicitly {@link message.Quad.verify|verify} messages.
         * @param {message.Quad$Properties} message Quad message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Quad.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tl != null && message.hasOwnProperty("tl"))
                $root.vec2.encode(message.tl, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.tr != null && message.hasOwnProperty("tr"))
                $root.vec2.encode(message.tr, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.bl != null && message.hasOwnProperty("bl"))
                $root.vec2.encode(message.bl, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.br != null && message.hasOwnProperty("br"))
                $root.vec2.encode(message.br, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Quad message, length delimited. Does not implicitly {@link message.Quad.verify|verify} messages.
         * @param {message.Quad$Properties} message Quad message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Quad.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Quad message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Quad} Quad
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Quad.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.Quad();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tl = $root.vec2.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.tr = $root.vec2.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.bl = $root.vec2.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.br = $root.vec2.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Quad message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {message.Quad} Quad
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Quad.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Quad message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        Quad.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tl != null && message.hasOwnProperty("tl")) {
                var error = $root.vec2.verify(message.tl);
                if (error)
                    return "tl." + error;
            }
            if (message.tr != null && message.hasOwnProperty("tr")) {
                var error = $root.vec2.verify(message.tr);
                if (error)
                    return "tr." + error;
            }
            if (message.bl != null && message.hasOwnProperty("bl")) {
                var error = $root.vec2.verify(message.bl);
                if (error)
                    return "bl." + error;
            }
            if (message.br != null && message.hasOwnProperty("br")) {
                var error = $root.vec2.verify(message.br);
                if (error)
                    return "br." + error;
            }
            return null;
        };

        /**
         * Creates a Quad message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Quad} Quad
         */
        Quad.fromObject = function fromObject(object) {
            if (object instanceof $root.message.Quad)
                return object;
            var message = new $root.message.Quad();
            if (object.tl != null) {
                if (typeof object.tl !== "object")
                    throw TypeError(".message.Quad.tl: object expected");
                message.tl = $root.vec2.fromObject(object.tl);
            }
            if (object.tr != null) {
                if (typeof object.tr !== "object")
                    throw TypeError(".message.Quad.tr: object expected");
                message.tr = $root.vec2.fromObject(object.tr);
            }
            if (object.bl != null) {
                if (typeof object.bl !== "object")
                    throw TypeError(".message.Quad.bl: object expected");
                message.bl = $root.vec2.fromObject(object.bl);
            }
            if (object.br != null) {
                if (typeof object.br !== "object")
                    throw TypeError(".message.Quad.br: object expected");
                message.br = $root.vec2.fromObject(object.br);
            }
            return message;
        };

        /**
         * Creates a Quad message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link message.Quad.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Quad} Quad
         */
        Quad.from = Quad.fromObject;

        /**
         * Creates a plain object from a Quad message. Also converts values to other types if specified.
         * @param {message.Quad} message Quad
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Quad.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tl = null;
                object.tr = null;
                object.bl = null;
                object.br = null;
            }
            if (message.tl != null && message.hasOwnProperty("tl"))
                object.tl = $root.vec2.toObject(message.tl, options);
            if (message.tr != null && message.hasOwnProperty("tr"))
                object.tr = $root.vec2.toObject(message.tr, options);
            if (message.bl != null && message.hasOwnProperty("bl"))
                object.bl = $root.vec2.toObject(message.bl, options);
            if (message.br != null && message.hasOwnProperty("br"))
                object.br = $root.vec2.toObject(message.br, options);
            return object;
        };

        /**
         * Creates a plain object from this Quad message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Quad.prototype.toObject = function toObject(options) {
            return this.constructor.toObject(this, options);
        };

        /**
         * Converts this Quad to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        Quad.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Quad;
    })();

    message.Polygon = (function() {

        /**
         * Properties of a Polygon.
         * @typedef message.Polygon$Properties
         * @type {Object}
         * @property {vec2$Properties} [point] Polygon point.
         */

        /**
         * Constructs a new Polygon.
         * @exports message.Polygon
         * @constructor
         * @param {message.Polygon$Properties=} [properties] Properties to set
         */
        function Polygon(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Polygon point.
         * @type {(vec2$Properties|null)}
         */
        Polygon.prototype.point = null;

        /**
         * Creates a new Polygon instance using the specified properties.
         * @param {message.Polygon$Properties=} [properties] Properties to set
         * @returns {message.Polygon} Polygon instance
         */
        Polygon.create = function create(properties) {
            return new Polygon(properties);
        };

        /**
         * Encodes the specified Polygon message. Does not implicitly {@link message.Polygon.verify|verify} messages.
         * @param {message.Polygon$Properties} message Polygon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Polygon.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.point != null && message.hasOwnProperty("point"))
                $root.vec2.encode(message.point, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Polygon message, length delimited. Does not implicitly {@link message.Polygon.verify|verify} messages.
         * @param {message.Polygon$Properties} message Polygon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Polygon.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Polygon message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Polygon} Polygon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Polygon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.Polygon();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.point = $root.vec2.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Polygon message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {message.Polygon} Polygon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Polygon.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Polygon message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        Polygon.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.point != null && message.hasOwnProperty("point")) {
                var error = $root.vec2.verify(message.point);
                if (error)
                    return "point." + error;
            }
            return null;
        };

        /**
         * Creates a Polygon message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Polygon} Polygon
         */
        Polygon.fromObject = function fromObject(object) {
            if (object instanceof $root.message.Polygon)
                return object;
            var message = new $root.message.Polygon();
            if (object.point != null) {
                if (typeof object.point !== "object")
                    throw TypeError(".message.Polygon.point: object expected");
                message.point = $root.vec2.fromObject(object.point);
            }
            return message;
        };

        /**
         * Creates a Polygon message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link message.Polygon.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Polygon} Polygon
         */
        Polygon.from = Polygon.fromObject;

        /**
         * Creates a plain object from a Polygon message. Also converts values to other types if specified.
         * @param {message.Polygon} message Polygon
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Polygon.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.point = null;
            if (message.point != null && message.hasOwnProperty("point"))
                object.point = $root.vec2.toObject(message.point, options);
            return object;
        };

        /**
         * Creates a plain object from this Polygon message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Polygon.prototype.toObject = function toObject(options) {
            return this.constructor.toObject(this, options);
        };

        /**
         * Converts this Polygon to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        Polygon.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Polygon;
    })();

    message.input = (function() {

        /**
         * Namespace input.
         * @exports message.input
         * @namespace
         */
        var input = {};

        input.CameraParameters = (function() {

            /**
             * Properties of a CameraParameters.
             * @typedef message.input.CameraParameters$Properties
             * @type {Object}
             * @property {uvec2$Properties} [imageSizePixels] CameraParameters imageSizePixels.
             * @property {vec2$Properties} [FOV] CameraParameters FOV.
             * @property {vec2$Properties} [pixelsToTanThetaFactor] CameraParameters pixelsToTanThetaFactor.
             * @property {number} [focalLengthPixels] CameraParameters focalLengthPixels.
             * @property {number} [distortionFactor] CameraParameters distortionFactor.
             */

            /**
             * Constructs a new CameraParameters.
             * @exports message.input.CameraParameters
             * @constructor
             * @param {message.input.CameraParameters$Properties=} [properties] Properties to set
             */
            function CameraParameters(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CameraParameters imageSizePixels.
             * @type {(uvec2$Properties|null)}
             */
            CameraParameters.prototype.imageSizePixels = null;

            /**
             * CameraParameters FOV.
             * @type {(vec2$Properties|null)}
             */
            CameraParameters.prototype.FOV = null;

            /**
             * CameraParameters pixelsToTanThetaFactor.
             * @type {(vec2$Properties|null)}
             */
            CameraParameters.prototype.pixelsToTanThetaFactor = null;

            /**
             * CameraParameters focalLengthPixels.
             * @type {number}
             */
            CameraParameters.prototype.focalLengthPixels = 0;

            /**
             * CameraParameters distortionFactor.
             * @type {number}
             */
            CameraParameters.prototype.distortionFactor = 0;

            /**
             * Creates a new CameraParameters instance using the specified properties.
             * @param {message.input.CameraParameters$Properties=} [properties] Properties to set
             * @returns {message.input.CameraParameters} CameraParameters instance
             */
            CameraParameters.create = function create(properties) {
                return new CameraParameters(properties);
            };

            /**
             * Encodes the specified CameraParameters message. Does not implicitly {@link message.input.CameraParameters.verify|verify} messages.
             * @param {message.input.CameraParameters$Properties} message CameraParameters message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CameraParameters.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.imageSizePixels != null && message.hasOwnProperty("imageSizePixels"))
                    $root.uvec2.encode(message.imageSizePixels, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.FOV != null && message.hasOwnProperty("FOV"))
                    $root.vec2.encode(message.FOV, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.pixelsToTanThetaFactor != null && message.hasOwnProperty("pixelsToTanThetaFactor"))
                    $root.vec2.encode(message.pixelsToTanThetaFactor, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.focalLengthPixels != null && message.hasOwnProperty("focalLengthPixels"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.focalLengthPixels);
                if (message.distortionFactor != null && message.hasOwnProperty("distortionFactor"))
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.distortionFactor);
                return writer;
            };

            /**
             * Encodes the specified CameraParameters message, length delimited. Does not implicitly {@link message.input.CameraParameters.verify|verify} messages.
             * @param {message.input.CameraParameters$Properties} message CameraParameters message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CameraParameters.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CameraParameters message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.CameraParameters} CameraParameters
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CameraParameters.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.CameraParameters();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.imageSizePixels = $root.uvec2.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.FOV = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.pixelsToTanThetaFactor = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.focalLengthPixels = reader.double();
                        break;
                    case 5:
                        message.distortionFactor = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CameraParameters message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.CameraParameters} CameraParameters
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CameraParameters.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CameraParameters message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            CameraParameters.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.imageSizePixels != null && message.hasOwnProperty("imageSizePixels")) {
                    var error = $root.uvec2.verify(message.imageSizePixels);
                    if (error)
                        return "imageSizePixels." + error;
                }
                if (message.FOV != null && message.hasOwnProperty("FOV")) {
                    var error = $root.vec2.verify(message.FOV);
                    if (error)
                        return "FOV." + error;
                }
                if (message.pixelsToTanThetaFactor != null && message.hasOwnProperty("pixelsToTanThetaFactor")) {
                    var error = $root.vec2.verify(message.pixelsToTanThetaFactor);
                    if (error)
                        return "pixelsToTanThetaFactor." + error;
                }
                if (message.focalLengthPixels != null && message.hasOwnProperty("focalLengthPixels"))
                    if (typeof message.focalLengthPixels !== "number")
                        return "focalLengthPixels: number expected";
                if (message.distortionFactor != null && message.hasOwnProperty("distortionFactor"))
                    if (typeof message.distortionFactor !== "number")
                        return "distortionFactor: number expected";
                return null;
            };

            /**
             * Creates a CameraParameters message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.CameraParameters} CameraParameters
             */
            CameraParameters.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.CameraParameters)
                    return object;
                var message = new $root.message.input.CameraParameters();
                if (object.imageSizePixels != null) {
                    if (typeof object.imageSizePixels !== "object")
                        throw TypeError(".message.input.CameraParameters.imageSizePixels: object expected");
                    message.imageSizePixels = $root.uvec2.fromObject(object.imageSizePixels);
                }
                if (object.FOV != null) {
                    if (typeof object.FOV !== "object")
                        throw TypeError(".message.input.CameraParameters.FOV: object expected");
                    message.FOV = $root.vec2.fromObject(object.FOV);
                }
                if (object.pixelsToTanThetaFactor != null) {
                    if (typeof object.pixelsToTanThetaFactor !== "object")
                        throw TypeError(".message.input.CameraParameters.pixelsToTanThetaFactor: object expected");
                    message.pixelsToTanThetaFactor = $root.vec2.fromObject(object.pixelsToTanThetaFactor);
                }
                if (object.focalLengthPixels != null)
                    message.focalLengthPixels = Number(object.focalLengthPixels);
                if (object.distortionFactor != null)
                    message.distortionFactor = Number(object.distortionFactor);
                return message;
            };

            /**
             * Creates a CameraParameters message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.CameraParameters.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.CameraParameters} CameraParameters
             */
            CameraParameters.from = CameraParameters.fromObject;

            /**
             * Creates a plain object from a CameraParameters message. Also converts values to other types if specified.
             * @param {message.input.CameraParameters} message CameraParameters
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CameraParameters.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.imageSizePixels = null;
                    object.FOV = null;
                    object.pixelsToTanThetaFactor = null;
                    object.focalLengthPixels = 0;
                    object.distortionFactor = 0;
                }
                if (message.imageSizePixels != null && message.hasOwnProperty("imageSizePixels"))
                    object.imageSizePixels = $root.uvec2.toObject(message.imageSizePixels, options);
                if (message.FOV != null && message.hasOwnProperty("FOV"))
                    object.FOV = $root.vec2.toObject(message.FOV, options);
                if (message.pixelsToTanThetaFactor != null && message.hasOwnProperty("pixelsToTanThetaFactor"))
                    object.pixelsToTanThetaFactor = $root.vec2.toObject(message.pixelsToTanThetaFactor, options);
                if (message.focalLengthPixels != null && message.hasOwnProperty("focalLengthPixels"))
                    object.focalLengthPixels = message.focalLengthPixels;
                if (message.distortionFactor != null && message.hasOwnProperty("distortionFactor"))
                    object.distortionFactor = message.distortionFactor;
                return object;
            };

            /**
             * Creates a plain object from this CameraParameters message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CameraParameters.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this CameraParameters to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            CameraParameters.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CameraParameters;
        })();

        input.GameEvents = (function() {

            /**
             * Properties of a GameEvents.
             * @typedef message.input.GameEvents$Properties
             * @type {Object}
             */

            /**
             * Constructs a new GameEvents.
             * @exports message.input.GameEvents
             * @constructor
             * @param {message.input.GameEvents$Properties=} [properties] Properties to set
             */
            function GameEvents(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GameEvents instance using the specified properties.
             * @param {message.input.GameEvents$Properties=} [properties] Properties to set
             * @returns {message.input.GameEvents} GameEvents instance
             */
            GameEvents.create = function create(properties) {
                return new GameEvents(properties);
            };

            /**
             * Encodes the specified GameEvents message. Does not implicitly {@link message.input.GameEvents.verify|verify} messages.
             * @param {message.input.GameEvents$Properties} message GameEvents message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameEvents.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GameEvents message, length delimited. Does not implicitly {@link message.input.GameEvents.verify|verify} messages.
             * @param {message.input.GameEvents$Properties} message GameEvents message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameEvents.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GameEvents message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.GameEvents} GameEvents
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameEvents.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GameEvents message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.GameEvents} GameEvents
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameEvents.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GameEvents message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            GameEvents.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GameEvents message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.GameEvents} GameEvents
             */
            GameEvents.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.GameEvents)
                    return object;
                return new $root.message.input.GameEvents();
            };

            /**
             * Creates a GameEvents message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.GameEvents.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.GameEvents} GameEvents
             */
            GameEvents.from = GameEvents.fromObject;

            /**
             * Creates a plain object from a GameEvents message. Also converts values to other types if specified.
             * @param {message.input.GameEvents} message GameEvents
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GameEvents.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this GameEvents message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GameEvents.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this GameEvents to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            GameEvents.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Context enum.
             * @name Context
             * @memberof message.input.GameEvents
             * @enum {number}
             * @property {number} UNKNOWN_CONTEXT=0 UNKNOWN_CONTEXT value
             * @property {number} SELF=1 SELF value
             * @property {number} TEAM=2 TEAM value
             * @property {number} OPPONENT=3 OPPONENT value
             * @property {number} UNKNOWN=4 UNKNOWN value
             */
            GameEvents.Context = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN_CONTEXT"] = 0;
                values[valuesById[1] = "SELF"] = 1;
                values[valuesById[2] = "TEAM"] = 2;
                values[valuesById[3] = "OPPONENT"] = 3;
                values[valuesById[4] = "UNKNOWN"] = 4;
                return values;
            })();

            /**
             * TeamColour enum.
             * @name TeamColour
             * @memberof message.input.GameEvents
             * @enum {number}
             * @property {number} UNKNOWN_TEAM_COLOUR=0 UNKNOWN_TEAM_COLOUR value
             * @property {number} CYAN=1 CYAN value
             * @property {number} MAGENTA=2 MAGENTA value
             */
            GameEvents.TeamColour = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN_TEAM_COLOUR"] = 0;
                values[valuesById[1] = "CYAN"] = 1;
                values[valuesById[2] = "MAGENTA"] = 2;
                return values;
            })();

            GameEvents.Score = (function() {

                /**
                 * Properties of a Score.
                 * @typedef message.input.GameEvents.Score$Properties
                 * @type {Object}
                 * @property {number} [ownScore] Score ownScore.
                 * @property {number} [opponentScore] Score opponentScore.
                 */

                /**
                 * Constructs a new Score.
                 * @exports message.input.GameEvents.Score
                 * @constructor
                 * @param {message.input.GameEvents.Score$Properties=} [properties] Properties to set
                 */
                function Score(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Score ownScore.
                 * @type {number}
                 */
                Score.prototype.ownScore = 0;

                /**
                 * Score opponentScore.
                 * @type {number}
                 */
                Score.prototype.opponentScore = 0;

                /**
                 * Creates a new Score instance using the specified properties.
                 * @param {message.input.GameEvents.Score$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.Score} Score instance
                 */
                Score.create = function create(properties) {
                    return new Score(properties);
                };

                /**
                 * Encodes the specified Score message. Does not implicitly {@link message.input.GameEvents.Score.verify|verify} messages.
                 * @param {message.input.GameEvents.Score$Properties} message Score message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Score.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ownScore != null && message.hasOwnProperty("ownScore"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ownScore);
                    if (message.opponentScore != null && message.hasOwnProperty("opponentScore"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.opponentScore);
                    return writer;
                };

                /**
                 * Encodes the specified Score message, length delimited. Does not implicitly {@link message.input.GameEvents.Score.verify|verify} messages.
                 * @param {message.input.GameEvents.Score$Properties} message Score message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Score.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Score message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.Score} Score
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Score.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.Score();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ownScore = reader.uint32();
                            break;
                        case 2:
                            message.opponentScore = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Score message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.Score} Score
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Score.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Score message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Score.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ownScore != null && message.hasOwnProperty("ownScore"))
                        if (!$util.isInteger(message.ownScore))
                            return "ownScore: integer expected";
                    if (message.opponentScore != null && message.hasOwnProperty("opponentScore"))
                        if (!$util.isInteger(message.opponentScore))
                            return "opponentScore: integer expected";
                    return null;
                };

                /**
                 * Creates a Score message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.Score} Score
                 */
                Score.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.GameEvents.Score)
                        return object;
                    var message = new $root.message.input.GameEvents.Score();
                    if (object.ownScore != null)
                        message.ownScore = object.ownScore >>> 0;
                    if (object.opponentScore != null)
                        message.opponentScore = object.opponentScore >>> 0;
                    return message;
                };

                /**
                 * Creates a Score message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.Score.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.Score} Score
                 */
                Score.from = Score.fromObject;

                /**
                 * Creates a plain object from a Score message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.Score} message Score
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Score.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.ownScore = 0;
                        object.opponentScore = 0;
                    }
                    if (message.ownScore != null && message.hasOwnProperty("ownScore"))
                        object.ownScore = message.ownScore;
                    if (message.opponentScore != null && message.hasOwnProperty("opponentScore"))
                        object.opponentScore = message.opponentScore;
                    return object;
                };

                /**
                 * Creates a plain object from this Score message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Score.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Score to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Score.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Score;
            })();

            GameEvents.GoalScored = (function() {

                /**
                 * Properties of a GoalScored.
                 * @typedef message.input.GameEvents.GoalScored$Properties
                 * @type {Object}
                 * @property {message.input.GameEvents.Context} [context] GoalScored context.
                 * @property {number} [totalScore] GoalScored totalScore.
                 */

                /**
                 * Constructs a new GoalScored.
                 * @exports message.input.GameEvents.GoalScored
                 * @constructor
                 * @param {message.input.GameEvents.GoalScored$Properties=} [properties] Properties to set
                 */
                function GoalScored(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GoalScored context.
                 * @type {message.input.GameEvents.Context}
                 */
                GoalScored.prototype.context = 0;

                /**
                 * GoalScored totalScore.
                 * @type {number}
                 */
                GoalScored.prototype.totalScore = 0;

                /**
                 * Creates a new GoalScored instance using the specified properties.
                 * @param {message.input.GameEvents.GoalScored$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.GoalScored} GoalScored instance
                 */
                GoalScored.create = function create(properties) {
                    return new GoalScored(properties);
                };

                /**
                 * Encodes the specified GoalScored message. Does not implicitly {@link message.input.GameEvents.GoalScored.verify|verify} messages.
                 * @param {message.input.GameEvents.GoalScored$Properties} message GoalScored message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GoalScored.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.context != null && message.hasOwnProperty("context"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.context);
                    if (message.totalScore != null && message.hasOwnProperty("totalScore"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.totalScore);
                    return writer;
                };

                /**
                 * Encodes the specified GoalScored message, length delimited. Does not implicitly {@link message.input.GameEvents.GoalScored.verify|verify} messages.
                 * @param {message.input.GameEvents.GoalScored$Properties} message GoalScored message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GoalScored.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GoalScored message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.GoalScored} GoalScored
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GoalScored.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.GoalScored();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.context = reader.uint32();
                            break;
                        case 2:
                            message.totalScore = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GoalScored message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.GoalScored} GoalScored
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GoalScored.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GoalScored message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                GoalScored.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.context != null && message.hasOwnProperty("context"))
                        switch (message.context) {
                        default:
                            return "context: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.totalScore != null && message.hasOwnProperty("totalScore"))
                        if (!$util.isInteger(message.totalScore))
                            return "totalScore: integer expected";
                    return null;
                };

                /**
                 * Creates a GoalScored message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.GoalScored} GoalScored
                 */
                GoalScored.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.GameEvents.GoalScored)
                        return object;
                    var message = new $root.message.input.GameEvents.GoalScored();
                    switch (object.context) {
                    case "UNKNOWN_CONTEXT":
                    case 0:
                        message.context = 0;
                        break;
                    case "SELF":
                    case 1:
                        message.context = 1;
                        break;
                    case "TEAM":
                    case 2:
                        message.context = 2;
                        break;
                    case "OPPONENT":
                    case 3:
                        message.context = 3;
                        break;
                    case "UNKNOWN":
                    case 4:
                        message.context = 4;
                        break;
                    }
                    if (object.totalScore != null)
                        message.totalScore = object.totalScore >>> 0;
                    return message;
                };

                /**
                 * Creates a GoalScored message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.GoalScored.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.GoalScored} GoalScored
                 */
                GoalScored.from = GoalScored.fromObject;

                /**
                 * Creates a plain object from a GoalScored message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.GoalScored} message GoalScored
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GoalScored.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.context = options.enums === String ? "UNKNOWN_CONTEXT" : 0;
                        object.totalScore = 0;
                    }
                    if (message.context != null && message.hasOwnProperty("context"))
                        object.context = options.enums === String ? $root.message.input.GameEvents.Context[message.context] : message.context;
                    if (message.totalScore != null && message.hasOwnProperty("totalScore"))
                        object.totalScore = message.totalScore;
                    return object;
                };

                /**
                 * Creates a plain object from this GoalScored message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GoalScored.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this GoalScored to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                GoalScored.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GoalScored;
            })();

            GameEvents.Penalisation = (function() {

                /**
                 * Properties of a Penalisation.
                 * @typedef message.input.GameEvents.Penalisation$Properties
                 * @type {Object}
                 * @property {message.input.GameEvents.Context} [context] Penalisation context.
                 * @property {number} [robotId] Penalisation robotId.
                 * @property {google.protobuf.Timestamp$Properties} [ends] Penalisation ends.
                 * @property {message.input.GameState.Data.PenaltyReason} [reason] Penalisation reason.
                 */

                /**
                 * Constructs a new Penalisation.
                 * @exports message.input.GameEvents.Penalisation
                 * @constructor
                 * @param {message.input.GameEvents.Penalisation$Properties=} [properties] Properties to set
                 */
                function Penalisation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Penalisation context.
                 * @type {message.input.GameEvents.Context}
                 */
                Penalisation.prototype.context = 0;

                /**
                 * Penalisation robotId.
                 * @type {number}
                 */
                Penalisation.prototype.robotId = 0;

                /**
                 * Penalisation ends.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                Penalisation.prototype.ends = null;

                /**
                 * Penalisation reason.
                 * @type {message.input.GameState.Data.PenaltyReason}
                 */
                Penalisation.prototype.reason = 0;

                /**
                 * Creates a new Penalisation instance using the specified properties.
                 * @param {message.input.GameEvents.Penalisation$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.Penalisation} Penalisation instance
                 */
                Penalisation.create = function create(properties) {
                    return new Penalisation(properties);
                };

                /**
                 * Encodes the specified Penalisation message. Does not implicitly {@link message.input.GameEvents.Penalisation.verify|verify} messages.
                 * @param {message.input.GameEvents.Penalisation$Properties} message Penalisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Penalisation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.context != null && message.hasOwnProperty("context"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.context);
                    if (message.robotId != null && message.hasOwnProperty("robotId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.robotId);
                    if (message.ends != null && message.hasOwnProperty("ends"))
                        $root.google.protobuf.Timestamp.encode(message.ends, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.reason);
                    return writer;
                };

                /**
                 * Encodes the specified Penalisation message, length delimited. Does not implicitly {@link message.input.GameEvents.Penalisation.verify|verify} messages.
                 * @param {message.input.GameEvents.Penalisation$Properties} message Penalisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Penalisation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Penalisation message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.Penalisation} Penalisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Penalisation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.Penalisation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.context = reader.uint32();
                            break;
                        case 2:
                            message.robotId = reader.uint32();
                            break;
                        case 3:
                            message.ends = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.reason = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Penalisation message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.Penalisation} Penalisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Penalisation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Penalisation message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Penalisation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.context != null && message.hasOwnProperty("context"))
                        switch (message.context) {
                        default:
                            return "context: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.robotId != null && message.hasOwnProperty("robotId"))
                        if (!$util.isInteger(message.robotId))
                            return "robotId: integer expected";
                    if (message.ends != null && message.hasOwnProperty("ends")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.ends);
                        if (error)
                            return "ends." + error;
                    }
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        switch (message.reason) {
                        default:
                            return "reason: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a Penalisation message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.Penalisation} Penalisation
                 */
                Penalisation.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.GameEvents.Penalisation)
                        return object;
                    var message = new $root.message.input.GameEvents.Penalisation();
                    switch (object.context) {
                    case "UNKNOWN_CONTEXT":
                    case 0:
                        message.context = 0;
                        break;
                    case "SELF":
                    case 1:
                        message.context = 1;
                        break;
                    case "TEAM":
                    case 2:
                        message.context = 2;
                        break;
                    case "OPPONENT":
                    case 3:
                        message.context = 3;
                        break;
                    case "UNKNOWN":
                    case 4:
                        message.context = 4;
                        break;
                    }
                    if (object.robotId != null)
                        message.robotId = object.robotId >>> 0;
                    if (object.ends != null) {
                        if (typeof object.ends !== "object")
                            throw TypeError(".message.input.GameEvents.Penalisation.ends: object expected");
                        message.ends = $root.google.protobuf.Timestamp.fromObject(object.ends);
                    }
                    switch (object.reason) {
                    case "UNKNOWN_PENALTY_REASON":
                    case 0:
                        message.reason = 0;
                        break;
                    case "UNPENALISED":
                    case 1:
                        message.reason = 1;
                        break;
                    case "BALL_MANIPULATION":
                    case 2:
                        message.reason = 2;
                        break;
                    case "PHYSICAL_CONTACT":
                    case 3:
                        message.reason = 3;
                        break;
                    case "ILLEGAL_ATTACK":
                    case 4:
                        message.reason = 4;
                        break;
                    case "ILLEGAL_DEFENSE":
                    case 5:
                        message.reason = 5;
                        break;
                    case "REQUEST_FOR_PICKUP":
                    case 6:
                        message.reason = 6;
                        break;
                    case "REQUEST_FOR_SERVICE":
                    case 7:
                        message.reason = 7;
                        break;
                    case "REQUEST_FOR_PICKUP_TO_SERVICE":
                    case 8:
                        message.reason = 8;
                        break;
                    case "SUBSTITUTE":
                    case 9:
                        message.reason = 9;
                        break;
                    case "MANUAL":
                    case 10:
                        message.reason = 10;
                        break;
                    case "PLAYER_PUSHING":
                    case 11:
                        message.reason = 11;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a Penalisation message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.Penalisation.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.Penalisation} Penalisation
                 */
                Penalisation.from = Penalisation.fromObject;

                /**
                 * Creates a plain object from a Penalisation message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.Penalisation} message Penalisation
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Penalisation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.context = options.enums === String ? "UNKNOWN_CONTEXT" : 0;
                        object.robotId = 0;
                        object.ends = null;
                        object.reason = options.enums === String ? "UNKNOWN_PENALTY_REASON" : 0;
                    }
                    if (message.context != null && message.hasOwnProperty("context"))
                        object.context = options.enums === String ? $root.message.input.GameEvents.Context[message.context] : message.context;
                    if (message.robotId != null && message.hasOwnProperty("robotId"))
                        object.robotId = message.robotId;
                    if (message.ends != null && message.hasOwnProperty("ends"))
                        object.ends = $root.google.protobuf.Timestamp.toObject(message.ends, options);
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        object.reason = options.enums === String ? $root.message.input.GameState.Data.PenaltyReason[message.reason] : message.reason;
                    return object;
                };

                /**
                 * Creates a plain object from this Penalisation message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Penalisation.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Penalisation to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Penalisation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Penalisation;
            })();

            GameEvents.Unpenalisation = (function() {

                /**
                 * Properties of an Unpenalisation.
                 * @typedef message.input.GameEvents.Unpenalisation$Properties
                 * @type {Object}
                 * @property {message.input.GameEvents.Context} [context] Unpenalisation context.
                 * @property {number} [robotId] Unpenalisation robotId.
                 */

                /**
                 * Constructs a new Unpenalisation.
                 * @exports message.input.GameEvents.Unpenalisation
                 * @constructor
                 * @param {message.input.GameEvents.Unpenalisation$Properties=} [properties] Properties to set
                 */
                function Unpenalisation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Unpenalisation context.
                 * @type {message.input.GameEvents.Context}
                 */
                Unpenalisation.prototype.context = 0;

                /**
                 * Unpenalisation robotId.
                 * @type {number}
                 */
                Unpenalisation.prototype.robotId = 0;

                /**
                 * Creates a new Unpenalisation instance using the specified properties.
                 * @param {message.input.GameEvents.Unpenalisation$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.Unpenalisation} Unpenalisation instance
                 */
                Unpenalisation.create = function create(properties) {
                    return new Unpenalisation(properties);
                };

                /**
                 * Encodes the specified Unpenalisation message. Does not implicitly {@link message.input.GameEvents.Unpenalisation.verify|verify} messages.
                 * @param {message.input.GameEvents.Unpenalisation$Properties} message Unpenalisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Unpenalisation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.context != null && message.hasOwnProperty("context"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.context);
                    if (message.robotId != null && message.hasOwnProperty("robotId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.robotId);
                    return writer;
                };

                /**
                 * Encodes the specified Unpenalisation message, length delimited. Does not implicitly {@link message.input.GameEvents.Unpenalisation.verify|verify} messages.
                 * @param {message.input.GameEvents.Unpenalisation$Properties} message Unpenalisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Unpenalisation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Unpenalisation message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.Unpenalisation} Unpenalisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Unpenalisation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.Unpenalisation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.context = reader.uint32();
                            break;
                        case 2:
                            message.robotId = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Unpenalisation message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.Unpenalisation} Unpenalisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Unpenalisation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Unpenalisation message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Unpenalisation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.context != null && message.hasOwnProperty("context"))
                        switch (message.context) {
                        default:
                            return "context: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.robotId != null && message.hasOwnProperty("robotId"))
                        if (!$util.isInteger(message.robotId))
                            return "robotId: integer expected";
                    return null;
                };

                /**
                 * Creates an Unpenalisation message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.Unpenalisation} Unpenalisation
                 */
                Unpenalisation.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.GameEvents.Unpenalisation)
                        return object;
                    var message = new $root.message.input.GameEvents.Unpenalisation();
                    switch (object.context) {
                    case "UNKNOWN_CONTEXT":
                    case 0:
                        message.context = 0;
                        break;
                    case "SELF":
                    case 1:
                        message.context = 1;
                        break;
                    case "TEAM":
                    case 2:
                        message.context = 2;
                        break;
                    case "OPPONENT":
                    case 3:
                        message.context = 3;
                        break;
                    case "UNKNOWN":
                    case 4:
                        message.context = 4;
                        break;
                    }
                    if (object.robotId != null)
                        message.robotId = object.robotId >>> 0;
                    return message;
                };

                /**
                 * Creates an Unpenalisation message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.Unpenalisation.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.Unpenalisation} Unpenalisation
                 */
                Unpenalisation.from = Unpenalisation.fromObject;

                /**
                 * Creates a plain object from an Unpenalisation message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.Unpenalisation} message Unpenalisation
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Unpenalisation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.context = options.enums === String ? "UNKNOWN_CONTEXT" : 0;
                        object.robotId = 0;
                    }
                    if (message.context != null && message.hasOwnProperty("context"))
                        object.context = options.enums === String ? $root.message.input.GameEvents.Context[message.context] : message.context;
                    if (message.robotId != null && message.hasOwnProperty("robotId"))
                        object.robotId = message.robotId;
                    return object;
                };

                /**
                 * Creates a plain object from this Unpenalisation message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Unpenalisation.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Unpenalisation to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Unpenalisation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Unpenalisation;
            })();

            GameEvents.CoachMessage = (function() {

                /**
                 * Properties of a CoachMessage.
                 * @typedef message.input.GameEvents.CoachMessage$Properties
                 * @type {Object}
                 * @property {message.input.GameEvents.Context} [context] CoachMessage context.
                 * @property {string} [message] CoachMessage message.
                 */

                /**
                 * Constructs a new CoachMessage.
                 * @exports message.input.GameEvents.CoachMessage
                 * @constructor
                 * @param {message.input.GameEvents.CoachMessage$Properties=} [properties] Properties to set
                 */
                function CoachMessage(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CoachMessage context.
                 * @type {message.input.GameEvents.Context}
                 */
                CoachMessage.prototype.context = 0;

                /**
                 * CoachMessage message.
                 * @type {string}
                 */
                CoachMessage.prototype.message = "";

                /**
                 * Creates a new CoachMessage instance using the specified properties.
                 * @param {message.input.GameEvents.CoachMessage$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.CoachMessage} CoachMessage instance
                 */
                CoachMessage.create = function create(properties) {
                    return new CoachMessage(properties);
                };

                /**
                 * Encodes the specified CoachMessage message. Does not implicitly {@link message.input.GameEvents.CoachMessage.verify|verify} messages.
                 * @param {message.input.GameEvents.CoachMessage$Properties} message CoachMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CoachMessage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.context != null && message.hasOwnProperty("context"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.context);
                    if (message.message != null && message.hasOwnProperty("message"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                    return writer;
                };

                /**
                 * Encodes the specified CoachMessage message, length delimited. Does not implicitly {@link message.input.GameEvents.CoachMessage.verify|verify} messages.
                 * @param {message.input.GameEvents.CoachMessage$Properties} message CoachMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CoachMessage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CoachMessage message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.CoachMessage} CoachMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CoachMessage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.CoachMessage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.context = reader.uint32();
                            break;
                        case 2:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CoachMessage message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.CoachMessage} CoachMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CoachMessage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CoachMessage message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                CoachMessage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.context != null && message.hasOwnProperty("context"))
                        switch (message.context) {
                        default:
                            return "context: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    return null;
                };

                /**
                 * Creates a CoachMessage message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.CoachMessage} CoachMessage
                 */
                CoachMessage.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.GameEvents.CoachMessage)
                        return object;
                    var message = new $root.message.input.GameEvents.CoachMessage();
                    switch (object.context) {
                    case "UNKNOWN_CONTEXT":
                    case 0:
                        message.context = 0;
                        break;
                    case "SELF":
                    case 1:
                        message.context = 1;
                        break;
                    case "TEAM":
                    case 2:
                        message.context = 2;
                        break;
                    case "OPPONENT":
                    case 3:
                        message.context = 3;
                        break;
                    case "UNKNOWN":
                    case 4:
                        message.context = 4;
                        break;
                    }
                    if (object.message != null)
                        message.message = String(object.message);
                    return message;
                };

                /**
                 * Creates a CoachMessage message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.CoachMessage.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.CoachMessage} CoachMessage
                 */
                CoachMessage.from = CoachMessage.fromObject;

                /**
                 * Creates a plain object from a CoachMessage message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.CoachMessage} message CoachMessage
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CoachMessage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.context = options.enums === String ? "UNKNOWN_CONTEXT" : 0;
                        object.message = "";
                    }
                    if (message.context != null && message.hasOwnProperty("context"))
                        object.context = options.enums === String ? $root.message.input.GameEvents.Context[message.context] : message.context;
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    return object;
                };

                /**
                 * Creates a plain object from this CoachMessage message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CoachMessage.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this CoachMessage to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                CoachMessage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CoachMessage;
            })();

            GameEvents.HalfTime = (function() {

                /**
                 * Properties of a HalfTime.
                 * @typedef message.input.GameEvents.HalfTime$Properties
                 * @type {Object}
                 * @property {boolean} [firstHalf] HalfTime firstHalf.
                 */

                /**
                 * Constructs a new HalfTime.
                 * @exports message.input.GameEvents.HalfTime
                 * @constructor
                 * @param {message.input.GameEvents.HalfTime$Properties=} [properties] Properties to set
                 */
                function HalfTime(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * HalfTime firstHalf.
                 * @type {boolean}
                 */
                HalfTime.prototype.firstHalf = false;

                /**
                 * Creates a new HalfTime instance using the specified properties.
                 * @param {message.input.GameEvents.HalfTime$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.HalfTime} HalfTime instance
                 */
                HalfTime.create = function create(properties) {
                    return new HalfTime(properties);
                };

                /**
                 * Encodes the specified HalfTime message. Does not implicitly {@link message.input.GameEvents.HalfTime.verify|verify} messages.
                 * @param {message.input.GameEvents.HalfTime$Properties} message HalfTime message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HalfTime.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.firstHalf != null && message.hasOwnProperty("firstHalf"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.firstHalf);
                    return writer;
                };

                /**
                 * Encodes the specified HalfTime message, length delimited. Does not implicitly {@link message.input.GameEvents.HalfTime.verify|verify} messages.
                 * @param {message.input.GameEvents.HalfTime$Properties} message HalfTime message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HalfTime.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a HalfTime message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.HalfTime} HalfTime
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HalfTime.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.HalfTime();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.firstHalf = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a HalfTime message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.HalfTime} HalfTime
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HalfTime.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a HalfTime message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                HalfTime.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.firstHalf != null && message.hasOwnProperty("firstHalf"))
                        if (typeof message.firstHalf !== "boolean")
                            return "firstHalf: boolean expected";
                    return null;
                };

                /**
                 * Creates a HalfTime message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.HalfTime} HalfTime
                 */
                HalfTime.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.GameEvents.HalfTime)
                        return object;
                    var message = new $root.message.input.GameEvents.HalfTime();
                    if (object.firstHalf != null)
                        message.firstHalf = Boolean(object.firstHalf);
                    return message;
                };

                /**
                 * Creates a HalfTime message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.HalfTime.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.HalfTime} HalfTime
                 */
                HalfTime.from = HalfTime.fromObject;

                /**
                 * Creates a plain object from a HalfTime message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.HalfTime} message HalfTime
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HalfTime.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.firstHalf = false;
                    if (message.firstHalf != null && message.hasOwnProperty("firstHalf"))
                        object.firstHalf = message.firstHalf;
                    return object;
                };

                /**
                 * Creates a plain object from this HalfTime message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HalfTime.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this HalfTime to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                HalfTime.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return HalfTime;
            })();

            GameEvents.BallKickedOut = (function() {

                /**
                 * Properties of a BallKickedOut.
                 * @typedef message.input.GameEvents.BallKickedOut$Properties
                 * @type {Object}
                 * @property {message.input.GameEvents.Context} [context] BallKickedOut context.
                 * @property {google.protobuf.Timestamp$Properties} [time] BallKickedOut time.
                 */

                /**
                 * Constructs a new BallKickedOut.
                 * @exports message.input.GameEvents.BallKickedOut
                 * @constructor
                 * @param {message.input.GameEvents.BallKickedOut$Properties=} [properties] Properties to set
                 */
                function BallKickedOut(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * BallKickedOut context.
                 * @type {message.input.GameEvents.Context}
                 */
                BallKickedOut.prototype.context = 0;

                /**
                 * BallKickedOut time.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                BallKickedOut.prototype.time = null;

                /**
                 * Creates a new BallKickedOut instance using the specified properties.
                 * @param {message.input.GameEvents.BallKickedOut$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.BallKickedOut} BallKickedOut instance
                 */
                BallKickedOut.create = function create(properties) {
                    return new BallKickedOut(properties);
                };

                /**
                 * Encodes the specified BallKickedOut message. Does not implicitly {@link message.input.GameEvents.BallKickedOut.verify|verify} messages.
                 * @param {message.input.GameEvents.BallKickedOut$Properties} message BallKickedOut message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BallKickedOut.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.context != null && message.hasOwnProperty("context"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.context);
                    if (message.time != null && message.hasOwnProperty("time"))
                        $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified BallKickedOut message, length delimited. Does not implicitly {@link message.input.GameEvents.BallKickedOut.verify|verify} messages.
                 * @param {message.input.GameEvents.BallKickedOut$Properties} message BallKickedOut message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BallKickedOut.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a BallKickedOut message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.BallKickedOut} BallKickedOut
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BallKickedOut.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.BallKickedOut();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.context = reader.uint32();
                            break;
                        case 3:
                            message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a BallKickedOut message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.BallKickedOut} BallKickedOut
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BallKickedOut.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a BallKickedOut message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                BallKickedOut.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.context != null && message.hasOwnProperty("context"))
                        switch (message.context) {
                        default:
                            return "context: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.time != null && message.hasOwnProperty("time")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.time);
                        if (error)
                            return "time." + error;
                    }
                    return null;
                };

                /**
                 * Creates a BallKickedOut message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.BallKickedOut} BallKickedOut
                 */
                BallKickedOut.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.GameEvents.BallKickedOut)
                        return object;
                    var message = new $root.message.input.GameEvents.BallKickedOut();
                    switch (object.context) {
                    case "UNKNOWN_CONTEXT":
                    case 0:
                        message.context = 0;
                        break;
                    case "SELF":
                    case 1:
                        message.context = 1;
                        break;
                    case "TEAM":
                    case 2:
                        message.context = 2;
                        break;
                    case "OPPONENT":
                    case 3:
                        message.context = 3;
                        break;
                    case "UNKNOWN":
                    case 4:
                        message.context = 4;
                        break;
                    }
                    if (object.time != null) {
                        if (typeof object.time !== "object")
                            throw TypeError(".message.input.GameEvents.BallKickedOut.time: object expected");
                        message.time = $root.google.protobuf.Timestamp.fromObject(object.time);
                    }
                    return message;
                };

                /**
                 * Creates a BallKickedOut message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.BallKickedOut.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.BallKickedOut} BallKickedOut
                 */
                BallKickedOut.from = BallKickedOut.fromObject;

                /**
                 * Creates a plain object from a BallKickedOut message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.BallKickedOut} message BallKickedOut
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BallKickedOut.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.context = options.enums === String ? "UNKNOWN_CONTEXT" : 0;
                        object.time = null;
                    }
                    if (message.context != null && message.hasOwnProperty("context"))
                        object.context = options.enums === String ? $root.message.input.GameEvents.Context[message.context] : message.context;
                    if (message.time != null && message.hasOwnProperty("time"))
                        object.time = $root.google.protobuf.Timestamp.toObject(message.time, options);
                    return object;
                };

                /**
                 * Creates a plain object from this BallKickedOut message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BallKickedOut.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this BallKickedOut to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                BallKickedOut.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return BallKickedOut;
            })();

            GameEvents.KickOffTeam = (function() {

                /**
                 * Properties of a KickOffTeam.
                 * @typedef message.input.GameEvents.KickOffTeam$Properties
                 * @type {Object}
                 * @property {message.input.GameEvents.Context} [context] KickOffTeam context.
                 */

                /**
                 * Constructs a new KickOffTeam.
                 * @exports message.input.GameEvents.KickOffTeam
                 * @constructor
                 * @param {message.input.GameEvents.KickOffTeam$Properties=} [properties] Properties to set
                 */
                function KickOffTeam(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * KickOffTeam context.
                 * @type {message.input.GameEvents.Context}
                 */
                KickOffTeam.prototype.context = 0;

                /**
                 * Creates a new KickOffTeam instance using the specified properties.
                 * @param {message.input.GameEvents.KickOffTeam$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.KickOffTeam} KickOffTeam instance
                 */
                KickOffTeam.create = function create(properties) {
                    return new KickOffTeam(properties);
                };

                /**
                 * Encodes the specified KickOffTeam message. Does not implicitly {@link message.input.GameEvents.KickOffTeam.verify|verify} messages.
                 * @param {message.input.GameEvents.KickOffTeam$Properties} message KickOffTeam message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KickOffTeam.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.context != null && message.hasOwnProperty("context"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.context);
                    return writer;
                };

                /**
                 * Encodes the specified KickOffTeam message, length delimited. Does not implicitly {@link message.input.GameEvents.KickOffTeam.verify|verify} messages.
                 * @param {message.input.GameEvents.KickOffTeam$Properties} message KickOffTeam message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KickOffTeam.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a KickOffTeam message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.KickOffTeam} KickOffTeam
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KickOffTeam.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.KickOffTeam();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.context = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a KickOffTeam message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.KickOffTeam} KickOffTeam
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KickOffTeam.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a KickOffTeam message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                KickOffTeam.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.context != null && message.hasOwnProperty("context"))
                        switch (message.context) {
                        default:
                            return "context: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a KickOffTeam message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.KickOffTeam} KickOffTeam
                 */
                KickOffTeam.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.GameEvents.KickOffTeam)
                        return object;
                    var message = new $root.message.input.GameEvents.KickOffTeam();
                    switch (object.context) {
                    case "UNKNOWN_CONTEXT":
                    case 0:
                        message.context = 0;
                        break;
                    case "SELF":
                    case 1:
                        message.context = 1;
                        break;
                    case "TEAM":
                    case 2:
                        message.context = 2;
                        break;
                    case "OPPONENT":
                    case 3:
                        message.context = 3;
                        break;
                    case "UNKNOWN":
                    case 4:
                        message.context = 4;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a KickOffTeam message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.KickOffTeam.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.KickOffTeam} KickOffTeam
                 */
                KickOffTeam.from = KickOffTeam.fromObject;

                /**
                 * Creates a plain object from a KickOffTeam message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.KickOffTeam} message KickOffTeam
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                KickOffTeam.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.context = options.enums === String ? "UNKNOWN_CONTEXT" : 0;
                    if (message.context != null && message.hasOwnProperty("context"))
                        object.context = options.enums === String ? $root.message.input.GameEvents.Context[message.context] : message.context;
                    return object;
                };

                /**
                 * Creates a plain object from this KickOffTeam message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                KickOffTeam.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this KickOffTeam to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                KickOffTeam.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return KickOffTeam;
            })();

            GameEvents.GamePhase = (function() {

                /**
                 * Properties of a GamePhase.
                 * @typedef message.input.GameEvents.GamePhase$Properties
                 * @type {Object}
                 * @property {message.input.GameState.Data.Phase} [phase] GamePhase phase.
                 * @property {google.protobuf.Timestamp$Properties} [readyTime] GamePhase readyTime.
                 * @property {google.protobuf.Timestamp$Properties} [endHalf] GamePhase endHalf.
                 * @property {google.protobuf.Timestamp$Properties} [ballFree] GamePhase ballFree.
                 * @property {google.protobuf.Timestamp$Properties} [ends] GamePhase ends.
                 * @property {google.protobuf.Timestamp$Properties} [nextHalf] GamePhase nextHalf.
                 */

                /**
                 * Constructs a new GamePhase.
                 * @exports message.input.GameEvents.GamePhase
                 * @constructor
                 * @param {message.input.GameEvents.GamePhase$Properties=} [properties] Properties to set
                 */
                function GamePhase(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GamePhase phase.
                 * @type {message.input.GameState.Data.Phase}
                 */
                GamePhase.prototype.phase = 0;

                /**
                 * GamePhase readyTime.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                GamePhase.prototype.readyTime = null;

                /**
                 * GamePhase endHalf.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                GamePhase.prototype.endHalf = null;

                /**
                 * GamePhase ballFree.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                GamePhase.prototype.ballFree = null;

                /**
                 * GamePhase ends.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                GamePhase.prototype.ends = null;

                /**
                 * GamePhase nextHalf.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                GamePhase.prototype.nextHalf = null;

                /**
                 * Creates a new GamePhase instance using the specified properties.
                 * @param {message.input.GameEvents.GamePhase$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.GamePhase} GamePhase instance
                 */
                GamePhase.create = function create(properties) {
                    return new GamePhase(properties);
                };

                /**
                 * Encodes the specified GamePhase message. Does not implicitly {@link message.input.GameEvents.GamePhase.verify|verify} messages.
                 * @param {message.input.GameEvents.GamePhase$Properties} message GamePhase message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GamePhase.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.phase);
                    if (message.readyTime != null && message.hasOwnProperty("readyTime"))
                        $root.google.protobuf.Timestamp.encode(message.readyTime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.endHalf != null && message.hasOwnProperty("endHalf"))
                        $root.google.protobuf.Timestamp.encode(message.endHalf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.ballFree != null && message.hasOwnProperty("ballFree"))
                        $root.google.protobuf.Timestamp.encode(message.ballFree, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.ends != null && message.hasOwnProperty("ends"))
                        $root.google.protobuf.Timestamp.encode(message.ends, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.nextHalf != null && message.hasOwnProperty("nextHalf"))
                        $root.google.protobuf.Timestamp.encode(message.nextHalf, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified GamePhase message, length delimited. Does not implicitly {@link message.input.GameEvents.GamePhase.verify|verify} messages.
                 * @param {message.input.GameEvents.GamePhase$Properties} message GamePhase message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GamePhase.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GamePhase message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.GamePhase} GamePhase
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GamePhase.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.GamePhase();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.phase = reader.uint32();
                            break;
                        case 2:
                            message.readyTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.endHalf = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.ballFree = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.ends = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.nextHalf = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GamePhase message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.GamePhase} GamePhase
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GamePhase.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GamePhase message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                GamePhase.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        switch (message.phase) {
                        default:
                            return "phase: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.readyTime != null && message.hasOwnProperty("readyTime")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.readyTime);
                        if (error)
                            return "readyTime." + error;
                    }
                    if (message.endHalf != null && message.hasOwnProperty("endHalf")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.endHalf);
                        if (error)
                            return "endHalf." + error;
                    }
                    if (message.ballFree != null && message.hasOwnProperty("ballFree")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.ballFree);
                        if (error)
                            return "ballFree." + error;
                    }
                    if (message.ends != null && message.hasOwnProperty("ends")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.ends);
                        if (error)
                            return "ends." + error;
                    }
                    if (message.nextHalf != null && message.hasOwnProperty("nextHalf")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.nextHalf);
                        if (error)
                            return "nextHalf." + error;
                    }
                    return null;
                };

                /**
                 * Creates a GamePhase message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.GamePhase} GamePhase
                 */
                GamePhase.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.GameEvents.GamePhase)
                        return object;
                    var message = new $root.message.input.GameEvents.GamePhase();
                    switch (object.phase) {
                    case "UNKNOWN_PHASE":
                    case 0:
                        message.phase = 0;
                        break;
                    case "INITIAL":
                    case 1:
                        message.phase = 1;
                        break;
                    case "READY":
                    case 2:
                        message.phase = 2;
                        break;
                    case "SET":
                    case 3:
                        message.phase = 3;
                        break;
                    case "PLAYING":
                    case 4:
                        message.phase = 4;
                        break;
                    case "TIMEOUT":
                    case 5:
                        message.phase = 5;
                        break;
                    case "FINISHED":
                    case 6:
                        message.phase = 6;
                        break;
                    }
                    if (object.readyTime != null) {
                        if (typeof object.readyTime !== "object")
                            throw TypeError(".message.input.GameEvents.GamePhase.readyTime: object expected");
                        message.readyTime = $root.google.protobuf.Timestamp.fromObject(object.readyTime);
                    }
                    if (object.endHalf != null) {
                        if (typeof object.endHalf !== "object")
                            throw TypeError(".message.input.GameEvents.GamePhase.endHalf: object expected");
                        message.endHalf = $root.google.protobuf.Timestamp.fromObject(object.endHalf);
                    }
                    if (object.ballFree != null) {
                        if (typeof object.ballFree !== "object")
                            throw TypeError(".message.input.GameEvents.GamePhase.ballFree: object expected");
                        message.ballFree = $root.google.protobuf.Timestamp.fromObject(object.ballFree);
                    }
                    if (object.ends != null) {
                        if (typeof object.ends !== "object")
                            throw TypeError(".message.input.GameEvents.GamePhase.ends: object expected");
                        message.ends = $root.google.protobuf.Timestamp.fromObject(object.ends);
                    }
                    if (object.nextHalf != null) {
                        if (typeof object.nextHalf !== "object")
                            throw TypeError(".message.input.GameEvents.GamePhase.nextHalf: object expected");
                        message.nextHalf = $root.google.protobuf.Timestamp.fromObject(object.nextHalf);
                    }
                    return message;
                };

                /**
                 * Creates a GamePhase message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.GamePhase.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.GamePhase} GamePhase
                 */
                GamePhase.from = GamePhase.fromObject;

                /**
                 * Creates a plain object from a GamePhase message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.GamePhase} message GamePhase
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GamePhase.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.phase = options.enums === String ? "UNKNOWN_PHASE" : 0;
                        object.readyTime = null;
                        object.endHalf = null;
                        object.ballFree = null;
                        object.ends = null;
                        object.nextHalf = null;
                    }
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        object.phase = options.enums === String ? $root.message.input.GameState.Data.Phase[message.phase] : message.phase;
                    if (message.readyTime != null && message.hasOwnProperty("readyTime"))
                        object.readyTime = $root.google.protobuf.Timestamp.toObject(message.readyTime, options);
                    if (message.endHalf != null && message.hasOwnProperty("endHalf"))
                        object.endHalf = $root.google.protobuf.Timestamp.toObject(message.endHalf, options);
                    if (message.ballFree != null && message.hasOwnProperty("ballFree"))
                        object.ballFree = $root.google.protobuf.Timestamp.toObject(message.ballFree, options);
                    if (message.ends != null && message.hasOwnProperty("ends"))
                        object.ends = $root.google.protobuf.Timestamp.toObject(message.ends, options);
                    if (message.nextHalf != null && message.hasOwnProperty("nextHalf"))
                        object.nextHalf = $root.google.protobuf.Timestamp.toObject(message.nextHalf, options);
                    return object;
                };

                /**
                 * Creates a plain object from this GamePhase message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GamePhase.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this GamePhase to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                GamePhase.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GamePhase;
            })();

            GameEvents.GameMode = (function() {

                /**
                 * Properties of a GameMode.
                 * @typedef message.input.GameEvents.GameMode$Properties
                 * @type {Object}
                 * @property {message.input.GameState.Data.Mode} [mode] GameMode mode.
                 */

                /**
                 * Constructs a new GameMode.
                 * @exports message.input.GameEvents.GameMode
                 * @constructor
                 * @param {message.input.GameEvents.GameMode$Properties=} [properties] Properties to set
                 */
                function GameMode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GameMode mode.
                 * @type {message.input.GameState.Data.Mode}
                 */
                GameMode.prototype.mode = 0;

                /**
                 * Creates a new GameMode instance using the specified properties.
                 * @param {message.input.GameEvents.GameMode$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.GameMode} GameMode instance
                 */
                GameMode.create = function create(properties) {
                    return new GameMode(properties);
                };

                /**
                 * Encodes the specified GameMode message. Does not implicitly {@link message.input.GameEvents.GameMode.verify|verify} messages.
                 * @param {message.input.GameEvents.GameMode$Properties} message GameMode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GameMode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.mode);
                    return writer;
                };

                /**
                 * Encodes the specified GameMode message, length delimited. Does not implicitly {@link message.input.GameEvents.GameMode.verify|verify} messages.
                 * @param {message.input.GameEvents.GameMode$Properties} message GameMode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GameMode.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GameMode message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.GameMode} GameMode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GameMode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameEvents.GameMode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mode = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GameMode message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.GameMode} GameMode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GameMode.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GameMode message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                GameMode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a GameMode message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.GameMode} GameMode
                 */
                GameMode.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.GameEvents.GameMode)
                        return object;
                    var message = new $root.message.input.GameEvents.GameMode();
                    switch (object.mode) {
                    case "UNKNOWN_MODE":
                    case 0:
                        message.mode = 0;
                        break;
                    case "NORMAL":
                    case 1:
                        message.mode = 1;
                        break;
                    case "PENALTY_SHOOTOUT":
                    case 2:
                        message.mode = 2;
                        break;
                    case "OVERTIME":
                    case 3:
                        message.mode = 3;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a GameMode message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.GameMode.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.GameMode} GameMode
                 */
                GameMode.from = GameMode.fromObject;

                /**
                 * Creates a plain object from a GameMode message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.GameMode} message GameMode
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GameMode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.mode = options.enums === String ? "UNKNOWN_MODE" : 0;
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.message.input.GameState.Data.Mode[message.mode] : message.mode;
                    return object;
                };

                /**
                 * Creates a plain object from this GameMode message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GameMode.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this GameMode to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                GameMode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GameMode;
            })();

            return GameEvents;
        })();

        input.GameState = (function() {

            /**
             * Properties of a GameState.
             * @typedef message.input.GameState$Properties
             * @type {Object}
             * @property {message.input.GameState.Data$Properties} [data] GameState data.
             * @property {string} [event] GameState event.
             */

            /**
             * Constructs a new GameState.
             * @exports message.input.GameState
             * @constructor
             * @param {message.input.GameState$Properties=} [properties] Properties to set
             */
            function GameState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GameState data.
             * @type {(message.input.GameState.Data$Properties|null)}
             */
            GameState.prototype.data = null;

            /**
             * GameState event.
             * @type {string}
             */
            GameState.prototype.event = "";

            /**
             * Creates a new GameState instance using the specified properties.
             * @param {message.input.GameState$Properties=} [properties] Properties to set
             * @returns {message.input.GameState} GameState instance
             */
            GameState.create = function create(properties) {
                return new GameState(properties);
            };

            /**
             * Encodes the specified GameState message. Does not implicitly {@link message.input.GameState.verify|verify} messages.
             * @param {message.input.GameState$Properties} message GameState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && message.hasOwnProperty("data"))
                    $root.message.input.GameState.Data.encode(message.data, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.event != null && message.hasOwnProperty("event"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.event);
                return writer;
            };

            /**
             * Encodes the specified GameState message, length delimited. Does not implicitly {@link message.input.GameState.verify|verify} messages.
             * @param {message.input.GameState$Properties} message GameState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GameState message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.GameState} GameState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.data = $root.message.input.GameState.Data.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.event = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GameState message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.GameState} GameState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GameState message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            GameState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.message.input.GameState.Data.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.event != null && message.hasOwnProperty("event"))
                    if (!$util.isString(message.event))
                        return "event: string expected";
                return null;
            };

            /**
             * Creates a GameState message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.GameState} GameState
             */
            GameState.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.GameState)
                    return object;
                var message = new $root.message.input.GameState();
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".message.input.GameState.data: object expected");
                    message.data = $root.message.input.GameState.Data.fromObject(object.data);
                }
                if (object.event != null)
                    message.event = String(object.event);
                return message;
            };

            /**
             * Creates a GameState message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.GameState.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.GameState} GameState
             */
            GameState.from = GameState.fromObject;

            /**
             * Creates a plain object from a GameState message. Also converts values to other types if specified.
             * @param {message.input.GameState} message GameState
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GameState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.data = null;
                    object.event = "";
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.message.input.GameState.Data.toObject(message.data, options);
                if (message.event != null && message.hasOwnProperty("event"))
                    object.event = message.event;
                return object;
            };

            /**
             * Creates a plain object from this GameState message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GameState.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this GameState to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            GameState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GameState.Data = (function() {

                /**
                 * Properties of a Data.
                 * @typedef message.input.GameState.Data$Properties
                 * @type {Object}
                 * @property {message.input.GameState.Data.Phase} [phase] Data phase.
                 * @property {message.input.GameState.Data.Mode} [mode] Data mode.
                 * @property {boolean} [firstHalf] Data firstHalf.
                 * @property {boolean} [kickedOutByUs] Data kickedOutByUs.
                 * @property {google.protobuf.Timestamp$Properties} [kickedOutTime] Data kickedOutTime.
                 * @property {boolean} [ourKickOff] Data ourKickOff.
                 * @property {google.protobuf.Timestamp$Properties} [primaryTime] Data primaryTime.
                 * @property {google.protobuf.Timestamp$Properties} [secondaryTime] Data secondaryTime.
                 * @property {message.input.GameState.Data.Team$Properties} [team] Data team.
                 * @property {message.input.GameState.Data.Team$Properties} [opponent] Data opponent.
                 * @property {message.input.GameState.Data.Robot$Properties} [self] Data self.
                 */

                /**
                 * Constructs a new Data.
                 * @exports message.input.GameState.Data
                 * @constructor
                 * @param {message.input.GameState.Data$Properties=} [properties] Properties to set
                 */
                function Data(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Data phase.
                 * @type {message.input.GameState.Data.Phase}
                 */
                Data.prototype.phase = 0;

                /**
                 * Data mode.
                 * @type {message.input.GameState.Data.Mode}
                 */
                Data.prototype.mode = 0;

                /**
                 * Data firstHalf.
                 * @type {boolean}
                 */
                Data.prototype.firstHalf = false;

                /**
                 * Data kickedOutByUs.
                 * @type {boolean}
                 */
                Data.prototype.kickedOutByUs = false;

                /**
                 * Data kickedOutTime.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                Data.prototype.kickedOutTime = null;

                /**
                 * Data ourKickOff.
                 * @type {boolean}
                 */
                Data.prototype.ourKickOff = false;

                /**
                 * Data primaryTime.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                Data.prototype.primaryTime = null;

                /**
                 * Data secondaryTime.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                Data.prototype.secondaryTime = null;

                /**
                 * Data team.
                 * @type {(message.input.GameState.Data.Team$Properties|null)}
                 */
                Data.prototype.team = null;

                /**
                 * Data opponent.
                 * @type {(message.input.GameState.Data.Team$Properties|null)}
                 */
                Data.prototype.opponent = null;

                /**
                 * Data self.
                 * @type {(message.input.GameState.Data.Robot$Properties|null)}
                 */
                Data.prototype.self = null;

                /**
                 * Creates a new Data instance using the specified properties.
                 * @param {message.input.GameState.Data$Properties=} [properties] Properties to set
                 * @returns {message.input.GameState.Data} Data instance
                 */
                Data.create = function create(properties) {
                    return new Data(properties);
                };

                /**
                 * Encodes the specified Data message. Does not implicitly {@link message.input.GameState.Data.verify|verify} messages.
                 * @param {message.input.GameState.Data$Properties} message Data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Data.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.phase);
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.mode);
                    if (message.firstHalf != null && message.hasOwnProperty("firstHalf"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.firstHalf);
                    if (message.kickedOutByUs != null && message.hasOwnProperty("kickedOutByUs"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.kickedOutByUs);
                    if (message.kickedOutTime != null && message.hasOwnProperty("kickedOutTime"))
                        $root.google.protobuf.Timestamp.encode(message.kickedOutTime, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.ourKickOff != null && message.hasOwnProperty("ourKickOff"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ourKickOff);
                    if (message.primaryTime != null && message.hasOwnProperty("primaryTime"))
                        $root.google.protobuf.Timestamp.encode(message.primaryTime, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.secondaryTime != null && message.hasOwnProperty("secondaryTime"))
                        $root.google.protobuf.Timestamp.encode(message.secondaryTime, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.team != null && message.hasOwnProperty("team"))
                        $root.message.input.GameState.Data.Team.encode(message.team, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.opponent != null && message.hasOwnProperty("opponent"))
                        $root.message.input.GameState.Data.Team.encode(message.opponent, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.self != null && message.hasOwnProperty("self"))
                        $root.message.input.GameState.Data.Robot.encode(message.self, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Data message, length delimited. Does not implicitly {@link message.input.GameState.Data.verify|verify} messages.
                 * @param {message.input.GameState.Data$Properties} message Data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Data.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Data message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameState.Data} Data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Data.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameState.Data();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.phase = reader.uint32();
                            break;
                        case 2:
                            message.mode = reader.uint32();
                            break;
                        case 3:
                            message.firstHalf = reader.bool();
                            break;
                        case 4:
                            message.kickedOutByUs = reader.bool();
                            break;
                        case 5:
                            message.kickedOutTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.ourKickOff = reader.bool();
                            break;
                        case 7:
                            message.primaryTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.secondaryTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.team = $root.message.input.GameState.Data.Team.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.opponent = $root.message.input.GameState.Data.Team.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.self = $root.message.input.GameState.Data.Robot.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Data message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameState.Data} Data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Data.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Data message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Data.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        switch (message.phase) {
                        default:
                            return "phase: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.firstHalf != null && message.hasOwnProperty("firstHalf"))
                        if (typeof message.firstHalf !== "boolean")
                            return "firstHalf: boolean expected";
                    if (message.kickedOutByUs != null && message.hasOwnProperty("kickedOutByUs"))
                        if (typeof message.kickedOutByUs !== "boolean")
                            return "kickedOutByUs: boolean expected";
                    if (message.kickedOutTime != null && message.hasOwnProperty("kickedOutTime")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.kickedOutTime);
                        if (error)
                            return "kickedOutTime." + error;
                    }
                    if (message.ourKickOff != null && message.hasOwnProperty("ourKickOff"))
                        if (typeof message.ourKickOff !== "boolean")
                            return "ourKickOff: boolean expected";
                    if (message.primaryTime != null && message.hasOwnProperty("primaryTime")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.primaryTime);
                        if (error)
                            return "primaryTime." + error;
                    }
                    if (message.secondaryTime != null && message.hasOwnProperty("secondaryTime")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.secondaryTime);
                        if (error)
                            return "secondaryTime." + error;
                    }
                    if (message.team != null && message.hasOwnProperty("team")) {
                        var error = $root.message.input.GameState.Data.Team.verify(message.team);
                        if (error)
                            return "team." + error;
                    }
                    if (message.opponent != null && message.hasOwnProperty("opponent")) {
                        var error = $root.message.input.GameState.Data.Team.verify(message.opponent);
                        if (error)
                            return "opponent." + error;
                    }
                    if (message.self != null && message.hasOwnProperty("self")) {
                        var error = $root.message.input.GameState.Data.Robot.verify(message.self);
                        if (error)
                            return "self." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Data message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameState.Data} Data
                 */
                Data.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.GameState.Data)
                        return object;
                    var message = new $root.message.input.GameState.Data();
                    switch (object.phase) {
                    case "UNKNOWN_PHASE":
                    case 0:
                        message.phase = 0;
                        break;
                    case "INITIAL":
                    case 1:
                        message.phase = 1;
                        break;
                    case "READY":
                    case 2:
                        message.phase = 2;
                        break;
                    case "SET":
                    case 3:
                        message.phase = 3;
                        break;
                    case "PLAYING":
                    case 4:
                        message.phase = 4;
                        break;
                    case "TIMEOUT":
                    case 5:
                        message.phase = 5;
                        break;
                    case "FINISHED":
                    case 6:
                        message.phase = 6;
                        break;
                    }
                    switch (object.mode) {
                    case "UNKNOWN_MODE":
                    case 0:
                        message.mode = 0;
                        break;
                    case "NORMAL":
                    case 1:
                        message.mode = 1;
                        break;
                    case "PENALTY_SHOOTOUT":
                    case 2:
                        message.mode = 2;
                        break;
                    case "OVERTIME":
                    case 3:
                        message.mode = 3;
                        break;
                    }
                    if (object.firstHalf != null)
                        message.firstHalf = Boolean(object.firstHalf);
                    if (object.kickedOutByUs != null)
                        message.kickedOutByUs = Boolean(object.kickedOutByUs);
                    if (object.kickedOutTime != null) {
                        if (typeof object.kickedOutTime !== "object")
                            throw TypeError(".message.input.GameState.Data.kickedOutTime: object expected");
                        message.kickedOutTime = $root.google.protobuf.Timestamp.fromObject(object.kickedOutTime);
                    }
                    if (object.ourKickOff != null)
                        message.ourKickOff = Boolean(object.ourKickOff);
                    if (object.primaryTime != null) {
                        if (typeof object.primaryTime !== "object")
                            throw TypeError(".message.input.GameState.Data.primaryTime: object expected");
                        message.primaryTime = $root.google.protobuf.Timestamp.fromObject(object.primaryTime);
                    }
                    if (object.secondaryTime != null) {
                        if (typeof object.secondaryTime !== "object")
                            throw TypeError(".message.input.GameState.Data.secondaryTime: object expected");
                        message.secondaryTime = $root.google.protobuf.Timestamp.fromObject(object.secondaryTime);
                    }
                    if (object.team != null) {
                        if (typeof object.team !== "object")
                            throw TypeError(".message.input.GameState.Data.team: object expected");
                        message.team = $root.message.input.GameState.Data.Team.fromObject(object.team);
                    }
                    if (object.opponent != null) {
                        if (typeof object.opponent !== "object")
                            throw TypeError(".message.input.GameState.Data.opponent: object expected");
                        message.opponent = $root.message.input.GameState.Data.Team.fromObject(object.opponent);
                    }
                    if (object.self != null) {
                        if (typeof object.self !== "object")
                            throw TypeError(".message.input.GameState.Data.self: object expected");
                        message.self = $root.message.input.GameState.Data.Robot.fromObject(object.self);
                    }
                    return message;
                };

                /**
                 * Creates a Data message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameState.Data.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameState.Data} Data
                 */
                Data.from = Data.fromObject;

                /**
                 * Creates a plain object from a Data message. Also converts values to other types if specified.
                 * @param {message.input.GameState.Data} message Data
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Data.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.phase = options.enums === String ? "UNKNOWN_PHASE" : 0;
                        object.mode = options.enums === String ? "UNKNOWN_MODE" : 0;
                        object.firstHalf = false;
                        object.kickedOutByUs = false;
                        object.kickedOutTime = null;
                        object.ourKickOff = false;
                        object.primaryTime = null;
                        object.secondaryTime = null;
                        object.team = null;
                        object.opponent = null;
                        object.self = null;
                    }
                    if (message.phase != null && message.hasOwnProperty("phase"))
                        object.phase = options.enums === String ? $root.message.input.GameState.Data.Phase[message.phase] : message.phase;
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.message.input.GameState.Data.Mode[message.mode] : message.mode;
                    if (message.firstHalf != null && message.hasOwnProperty("firstHalf"))
                        object.firstHalf = message.firstHalf;
                    if (message.kickedOutByUs != null && message.hasOwnProperty("kickedOutByUs"))
                        object.kickedOutByUs = message.kickedOutByUs;
                    if (message.kickedOutTime != null && message.hasOwnProperty("kickedOutTime"))
                        object.kickedOutTime = $root.google.protobuf.Timestamp.toObject(message.kickedOutTime, options);
                    if (message.ourKickOff != null && message.hasOwnProperty("ourKickOff"))
                        object.ourKickOff = message.ourKickOff;
                    if (message.primaryTime != null && message.hasOwnProperty("primaryTime"))
                        object.primaryTime = $root.google.protobuf.Timestamp.toObject(message.primaryTime, options);
                    if (message.secondaryTime != null && message.hasOwnProperty("secondaryTime"))
                        object.secondaryTime = $root.google.protobuf.Timestamp.toObject(message.secondaryTime, options);
                    if (message.team != null && message.hasOwnProperty("team"))
                        object.team = $root.message.input.GameState.Data.Team.toObject(message.team, options);
                    if (message.opponent != null && message.hasOwnProperty("opponent"))
                        object.opponent = $root.message.input.GameState.Data.Team.toObject(message.opponent, options);
                    if (message.self != null && message.hasOwnProperty("self"))
                        object.self = $root.message.input.GameState.Data.Robot.toObject(message.self, options);
                    return object;
                };

                /**
                 * Creates a plain object from this Data message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Data.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Data to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Data.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Mode enum.
                 * @name Mode
                 * @memberof message.input.GameState.Data
                 * @enum {number}
                 * @property {number} UNKNOWN_MODE=0 UNKNOWN_MODE value
                 * @property {number} NORMAL=1 NORMAL value
                 * @property {number} PENALTY_SHOOTOUT=2 PENALTY_SHOOTOUT value
                 * @property {number} OVERTIME=3 OVERTIME value
                 */
                Data.Mode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN_MODE"] = 0;
                    values[valuesById[1] = "NORMAL"] = 1;
                    values[valuesById[2] = "PENALTY_SHOOTOUT"] = 2;
                    values[valuesById[3] = "OVERTIME"] = 3;
                    return values;
                })();

                /**
                 * Phase enum.
                 * @name Phase
                 * @memberof message.input.GameState.Data
                 * @enum {number}
                 * @property {number} UNKNOWN_PHASE=0 UNKNOWN_PHASE value
                 * @property {number} INITIAL=1 INITIAL value
                 * @property {number} READY=2 READY value
                 * @property {number} SET=3 SET value
                 * @property {number} PLAYING=4 PLAYING value
                 * @property {number} TIMEOUT=5 TIMEOUT value
                 * @property {number} FINISHED=6 FINISHED value
                 */
                Data.Phase = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN_PHASE"] = 0;
                    values[valuesById[1] = "INITIAL"] = 1;
                    values[valuesById[2] = "READY"] = 2;
                    values[valuesById[3] = "SET"] = 3;
                    values[valuesById[4] = "PLAYING"] = 4;
                    values[valuesById[5] = "TIMEOUT"] = 5;
                    values[valuesById[6] = "FINISHED"] = 6;
                    return values;
                })();

                /**
                 * PenaltyReason enum.
                 * @name PenaltyReason
                 * @memberof message.input.GameState.Data
                 * @enum {number}
                 * @property {number} UNKNOWN_PENALTY_REASON=0 UNKNOWN_PENALTY_REASON value
                 * @property {number} UNPENALISED=1 UNPENALISED value
                 * @property {number} BALL_MANIPULATION=2 BALL_MANIPULATION value
                 * @property {number} PHYSICAL_CONTACT=3 PHYSICAL_CONTACT value
                 * @property {number} ILLEGAL_ATTACK=4 ILLEGAL_ATTACK value
                 * @property {number} ILLEGAL_DEFENSE=5 ILLEGAL_DEFENSE value
                 * @property {number} REQUEST_FOR_PICKUP=6 REQUEST_FOR_PICKUP value
                 * @property {number} REQUEST_FOR_SERVICE=7 REQUEST_FOR_SERVICE value
                 * @property {number} REQUEST_FOR_PICKUP_TO_SERVICE=8 REQUEST_FOR_PICKUP_TO_SERVICE value
                 * @property {number} SUBSTITUTE=9 SUBSTITUTE value
                 * @property {number} MANUAL=10 MANUAL value
                 * @property {number} PLAYER_PUSHING=11 PLAYER_PUSHING value
                 */
                Data.PenaltyReason = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN_PENALTY_REASON"] = 0;
                    values[valuesById[1] = "UNPENALISED"] = 1;
                    values[valuesById[2] = "BALL_MANIPULATION"] = 2;
                    values[valuesById[3] = "PHYSICAL_CONTACT"] = 3;
                    values[valuesById[4] = "ILLEGAL_ATTACK"] = 4;
                    values[valuesById[5] = "ILLEGAL_DEFENSE"] = 5;
                    values[valuesById[6] = "REQUEST_FOR_PICKUP"] = 6;
                    values[valuesById[7] = "REQUEST_FOR_SERVICE"] = 7;
                    values[valuesById[8] = "REQUEST_FOR_PICKUP_TO_SERVICE"] = 8;
                    values[valuesById[9] = "SUBSTITUTE"] = 9;
                    values[valuesById[10] = "MANUAL"] = 10;
                    values[valuesById[11] = "PLAYER_PUSHING"] = 11;
                    return values;
                })();

                Data.Robot = (function() {

                    /**
                     * Properties of a Robot.
                     * @typedef message.input.GameState.Data.Robot$Properties
                     * @type {Object}
                     * @property {number} [id] Robot id.
                     * @property {message.input.GameState.Data.PenaltyReason} [penaltyReason] Robot penaltyReason.
                     * @property {google.protobuf.Timestamp$Properties} [unpenalised] Robot unpenalised.
                     */

                    /**
                     * Constructs a new Robot.
                     * @exports message.input.GameState.Data.Robot
                     * @constructor
                     * @param {message.input.GameState.Data.Robot$Properties=} [properties] Properties to set
                     */
                    function Robot(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Robot id.
                     * @type {number}
                     */
                    Robot.prototype.id = 0;

                    /**
                     * Robot penaltyReason.
                     * @type {message.input.GameState.Data.PenaltyReason}
                     */
                    Robot.prototype.penaltyReason = 0;

                    /**
                     * Robot unpenalised.
                     * @type {(google.protobuf.Timestamp$Properties|null)}
                     */
                    Robot.prototype.unpenalised = null;

                    /**
                     * Creates a new Robot instance using the specified properties.
                     * @param {message.input.GameState.Data.Robot$Properties=} [properties] Properties to set
                     * @returns {message.input.GameState.Data.Robot} Robot instance
                     */
                    Robot.create = function create(properties) {
                        return new Robot(properties);
                    };

                    /**
                     * Encodes the specified Robot message. Does not implicitly {@link message.input.GameState.Data.Robot.verify|verify} messages.
                     * @param {message.input.GameState.Data.Robot$Properties} message Robot message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Robot.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                        if (message.penaltyReason != null && message.hasOwnProperty("penaltyReason"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.penaltyReason);
                        if (message.unpenalised != null && message.hasOwnProperty("unpenalised"))
                            $root.google.protobuf.Timestamp.encode(message.unpenalised, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Robot message, length delimited. Does not implicitly {@link message.input.GameState.Data.Robot.verify|verify} messages.
                     * @param {message.input.GameState.Data.Robot$Properties} message Robot message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Robot.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Robot message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.input.GameState.Data.Robot} Robot
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Robot.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameState.Data.Robot();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.uint32();
                                break;
                            case 2:
                                message.penaltyReason = reader.uint32();
                                break;
                            case 3:
                                message.unpenalised = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Robot message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.input.GameState.Data.Robot} Robot
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Robot.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Robot message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Robot.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isInteger(message.id))
                                return "id: integer expected";
                        if (message.penaltyReason != null && message.hasOwnProperty("penaltyReason"))
                            switch (message.penaltyReason) {
                            default:
                                return "penaltyReason: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                                break;
                            }
                        if (message.unpenalised != null && message.hasOwnProperty("unpenalised")) {
                            var error = $root.google.protobuf.Timestamp.verify(message.unpenalised);
                            if (error)
                                return "unpenalised." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Robot message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.input.GameState.Data.Robot} Robot
                     */
                    Robot.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.input.GameState.Data.Robot)
                            return object;
                        var message = new $root.message.input.GameState.Data.Robot();
                        if (object.id != null)
                            message.id = object.id >>> 0;
                        switch (object.penaltyReason) {
                        case "UNKNOWN_PENALTY_REASON":
                        case 0:
                            message.penaltyReason = 0;
                            break;
                        case "UNPENALISED":
                        case 1:
                            message.penaltyReason = 1;
                            break;
                        case "BALL_MANIPULATION":
                        case 2:
                            message.penaltyReason = 2;
                            break;
                        case "PHYSICAL_CONTACT":
                        case 3:
                            message.penaltyReason = 3;
                            break;
                        case "ILLEGAL_ATTACK":
                        case 4:
                            message.penaltyReason = 4;
                            break;
                        case "ILLEGAL_DEFENSE":
                        case 5:
                            message.penaltyReason = 5;
                            break;
                        case "REQUEST_FOR_PICKUP":
                        case 6:
                            message.penaltyReason = 6;
                            break;
                        case "REQUEST_FOR_SERVICE":
                        case 7:
                            message.penaltyReason = 7;
                            break;
                        case "REQUEST_FOR_PICKUP_TO_SERVICE":
                        case 8:
                            message.penaltyReason = 8;
                            break;
                        case "SUBSTITUTE":
                        case 9:
                            message.penaltyReason = 9;
                            break;
                        case "MANUAL":
                        case 10:
                            message.penaltyReason = 10;
                            break;
                        case "PLAYER_PUSHING":
                        case 11:
                            message.penaltyReason = 11;
                            break;
                        }
                        if (object.unpenalised != null) {
                            if (typeof object.unpenalised !== "object")
                                throw TypeError(".message.input.GameState.Data.Robot.unpenalised: object expected");
                            message.unpenalised = $root.google.protobuf.Timestamp.fromObject(object.unpenalised);
                        }
                        return message;
                    };

                    /**
                     * Creates a Robot message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.input.GameState.Data.Robot.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.input.GameState.Data.Robot} Robot
                     */
                    Robot.from = Robot.fromObject;

                    /**
                     * Creates a plain object from a Robot message. Also converts values to other types if specified.
                     * @param {message.input.GameState.Data.Robot} message Robot
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Robot.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.id = 0;
                            object.penaltyReason = options.enums === String ? "UNKNOWN_PENALTY_REASON" : 0;
                            object.unpenalised = null;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.penaltyReason != null && message.hasOwnProperty("penaltyReason"))
                            object.penaltyReason = options.enums === String ? $root.message.input.GameState.Data.PenaltyReason[message.penaltyReason] : message.penaltyReason;
                        if (message.unpenalised != null && message.hasOwnProperty("unpenalised"))
                            object.unpenalised = $root.google.protobuf.Timestamp.toObject(message.unpenalised, options);
                        return object;
                    };

                    /**
                     * Creates a plain object from this Robot message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Robot.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Robot to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Robot.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Robot;
                })();

                Data.Team = (function() {

                    /**
                     * Properties of a Team.
                     * @typedef message.input.GameState.Data.Team$Properties
                     * @type {Object}
                     * @property {number} [teamId] Team teamId.
                     * @property {number} [score] Team score.
                     * @property {string} [coachMessage] Team coachMessage.
                     * @property {Array.<message.input.GameState.Data.Robot$Properties>} [players] Team players.
                     */

                    /**
                     * Constructs a new Team.
                     * @exports message.input.GameState.Data.Team
                     * @constructor
                     * @param {message.input.GameState.Data.Team$Properties=} [properties] Properties to set
                     */
                    function Team(properties) {
                        this.players = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Team teamId.
                     * @type {number}
                     */
                    Team.prototype.teamId = 0;

                    /**
                     * Team score.
                     * @type {number}
                     */
                    Team.prototype.score = 0;

                    /**
                     * Team coachMessage.
                     * @type {string}
                     */
                    Team.prototype.coachMessage = "";

                    /**
                     * Team players.
                     * @type {Array.<message.input.GameState.Data.Robot$Properties>}
                     */
                    Team.prototype.players = $util.emptyArray;

                    /**
                     * Creates a new Team instance using the specified properties.
                     * @param {message.input.GameState.Data.Team$Properties=} [properties] Properties to set
                     * @returns {message.input.GameState.Data.Team} Team instance
                     */
                    Team.create = function create(properties) {
                        return new Team(properties);
                    };

                    /**
                     * Encodes the specified Team message. Does not implicitly {@link message.input.GameState.Data.Team.verify|verify} messages.
                     * @param {message.input.GameState.Data.Team$Properties} message Team message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Team.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.teamId != null && message.hasOwnProperty("teamId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.teamId);
                        if (message.score != null && message.hasOwnProperty("score"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.score);
                        if (message.coachMessage != null && message.hasOwnProperty("coachMessage"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.coachMessage);
                        if (message.players != null && message.players.length)
                            for (var i = 0; i < message.players.length; ++i)
                                $root.message.input.GameState.Data.Robot.encode(message.players[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Team message, length delimited. Does not implicitly {@link message.input.GameState.Data.Team.verify|verify} messages.
                     * @param {message.input.GameState.Data.Team$Properties} message Team message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Team.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Team message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.input.GameState.Data.Team} Team
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Team.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.GameState.Data.Team();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.teamId = reader.uint32();
                                break;
                            case 2:
                                message.score = reader.uint32();
                                break;
                            case 3:
                                message.coachMessage = reader.string();
                                break;
                            case 4:
                                if (!(message.players && message.players.length))
                                    message.players = [];
                                message.players.push($root.message.input.GameState.Data.Robot.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Team message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.input.GameState.Data.Team} Team
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Team.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Team message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Team.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.teamId != null && message.hasOwnProperty("teamId"))
                            if (!$util.isInteger(message.teamId))
                                return "teamId: integer expected";
                        if (message.score != null && message.hasOwnProperty("score"))
                            if (!$util.isInteger(message.score))
                                return "score: integer expected";
                        if (message.coachMessage != null && message.hasOwnProperty("coachMessage"))
                            if (!$util.isString(message.coachMessage))
                                return "coachMessage: string expected";
                        if (message.players != null && message.hasOwnProperty("players")) {
                            if (!Array.isArray(message.players))
                                return "players: array expected";
                            for (var i = 0; i < message.players.length; ++i) {
                                var error = $root.message.input.GameState.Data.Robot.verify(message.players[i]);
                                if (error)
                                    return "players." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Team message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.input.GameState.Data.Team} Team
                     */
                    Team.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.input.GameState.Data.Team)
                            return object;
                        var message = new $root.message.input.GameState.Data.Team();
                        if (object.teamId != null)
                            message.teamId = object.teamId >>> 0;
                        if (object.score != null)
                            message.score = object.score >>> 0;
                        if (object.coachMessage != null)
                            message.coachMessage = String(object.coachMessage);
                        if (object.players) {
                            if (!Array.isArray(object.players))
                                throw TypeError(".message.input.GameState.Data.Team.players: array expected");
                            message.players = [];
                            for (var i = 0; i < object.players.length; ++i) {
                                if (typeof object.players[i] !== "object")
                                    throw TypeError(".message.input.GameState.Data.Team.players: object expected");
                                message.players[i] = $root.message.input.GameState.Data.Robot.fromObject(object.players[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a Team message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.input.GameState.Data.Team.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.input.GameState.Data.Team} Team
                     */
                    Team.from = Team.fromObject;

                    /**
                     * Creates a plain object from a Team message. Also converts values to other types if specified.
                     * @param {message.input.GameState.Data.Team} message Team
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Team.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.players = [];
                        if (options.defaults) {
                            object.teamId = 0;
                            object.score = 0;
                            object.coachMessage = "";
                        }
                        if (message.teamId != null && message.hasOwnProperty("teamId"))
                            object.teamId = message.teamId;
                        if (message.score != null && message.hasOwnProperty("score"))
                            object.score = message.score;
                        if (message.coachMessage != null && message.hasOwnProperty("coachMessage"))
                            object.coachMessage = message.coachMessage;
                        if (message.players && message.players.length) {
                            object.players = [];
                            for (var j = 0; j < message.players.length; ++j)
                                object.players[j] = $root.message.input.GameState.Data.Robot.toObject(message.players[j], options);
                        }
                        return object;
                    };

                    /**
                     * Creates a plain object from this Team message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Team.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Team to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Team.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Team;
                })();

                return Data;
            })();

            return GameState;
        })();

        input.Image = (function() {

            /**
             * Properties of an Image.
             * @typedef message.input.Image$Properties
             * @type {Object}
             * @property {number} [format] Image format.
             * @property {uvec2$Properties} [dimensions] Image dimensions.
             * @property {Uint8Array} [data] Image data.
             * @property {number} [cameraId] Image cameraId.
             * @property {string} [serialNumber] Image serialNumber.
             * @property {google.protobuf.Timestamp$Properties} [timestamp] Image timestamp.
             */

            /**
             * Constructs a new Image.
             * @exports message.input.Image
             * @constructor
             * @param {message.input.Image$Properties=} [properties] Properties to set
             */
            function Image(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Image format.
             * @type {number}
             */
            Image.prototype.format = 0;

            /**
             * Image dimensions.
             * @type {(uvec2$Properties|null)}
             */
            Image.prototype.dimensions = null;

            /**
             * Image data.
             * @type {Uint8Array}
             */
            Image.prototype.data = $util.newBuffer([]);

            /**
             * Image cameraId.
             * @type {number}
             */
            Image.prototype.cameraId = 0;

            /**
             * Image serialNumber.
             * @type {string}
             */
            Image.prototype.serialNumber = "";

            /**
             * Image timestamp.
             * @type {(google.protobuf.Timestamp$Properties|null)}
             */
            Image.prototype.timestamp = null;

            /**
             * Creates a new Image instance using the specified properties.
             * @param {message.input.Image$Properties=} [properties] Properties to set
             * @returns {message.input.Image} Image instance
             */
            Image.create = function create(properties) {
                return new Image(properties);
            };

            /**
             * Encodes the specified Image message. Does not implicitly {@link message.input.Image.verify|verify} messages.
             * @param {message.input.Image$Properties} message Image message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Image.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.format != null && message.hasOwnProperty("format"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.format);
                if (message.dimensions != null && message.hasOwnProperty("dimensions"))
                    $root.uvec2.encode(message.dimensions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.data != null && message.hasOwnProperty("data"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                if (message.cameraId != null && message.hasOwnProperty("cameraId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.cameraId);
                if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.serialNumber);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Image message, length delimited. Does not implicitly {@link message.input.Image.verify|verify} messages.
             * @param {message.input.Image$Properties} message Image message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Image.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Image message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.Image} Image
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Image.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.Image();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.format = reader.uint32();
                        break;
                    case 2:
                        message.dimensions = $root.uvec2.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.data = reader.bytes();
                        break;
                    case 4:
                        message.cameraId = reader.uint32();
                        break;
                    case 5:
                        message.serialNumber = reader.string();
                        break;
                    case 6:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Image message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.Image} Image
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Image.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Image message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Image.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.format != null && message.hasOwnProperty("format"))
                    if (!$util.isInteger(message.format))
                        return "format: integer expected";
                if (message.dimensions != null && message.hasOwnProperty("dimensions")) {
                    var error = $root.uvec2.verify(message.dimensions);
                    if (error)
                        return "dimensions." + error;
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                if (message.cameraId != null && message.hasOwnProperty("cameraId"))
                    if (!$util.isInteger(message.cameraId))
                        return "cameraId: integer expected";
                if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
                    if (!$util.isString(message.serialNumber))
                        return "serialNumber: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                return null;
            };

            /**
             * Creates an Image message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.Image} Image
             */
            Image.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.Image)
                    return object;
                var message = new $root.message.input.Image();
                if (object.format != null)
                    message.format = object.format >>> 0;
                if (object.dimensions != null) {
                    if (typeof object.dimensions !== "object")
                        throw TypeError(".message.input.Image.dimensions: object expected");
                    message.dimensions = $root.uvec2.fromObject(object.dimensions);
                }
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                if (object.cameraId != null)
                    message.cameraId = object.cameraId >>> 0;
                if (object.serialNumber != null)
                    message.serialNumber = String(object.serialNumber);
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".message.input.Image.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                return message;
            };

            /**
             * Creates an Image message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.Image.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.Image} Image
             */
            Image.from = Image.fromObject;

            /**
             * Creates a plain object from an Image message. Also converts values to other types if specified.
             * @param {message.input.Image} message Image
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Image.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.format = 0;
                    object.dimensions = null;
                    object.data = options.bytes === String ? "" : [];
                    object.cameraId = 0;
                    object.serialNumber = "";
                    object.timestamp = null;
                }
                if (message.format != null && message.hasOwnProperty("format"))
                    object.format = message.format;
                if (message.dimensions != null && message.hasOwnProperty("dimensions"))
                    object.dimensions = $root.uvec2.toObject(message.dimensions, options);
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                if (message.cameraId != null && message.hasOwnProperty("cameraId"))
                    object.cameraId = message.cameraId;
                if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
                    object.serialNumber = message.serialNumber;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                return object;
            };

            /**
             * Creates a plain object from this Image message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Image.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Image to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Image.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Image;
        })();

        input.ImageFragment = (function() {

            /**
             * Properties of an ImageFragment.
             * @typedef message.input.ImageFragment$Properties
             * @type {Object}
             * @property {message.input.Image$Properties} [image] ImageFragment image.
             * @property {number} [start] ImageFragment start.
             * @property {number} [end] ImageFragment end.
             * @property {fmat44$Properties} [camToFeet] ImageFragment camToFeet.
             */

            /**
             * Constructs a new ImageFragment.
             * @exports message.input.ImageFragment
             * @constructor
             * @param {message.input.ImageFragment$Properties=} [properties] Properties to set
             */
            function ImageFragment(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ImageFragment image.
             * @type {(message.input.Image$Properties|null)}
             */
            ImageFragment.prototype.image = null;

            /**
             * ImageFragment start.
             * @type {number}
             */
            ImageFragment.prototype.start = 0;

            /**
             * ImageFragment end.
             * @type {number}
             */
            ImageFragment.prototype.end = 0;

            /**
             * ImageFragment camToFeet.
             * @type {(fmat44$Properties|null)}
             */
            ImageFragment.prototype.camToFeet = null;

            /**
             * Creates a new ImageFragment instance using the specified properties.
             * @param {message.input.ImageFragment$Properties=} [properties] Properties to set
             * @returns {message.input.ImageFragment} ImageFragment instance
             */
            ImageFragment.create = function create(properties) {
                return new ImageFragment(properties);
            };

            /**
             * Encodes the specified ImageFragment message. Does not implicitly {@link message.input.ImageFragment.verify|verify} messages.
             * @param {message.input.ImageFragment$Properties} message ImageFragment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImageFragment.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.image != null && message.hasOwnProperty("image"))
                    $root.message.input.Image.encode(message.image, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.start != null && message.hasOwnProperty("start"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.start);
                if (message.end != null && message.hasOwnProperty("end"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.end);
                if (message.camToFeet != null && message.hasOwnProperty("camToFeet"))
                    $root.fmat44.encode(message.camToFeet, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ImageFragment message, length delimited. Does not implicitly {@link message.input.ImageFragment.verify|verify} messages.
             * @param {message.input.ImageFragment$Properties} message ImageFragment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImageFragment.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImageFragment message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.ImageFragment} ImageFragment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImageFragment.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.ImageFragment();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.image = $root.message.input.Image.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.start = reader.uint32();
                        break;
                    case 6:
                        message.end = reader.uint32();
                        break;
                    case 7:
                        message.camToFeet = $root.fmat44.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImageFragment message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.ImageFragment} ImageFragment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImageFragment.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImageFragment message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ImageFragment.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.image != null && message.hasOwnProperty("image")) {
                    var error = $root.message.input.Image.verify(message.image);
                    if (error)
                        return "image." + error;
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    if (!$util.isInteger(message.start))
                        return "start: integer expected";
                if (message.end != null && message.hasOwnProperty("end"))
                    if (!$util.isInteger(message.end))
                        return "end: integer expected";
                if (message.camToFeet != null && message.hasOwnProperty("camToFeet")) {
                    var error = $root.fmat44.verify(message.camToFeet);
                    if (error)
                        return "camToFeet." + error;
                }
                return null;
            };

            /**
             * Creates an ImageFragment message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.ImageFragment} ImageFragment
             */
            ImageFragment.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.ImageFragment)
                    return object;
                var message = new $root.message.input.ImageFragment();
                if (object.image != null) {
                    if (typeof object.image !== "object")
                        throw TypeError(".message.input.ImageFragment.image: object expected");
                    message.image = $root.message.input.Image.fromObject(object.image);
                }
                if (object.start != null)
                    message.start = object.start >>> 0;
                if (object.end != null)
                    message.end = object.end >>> 0;
                if (object.camToFeet != null) {
                    if (typeof object.camToFeet !== "object")
                        throw TypeError(".message.input.ImageFragment.camToFeet: object expected");
                    message.camToFeet = $root.fmat44.fromObject(object.camToFeet);
                }
                return message;
            };

            /**
             * Creates an ImageFragment message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.ImageFragment.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.ImageFragment} ImageFragment
             */
            ImageFragment.from = ImageFragment.fromObject;

            /**
             * Creates a plain object from an ImageFragment message. Also converts values to other types if specified.
             * @param {message.input.ImageFragment} message ImageFragment
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImageFragment.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.image = null;
                    object.start = 0;
                    object.end = 0;
                    object.camToFeet = null;
                }
                if (message.image != null && message.hasOwnProperty("image"))
                    object.image = $root.message.input.Image.toObject(message.image, options);
                if (message.start != null && message.hasOwnProperty("start"))
                    object.start = message.start;
                if (message.end != null && message.hasOwnProperty("end"))
                    object.end = message.end;
                if (message.camToFeet != null && message.hasOwnProperty("camToFeet"))
                    object.camToFeet = $root.fmat44.toObject(message.camToFeet, options);
                return object;
            };

            /**
             * Creates a plain object from this ImageFragment message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImageFragment.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ImageFragment to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ImageFragment.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ImageFragment;
        })();

        input.MotionCapture = (function() {

            /**
             * Properties of a MotionCapture.
             * @typedef message.input.MotionCapture$Properties
             * @type {Object}
             * @property {number} [frameNumber] MotionCapture frameNumber.
             * @property {number} [latency] MotionCapture latency.
             * @property {number} [timecode] MotionCapture timecode.
             * @property {number} [timecodeSub] MotionCapture timecodeSub.
             * @property {number} [timestamp] MotionCapture timestamp.
             * @property {boolean} [recording] MotionCapture recording.
             * @property {boolean} [trackedModelsChanged] MotionCapture trackedModelsChanged.
             * @property {Array.<message.input.MotionCapture.MarkerSet$Properties>} [markerSets] MotionCapture markerSets.
             * @property {Array.<message.input.MotionCapture.Marker$Properties>} [markers] MotionCapture markers.
             * @property {Array.<message.input.MotionCapture.RigidBody$Properties>} [rigidBodies] MotionCapture rigidBodies.
             * @property {Array.<message.input.MotionCapture.Skeleton$Properties>} [skeletons] MotionCapture skeletons.
             * @property {Array.<message.input.MotionCapture.LabeledMarker$Properties>} [labeledMarkers] MotionCapture labeledMarkers.
             * @property {Array.<message.input.MotionCapture.ForcePlate$Properties>} [forcePlates] MotionCapture forcePlates.
             */

            /**
             * Constructs a new MotionCapture.
             * @exports message.input.MotionCapture
             * @constructor
             * @param {message.input.MotionCapture$Properties=} [properties] Properties to set
             */
            function MotionCapture(properties) {
                this.markerSets = [];
                this.markers = [];
                this.rigidBodies = [];
                this.skeletons = [];
                this.labeledMarkers = [];
                this.forcePlates = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MotionCapture frameNumber.
             * @type {number}
             */
            MotionCapture.prototype.frameNumber = 0;

            /**
             * MotionCapture latency.
             * @type {number}
             */
            MotionCapture.prototype.latency = 0;

            /**
             * MotionCapture timecode.
             * @type {number}
             */
            MotionCapture.prototype.timecode = 0;

            /**
             * MotionCapture timecodeSub.
             * @type {number}
             */
            MotionCapture.prototype.timecodeSub = 0;

            /**
             * MotionCapture timestamp.
             * @type {number}
             */
            MotionCapture.prototype.timestamp = 0;

            /**
             * MotionCapture recording.
             * @type {boolean}
             */
            MotionCapture.prototype.recording = false;

            /**
             * MotionCapture trackedModelsChanged.
             * @type {boolean}
             */
            MotionCapture.prototype.trackedModelsChanged = false;

            /**
             * MotionCapture markerSets.
             * @type {Array.<message.input.MotionCapture.MarkerSet$Properties>}
             */
            MotionCapture.prototype.markerSets = $util.emptyArray;

            /**
             * MotionCapture markers.
             * @type {Array.<message.input.MotionCapture.Marker$Properties>}
             */
            MotionCapture.prototype.markers = $util.emptyArray;

            /**
             * MotionCapture rigidBodies.
             * @type {Array.<message.input.MotionCapture.RigidBody$Properties>}
             */
            MotionCapture.prototype.rigidBodies = $util.emptyArray;

            /**
             * MotionCapture skeletons.
             * @type {Array.<message.input.MotionCapture.Skeleton$Properties>}
             */
            MotionCapture.prototype.skeletons = $util.emptyArray;

            /**
             * MotionCapture labeledMarkers.
             * @type {Array.<message.input.MotionCapture.LabeledMarker$Properties>}
             */
            MotionCapture.prototype.labeledMarkers = $util.emptyArray;

            /**
             * MotionCapture forcePlates.
             * @type {Array.<message.input.MotionCapture.ForcePlate$Properties>}
             */
            MotionCapture.prototype.forcePlates = $util.emptyArray;

            /**
             * Creates a new MotionCapture instance using the specified properties.
             * @param {message.input.MotionCapture$Properties=} [properties] Properties to set
             * @returns {message.input.MotionCapture} MotionCapture instance
             */
            MotionCapture.create = function create(properties) {
                return new MotionCapture(properties);
            };

            /**
             * Encodes the specified MotionCapture message. Does not implicitly {@link message.input.MotionCapture.verify|verify} messages.
             * @param {message.input.MotionCapture$Properties} message MotionCapture message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MotionCapture.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frameNumber != null && message.hasOwnProperty("frameNumber"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.frameNumber);
                if (message.latency != null && message.hasOwnProperty("latency"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.latency);
                if (message.timecode != null && message.hasOwnProperty("timecode"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timecode);
                if (message.timecodeSub != null && message.hasOwnProperty("timecodeSub"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.timecodeSub);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.timestamp);
                if (message.recording != null && message.hasOwnProperty("recording"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.recording);
                if (message.trackedModelsChanged != null && message.hasOwnProperty("trackedModelsChanged"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.trackedModelsChanged);
                if (message.markerSets != null && message.markerSets.length)
                    for (var i = 0; i < message.markerSets.length; ++i)
                        $root.message.input.MotionCapture.MarkerSet.encode(message.markerSets[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.markers != null && message.markers.length)
                    for (var i = 0; i < message.markers.length; ++i)
                        $root.message.input.MotionCapture.Marker.encode(message.markers[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.rigidBodies != null && message.rigidBodies.length)
                    for (var i = 0; i < message.rigidBodies.length; ++i)
                        $root.message.input.MotionCapture.RigidBody.encode(message.rigidBodies[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.skeletons != null && message.skeletons.length)
                    for (var i = 0; i < message.skeletons.length; ++i)
                        $root.message.input.MotionCapture.Skeleton.encode(message.skeletons[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.labeledMarkers != null && message.labeledMarkers.length)
                    for (var i = 0; i < message.labeledMarkers.length; ++i)
                        $root.message.input.MotionCapture.LabeledMarker.encode(message.labeledMarkers[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.forcePlates != null && message.forcePlates.length)
                    for (var i = 0; i < message.forcePlates.length; ++i)
                        $root.message.input.MotionCapture.ForcePlate.encode(message.forcePlates[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MotionCapture message, length delimited. Does not implicitly {@link message.input.MotionCapture.verify|verify} messages.
             * @param {message.input.MotionCapture$Properties} message MotionCapture message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MotionCapture.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MotionCapture message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.MotionCapture} MotionCapture
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MotionCapture.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.frameNumber = reader.uint32();
                        break;
                    case 2:
                        message.latency = reader.float();
                        break;
                    case 3:
                        message.timecode = reader.uint32();
                        break;
                    case 4:
                        message.timecodeSub = reader.uint32();
                        break;
                    case 5:
                        message.timestamp = reader.double();
                        break;
                    case 6:
                        message.recording = reader.bool();
                        break;
                    case 7:
                        message.trackedModelsChanged = reader.bool();
                        break;
                    case 8:
                        if (!(message.markerSets && message.markerSets.length))
                            message.markerSets = [];
                        message.markerSets.push($root.message.input.MotionCapture.MarkerSet.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.markers && message.markers.length))
                            message.markers = [];
                        message.markers.push($root.message.input.MotionCapture.Marker.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.rigidBodies && message.rigidBodies.length))
                            message.rigidBodies = [];
                        message.rigidBodies.push($root.message.input.MotionCapture.RigidBody.decode(reader, reader.uint32()));
                        break;
                    case 11:
                        if (!(message.skeletons && message.skeletons.length))
                            message.skeletons = [];
                        message.skeletons.push($root.message.input.MotionCapture.Skeleton.decode(reader, reader.uint32()));
                        break;
                    case 12:
                        if (!(message.labeledMarkers && message.labeledMarkers.length))
                            message.labeledMarkers = [];
                        message.labeledMarkers.push($root.message.input.MotionCapture.LabeledMarker.decode(reader, reader.uint32()));
                        break;
                    case 13:
                        if (!(message.forcePlates && message.forcePlates.length))
                            message.forcePlates = [];
                        message.forcePlates.push($root.message.input.MotionCapture.ForcePlate.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MotionCapture message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.MotionCapture} MotionCapture
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MotionCapture.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MotionCapture message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            MotionCapture.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.frameNumber != null && message.hasOwnProperty("frameNumber"))
                    if (!$util.isInteger(message.frameNumber))
                        return "frameNumber: integer expected";
                if (message.latency != null && message.hasOwnProperty("latency"))
                    if (typeof message.latency !== "number")
                        return "latency: number expected";
                if (message.timecode != null && message.hasOwnProperty("timecode"))
                    if (!$util.isInteger(message.timecode))
                        return "timecode: integer expected";
                if (message.timecodeSub != null && message.hasOwnProperty("timecodeSub"))
                    if (!$util.isInteger(message.timecodeSub))
                        return "timecodeSub: integer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp !== "number")
                        return "timestamp: number expected";
                if (message.recording != null && message.hasOwnProperty("recording"))
                    if (typeof message.recording !== "boolean")
                        return "recording: boolean expected";
                if (message.trackedModelsChanged != null && message.hasOwnProperty("trackedModelsChanged"))
                    if (typeof message.trackedModelsChanged !== "boolean")
                        return "trackedModelsChanged: boolean expected";
                if (message.markerSets != null && message.hasOwnProperty("markerSets")) {
                    if (!Array.isArray(message.markerSets))
                        return "markerSets: array expected";
                    for (var i = 0; i < message.markerSets.length; ++i) {
                        var error = $root.message.input.MotionCapture.MarkerSet.verify(message.markerSets[i]);
                        if (error)
                            return "markerSets." + error;
                    }
                }
                if (message.markers != null && message.hasOwnProperty("markers")) {
                    if (!Array.isArray(message.markers))
                        return "markers: array expected";
                    for (var i = 0; i < message.markers.length; ++i) {
                        var error = $root.message.input.MotionCapture.Marker.verify(message.markers[i]);
                        if (error)
                            return "markers." + error;
                    }
                }
                if (message.rigidBodies != null && message.hasOwnProperty("rigidBodies")) {
                    if (!Array.isArray(message.rigidBodies))
                        return "rigidBodies: array expected";
                    for (var i = 0; i < message.rigidBodies.length; ++i) {
                        var error = $root.message.input.MotionCapture.RigidBody.verify(message.rigidBodies[i]);
                        if (error)
                            return "rigidBodies." + error;
                    }
                }
                if (message.skeletons != null && message.hasOwnProperty("skeletons")) {
                    if (!Array.isArray(message.skeletons))
                        return "skeletons: array expected";
                    for (var i = 0; i < message.skeletons.length; ++i) {
                        var error = $root.message.input.MotionCapture.Skeleton.verify(message.skeletons[i]);
                        if (error)
                            return "skeletons." + error;
                    }
                }
                if (message.labeledMarkers != null && message.hasOwnProperty("labeledMarkers")) {
                    if (!Array.isArray(message.labeledMarkers))
                        return "labeledMarkers: array expected";
                    for (var i = 0; i < message.labeledMarkers.length; ++i) {
                        var error = $root.message.input.MotionCapture.LabeledMarker.verify(message.labeledMarkers[i]);
                        if (error)
                            return "labeledMarkers." + error;
                    }
                }
                if (message.forcePlates != null && message.hasOwnProperty("forcePlates")) {
                    if (!Array.isArray(message.forcePlates))
                        return "forcePlates: array expected";
                    for (var i = 0; i < message.forcePlates.length; ++i) {
                        var error = $root.message.input.MotionCapture.ForcePlate.verify(message.forcePlates[i]);
                        if (error)
                            return "forcePlates." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MotionCapture message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.MotionCapture} MotionCapture
             */
            MotionCapture.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.MotionCapture)
                    return object;
                var message = new $root.message.input.MotionCapture();
                if (object.frameNumber != null)
                    message.frameNumber = object.frameNumber >>> 0;
                if (object.latency != null)
                    message.latency = Number(object.latency);
                if (object.timecode != null)
                    message.timecode = object.timecode >>> 0;
                if (object.timecodeSub != null)
                    message.timecodeSub = object.timecodeSub >>> 0;
                if (object.timestamp != null)
                    message.timestamp = Number(object.timestamp);
                if (object.recording != null)
                    message.recording = Boolean(object.recording);
                if (object.trackedModelsChanged != null)
                    message.trackedModelsChanged = Boolean(object.trackedModelsChanged);
                if (object.markerSets) {
                    if (!Array.isArray(object.markerSets))
                        throw TypeError(".message.input.MotionCapture.markerSets: array expected");
                    message.markerSets = [];
                    for (var i = 0; i < object.markerSets.length; ++i) {
                        if (typeof object.markerSets[i] !== "object")
                            throw TypeError(".message.input.MotionCapture.markerSets: object expected");
                        message.markerSets[i] = $root.message.input.MotionCapture.MarkerSet.fromObject(object.markerSets[i]);
                    }
                }
                if (object.markers) {
                    if (!Array.isArray(object.markers))
                        throw TypeError(".message.input.MotionCapture.markers: array expected");
                    message.markers = [];
                    for (var i = 0; i < object.markers.length; ++i) {
                        if (typeof object.markers[i] !== "object")
                            throw TypeError(".message.input.MotionCapture.markers: object expected");
                        message.markers[i] = $root.message.input.MotionCapture.Marker.fromObject(object.markers[i]);
                    }
                }
                if (object.rigidBodies) {
                    if (!Array.isArray(object.rigidBodies))
                        throw TypeError(".message.input.MotionCapture.rigidBodies: array expected");
                    message.rigidBodies = [];
                    for (var i = 0; i < object.rigidBodies.length; ++i) {
                        if (typeof object.rigidBodies[i] !== "object")
                            throw TypeError(".message.input.MotionCapture.rigidBodies: object expected");
                        message.rigidBodies[i] = $root.message.input.MotionCapture.RigidBody.fromObject(object.rigidBodies[i]);
                    }
                }
                if (object.skeletons) {
                    if (!Array.isArray(object.skeletons))
                        throw TypeError(".message.input.MotionCapture.skeletons: array expected");
                    message.skeletons = [];
                    for (var i = 0; i < object.skeletons.length; ++i) {
                        if (typeof object.skeletons[i] !== "object")
                            throw TypeError(".message.input.MotionCapture.skeletons: object expected");
                        message.skeletons[i] = $root.message.input.MotionCapture.Skeleton.fromObject(object.skeletons[i]);
                    }
                }
                if (object.labeledMarkers) {
                    if (!Array.isArray(object.labeledMarkers))
                        throw TypeError(".message.input.MotionCapture.labeledMarkers: array expected");
                    message.labeledMarkers = [];
                    for (var i = 0; i < object.labeledMarkers.length; ++i) {
                        if (typeof object.labeledMarkers[i] !== "object")
                            throw TypeError(".message.input.MotionCapture.labeledMarkers: object expected");
                        message.labeledMarkers[i] = $root.message.input.MotionCapture.LabeledMarker.fromObject(object.labeledMarkers[i]);
                    }
                }
                if (object.forcePlates) {
                    if (!Array.isArray(object.forcePlates))
                        throw TypeError(".message.input.MotionCapture.forcePlates: array expected");
                    message.forcePlates = [];
                    for (var i = 0; i < object.forcePlates.length; ++i) {
                        if (typeof object.forcePlates[i] !== "object")
                            throw TypeError(".message.input.MotionCapture.forcePlates: object expected");
                        message.forcePlates[i] = $root.message.input.MotionCapture.ForcePlate.fromObject(object.forcePlates[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a MotionCapture message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.MotionCapture.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.MotionCapture} MotionCapture
             */
            MotionCapture.from = MotionCapture.fromObject;

            /**
             * Creates a plain object from a MotionCapture message. Also converts values to other types if specified.
             * @param {message.input.MotionCapture} message MotionCapture
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MotionCapture.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.markerSets = [];
                    object.markers = [];
                    object.rigidBodies = [];
                    object.skeletons = [];
                    object.labeledMarkers = [];
                    object.forcePlates = [];
                }
                if (options.defaults) {
                    object.frameNumber = 0;
                    object.latency = 0;
                    object.timecode = 0;
                    object.timecodeSub = 0;
                    object.timestamp = 0;
                    object.recording = false;
                    object.trackedModelsChanged = false;
                }
                if (message.frameNumber != null && message.hasOwnProperty("frameNumber"))
                    object.frameNumber = message.frameNumber;
                if (message.latency != null && message.hasOwnProperty("latency"))
                    object.latency = message.latency;
                if (message.timecode != null && message.hasOwnProperty("timecode"))
                    object.timecode = message.timecode;
                if (message.timecodeSub != null && message.hasOwnProperty("timecodeSub"))
                    object.timecodeSub = message.timecodeSub;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = message.timestamp;
                if (message.recording != null && message.hasOwnProperty("recording"))
                    object.recording = message.recording;
                if (message.trackedModelsChanged != null && message.hasOwnProperty("trackedModelsChanged"))
                    object.trackedModelsChanged = message.trackedModelsChanged;
                if (message.markerSets && message.markerSets.length) {
                    object.markerSets = [];
                    for (var j = 0; j < message.markerSets.length; ++j)
                        object.markerSets[j] = $root.message.input.MotionCapture.MarkerSet.toObject(message.markerSets[j], options);
                }
                if (message.markers && message.markers.length) {
                    object.markers = [];
                    for (var j = 0; j < message.markers.length; ++j)
                        object.markers[j] = $root.message.input.MotionCapture.Marker.toObject(message.markers[j], options);
                }
                if (message.rigidBodies && message.rigidBodies.length) {
                    object.rigidBodies = [];
                    for (var j = 0; j < message.rigidBodies.length; ++j)
                        object.rigidBodies[j] = $root.message.input.MotionCapture.RigidBody.toObject(message.rigidBodies[j], options);
                }
                if (message.skeletons && message.skeletons.length) {
                    object.skeletons = [];
                    for (var j = 0; j < message.skeletons.length; ++j)
                        object.skeletons[j] = $root.message.input.MotionCapture.Skeleton.toObject(message.skeletons[j], options);
                }
                if (message.labeledMarkers && message.labeledMarkers.length) {
                    object.labeledMarkers = [];
                    for (var j = 0; j < message.labeledMarkers.length; ++j)
                        object.labeledMarkers[j] = $root.message.input.MotionCapture.LabeledMarker.toObject(message.labeledMarkers[j], options);
                }
                if (message.forcePlates && message.forcePlates.length) {
                    object.forcePlates = [];
                    for (var j = 0; j < message.forcePlates.length; ++j)
                        object.forcePlates[j] = $root.message.input.MotionCapture.ForcePlate.toObject(message.forcePlates[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this MotionCapture message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MotionCapture.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this MotionCapture to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            MotionCapture.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            MotionCapture.Marker = (function() {

                /**
                 * Properties of a Marker.
                 * @typedef message.input.MotionCapture.Marker$Properties
                 * @type {Object}
                 * @property {number} [id] Marker id.
                 * @property {fvec3$Properties} [position] Marker position.
                 * @property {number} [size] Marker size.
                 */

                /**
                 * Constructs a new Marker.
                 * @exports message.input.MotionCapture.Marker
                 * @constructor
                 * @param {message.input.MotionCapture.Marker$Properties=} [properties] Properties to set
                 */
                function Marker(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Marker id.
                 * @type {number}
                 */
                Marker.prototype.id = 0;

                /**
                 * Marker position.
                 * @type {(fvec3$Properties|null)}
                 */
                Marker.prototype.position = null;

                /**
                 * Marker size.
                 * @type {number}
                 */
                Marker.prototype.size = 0;

                /**
                 * Creates a new Marker instance using the specified properties.
                 * @param {message.input.MotionCapture.Marker$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.Marker} Marker instance
                 */
                Marker.create = function create(properties) {
                    return new Marker(properties);
                };

                /**
                 * Encodes the specified Marker message. Does not implicitly {@link message.input.MotionCapture.Marker.verify|verify} messages.
                 * @param {message.input.MotionCapture.Marker$Properties} message Marker message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Marker.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.position != null && message.hasOwnProperty("position"))
                        $root.fvec3.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.size != null && message.hasOwnProperty("size"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.size);
                    return writer;
                };

                /**
                 * Encodes the specified Marker message, length delimited. Does not implicitly {@link message.input.MotionCapture.Marker.verify|verify} messages.
                 * @param {message.input.MotionCapture.Marker$Properties} message Marker message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Marker.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Marker message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.Marker} Marker
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Marker.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.Marker();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            message.position = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.size = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Marker message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.Marker} Marker
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Marker.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Marker message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Marker.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.position != null && message.hasOwnProperty("position")) {
                        var error = $root.fvec3.verify(message.position);
                        if (error)
                            return "position." + error;
                    }
                    if (message.size != null && message.hasOwnProperty("size"))
                        if (typeof message.size !== "number")
                            return "size: number expected";
                    return null;
                };

                /**
                 * Creates a Marker message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.Marker} Marker
                 */
                Marker.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.MotionCapture.Marker)
                        return object;
                    var message = new $root.message.input.MotionCapture.Marker();
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.position != null) {
                        if (typeof object.position !== "object")
                            throw TypeError(".message.input.MotionCapture.Marker.position: object expected");
                        message.position = $root.fvec3.fromObject(object.position);
                    }
                    if (object.size != null)
                        message.size = Number(object.size);
                    return message;
                };

                /**
                 * Creates a Marker message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.Marker.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.Marker} Marker
                 */
                Marker.from = Marker.fromObject;

                /**
                 * Creates a plain object from a Marker message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.Marker} message Marker
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Marker.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = 0;
                        object.position = null;
                        object.size = 0;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.position != null && message.hasOwnProperty("position"))
                        object.position = $root.fvec3.toObject(message.position, options);
                    if (message.size != null && message.hasOwnProperty("size"))
                        object.size = message.size;
                    return object;
                };

                /**
                 * Creates a plain object from this Marker message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Marker.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Marker to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Marker.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Marker;
            })();

            MotionCapture.MarkerSet = (function() {

                /**
                 * Properties of a MarkerSet.
                 * @typedef message.input.MotionCapture.MarkerSet$Properties
                 * @type {Object}
                 * @property {string} [name] MarkerSet name.
                 * @property {Array.<message.input.MotionCapture.Marker$Properties>} [markers] MarkerSet markers.
                 */

                /**
                 * Constructs a new MarkerSet.
                 * @exports message.input.MotionCapture.MarkerSet
                 * @constructor
                 * @param {message.input.MotionCapture.MarkerSet$Properties=} [properties] Properties to set
                 */
                function MarkerSet(properties) {
                    this.markers = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MarkerSet name.
                 * @type {string}
                 */
                MarkerSet.prototype.name = "";

                /**
                 * MarkerSet markers.
                 * @type {Array.<message.input.MotionCapture.Marker$Properties>}
                 */
                MarkerSet.prototype.markers = $util.emptyArray;

                /**
                 * Creates a new MarkerSet instance using the specified properties.
                 * @param {message.input.MotionCapture.MarkerSet$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.MarkerSet} MarkerSet instance
                 */
                MarkerSet.create = function create(properties) {
                    return new MarkerSet(properties);
                };

                /**
                 * Encodes the specified MarkerSet message. Does not implicitly {@link message.input.MotionCapture.MarkerSet.verify|verify} messages.
                 * @param {message.input.MotionCapture.MarkerSet$Properties} message MarkerSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MarkerSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.markers != null && message.markers.length)
                        for (var i = 0; i < message.markers.length; ++i)
                            $root.message.input.MotionCapture.Marker.encode(message.markers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MarkerSet message, length delimited. Does not implicitly {@link message.input.MotionCapture.MarkerSet.verify|verify} messages.
                 * @param {message.input.MotionCapture.MarkerSet$Properties} message MarkerSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MarkerSet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MarkerSet message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.MarkerSet} MarkerSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MarkerSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.MarkerSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.markers && message.markers.length))
                                message.markers = [];
                            message.markers.push($root.message.input.MotionCapture.Marker.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MarkerSet message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.MarkerSet} MarkerSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MarkerSet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MarkerSet message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                MarkerSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.markers != null && message.hasOwnProperty("markers")) {
                        if (!Array.isArray(message.markers))
                            return "markers: array expected";
                        for (var i = 0; i < message.markers.length; ++i) {
                            var error = $root.message.input.MotionCapture.Marker.verify(message.markers[i]);
                            if (error)
                                return "markers." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MarkerSet message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.MarkerSet} MarkerSet
                 */
                MarkerSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.MotionCapture.MarkerSet)
                        return object;
                    var message = new $root.message.input.MotionCapture.MarkerSet();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.markers) {
                        if (!Array.isArray(object.markers))
                            throw TypeError(".message.input.MotionCapture.MarkerSet.markers: array expected");
                        message.markers = [];
                        for (var i = 0; i < object.markers.length; ++i) {
                            if (typeof object.markers[i] !== "object")
                                throw TypeError(".message.input.MotionCapture.MarkerSet.markers: object expected");
                            message.markers[i] = $root.message.input.MotionCapture.Marker.fromObject(object.markers[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a MarkerSet message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.MarkerSet.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.MarkerSet} MarkerSet
                 */
                MarkerSet.from = MarkerSet.fromObject;

                /**
                 * Creates a plain object from a MarkerSet message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.MarkerSet} message MarkerSet
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MarkerSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.markers = [];
                    if (options.defaults)
                        object.name = "";
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.markers && message.markers.length) {
                        object.markers = [];
                        for (var j = 0; j < message.markers.length; ++j)
                            object.markers[j] = $root.message.input.MotionCapture.Marker.toObject(message.markers[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this MarkerSet message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MarkerSet.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this MarkerSet to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                MarkerSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MarkerSet;
            })();

            MotionCapture.RigidBody = (function() {

                /**
                 * Properties of a RigidBody.
                 * @typedef message.input.MotionCapture.RigidBody$Properties
                 * @type {Object}
                 * @property {number} [id] RigidBody id.
                 * @property {fvec3$Properties} [position] RigidBody position.
                 * @property {fvec4$Properties} [rotation] RigidBody rotation.
                 * @property {Array.<message.input.MotionCapture.Marker$Properties>} [markers] RigidBody markers.
                 * @property {number} [error] RigidBody error.
                 * @property {boolean} [trackingValid] RigidBody trackingValid.
                 * @property {string} [name] RigidBody name.
                 * @property {fvec3$Properties} [offset] RigidBody offset.
                 * @property {number} [parent] RigidBody parent.
                 * @property {Array.<number>} [children] RigidBody children.
                 */

                /**
                 * Constructs a new RigidBody.
                 * @exports message.input.MotionCapture.RigidBody
                 * @constructor
                 * @param {message.input.MotionCapture.RigidBody$Properties=} [properties] Properties to set
                 */
                function RigidBody(properties) {
                    this.markers = [];
                    this.children = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RigidBody id.
                 * @type {number}
                 */
                RigidBody.prototype.id = 0;

                /**
                 * RigidBody position.
                 * @type {(fvec3$Properties|null)}
                 */
                RigidBody.prototype.position = null;

                /**
                 * RigidBody rotation.
                 * @type {(fvec4$Properties|null)}
                 */
                RigidBody.prototype.rotation = null;

                /**
                 * RigidBody markers.
                 * @type {Array.<message.input.MotionCapture.Marker$Properties>}
                 */
                RigidBody.prototype.markers = $util.emptyArray;

                /**
                 * RigidBody error.
                 * @type {number}
                 */
                RigidBody.prototype.error = 0;

                /**
                 * RigidBody trackingValid.
                 * @type {boolean}
                 */
                RigidBody.prototype.trackingValid = false;

                /**
                 * RigidBody name.
                 * @type {string}
                 */
                RigidBody.prototype.name = "";

                /**
                 * RigidBody offset.
                 * @type {(fvec3$Properties|null)}
                 */
                RigidBody.prototype.offset = null;

                /**
                 * RigidBody parent.
                 * @type {number}
                 */
                RigidBody.prototype.parent = 0;

                /**
                 * RigidBody children.
                 * @type {Array.<number>}
                 */
                RigidBody.prototype.children = $util.emptyArray;

                /**
                 * Creates a new RigidBody instance using the specified properties.
                 * @param {message.input.MotionCapture.RigidBody$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.RigidBody} RigidBody instance
                 */
                RigidBody.create = function create(properties) {
                    return new RigidBody(properties);
                };

                /**
                 * Encodes the specified RigidBody message. Does not implicitly {@link message.input.MotionCapture.RigidBody.verify|verify} messages.
                 * @param {message.input.MotionCapture.RigidBody$Properties} message RigidBody message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RigidBody.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.position != null && message.hasOwnProperty("position"))
                        $root.fvec3.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.rotation != null && message.hasOwnProperty("rotation"))
                        $root.fvec4.encode(message.rotation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.markers != null && message.markers.length)
                        for (var i = 0; i < message.markers.length; ++i)
                            $root.message.input.MotionCapture.Marker.encode(message.markers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.error != null && message.hasOwnProperty("error"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.error);
                    if (message.trackingValid != null && message.hasOwnProperty("trackingValid"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.trackingValid);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
                    if (message.offset != null && message.hasOwnProperty("offset"))
                        $root.fvec3.encode(message.offset, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.parent != null && message.hasOwnProperty("parent"))
                        writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.parent);
                    if (message.children != null && message.children.length) {
                        writer.uint32(/* id 10, wireType 2 =*/82).fork();
                        for (var i = 0; i < message.children.length; ++i)
                            writer.uint32(message.children[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified RigidBody message, length delimited. Does not implicitly {@link message.input.MotionCapture.RigidBody.verify|verify} messages.
                 * @param {message.input.MotionCapture.RigidBody$Properties} message RigidBody message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RigidBody.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RigidBody message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.RigidBody} RigidBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RigidBody.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.RigidBody();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            message.position = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.rotation = $root.fvec4.decode(reader, reader.uint32());
                            break;
                        case 4:
                            if (!(message.markers && message.markers.length))
                                message.markers = [];
                            message.markers.push($root.message.input.MotionCapture.Marker.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            message.error = reader.float();
                            break;
                        case 6:
                            message.trackingValid = reader.bool();
                            break;
                        case 7:
                            message.name = reader.string();
                            break;
                        case 8:
                            message.offset = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.parent = reader.uint32();
                            break;
                        case 10:
                            if (!(message.children && message.children.length))
                                message.children = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.children.push(reader.uint32());
                            } else
                                message.children.push(reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RigidBody message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.RigidBody} RigidBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RigidBody.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RigidBody message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RigidBody.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.position != null && message.hasOwnProperty("position")) {
                        var error = $root.fvec3.verify(message.position);
                        if (error)
                            return "position." + error;
                    }
                    if (message.rotation != null && message.hasOwnProperty("rotation")) {
                        var error = $root.fvec4.verify(message.rotation);
                        if (error)
                            return "rotation." + error;
                    }
                    if (message.markers != null && message.hasOwnProperty("markers")) {
                        if (!Array.isArray(message.markers))
                            return "markers: array expected";
                        for (var i = 0; i < message.markers.length; ++i) {
                            var error = $root.message.input.MotionCapture.Marker.verify(message.markers[i]);
                            if (error)
                                return "markers." + error;
                        }
                    }
                    if (message.error != null && message.hasOwnProperty("error"))
                        if (typeof message.error !== "number")
                            return "error: number expected";
                    if (message.trackingValid != null && message.hasOwnProperty("trackingValid"))
                        if (typeof message.trackingValid !== "boolean")
                            return "trackingValid: boolean expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.offset != null && message.hasOwnProperty("offset")) {
                        var error = $root.fvec3.verify(message.offset);
                        if (error)
                            return "offset." + error;
                    }
                    if (message.parent != null && message.hasOwnProperty("parent"))
                        if (!$util.isInteger(message.parent))
                            return "parent: integer expected";
                    if (message.children != null && message.hasOwnProperty("children")) {
                        if (!Array.isArray(message.children))
                            return "children: array expected";
                        for (var i = 0; i < message.children.length; ++i)
                            if (!$util.isInteger(message.children[i]))
                                return "children: integer[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a RigidBody message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.RigidBody} RigidBody
                 */
                RigidBody.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.MotionCapture.RigidBody)
                        return object;
                    var message = new $root.message.input.MotionCapture.RigidBody();
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.position != null) {
                        if (typeof object.position !== "object")
                            throw TypeError(".message.input.MotionCapture.RigidBody.position: object expected");
                        message.position = $root.fvec3.fromObject(object.position);
                    }
                    if (object.rotation != null) {
                        if (typeof object.rotation !== "object")
                            throw TypeError(".message.input.MotionCapture.RigidBody.rotation: object expected");
                        message.rotation = $root.fvec4.fromObject(object.rotation);
                    }
                    if (object.markers) {
                        if (!Array.isArray(object.markers))
                            throw TypeError(".message.input.MotionCapture.RigidBody.markers: array expected");
                        message.markers = [];
                        for (var i = 0; i < object.markers.length; ++i) {
                            if (typeof object.markers[i] !== "object")
                                throw TypeError(".message.input.MotionCapture.RigidBody.markers: object expected");
                            message.markers[i] = $root.message.input.MotionCapture.Marker.fromObject(object.markers[i]);
                        }
                    }
                    if (object.error != null)
                        message.error = Number(object.error);
                    if (object.trackingValid != null)
                        message.trackingValid = Boolean(object.trackingValid);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.offset != null) {
                        if (typeof object.offset !== "object")
                            throw TypeError(".message.input.MotionCapture.RigidBody.offset: object expected");
                        message.offset = $root.fvec3.fromObject(object.offset);
                    }
                    if (object.parent != null)
                        message.parent = object.parent >>> 0;
                    if (object.children) {
                        if (!Array.isArray(object.children))
                            throw TypeError(".message.input.MotionCapture.RigidBody.children: array expected");
                        message.children = [];
                        for (var i = 0; i < object.children.length; ++i)
                            message.children[i] = object.children[i] >>> 0;
                    }
                    return message;
                };

                /**
                 * Creates a RigidBody message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.RigidBody.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.RigidBody} RigidBody
                 */
                RigidBody.from = RigidBody.fromObject;

                /**
                 * Creates a plain object from a RigidBody message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.RigidBody} message RigidBody
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RigidBody.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.markers = [];
                        object.children = [];
                    }
                    if (options.defaults) {
                        object.id = 0;
                        object.position = null;
                        object.rotation = null;
                        object.error = 0;
                        object.trackingValid = false;
                        object.name = "";
                        object.offset = null;
                        object.parent = 0;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.position != null && message.hasOwnProperty("position"))
                        object.position = $root.fvec3.toObject(message.position, options);
                    if (message.rotation != null && message.hasOwnProperty("rotation"))
                        object.rotation = $root.fvec4.toObject(message.rotation, options);
                    if (message.markers && message.markers.length) {
                        object.markers = [];
                        for (var j = 0; j < message.markers.length; ++j)
                            object.markers[j] = $root.message.input.MotionCapture.Marker.toObject(message.markers[j], options);
                    }
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = message.error;
                    if (message.trackingValid != null && message.hasOwnProperty("trackingValid"))
                        object.trackingValid = message.trackingValid;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.offset != null && message.hasOwnProperty("offset"))
                        object.offset = $root.fvec3.toObject(message.offset, options);
                    if (message.parent != null && message.hasOwnProperty("parent"))
                        object.parent = message.parent;
                    if (message.children && message.children.length) {
                        object.children = [];
                        for (var j = 0; j < message.children.length; ++j)
                            object.children[j] = message.children[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this RigidBody message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RigidBody.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RigidBody to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RigidBody.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RigidBody;
            })();

            MotionCapture.Skeleton = (function() {

                /**
                 * Properties of a Skeleton.
                 * @typedef message.input.MotionCapture.Skeleton$Properties
                 * @type {Object}
                 * @property {number} [id] Skeleton id.
                 * @property {Array.<message.input.MotionCapture.RigidBody$Properties>} [bones] Skeleton bones.
                 * @property {string} [name] Skeleton name.
                 */

                /**
                 * Constructs a new Skeleton.
                 * @exports message.input.MotionCapture.Skeleton
                 * @constructor
                 * @param {message.input.MotionCapture.Skeleton$Properties=} [properties] Properties to set
                 */
                function Skeleton(properties) {
                    this.bones = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Skeleton id.
                 * @type {number}
                 */
                Skeleton.prototype.id = 0;

                /**
                 * Skeleton bones.
                 * @type {Array.<message.input.MotionCapture.RigidBody$Properties>}
                 */
                Skeleton.prototype.bones = $util.emptyArray;

                /**
                 * Skeleton name.
                 * @type {string}
                 */
                Skeleton.prototype.name = "";

                /**
                 * Creates a new Skeleton instance using the specified properties.
                 * @param {message.input.MotionCapture.Skeleton$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.Skeleton} Skeleton instance
                 */
                Skeleton.create = function create(properties) {
                    return new Skeleton(properties);
                };

                /**
                 * Encodes the specified Skeleton message. Does not implicitly {@link message.input.MotionCapture.Skeleton.verify|verify} messages.
                 * @param {message.input.MotionCapture.Skeleton$Properties} message Skeleton message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Skeleton.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.bones != null && message.bones.length)
                        for (var i = 0; i < message.bones.length; ++i)
                            $root.message.input.MotionCapture.RigidBody.encode(message.bones[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    return writer;
                };

                /**
                 * Encodes the specified Skeleton message, length delimited. Does not implicitly {@link message.input.MotionCapture.Skeleton.verify|verify} messages.
                 * @param {message.input.MotionCapture.Skeleton$Properties} message Skeleton message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Skeleton.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Skeleton message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.Skeleton} Skeleton
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Skeleton.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.Skeleton();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            if (!(message.bones && message.bones.length))
                                message.bones = [];
                            message.bones.push($root.message.input.MotionCapture.RigidBody.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Skeleton message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.Skeleton} Skeleton
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Skeleton.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Skeleton message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Skeleton.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.bones != null && message.hasOwnProperty("bones")) {
                        if (!Array.isArray(message.bones))
                            return "bones: array expected";
                        for (var i = 0; i < message.bones.length; ++i) {
                            var error = $root.message.input.MotionCapture.RigidBody.verify(message.bones[i]);
                            if (error)
                                return "bones." + error;
                        }
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a Skeleton message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.Skeleton} Skeleton
                 */
                Skeleton.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.MotionCapture.Skeleton)
                        return object;
                    var message = new $root.message.input.MotionCapture.Skeleton();
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.bones) {
                        if (!Array.isArray(object.bones))
                            throw TypeError(".message.input.MotionCapture.Skeleton.bones: array expected");
                        message.bones = [];
                        for (var i = 0; i < object.bones.length; ++i) {
                            if (typeof object.bones[i] !== "object")
                                throw TypeError(".message.input.MotionCapture.Skeleton.bones: object expected");
                            message.bones[i] = $root.message.input.MotionCapture.RigidBody.fromObject(object.bones[i]);
                        }
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a Skeleton message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.Skeleton.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.Skeleton} Skeleton
                 */
                Skeleton.from = Skeleton.fromObject;

                /**
                 * Creates a plain object from a Skeleton message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.Skeleton} message Skeleton
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Skeleton.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.bones = [];
                    if (options.defaults) {
                        object.id = 0;
                        object.name = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.bones && message.bones.length) {
                        object.bones = [];
                        for (var j = 0; j < message.bones.length; ++j)
                            object.bones[j] = $root.message.input.MotionCapture.RigidBody.toObject(message.bones[j], options);
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Creates a plain object from this Skeleton message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Skeleton.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Skeleton to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Skeleton.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Skeleton;
            })();

            MotionCapture.LabeledMarker = (function() {

                /**
                 * Properties of a LabeledMarker.
                 * @typedef message.input.MotionCapture.LabeledMarker$Properties
                 * @type {Object}
                 * @property {message.input.MotionCapture.Marker$Properties} [marker] LabeledMarker marker.
                 * @property {boolean} [occluded] LabeledMarker occluded.
                 * @property {boolean} [pointCloudSolved] LabeledMarker pointCloudSolved.
                 * @property {boolean} [modelSolved] LabeledMarker modelSolved.
                 */

                /**
                 * Constructs a new LabeledMarker.
                 * @exports message.input.MotionCapture.LabeledMarker
                 * @constructor
                 * @param {message.input.MotionCapture.LabeledMarker$Properties=} [properties] Properties to set
                 */
                function LabeledMarker(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LabeledMarker marker.
                 * @type {(message.input.MotionCapture.Marker$Properties|null)}
                 */
                LabeledMarker.prototype.marker = null;

                /**
                 * LabeledMarker occluded.
                 * @type {boolean}
                 */
                LabeledMarker.prototype.occluded = false;

                /**
                 * LabeledMarker pointCloudSolved.
                 * @type {boolean}
                 */
                LabeledMarker.prototype.pointCloudSolved = false;

                /**
                 * LabeledMarker modelSolved.
                 * @type {boolean}
                 */
                LabeledMarker.prototype.modelSolved = false;

                /**
                 * Creates a new LabeledMarker instance using the specified properties.
                 * @param {message.input.MotionCapture.LabeledMarker$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.LabeledMarker} LabeledMarker instance
                 */
                LabeledMarker.create = function create(properties) {
                    return new LabeledMarker(properties);
                };

                /**
                 * Encodes the specified LabeledMarker message. Does not implicitly {@link message.input.MotionCapture.LabeledMarker.verify|verify} messages.
                 * @param {message.input.MotionCapture.LabeledMarker$Properties} message LabeledMarker message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LabeledMarker.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.marker != null && message.hasOwnProperty("marker"))
                        $root.message.input.MotionCapture.Marker.encode(message.marker, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.occluded != null && message.hasOwnProperty("occluded"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.occluded);
                    if (message.pointCloudSolved != null && message.hasOwnProperty("pointCloudSolved"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.pointCloudSolved);
                    if (message.modelSolved != null && message.hasOwnProperty("modelSolved"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.modelSolved);
                    return writer;
                };

                /**
                 * Encodes the specified LabeledMarker message, length delimited. Does not implicitly {@link message.input.MotionCapture.LabeledMarker.verify|verify} messages.
                 * @param {message.input.MotionCapture.LabeledMarker$Properties} message LabeledMarker message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LabeledMarker.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LabeledMarker message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.LabeledMarker} LabeledMarker
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LabeledMarker.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.LabeledMarker();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.marker = $root.message.input.MotionCapture.Marker.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.occluded = reader.bool();
                            break;
                        case 3:
                            message.pointCloudSolved = reader.bool();
                            break;
                        case 4:
                            message.modelSolved = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LabeledMarker message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.LabeledMarker} LabeledMarker
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LabeledMarker.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LabeledMarker message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                LabeledMarker.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.marker != null && message.hasOwnProperty("marker")) {
                        var error = $root.message.input.MotionCapture.Marker.verify(message.marker);
                        if (error)
                            return "marker." + error;
                    }
                    if (message.occluded != null && message.hasOwnProperty("occluded"))
                        if (typeof message.occluded !== "boolean")
                            return "occluded: boolean expected";
                    if (message.pointCloudSolved != null && message.hasOwnProperty("pointCloudSolved"))
                        if (typeof message.pointCloudSolved !== "boolean")
                            return "pointCloudSolved: boolean expected";
                    if (message.modelSolved != null && message.hasOwnProperty("modelSolved"))
                        if (typeof message.modelSolved !== "boolean")
                            return "modelSolved: boolean expected";
                    return null;
                };

                /**
                 * Creates a LabeledMarker message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.LabeledMarker} LabeledMarker
                 */
                LabeledMarker.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.MotionCapture.LabeledMarker)
                        return object;
                    var message = new $root.message.input.MotionCapture.LabeledMarker();
                    if (object.marker != null) {
                        if (typeof object.marker !== "object")
                            throw TypeError(".message.input.MotionCapture.LabeledMarker.marker: object expected");
                        message.marker = $root.message.input.MotionCapture.Marker.fromObject(object.marker);
                    }
                    if (object.occluded != null)
                        message.occluded = Boolean(object.occluded);
                    if (object.pointCloudSolved != null)
                        message.pointCloudSolved = Boolean(object.pointCloudSolved);
                    if (object.modelSolved != null)
                        message.modelSolved = Boolean(object.modelSolved);
                    return message;
                };

                /**
                 * Creates a LabeledMarker message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.LabeledMarker.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.LabeledMarker} LabeledMarker
                 */
                LabeledMarker.from = LabeledMarker.fromObject;

                /**
                 * Creates a plain object from a LabeledMarker message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.LabeledMarker} message LabeledMarker
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LabeledMarker.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.marker = null;
                        object.occluded = false;
                        object.pointCloudSolved = false;
                        object.modelSolved = false;
                    }
                    if (message.marker != null && message.hasOwnProperty("marker"))
                        object.marker = $root.message.input.MotionCapture.Marker.toObject(message.marker, options);
                    if (message.occluded != null && message.hasOwnProperty("occluded"))
                        object.occluded = message.occluded;
                    if (message.pointCloudSolved != null && message.hasOwnProperty("pointCloudSolved"))
                        object.pointCloudSolved = message.pointCloudSolved;
                    if (message.modelSolved != null && message.hasOwnProperty("modelSolved"))
                        object.modelSolved = message.modelSolved;
                    return object;
                };

                /**
                 * Creates a plain object from this LabeledMarker message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LabeledMarker.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this LabeledMarker to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                LabeledMarker.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LabeledMarker;
            })();

            MotionCapture.Channel = (function() {

                /**
                 * Properties of a Channel.
                 * @typedef message.input.MotionCapture.Channel$Properties
                 * @type {Object}
                 * @property {Array.<number>} [channel] Channel channel.
                 */

                /**
                 * Constructs a new Channel.
                 * @exports message.input.MotionCapture.Channel
                 * @constructor
                 * @param {message.input.MotionCapture.Channel$Properties=} [properties] Properties to set
                 */
                function Channel(properties) {
                    this.channel = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Channel channel.
                 * @type {Array.<number>}
                 */
                Channel.prototype.channel = $util.emptyArray;

                /**
                 * Creates a new Channel instance using the specified properties.
                 * @param {message.input.MotionCapture.Channel$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.Channel} Channel instance
                 */
                Channel.create = function create(properties) {
                    return new Channel(properties);
                };

                /**
                 * Encodes the specified Channel message. Does not implicitly {@link message.input.MotionCapture.Channel.verify|verify} messages.
                 * @param {message.input.MotionCapture.Channel$Properties} message Channel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Channel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.channel != null && message.channel.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.channel.length; ++i)
                            writer.float(message.channel[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified Channel message, length delimited. Does not implicitly {@link message.input.MotionCapture.Channel.verify|verify} messages.
                 * @param {message.input.MotionCapture.Channel$Properties} message Channel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Channel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Channel message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.Channel} Channel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Channel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.Channel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.channel && message.channel.length))
                                message.channel = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.channel.push(reader.float());
                            } else
                                message.channel.push(reader.float());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Channel message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.Channel} Channel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Channel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Channel message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Channel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.channel != null && message.hasOwnProperty("channel")) {
                        if (!Array.isArray(message.channel))
                            return "channel: array expected";
                        for (var i = 0; i < message.channel.length; ++i)
                            if (typeof message.channel[i] !== "number")
                                return "channel: number[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Channel message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.Channel} Channel
                 */
                Channel.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.MotionCapture.Channel)
                        return object;
                    var message = new $root.message.input.MotionCapture.Channel();
                    if (object.channel) {
                        if (!Array.isArray(object.channel))
                            throw TypeError(".message.input.MotionCapture.Channel.channel: array expected");
                        message.channel = [];
                        for (var i = 0; i < object.channel.length; ++i)
                            message.channel[i] = Number(object.channel[i]);
                    }
                    return message;
                };

                /**
                 * Creates a Channel message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.Channel.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.Channel} Channel
                 */
                Channel.from = Channel.fromObject;

                /**
                 * Creates a plain object from a Channel message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.Channel} message Channel
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Channel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.channel = [];
                    if (message.channel && message.channel.length) {
                        object.channel = [];
                        for (var j = 0; j < message.channel.length; ++j)
                            object.channel[j] = message.channel[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this Channel message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Channel.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Channel to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Channel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Channel;
            })();

            MotionCapture.ForcePlate = (function() {

                /**
                 * Properties of a ForcePlate.
                 * @typedef message.input.MotionCapture.ForcePlate$Properties
                 * @type {Object}
                 * @property {number} [id] ForcePlate id.
                 * @property {Array.<message.input.MotionCapture.Channel$Properties>} [channels] ForcePlate channels.
                 */

                /**
                 * Constructs a new ForcePlate.
                 * @exports message.input.MotionCapture.ForcePlate
                 * @constructor
                 * @param {message.input.MotionCapture.ForcePlate$Properties=} [properties] Properties to set
                 */
                function ForcePlate(properties) {
                    this.channels = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ForcePlate id.
                 * @type {number}
                 */
                ForcePlate.prototype.id = 0;

                /**
                 * ForcePlate channels.
                 * @type {Array.<message.input.MotionCapture.Channel$Properties>}
                 */
                ForcePlate.prototype.channels = $util.emptyArray;

                /**
                 * Creates a new ForcePlate instance using the specified properties.
                 * @param {message.input.MotionCapture.ForcePlate$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.ForcePlate} ForcePlate instance
                 */
                ForcePlate.create = function create(properties) {
                    return new ForcePlate(properties);
                };

                /**
                 * Encodes the specified ForcePlate message. Does not implicitly {@link message.input.MotionCapture.ForcePlate.verify|verify} messages.
                 * @param {message.input.MotionCapture.ForcePlate$Properties} message ForcePlate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ForcePlate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.channels != null && message.channels.length)
                        for (var i = 0; i < message.channels.length; ++i)
                            $root.message.input.MotionCapture.Channel.encode(message.channels[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ForcePlate message, length delimited. Does not implicitly {@link message.input.MotionCapture.ForcePlate.verify|verify} messages.
                 * @param {message.input.MotionCapture.ForcePlate$Properties} message ForcePlate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ForcePlate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ForcePlate message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.ForcePlate} ForcePlate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ForcePlate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.MotionCapture.ForcePlate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            if (!(message.channels && message.channels.length))
                                message.channels = [];
                            message.channels.push($root.message.input.MotionCapture.Channel.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ForcePlate message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.ForcePlate} ForcePlate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ForcePlate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ForcePlate message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ForcePlate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.channels != null && message.hasOwnProperty("channels")) {
                        if (!Array.isArray(message.channels))
                            return "channels: array expected";
                        for (var i = 0; i < message.channels.length; ++i) {
                            var error = $root.message.input.MotionCapture.Channel.verify(message.channels[i]);
                            if (error)
                                return "channels." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ForcePlate message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.ForcePlate} ForcePlate
                 */
                ForcePlate.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.MotionCapture.ForcePlate)
                        return object;
                    var message = new $root.message.input.MotionCapture.ForcePlate();
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.channels) {
                        if (!Array.isArray(object.channels))
                            throw TypeError(".message.input.MotionCapture.ForcePlate.channels: array expected");
                        message.channels = [];
                        for (var i = 0; i < object.channels.length; ++i) {
                            if (typeof object.channels[i] !== "object")
                                throw TypeError(".message.input.MotionCapture.ForcePlate.channels: object expected");
                            message.channels[i] = $root.message.input.MotionCapture.Channel.fromObject(object.channels[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a ForcePlate message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.ForcePlate.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.ForcePlate} ForcePlate
                 */
                ForcePlate.from = ForcePlate.fromObject;

                /**
                 * Creates a plain object from a ForcePlate message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.ForcePlate} message ForcePlate
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ForcePlate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.channels = [];
                    if (options.defaults)
                        object.id = 0;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.channels && message.channels.length) {
                        object.channels = [];
                        for (var j = 0; j < message.channels.length; ++j)
                            object.channels[j] = $root.message.input.MotionCapture.Channel.toObject(message.channels[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this ForcePlate message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ForcePlate.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ForcePlate to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ForcePlate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ForcePlate;
            })();

            return MotionCapture;
        })();

        input.WalkingDetected = (function() {

            /**
             * Properties of a WalkingDetected.
             * @typedef message.input.WalkingDetected$Properties
             * @type {Object}
             */

            /**
             * Constructs a new WalkingDetected.
             * @exports message.input.WalkingDetected
             * @constructor
             * @param {message.input.WalkingDetected$Properties=} [properties] Properties to set
             */
            function WalkingDetected(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new WalkingDetected instance using the specified properties.
             * @param {message.input.WalkingDetected$Properties=} [properties] Properties to set
             * @returns {message.input.WalkingDetected} WalkingDetected instance
             */
            WalkingDetected.create = function create(properties) {
                return new WalkingDetected(properties);
            };

            /**
             * Encodes the specified WalkingDetected message. Does not implicitly {@link message.input.WalkingDetected.verify|verify} messages.
             * @param {message.input.WalkingDetected$Properties} message WalkingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkingDetected.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified WalkingDetected message, length delimited. Does not implicitly {@link message.input.WalkingDetected.verify|verify} messages.
             * @param {message.input.WalkingDetected$Properties} message WalkingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkingDetected.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WalkingDetected message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.WalkingDetected} WalkingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkingDetected.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.WalkingDetected();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WalkingDetected message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.WalkingDetected} WalkingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkingDetected.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WalkingDetected message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            WalkingDetected.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a WalkingDetected message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.WalkingDetected} WalkingDetected
             */
            WalkingDetected.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.WalkingDetected)
                    return object;
                return new $root.message.input.WalkingDetected();
            };

            /**
             * Creates a WalkingDetected message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.WalkingDetected.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.WalkingDetected} WalkingDetected
             */
            WalkingDetected.from = WalkingDetected.fromObject;

            /**
             * Creates a plain object from a WalkingDetected message. Also converts values to other types if specified.
             * @param {message.input.WalkingDetected} message WalkingDetected
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkingDetected.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this WalkingDetected message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkingDetected.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this WalkingDetected to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            WalkingDetected.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WalkingDetected;
        })();

        input.BendingDetected = (function() {

            /**
             * Properties of a BendingDetected.
             * @typedef message.input.BendingDetected$Properties
             * @type {Object}
             */

            /**
             * Constructs a new BendingDetected.
             * @exports message.input.BendingDetected
             * @constructor
             * @param {message.input.BendingDetected$Properties=} [properties] Properties to set
             */
            function BendingDetected(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BendingDetected instance using the specified properties.
             * @param {message.input.BendingDetected$Properties=} [properties] Properties to set
             * @returns {message.input.BendingDetected} BendingDetected instance
             */
            BendingDetected.create = function create(properties) {
                return new BendingDetected(properties);
            };

            /**
             * Encodes the specified BendingDetected message. Does not implicitly {@link message.input.BendingDetected.verify|verify} messages.
             * @param {message.input.BendingDetected$Properties} message BendingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BendingDetected.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BendingDetected message, length delimited. Does not implicitly {@link message.input.BendingDetected.verify|verify} messages.
             * @param {message.input.BendingDetected$Properties} message BendingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BendingDetected.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BendingDetected message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.BendingDetected} BendingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BendingDetected.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.BendingDetected();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BendingDetected message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.BendingDetected} BendingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BendingDetected.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BendingDetected message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            BendingDetected.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BendingDetected message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.BendingDetected} BendingDetected
             */
            BendingDetected.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.BendingDetected)
                    return object;
                return new $root.message.input.BendingDetected();
            };

            /**
             * Creates a BendingDetected message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.BendingDetected.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.BendingDetected} BendingDetected
             */
            BendingDetected.from = BendingDetected.fromObject;

            /**
             * Creates a plain object from a BendingDetected message. Also converts values to other types if specified.
             * @param {message.input.BendingDetected} message BendingDetected
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BendingDetected.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this BendingDetected message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BendingDetected.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this BendingDetected to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            BendingDetected.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BendingDetected;
        })();

        input.KickingDetected = (function() {

            /**
             * Properties of a KickingDetected.
             * @typedef message.input.KickingDetected$Properties
             * @type {Object}
             */

            /**
             * Constructs a new KickingDetected.
             * @exports message.input.KickingDetected
             * @constructor
             * @param {message.input.KickingDetected$Properties=} [properties] Properties to set
             */
            function KickingDetected(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new KickingDetected instance using the specified properties.
             * @param {message.input.KickingDetected$Properties=} [properties] Properties to set
             * @returns {message.input.KickingDetected} KickingDetected instance
             */
            KickingDetected.create = function create(properties) {
                return new KickingDetected(properties);
            };

            /**
             * Encodes the specified KickingDetected message. Does not implicitly {@link message.input.KickingDetected.verify|verify} messages.
             * @param {message.input.KickingDetected$Properties} message KickingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickingDetected.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified KickingDetected message, length delimited. Does not implicitly {@link message.input.KickingDetected.verify|verify} messages.
             * @param {message.input.KickingDetected$Properties} message KickingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickingDetected.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickingDetected message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.KickingDetected} KickingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickingDetected.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.KickingDetected();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KickingDetected message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.KickingDetected} KickingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickingDetected.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickingDetected message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            KickingDetected.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a KickingDetected message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.KickingDetected} KickingDetected
             */
            KickingDetected.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.KickingDetected)
                    return object;
                return new $root.message.input.KickingDetected();
            };

            /**
             * Creates a KickingDetected message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.KickingDetected.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.KickingDetected} KickingDetected
             */
            KickingDetected.from = KickingDetected.fromObject;

            /**
             * Creates a plain object from a KickingDetected message. Also converts values to other types if specified.
             * @param {message.input.KickingDetected} message KickingDetected
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickingDetected.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this KickingDetected message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickingDetected.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this KickingDetected to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            KickingDetected.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KickingDetected;
        })();

        input.SittingDetected = (function() {

            /**
             * Properties of a SittingDetected.
             * @typedef message.input.SittingDetected$Properties
             * @type {Object}
             */

            /**
             * Constructs a new SittingDetected.
             * @exports message.input.SittingDetected
             * @constructor
             * @param {message.input.SittingDetected$Properties=} [properties] Properties to set
             */
            function SittingDetected(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SittingDetected instance using the specified properties.
             * @param {message.input.SittingDetected$Properties=} [properties] Properties to set
             * @returns {message.input.SittingDetected} SittingDetected instance
             */
            SittingDetected.create = function create(properties) {
                return new SittingDetected(properties);
            };

            /**
             * Encodes the specified SittingDetected message. Does not implicitly {@link message.input.SittingDetected.verify|verify} messages.
             * @param {message.input.SittingDetected$Properties} message SittingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SittingDetected.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SittingDetected message, length delimited. Does not implicitly {@link message.input.SittingDetected.verify|verify} messages.
             * @param {message.input.SittingDetected$Properties} message SittingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SittingDetected.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SittingDetected message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.SittingDetected} SittingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SittingDetected.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.SittingDetected();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SittingDetected message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.SittingDetected} SittingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SittingDetected.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SittingDetected message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            SittingDetected.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SittingDetected message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.SittingDetected} SittingDetected
             */
            SittingDetected.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.SittingDetected)
                    return object;
                return new $root.message.input.SittingDetected();
            };

            /**
             * Creates a SittingDetected message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.SittingDetected.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.SittingDetected} SittingDetected
             */
            SittingDetected.from = SittingDetected.fromObject;

            /**
             * Creates a plain object from a SittingDetected message. Also converts values to other types if specified.
             * @param {message.input.SittingDetected} message SittingDetected
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SittingDetected.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this SittingDetected message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SittingDetected.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this SittingDetected to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            SittingDetected.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SittingDetected;
        })();

        input.StandingDetected = (function() {

            /**
             * Properties of a StandingDetected.
             * @typedef message.input.StandingDetected$Properties
             * @type {Object}
             */

            /**
             * Constructs a new StandingDetected.
             * @exports message.input.StandingDetected
             * @constructor
             * @param {message.input.StandingDetected$Properties=} [properties] Properties to set
             */
            function StandingDetected(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new StandingDetected instance using the specified properties.
             * @param {message.input.StandingDetected$Properties=} [properties] Properties to set
             * @returns {message.input.StandingDetected} StandingDetected instance
             */
            StandingDetected.create = function create(properties) {
                return new StandingDetected(properties);
            };

            /**
             * Encodes the specified StandingDetected message. Does not implicitly {@link message.input.StandingDetected.verify|verify} messages.
             * @param {message.input.StandingDetected$Properties} message StandingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StandingDetected.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified StandingDetected message, length delimited. Does not implicitly {@link message.input.StandingDetected.verify|verify} messages.
             * @param {message.input.StandingDetected$Properties} message StandingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StandingDetected.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StandingDetected message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.StandingDetected} StandingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StandingDetected.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.StandingDetected();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StandingDetected message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.StandingDetected} StandingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StandingDetected.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StandingDetected message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            StandingDetected.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a StandingDetected message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.StandingDetected} StandingDetected
             */
            StandingDetected.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.StandingDetected)
                    return object;
                return new $root.message.input.StandingDetected();
            };

            /**
             * Creates a StandingDetected message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.StandingDetected.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.StandingDetected} StandingDetected
             */
            StandingDetected.from = StandingDetected.fromObject;

            /**
             * Creates a plain object from a StandingDetected message. Also converts values to other types if specified.
             * @param {message.input.StandingDetected} message StandingDetected
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StandingDetected.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this StandingDetected message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StandingDetected.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this StandingDetected to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            StandingDetected.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StandingDetected;
        })();

        input.FallingDetected = (function() {

            /**
             * Properties of a FallingDetected.
             * @typedef message.input.FallingDetected$Properties
             * @type {Object}
             * @property {number} [x] FallingDetected x.
             * @property {number} [y] FallingDetected y.
             * @property {number} [z] FallingDetected z.
             */

            /**
             * Constructs a new FallingDetected.
             * @exports message.input.FallingDetected
             * @constructor
             * @param {message.input.FallingDetected$Properties=} [properties] Properties to set
             */
            function FallingDetected(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FallingDetected x.
             * @type {number}
             */
            FallingDetected.prototype.x = 0;

            /**
             * FallingDetected y.
             * @type {number}
             */
            FallingDetected.prototype.y = 0;

            /**
             * FallingDetected z.
             * @type {number}
             */
            FallingDetected.prototype.z = 0;

            /**
             * Creates a new FallingDetected instance using the specified properties.
             * @param {message.input.FallingDetected$Properties=} [properties] Properties to set
             * @returns {message.input.FallingDetected} FallingDetected instance
             */
            FallingDetected.create = function create(properties) {
                return new FallingDetected(properties);
            };

            /**
             * Encodes the specified FallingDetected message. Does not implicitly {@link message.input.FallingDetected.verify|verify} messages.
             * @param {message.input.FallingDetected$Properties} message FallingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FallingDetected.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.x != null && message.hasOwnProperty("x"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
                if (message.y != null && message.hasOwnProperty("y"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
                if (message.z != null && message.hasOwnProperty("z"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.z);
                return writer;
            };

            /**
             * Encodes the specified FallingDetected message, length delimited. Does not implicitly {@link message.input.FallingDetected.verify|verify} messages.
             * @param {message.input.FallingDetected$Properties} message FallingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FallingDetected.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FallingDetected message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.FallingDetected} FallingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FallingDetected.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.FallingDetected();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.x = reader.double();
                        break;
                    case 2:
                        message.y = reader.double();
                        break;
                    case 3:
                        message.z = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FallingDetected message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.FallingDetected} FallingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FallingDetected.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FallingDetected message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FallingDetected.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.x != null && message.hasOwnProperty("x"))
                    if (typeof message.x !== "number")
                        return "x: number expected";
                if (message.y != null && message.hasOwnProperty("y"))
                    if (typeof message.y !== "number")
                        return "y: number expected";
                if (message.z != null && message.hasOwnProperty("z"))
                    if (typeof message.z !== "number")
                        return "z: number expected";
                return null;
            };

            /**
             * Creates a FallingDetected message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.FallingDetected} FallingDetected
             */
            FallingDetected.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.FallingDetected)
                    return object;
                var message = new $root.message.input.FallingDetected();
                if (object.x != null)
                    message.x = Number(object.x);
                if (object.y != null)
                    message.y = Number(object.y);
                if (object.z != null)
                    message.z = Number(object.z);
                return message;
            };

            /**
             * Creates a FallingDetected message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.FallingDetected.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.FallingDetected} FallingDetected
             */
            FallingDetected.from = FallingDetected.fromObject;

            /**
             * Creates a plain object from a FallingDetected message. Also converts values to other types if specified.
             * @param {message.input.FallingDetected} message FallingDetected
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FallingDetected.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.x = 0;
                    object.y = 0;
                    object.z = 0;
                }
                if (message.x != null && message.hasOwnProperty("x"))
                    object.x = message.x;
                if (message.y != null && message.hasOwnProperty("y"))
                    object.y = message.y;
                if (message.z != null && message.hasOwnProperty("z"))
                    object.z = message.z;
                return object;
            };

            /**
             * Creates a plain object from this FallingDetected message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FallingDetected.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FallingDetected to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FallingDetected.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FallingDetected;
        })();

        input.PresenceUserState = (function() {

            /**
             * Properties of a PresenceUserState.
             * @typedef message.input.PresenceUserState$Properties
             * @type {Object}
             * @property {fmat44$Properties} [headPose] PresenceUserState headPose.
             */

            /**
             * Constructs a new PresenceUserState.
             * @exports message.input.PresenceUserState
             * @constructor
             * @param {message.input.PresenceUserState$Properties=} [properties] Properties to set
             */
            function PresenceUserState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PresenceUserState headPose.
             * @type {(fmat44$Properties|null)}
             */
            PresenceUserState.prototype.headPose = null;

            /**
             * Creates a new PresenceUserState instance using the specified properties.
             * @param {message.input.PresenceUserState$Properties=} [properties] Properties to set
             * @returns {message.input.PresenceUserState} PresenceUserState instance
             */
            PresenceUserState.create = function create(properties) {
                return new PresenceUserState(properties);
            };

            /**
             * Encodes the specified PresenceUserState message. Does not implicitly {@link message.input.PresenceUserState.verify|verify} messages.
             * @param {message.input.PresenceUserState$Properties} message PresenceUserState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PresenceUserState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.headPose != null && message.hasOwnProperty("headPose"))
                    $root.fmat44.encode(message.headPose, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PresenceUserState message, length delimited. Does not implicitly {@link message.input.PresenceUserState.verify|verify} messages.
             * @param {message.input.PresenceUserState$Properties} message PresenceUserState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PresenceUserState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PresenceUserState message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.PresenceUserState} PresenceUserState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PresenceUserState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.PresenceUserState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.headPose = $root.fmat44.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PresenceUserState message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.PresenceUserState} PresenceUserState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PresenceUserState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PresenceUserState message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            PresenceUserState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.headPose != null && message.hasOwnProperty("headPose")) {
                    var error = $root.fmat44.verify(message.headPose);
                    if (error)
                        return "headPose." + error;
                }
                return null;
            };

            /**
             * Creates a PresenceUserState message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.PresenceUserState} PresenceUserState
             */
            PresenceUserState.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.PresenceUserState)
                    return object;
                var message = new $root.message.input.PresenceUserState();
                if (object.headPose != null) {
                    if (typeof object.headPose !== "object")
                        throw TypeError(".message.input.PresenceUserState.headPose: object expected");
                    message.headPose = $root.fmat44.fromObject(object.headPose);
                }
                return message;
            };

            /**
             * Creates a PresenceUserState message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.PresenceUserState.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.PresenceUserState} PresenceUserState
             */
            PresenceUserState.from = PresenceUserState.fromObject;

            /**
             * Creates a plain object from a PresenceUserState message. Also converts values to other types if specified.
             * @param {message.input.PresenceUserState} message PresenceUserState
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PresenceUserState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.headPose = null;
                if (message.headPose != null && message.hasOwnProperty("headPose"))
                    object.headPose = $root.fmat44.toObject(message.headPose, options);
                return object;
            };

            /**
             * Creates a plain object from this PresenceUserState message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PresenceUserState.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this PresenceUserState to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            PresenceUserState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PresenceUserState;
        })();

        input.Sensors = (function() {

            /**
             * Properties of a Sensors.
             * @typedef message.input.Sensors$Properties
             * @type {Object}
             * @property {google.protobuf.Timestamp$Properties} [timestamp] Sensors timestamp.
             * @property {vec3$Properties} [accelerometer] Sensors accelerometer.
             * @property {vec3$Properties} [gyroscope] Sensors gyroscope.
             * @property {mat44$Properties} [world] Sensors world.
             * @property {Array.<message.input.Sensors.FSR$Properties>} [fsr] Sensors fsr.
             * @property {Array.<message.input.Sensors.Servo$Properties>} [servo] Sensors servo.
             * @property {Array.<message.input.Sensors.Button$Properties>} [button] Sensors button.
             * @property {Array.<message.input.Sensors.LED$Properties>} [led] Sensors led.
             * @property {number} [voltage] Sensors voltage.
             * @property {number} [battery] Sensors battery.
             * @property {vec3$Properties} [centreOfPressure] Sensors centreOfPressure.
             * @property {mat22$Properties} [robotToIMU] Sensors robotToIMU.
             * @property {boolean} [leftFootDown] Sensors leftFootDown.
             * @property {boolean} [rightFootDown] Sensors rightFootDown.
             * @property {Object.<string,mat44$Properties>} [forwardKinematics] Sensors forwardKinematics.
             * @property {number} [bodyCentreHeight] Sensors bodyCentreHeight.
             * @property {vec4$Properties} [centreOfMass] Sensors centreOfMass.
             * @property {mat44$Properties} [bodyToGround] Sensors bodyToGround.
             * @property {mat44$Properties} [camToGround] Sensors camToGround.
             */

            /**
             * Constructs a new Sensors.
             * @exports message.input.Sensors
             * @constructor
             * @param {message.input.Sensors$Properties=} [properties] Properties to set
             */
            function Sensors(properties) {
                this.fsr = [];
                this.servo = [];
                this.button = [];
                this.led = [];
                this.forwardKinematics = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sensors timestamp.
             * @type {(google.protobuf.Timestamp$Properties|null)}
             */
            Sensors.prototype.timestamp = null;

            /**
             * Sensors accelerometer.
             * @type {(vec3$Properties|null)}
             */
            Sensors.prototype.accelerometer = null;

            /**
             * Sensors gyroscope.
             * @type {(vec3$Properties|null)}
             */
            Sensors.prototype.gyroscope = null;

            /**
             * Sensors world.
             * @type {(mat44$Properties|null)}
             */
            Sensors.prototype.world = null;

            /**
             * Sensors fsr.
             * @type {Array.<message.input.Sensors.FSR$Properties>}
             */
            Sensors.prototype.fsr = $util.emptyArray;

            /**
             * Sensors servo.
             * @type {Array.<message.input.Sensors.Servo$Properties>}
             */
            Sensors.prototype.servo = $util.emptyArray;

            /**
             * Sensors button.
             * @type {Array.<message.input.Sensors.Button$Properties>}
             */
            Sensors.prototype.button = $util.emptyArray;

            /**
             * Sensors led.
             * @type {Array.<message.input.Sensors.LED$Properties>}
             */
            Sensors.prototype.led = $util.emptyArray;

            /**
             * Sensors voltage.
             * @type {number}
             */
            Sensors.prototype.voltage = 0;

            /**
             * Sensors battery.
             * @type {number}
             */
            Sensors.prototype.battery = 0;

            /**
             * Sensors centreOfPressure.
             * @type {(vec3$Properties|null)}
             */
            Sensors.prototype.centreOfPressure = null;

            /**
             * Sensors robotToIMU.
             * @type {(mat22$Properties|null)}
             */
            Sensors.prototype.robotToIMU = null;

            /**
             * Sensors leftFootDown.
             * @type {boolean}
             */
            Sensors.prototype.leftFootDown = false;

            /**
             * Sensors rightFootDown.
             * @type {boolean}
             */
            Sensors.prototype.rightFootDown = false;

            /**
             * Sensors forwardKinematics.
             * @type {Object.<string,mat44$Properties>}
             */
            Sensors.prototype.forwardKinematics = $util.emptyObject;

            /**
             * Sensors bodyCentreHeight.
             * @type {number}
             */
            Sensors.prototype.bodyCentreHeight = 0;

            /**
             * Sensors centreOfMass.
             * @type {(vec4$Properties|null)}
             */
            Sensors.prototype.centreOfMass = null;

            /**
             * Sensors bodyToGround.
             * @type {(mat44$Properties|null)}
             */
            Sensors.prototype.bodyToGround = null;

            /**
             * Sensors camToGround.
             * @type {(mat44$Properties|null)}
             */
            Sensors.prototype.camToGround = null;

            /**
             * Creates a new Sensors instance using the specified properties.
             * @param {message.input.Sensors$Properties=} [properties] Properties to set
             * @returns {message.input.Sensors} Sensors instance
             */
            Sensors.create = function create(properties) {
                return new Sensors(properties);
            };

            /**
             * Encodes the specified Sensors message. Does not implicitly {@link message.input.Sensors.verify|verify} messages.
             * @param {message.input.Sensors$Properties} message Sensors message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sensors.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.accelerometer != null && message.hasOwnProperty("accelerometer"))
                    $root.vec3.encode(message.accelerometer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.gyroscope != null && message.hasOwnProperty("gyroscope"))
                    $root.vec3.encode(message.gyroscope, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.world != null && message.hasOwnProperty("world"))
                    $root.mat44.encode(message.world, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.fsr != null && message.fsr.length)
                    for (var i = 0; i < message.fsr.length; ++i)
                        $root.message.input.Sensors.FSR.encode(message.fsr[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.servo != null && message.servo.length)
                    for (var i = 0; i < message.servo.length; ++i)
                        $root.message.input.Sensors.Servo.encode(message.servo[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.button != null && message.button.length)
                    for (var i = 0; i < message.button.length; ++i)
                        $root.message.input.Sensors.Button.encode(message.button[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.led != null && message.led.length)
                    for (var i = 0; i < message.led.length; ++i)
                        $root.message.input.Sensors.LED.encode(message.led[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.voltage != null && message.hasOwnProperty("voltage"))
                    writer.uint32(/* id 9, wireType 5 =*/77).float(message.voltage);
                if (message.battery != null && message.hasOwnProperty("battery"))
                    writer.uint32(/* id 10, wireType 5 =*/85).float(message.battery);
                if (message.centreOfPressure != null && message.hasOwnProperty("centreOfPressure"))
                    $root.vec3.encode(message.centreOfPressure, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.robotToIMU != null && message.hasOwnProperty("robotToIMU"))
                    $root.mat22.encode(message.robotToIMU, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.leftFootDown != null && message.hasOwnProperty("leftFootDown"))
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.leftFootDown);
                if (message.rightFootDown != null && message.hasOwnProperty("rightFootDown"))
                    writer.uint32(/* id 14, wireType 0 =*/112).bool(message.rightFootDown);
                if (message.forwardKinematics != null && message.hasOwnProperty("forwardKinematics"))
                    for (var keys = Object.keys(message.forwardKinematics), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 15, wireType 2 =*/122).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                        $root.mat44.encode(message.forwardKinematics[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.bodyCentreHeight != null && message.hasOwnProperty("bodyCentreHeight"))
                    writer.uint32(/* id 16, wireType 5 =*/133).float(message.bodyCentreHeight);
                if (message.centreOfMass != null && message.hasOwnProperty("centreOfMass"))
                    $root.vec4.encode(message.centreOfMass, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.bodyToGround != null && message.hasOwnProperty("bodyToGround"))
                    $root.mat44.encode(message.bodyToGround, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.camToGround != null && message.hasOwnProperty("camToGround"))
                    $root.mat44.encode(message.camToGround, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Sensors message, length delimited. Does not implicitly {@link message.input.Sensors.verify|verify} messages.
             * @param {message.input.Sensors$Properties} message Sensors message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sensors.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sensors message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.Sensors} Sensors
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sensors.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.Sensors(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.accelerometer = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.gyroscope = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.world = $root.mat44.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.fsr && message.fsr.length))
                            message.fsr = [];
                        message.fsr.push($root.message.input.Sensors.FSR.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.servo && message.servo.length))
                            message.servo = [];
                        message.servo.push($root.message.input.Sensors.Servo.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.button && message.button.length))
                            message.button = [];
                        message.button.push($root.message.input.Sensors.Button.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.led && message.led.length))
                            message.led = [];
                        message.led.push($root.message.input.Sensors.LED.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        message.voltage = reader.float();
                        break;
                    case 10:
                        message.battery = reader.float();
                        break;
                    case 11:
                        message.centreOfPressure = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.robotToIMU = $root.mat22.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.leftFootDown = reader.bool();
                        break;
                    case 14:
                        message.rightFootDown = reader.bool();
                        break;
                    case 15:
                        reader.skip().pos++;
                        if (message.forwardKinematics === $util.emptyObject)
                            message.forwardKinematics = {};
                        key = reader.uint32();
                        reader.pos++;
                        message.forwardKinematics[key] = $root.mat44.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.bodyCentreHeight = reader.float();
                        break;
                    case 17:
                        message.centreOfMass = $root.vec4.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.bodyToGround = $root.mat44.decode(reader, reader.uint32());
                        break;
                    case 19:
                        message.camToGround = $root.mat44.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sensors message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.Sensors} Sensors
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sensors.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sensors message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Sensors.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.accelerometer != null && message.hasOwnProperty("accelerometer")) {
                    var error = $root.vec3.verify(message.accelerometer);
                    if (error)
                        return "accelerometer." + error;
                }
                if (message.gyroscope != null && message.hasOwnProperty("gyroscope")) {
                    var error = $root.vec3.verify(message.gyroscope);
                    if (error)
                        return "gyroscope." + error;
                }
                if (message.world != null && message.hasOwnProperty("world")) {
                    var error = $root.mat44.verify(message.world);
                    if (error)
                        return "world." + error;
                }
                if (message.fsr != null && message.hasOwnProperty("fsr")) {
                    if (!Array.isArray(message.fsr))
                        return "fsr: array expected";
                    for (var i = 0; i < message.fsr.length; ++i) {
                        var error = $root.message.input.Sensors.FSR.verify(message.fsr[i]);
                        if (error)
                            return "fsr." + error;
                    }
                }
                if (message.servo != null && message.hasOwnProperty("servo")) {
                    if (!Array.isArray(message.servo))
                        return "servo: array expected";
                    for (var i = 0; i < message.servo.length; ++i) {
                        var error = $root.message.input.Sensors.Servo.verify(message.servo[i]);
                        if (error)
                            return "servo." + error;
                    }
                }
                if (message.button != null && message.hasOwnProperty("button")) {
                    if (!Array.isArray(message.button))
                        return "button: array expected";
                    for (var i = 0; i < message.button.length; ++i) {
                        var error = $root.message.input.Sensors.Button.verify(message.button[i]);
                        if (error)
                            return "button." + error;
                    }
                }
                if (message.led != null && message.hasOwnProperty("led")) {
                    if (!Array.isArray(message.led))
                        return "led: array expected";
                    for (var i = 0; i < message.led.length; ++i) {
                        var error = $root.message.input.Sensors.LED.verify(message.led[i]);
                        if (error)
                            return "led." + error;
                    }
                }
                if (message.voltage != null && message.hasOwnProperty("voltage"))
                    if (typeof message.voltage !== "number")
                        return "voltage: number expected";
                if (message.battery != null && message.hasOwnProperty("battery"))
                    if (typeof message.battery !== "number")
                        return "battery: number expected";
                if (message.centreOfPressure != null && message.hasOwnProperty("centreOfPressure")) {
                    var error = $root.vec3.verify(message.centreOfPressure);
                    if (error)
                        return "centreOfPressure." + error;
                }
                if (message.robotToIMU != null && message.hasOwnProperty("robotToIMU")) {
                    var error = $root.mat22.verify(message.robotToIMU);
                    if (error)
                        return "robotToIMU." + error;
                }
                if (message.leftFootDown != null && message.hasOwnProperty("leftFootDown"))
                    if (typeof message.leftFootDown !== "boolean")
                        return "leftFootDown: boolean expected";
                if (message.rightFootDown != null && message.hasOwnProperty("rightFootDown"))
                    if (typeof message.rightFootDown !== "boolean")
                        return "rightFootDown: boolean expected";
                if (message.forwardKinematics != null && message.hasOwnProperty("forwardKinematics")) {
                    if (!$util.isObject(message.forwardKinematics))
                        return "forwardKinematics: object expected";
                    var key = Object.keys(message.forwardKinematics);
                    for (var i = 0; i < key.length; ++i) {
                        if (!$util.key32Re.test(key[i]))
                            return "forwardKinematics: integer key{k:uint32} expected";
                        var error = $root.mat44.verify(message.forwardKinematics[key[i]]);
                        if (error)
                            return "forwardKinematics." + error;
                    }
                }
                if (message.bodyCentreHeight != null && message.hasOwnProperty("bodyCentreHeight"))
                    if (typeof message.bodyCentreHeight !== "number")
                        return "bodyCentreHeight: number expected";
                if (message.centreOfMass != null && message.hasOwnProperty("centreOfMass")) {
                    var error = $root.vec4.verify(message.centreOfMass);
                    if (error)
                        return "centreOfMass." + error;
                }
                if (message.bodyToGround != null && message.hasOwnProperty("bodyToGround")) {
                    var error = $root.mat44.verify(message.bodyToGround);
                    if (error)
                        return "bodyToGround." + error;
                }
                if (message.camToGround != null && message.hasOwnProperty("camToGround")) {
                    var error = $root.mat44.verify(message.camToGround);
                    if (error)
                        return "camToGround." + error;
                }
                return null;
            };

            /**
             * Creates a Sensors message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.Sensors} Sensors
             */
            Sensors.fromObject = function fromObject(object) {
                if (object instanceof $root.message.input.Sensors)
                    return object;
                var message = new $root.message.input.Sensors();
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".message.input.Sensors.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                if (object.accelerometer != null) {
                    if (typeof object.accelerometer !== "object")
                        throw TypeError(".message.input.Sensors.accelerometer: object expected");
                    message.accelerometer = $root.vec3.fromObject(object.accelerometer);
                }
                if (object.gyroscope != null) {
                    if (typeof object.gyroscope !== "object")
                        throw TypeError(".message.input.Sensors.gyroscope: object expected");
                    message.gyroscope = $root.vec3.fromObject(object.gyroscope);
                }
                if (object.world != null) {
                    if (typeof object.world !== "object")
                        throw TypeError(".message.input.Sensors.world: object expected");
                    message.world = $root.mat44.fromObject(object.world);
                }
                if (object.fsr) {
                    if (!Array.isArray(object.fsr))
                        throw TypeError(".message.input.Sensors.fsr: array expected");
                    message.fsr = [];
                    for (var i = 0; i < object.fsr.length; ++i) {
                        if (typeof object.fsr[i] !== "object")
                            throw TypeError(".message.input.Sensors.fsr: object expected");
                        message.fsr[i] = $root.message.input.Sensors.FSR.fromObject(object.fsr[i]);
                    }
                }
                if (object.servo) {
                    if (!Array.isArray(object.servo))
                        throw TypeError(".message.input.Sensors.servo: array expected");
                    message.servo = [];
                    for (var i = 0; i < object.servo.length; ++i) {
                        if (typeof object.servo[i] !== "object")
                            throw TypeError(".message.input.Sensors.servo: object expected");
                        message.servo[i] = $root.message.input.Sensors.Servo.fromObject(object.servo[i]);
                    }
                }
                if (object.button) {
                    if (!Array.isArray(object.button))
                        throw TypeError(".message.input.Sensors.button: array expected");
                    message.button = [];
                    for (var i = 0; i < object.button.length; ++i) {
                        if (typeof object.button[i] !== "object")
                            throw TypeError(".message.input.Sensors.button: object expected");
                        message.button[i] = $root.message.input.Sensors.Button.fromObject(object.button[i]);
                    }
                }
                if (object.led) {
                    if (!Array.isArray(object.led))
                        throw TypeError(".message.input.Sensors.led: array expected");
                    message.led = [];
                    for (var i = 0; i < object.led.length; ++i) {
                        if (typeof object.led[i] !== "object")
                            throw TypeError(".message.input.Sensors.led: object expected");
                        message.led[i] = $root.message.input.Sensors.LED.fromObject(object.led[i]);
                    }
                }
                if (object.voltage != null)
                    message.voltage = Number(object.voltage);
                if (object.battery != null)
                    message.battery = Number(object.battery);
                if (object.centreOfPressure != null) {
                    if (typeof object.centreOfPressure !== "object")
                        throw TypeError(".message.input.Sensors.centreOfPressure: object expected");
                    message.centreOfPressure = $root.vec3.fromObject(object.centreOfPressure);
                }
                if (object.robotToIMU != null) {
                    if (typeof object.robotToIMU !== "object")
                        throw TypeError(".message.input.Sensors.robotToIMU: object expected");
                    message.robotToIMU = $root.mat22.fromObject(object.robotToIMU);
                }
                if (object.leftFootDown != null)
                    message.leftFootDown = Boolean(object.leftFootDown);
                if (object.rightFootDown != null)
                    message.rightFootDown = Boolean(object.rightFootDown);
                if (object.forwardKinematics) {
                    if (typeof object.forwardKinematics !== "object")
                        throw TypeError(".message.input.Sensors.forwardKinematics: object expected");
                    message.forwardKinematics = {};
                    for (var keys = Object.keys(object.forwardKinematics), i = 0; i < keys.length; ++i) {
                        if (typeof object.forwardKinematics[keys[i]] !== "object")
                            throw TypeError(".message.input.Sensors.forwardKinematics: object expected");
                        message.forwardKinematics[keys[i]] = $root.mat44.fromObject(object.forwardKinematics[keys[i]]);
                    }
                }
                if (object.bodyCentreHeight != null)
                    message.bodyCentreHeight = Number(object.bodyCentreHeight);
                if (object.centreOfMass != null) {
                    if (typeof object.centreOfMass !== "object")
                        throw TypeError(".message.input.Sensors.centreOfMass: object expected");
                    message.centreOfMass = $root.vec4.fromObject(object.centreOfMass);
                }
                if (object.bodyToGround != null) {
                    if (typeof object.bodyToGround !== "object")
                        throw TypeError(".message.input.Sensors.bodyToGround: object expected");
                    message.bodyToGround = $root.mat44.fromObject(object.bodyToGround);
                }
                if (object.camToGround != null) {
                    if (typeof object.camToGround !== "object")
                        throw TypeError(".message.input.Sensors.camToGround: object expected");
                    message.camToGround = $root.mat44.fromObject(object.camToGround);
                }
                return message;
            };

            /**
             * Creates a Sensors message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.Sensors.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.Sensors} Sensors
             */
            Sensors.from = Sensors.fromObject;

            /**
             * Creates a plain object from a Sensors message. Also converts values to other types if specified.
             * @param {message.input.Sensors} message Sensors
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sensors.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.fsr = [];
                    object.servo = [];
                    object.button = [];
                    object.led = [];
                }
                if (options.objects || options.defaults)
                    object.forwardKinematics = {};
                if (options.defaults) {
                    object.timestamp = null;
                    object.accelerometer = null;
                    object.gyroscope = null;
                    object.world = null;
                    object.voltage = 0;
                    object.battery = 0;
                    object.centreOfPressure = null;
                    object.robotToIMU = null;
                    object.leftFootDown = false;
                    object.rightFootDown = false;
                    object.bodyCentreHeight = 0;
                    object.centreOfMass = null;
                    object.bodyToGround = null;
                    object.camToGround = null;
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                if (message.accelerometer != null && message.hasOwnProperty("accelerometer"))
                    object.accelerometer = $root.vec3.toObject(message.accelerometer, options);
                if (message.gyroscope != null && message.hasOwnProperty("gyroscope"))
                    object.gyroscope = $root.vec3.toObject(message.gyroscope, options);
                if (message.world != null && message.hasOwnProperty("world"))
                    object.world = $root.mat44.toObject(message.world, options);
                if (message.fsr && message.fsr.length) {
                    object.fsr = [];
                    for (var j = 0; j < message.fsr.length; ++j)
                        object.fsr[j] = $root.message.input.Sensors.FSR.toObject(message.fsr[j], options);
                }
                if (message.servo && message.servo.length) {
                    object.servo = [];
                    for (var j = 0; j < message.servo.length; ++j)
                        object.servo[j] = $root.message.input.Sensors.Servo.toObject(message.servo[j], options);
                }
                if (message.button && message.button.length) {
                    object.button = [];
                    for (var j = 0; j < message.button.length; ++j)
                        object.button[j] = $root.message.input.Sensors.Button.toObject(message.button[j], options);
                }
                if (message.led && message.led.length) {
                    object.led = [];
                    for (var j = 0; j < message.led.length; ++j)
                        object.led[j] = $root.message.input.Sensors.LED.toObject(message.led[j], options);
                }
                if (message.voltage != null && message.hasOwnProperty("voltage"))
                    object.voltage = message.voltage;
                if (message.battery != null && message.hasOwnProperty("battery"))
                    object.battery = message.battery;
                if (message.centreOfPressure != null && message.hasOwnProperty("centreOfPressure"))
                    object.centreOfPressure = $root.vec3.toObject(message.centreOfPressure, options);
                if (message.robotToIMU != null && message.hasOwnProperty("robotToIMU"))
                    object.robotToIMU = $root.mat22.toObject(message.robotToIMU, options);
                if (message.leftFootDown != null && message.hasOwnProperty("leftFootDown"))
                    object.leftFootDown = message.leftFootDown;
                if (message.rightFootDown != null && message.hasOwnProperty("rightFootDown"))
                    object.rightFootDown = message.rightFootDown;
                var keys2;
                if (message.forwardKinematics && (keys2 = Object.keys(message.forwardKinematics)).length) {
                    object.forwardKinematics = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.forwardKinematics[keys2[j]] = $root.mat44.toObject(message.forwardKinematics[keys2[j]], options);
                }
                if (message.bodyCentreHeight != null && message.hasOwnProperty("bodyCentreHeight"))
                    object.bodyCentreHeight = message.bodyCentreHeight;
                if (message.centreOfMass != null && message.hasOwnProperty("centreOfMass"))
                    object.centreOfMass = $root.vec4.toObject(message.centreOfMass, options);
                if (message.bodyToGround != null && message.hasOwnProperty("bodyToGround"))
                    object.bodyToGround = $root.mat44.toObject(message.bodyToGround, options);
                if (message.camToGround != null && message.hasOwnProperty("camToGround"))
                    object.camToGround = $root.mat44.toObject(message.camToGround, options);
                return object;
            };

            /**
             * Creates a plain object from this Sensors message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sensors.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Sensors to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Sensors.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Sensors.Servo = (function() {

                /**
                 * Properties of a Servo.
                 * @typedef message.input.Sensors.Servo$Properties
                 * @type {Object}
                 * @property {number} [errorFlags] Servo errorFlags.
                 * @property {number} [id] Servo id.
                 * @property {boolean} [enabled] Servo enabled.
                 * @property {number} [pGain] Servo pGain.
                 * @property {number} [iGain] Servo iGain.
                 * @property {number} [dGain] Servo dGain.
                 * @property {number} [goalPosition] Servo goalPosition.
                 * @property {number} [goalVelocity] Servo goalVelocity.
                 * @property {number} [presentPosition] Servo presentPosition.
                 * @property {number} [presentVelocity] Servo presentVelocity.
                 * @property {number} [load] Servo load.
                 * @property {number} [voltage] Servo voltage.
                 * @property {number} [temperature] Servo temperature.
                 */

                /**
                 * Constructs a new Servo.
                 * @exports message.input.Sensors.Servo
                 * @constructor
                 * @param {message.input.Sensors.Servo$Properties=} [properties] Properties to set
                 */
                function Servo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Servo errorFlags.
                 * @type {number}
                 */
                Servo.prototype.errorFlags = 0;

                /**
                 * Servo id.
                 * @type {number}
                 */
                Servo.prototype.id = 0;

                /**
                 * Servo enabled.
                 * @type {boolean}
                 */
                Servo.prototype.enabled = false;

                /**
                 * Servo pGain.
                 * @type {number}
                 */
                Servo.prototype.pGain = 0;

                /**
                 * Servo iGain.
                 * @type {number}
                 */
                Servo.prototype.iGain = 0;

                /**
                 * Servo dGain.
                 * @type {number}
                 */
                Servo.prototype.dGain = 0;

                /**
                 * Servo goalPosition.
                 * @type {number}
                 */
                Servo.prototype.goalPosition = 0;

                /**
                 * Servo goalVelocity.
                 * @type {number}
                 */
                Servo.prototype.goalVelocity = 0;

                /**
                 * Servo presentPosition.
                 * @type {number}
                 */
                Servo.prototype.presentPosition = 0;

                /**
                 * Servo presentVelocity.
                 * @type {number}
                 */
                Servo.prototype.presentVelocity = 0;

                /**
                 * Servo load.
                 * @type {number}
                 */
                Servo.prototype.load = 0;

                /**
                 * Servo voltage.
                 * @type {number}
                 */
                Servo.prototype.voltage = 0;

                /**
                 * Servo temperature.
                 * @type {number}
                 */
                Servo.prototype.temperature = 0;

                /**
                 * Creates a new Servo instance using the specified properties.
                 * @param {message.input.Sensors.Servo$Properties=} [properties] Properties to set
                 * @returns {message.input.Sensors.Servo} Servo instance
                 */
                Servo.create = function create(properties) {
                    return new Servo(properties);
                };

                /**
                 * Encodes the specified Servo message. Does not implicitly {@link message.input.Sensors.Servo.verify|verify} messages.
                 * @param {message.input.Sensors.Servo$Properties} message Servo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Servo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.errorFlags != null && message.hasOwnProperty("errorFlags"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.errorFlags);
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                    if (message.enabled != null && message.hasOwnProperty("enabled"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.enabled);
                    if (message.pGain != null && message.hasOwnProperty("pGain"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.pGain);
                    if (message.iGain != null && message.hasOwnProperty("iGain"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.iGain);
                    if (message.dGain != null && message.hasOwnProperty("dGain"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.dGain);
                    if (message.goalPosition != null && message.hasOwnProperty("goalPosition"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.goalPosition);
                    if (message.goalVelocity != null && message.hasOwnProperty("goalVelocity"))
                        writer.uint32(/* id 8, wireType 5 =*/69).float(message.goalVelocity);
                    if (message.presentPosition != null && message.hasOwnProperty("presentPosition"))
                        writer.uint32(/* id 9, wireType 5 =*/77).float(message.presentPosition);
                    if (message.presentVelocity != null && message.hasOwnProperty("presentVelocity"))
                        writer.uint32(/* id 10, wireType 5 =*/85).float(message.presentVelocity);
                    if (message.load != null && message.hasOwnProperty("load"))
                        writer.uint32(/* id 11, wireType 5 =*/93).float(message.load);
                    if (message.voltage != null && message.hasOwnProperty("voltage"))
                        writer.uint32(/* id 12, wireType 5 =*/101).float(message.voltage);
                    if (message.temperature != null && message.hasOwnProperty("temperature"))
                        writer.uint32(/* id 13, wireType 5 =*/109).float(message.temperature);
                    return writer;
                };

                /**
                 * Encodes the specified Servo message, length delimited. Does not implicitly {@link message.input.Sensors.Servo.verify|verify} messages.
                 * @param {message.input.Sensors.Servo$Properties} message Servo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Servo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Servo message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.Sensors.Servo} Servo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Servo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.Sensors.Servo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.errorFlags = reader.uint32();
                            break;
                        case 2:
                            message.id = reader.uint32();
                            break;
                        case 3:
                            message.enabled = reader.bool();
                            break;
                        case 4:
                            message.pGain = reader.float();
                            break;
                        case 5:
                            message.iGain = reader.float();
                            break;
                        case 6:
                            message.dGain = reader.float();
                            break;
                        case 7:
                            message.goalPosition = reader.float();
                            break;
                        case 8:
                            message.goalVelocity = reader.float();
                            break;
                        case 9:
                            message.presentPosition = reader.float();
                            break;
                        case 10:
                            message.presentVelocity = reader.float();
                            break;
                        case 11:
                            message.load = reader.float();
                            break;
                        case 12:
                            message.voltage = reader.float();
                            break;
                        case 13:
                            message.temperature = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Servo message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.Sensors.Servo} Servo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Servo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Servo message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Servo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.errorFlags != null && message.hasOwnProperty("errorFlags"))
                        if (!$util.isInteger(message.errorFlags))
                            return "errorFlags: integer expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.enabled != null && message.hasOwnProperty("enabled"))
                        if (typeof message.enabled !== "boolean")
                            return "enabled: boolean expected";
                    if (message.pGain != null && message.hasOwnProperty("pGain"))
                        if (typeof message.pGain !== "number")
                            return "pGain: number expected";
                    if (message.iGain != null && message.hasOwnProperty("iGain"))
                        if (typeof message.iGain !== "number")
                            return "iGain: number expected";
                    if (message.dGain != null && message.hasOwnProperty("dGain"))
                        if (typeof message.dGain !== "number")
                            return "dGain: number expected";
                    if (message.goalPosition != null && message.hasOwnProperty("goalPosition"))
                        if (typeof message.goalPosition !== "number")
                            return "goalPosition: number expected";
                    if (message.goalVelocity != null && message.hasOwnProperty("goalVelocity"))
                        if (typeof message.goalVelocity !== "number")
                            return "goalVelocity: number expected";
                    if (message.presentPosition != null && message.hasOwnProperty("presentPosition"))
                        if (typeof message.presentPosition !== "number")
                            return "presentPosition: number expected";
                    if (message.presentVelocity != null && message.hasOwnProperty("presentVelocity"))
                        if (typeof message.presentVelocity !== "number")
                            return "presentVelocity: number expected";
                    if (message.load != null && message.hasOwnProperty("load"))
                        if (typeof message.load !== "number")
                            return "load: number expected";
                    if (message.voltage != null && message.hasOwnProperty("voltage"))
                        if (typeof message.voltage !== "number")
                            return "voltage: number expected";
                    if (message.temperature != null && message.hasOwnProperty("temperature"))
                        if (typeof message.temperature !== "number")
                            return "temperature: number expected";
                    return null;
                };

                /**
                 * Creates a Servo message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.Servo} Servo
                 */
                Servo.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.Sensors.Servo)
                        return object;
                    var message = new $root.message.input.Sensors.Servo();
                    if (object.errorFlags != null)
                        message.errorFlags = object.errorFlags >>> 0;
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.enabled != null)
                        message.enabled = Boolean(object.enabled);
                    if (object.pGain != null)
                        message.pGain = Number(object.pGain);
                    if (object.iGain != null)
                        message.iGain = Number(object.iGain);
                    if (object.dGain != null)
                        message.dGain = Number(object.dGain);
                    if (object.goalPosition != null)
                        message.goalPosition = Number(object.goalPosition);
                    if (object.goalVelocity != null)
                        message.goalVelocity = Number(object.goalVelocity);
                    if (object.presentPosition != null)
                        message.presentPosition = Number(object.presentPosition);
                    if (object.presentVelocity != null)
                        message.presentVelocity = Number(object.presentVelocity);
                    if (object.load != null)
                        message.load = Number(object.load);
                    if (object.voltage != null)
                        message.voltage = Number(object.voltage);
                    if (object.temperature != null)
                        message.temperature = Number(object.temperature);
                    return message;
                };

                /**
                 * Creates a Servo message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.Sensors.Servo.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.Servo} Servo
                 */
                Servo.from = Servo.fromObject;

                /**
                 * Creates a plain object from a Servo message. Also converts values to other types if specified.
                 * @param {message.input.Sensors.Servo} message Servo
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Servo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.errorFlags = 0;
                        object.id = 0;
                        object.enabled = false;
                        object.pGain = 0;
                        object.iGain = 0;
                        object.dGain = 0;
                        object.goalPosition = 0;
                        object.goalVelocity = 0;
                        object.presentPosition = 0;
                        object.presentVelocity = 0;
                        object.load = 0;
                        object.voltage = 0;
                        object.temperature = 0;
                    }
                    if (message.errorFlags != null && message.hasOwnProperty("errorFlags"))
                        object.errorFlags = message.errorFlags;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.enabled != null && message.hasOwnProperty("enabled"))
                        object.enabled = message.enabled;
                    if (message.pGain != null && message.hasOwnProperty("pGain"))
                        object.pGain = message.pGain;
                    if (message.iGain != null && message.hasOwnProperty("iGain"))
                        object.iGain = message.iGain;
                    if (message.dGain != null && message.hasOwnProperty("dGain"))
                        object.dGain = message.dGain;
                    if (message.goalPosition != null && message.hasOwnProperty("goalPosition"))
                        object.goalPosition = message.goalPosition;
                    if (message.goalVelocity != null && message.hasOwnProperty("goalVelocity"))
                        object.goalVelocity = message.goalVelocity;
                    if (message.presentPosition != null && message.hasOwnProperty("presentPosition"))
                        object.presentPosition = message.presentPosition;
                    if (message.presentVelocity != null && message.hasOwnProperty("presentVelocity"))
                        object.presentVelocity = message.presentVelocity;
                    if (message.load != null && message.hasOwnProperty("load"))
                        object.load = message.load;
                    if (message.voltage != null && message.hasOwnProperty("voltage"))
                        object.voltage = message.voltage;
                    if (message.temperature != null && message.hasOwnProperty("temperature"))
                        object.temperature = message.temperature;
                    return object;
                };

                /**
                 * Creates a plain object from this Servo message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Servo.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Servo to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Servo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Servo;
            })();

            Sensors.Button = (function() {

                /**
                 * Properties of a Button.
                 * @typedef message.input.Sensors.Button$Properties
                 * @type {Object}
                 * @property {number} [id] Button id.
                 * @property {boolean} [value] Button value.
                 */

                /**
                 * Constructs a new Button.
                 * @exports message.input.Sensors.Button
                 * @constructor
                 * @param {message.input.Sensors.Button$Properties=} [properties] Properties to set
                 */
                function Button(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Button id.
                 * @type {number}
                 */
                Button.prototype.id = 0;

                /**
                 * Button value.
                 * @type {boolean}
                 */
                Button.prototype.value = false;

                /**
                 * Creates a new Button instance using the specified properties.
                 * @param {message.input.Sensors.Button$Properties=} [properties] Properties to set
                 * @returns {message.input.Sensors.Button} Button instance
                 */
                Button.create = function create(properties) {
                    return new Button(properties);
                };

                /**
                 * Encodes the specified Button message. Does not implicitly {@link message.input.Sensors.Button.verify|verify} messages.
                 * @param {message.input.Sensors.Button$Properties} message Button message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Button.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.value);
                    return writer;
                };

                /**
                 * Encodes the specified Button message, length delimited. Does not implicitly {@link message.input.Sensors.Button.verify|verify} messages.
                 * @param {message.input.Sensors.Button$Properties} message Button message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Button.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Button message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.Sensors.Button} Button
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Button.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.Sensors.Button();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Button message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.Sensors.Button} Button
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Button.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Button message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Button.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "boolean")
                            return "value: boolean expected";
                    return null;
                };

                /**
                 * Creates a Button message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.Button} Button
                 */
                Button.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.Sensors.Button)
                        return object;
                    var message = new $root.message.input.Sensors.Button();
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.value != null)
                        message.value = Boolean(object.value);
                    return message;
                };

                /**
                 * Creates a Button message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.Sensors.Button.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.Button} Button
                 */
                Button.from = Button.fromObject;

                /**
                 * Creates a plain object from a Button message. Also converts values to other types if specified.
                 * @param {message.input.Sensors.Button} message Button
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Button.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = 0;
                        object.value = false;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };

                /**
                 * Creates a plain object from this Button message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Button.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Button to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Button.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Button;
            })();

            Sensors.LED = (function() {

                /**
                 * Properties of a LED.
                 * @typedef message.input.Sensors.LED$Properties
                 * @type {Object}
                 * @property {number} [id] LED id.
                 * @property {number} [colour] LED colour.
                 */

                /**
                 * Constructs a new LED.
                 * @exports message.input.Sensors.LED
                 * @constructor
                 * @param {message.input.Sensors.LED$Properties=} [properties] Properties to set
                 */
                function LED(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LED id.
                 * @type {number}
                 */
                LED.prototype.id = 0;

                /**
                 * LED colour.
                 * @type {number}
                 */
                LED.prototype.colour = 0;

                /**
                 * Creates a new LED instance using the specified properties.
                 * @param {message.input.Sensors.LED$Properties=} [properties] Properties to set
                 * @returns {message.input.Sensors.LED} LED instance
                 */
                LED.create = function create(properties) {
                    return new LED(properties);
                };

                /**
                 * Encodes the specified LED message. Does not implicitly {@link message.input.Sensors.LED.verify|verify} messages.
                 * @param {message.input.Sensors.LED$Properties} message LED message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LED.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && message.hasOwnProperty("id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if (message.colour != null && message.hasOwnProperty("colour"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.colour);
                    return writer;
                };

                /**
                 * Encodes the specified LED message, length delimited. Does not implicitly {@link message.input.Sensors.LED.verify|verify} messages.
                 * @param {message.input.Sensors.LED$Properties} message LED message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LED.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LED message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.Sensors.LED} LED
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LED.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.Sensors.LED();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.uint32();
                            break;
                        case 2:
                            message.colour = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LED message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.Sensors.LED} LED
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LED.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LED message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                LED.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    if (message.colour != null && message.hasOwnProperty("colour"))
                        if (!$util.isInteger(message.colour))
                            return "colour: integer expected";
                    return null;
                };

                /**
                 * Creates a LED message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.LED} LED
                 */
                LED.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.Sensors.LED)
                        return object;
                    var message = new $root.message.input.Sensors.LED();
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    if (object.colour != null)
                        message.colour = object.colour >>> 0;
                    return message;
                };

                /**
                 * Creates a LED message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.Sensors.LED.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.LED} LED
                 */
                LED.from = LED.fromObject;

                /**
                 * Creates a plain object from a LED message. Also converts values to other types if specified.
                 * @param {message.input.Sensors.LED} message LED
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LED.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.id = 0;
                        object.colour = 0;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.colour != null && message.hasOwnProperty("colour"))
                        object.colour = message.colour;
                    return object;
                };

                /**
                 * Creates a plain object from this LED message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LED.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this LED to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                LED.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LED;
            })();

            Sensors.FSR = (function() {

                /**
                 * Properties of a FSR.
                 * @typedef message.input.Sensors.FSR$Properties
                 * @type {Object}
                 * @property {Array.<number>} [value] FSR value.
                 * @property {vec2$Properties} [centre] FSR centre.
                 */

                /**
                 * Constructs a new FSR.
                 * @exports message.input.Sensors.FSR
                 * @constructor
                 * @param {message.input.Sensors.FSR$Properties=} [properties] Properties to set
                 */
                function FSR(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FSR value.
                 * @type {Array.<number>}
                 */
                FSR.prototype.value = $util.emptyArray;

                /**
                 * FSR centre.
                 * @type {(vec2$Properties|null)}
                 */
                FSR.prototype.centre = null;

                /**
                 * Creates a new FSR instance using the specified properties.
                 * @param {message.input.Sensors.FSR$Properties=} [properties] Properties to set
                 * @returns {message.input.Sensors.FSR} FSR instance
                 */
                FSR.create = function create(properties) {
                    return new FSR(properties);
                };

                /**
                 * Encodes the specified FSR message. Does not implicitly {@link message.input.Sensors.FSR.verify|verify} messages.
                 * @param {message.input.Sensors.FSR$Properties} message FSR message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FSR.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.value.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.value.length; ++i)
                            writer.float(message.value[i]);
                        writer.ldelim();
                    }
                    if (message.centre != null && message.hasOwnProperty("centre"))
                        $root.vec2.encode(message.centre, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified FSR message, length delimited. Does not implicitly {@link message.input.Sensors.FSR.verify|verify} messages.
                 * @param {message.input.Sensors.FSR$Properties} message FSR message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FSR.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FSR message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.Sensors.FSR} FSR
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FSR.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.input.Sensors.FSR();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.value.push(reader.float());
                            } else
                                message.value.push(reader.float());
                            break;
                        case 2:
                            message.centre = $root.vec2.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FSR message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.Sensors.FSR} FSR
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FSR.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FSR message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                FSR.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i)
                            if (typeof message.value[i] !== "number")
                                return "value: number[] expected";
                    }
                    if (message.centre != null && message.hasOwnProperty("centre")) {
                        var error = $root.vec2.verify(message.centre);
                        if (error)
                            return "centre." + error;
                    }
                    return null;
                };

                /**
                 * Creates a FSR message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.FSR} FSR
                 */
                FSR.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.input.Sensors.FSR)
                        return object;
                    var message = new $root.message.input.Sensors.FSR();
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".message.input.Sensors.FSR.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i)
                            message.value[i] = Number(object.value[i]);
                    }
                    if (object.centre != null) {
                        if (typeof object.centre !== "object")
                            throw TypeError(".message.input.Sensors.FSR.centre: object expected");
                        message.centre = $root.vec2.fromObject(object.centre);
                    }
                    return message;
                };

                /**
                 * Creates a FSR message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.Sensors.FSR.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.FSR} FSR
                 */
                FSR.from = FSR.fromObject;

                /**
                 * Creates a plain object from a FSR message. Also converts values to other types if specified.
                 * @param {message.input.Sensors.FSR} message FSR
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FSR.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (options.defaults)
                        object.centre = null;
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = message.value[j];
                    }
                    if (message.centre != null && message.hasOwnProperty("centre"))
                        object.centre = $root.vec2.toObject(message.centre, options);
                    return object;
                };

                /**
                 * Creates a plain object from this FSR message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FSR.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this FSR to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                FSR.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FSR;
            })();

            return Sensors;
        })();

        return input;
    })();

    message.localisation = (function() {

        /**
         * Namespace localisation.
         * @exports message.localisation
         * @namespace
         */
        var localisation = {};

        localisation.Ball = (function() {

            /**
             * Properties of a Ball.
             * @typedef message.localisation.Ball$Properties
             * @type {Object}
             * @property {vec2$Properties} [position] Ball position.
             * @property {mat22$Properties} [covariance] Ball covariance.
             */

            /**
             * Constructs a new Ball.
             * @exports message.localisation.Ball
             * @constructor
             * @param {message.localisation.Ball$Properties=} [properties] Properties to set
             */
            function Ball(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Ball position.
             * @type {(vec2$Properties|null)}
             */
            Ball.prototype.position = null;

            /**
             * Ball covariance.
             * @type {(mat22$Properties|null)}
             */
            Ball.prototype.covariance = null;

            /**
             * Creates a new Ball instance using the specified properties.
             * @param {message.localisation.Ball$Properties=} [properties] Properties to set
             * @returns {message.localisation.Ball} Ball instance
             */
            Ball.create = function create(properties) {
                return new Ball(properties);
            };

            /**
             * Encodes the specified Ball message. Does not implicitly {@link message.localisation.Ball.verify|verify} messages.
             * @param {message.localisation.Ball$Properties} message Ball message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ball.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && message.hasOwnProperty("position"))
                    $root.vec2.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.covariance != null && message.hasOwnProperty("covariance"))
                    $root.mat22.encode(message.covariance, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Ball message, length delimited. Does not implicitly {@link message.localisation.Ball.verify|verify} messages.
             * @param {message.localisation.Ball$Properties} message Ball message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ball.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Ball message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.localisation.Ball} Ball
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ball.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.localisation.Ball();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.position = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.covariance = $root.mat22.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Ball message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.localisation.Ball} Ball
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ball.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Ball message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Ball.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.vec2.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.covariance != null && message.hasOwnProperty("covariance")) {
                    var error = $root.mat22.verify(message.covariance);
                    if (error)
                        return "covariance." + error;
                }
                return null;
            };

            /**
             * Creates a Ball message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.localisation.Ball} Ball
             */
            Ball.fromObject = function fromObject(object) {
                if (object instanceof $root.message.localisation.Ball)
                    return object;
                var message = new $root.message.localisation.Ball();
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".message.localisation.Ball.position: object expected");
                    message.position = $root.vec2.fromObject(object.position);
                }
                if (object.covariance != null) {
                    if (typeof object.covariance !== "object")
                        throw TypeError(".message.localisation.Ball.covariance: object expected");
                    message.covariance = $root.mat22.fromObject(object.covariance);
                }
                return message;
            };

            /**
             * Creates a Ball message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.localisation.Ball.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.localisation.Ball} Ball
             */
            Ball.from = Ball.fromObject;

            /**
             * Creates a plain object from a Ball message. Also converts values to other types if specified.
             * @param {message.localisation.Ball} message Ball
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Ball.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.position = null;
                    object.covariance = null;
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.vec2.toObject(message.position, options);
                if (message.covariance != null && message.hasOwnProperty("covariance"))
                    object.covariance = $root.mat22.toObject(message.covariance, options);
                return object;
            };

            /**
             * Creates a plain object from this Ball message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Ball.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Ball to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Ball.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Ball;
        })();

        localisation.Field = (function() {

            /**
             * Properties of a Field.
             * @typedef message.localisation.Field$Properties
             * @type {Object}
             * @property {vec3$Properties} [position] Field position.
             * @property {mat33$Properties} [covariance] Field covariance.
             */

            /**
             * Constructs a new Field.
             * @exports message.localisation.Field
             * @constructor
             * @param {message.localisation.Field$Properties=} [properties] Properties to set
             */
            function Field(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Field position.
             * @type {(vec3$Properties|null)}
             */
            Field.prototype.position = null;

            /**
             * Field covariance.
             * @type {(mat33$Properties|null)}
             */
            Field.prototype.covariance = null;

            /**
             * Creates a new Field instance using the specified properties.
             * @param {message.localisation.Field$Properties=} [properties] Properties to set
             * @returns {message.localisation.Field} Field instance
             */
            Field.create = function create(properties) {
                return new Field(properties);
            };

            /**
             * Encodes the specified Field message. Does not implicitly {@link message.localisation.Field.verify|verify} messages.
             * @param {message.localisation.Field$Properties} message Field message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Field.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && message.hasOwnProperty("position"))
                    $root.vec3.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.covariance != null && message.hasOwnProperty("covariance"))
                    $root.mat33.encode(message.covariance, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Field message, length delimited. Does not implicitly {@link message.localisation.Field.verify|verify} messages.
             * @param {message.localisation.Field$Properties} message Field message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Field.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Field message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.localisation.Field} Field
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Field.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.localisation.Field();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.position = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.covariance = $root.mat33.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Field message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.localisation.Field} Field
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Field.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Field message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Field.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.vec3.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.covariance != null && message.hasOwnProperty("covariance")) {
                    var error = $root.mat33.verify(message.covariance);
                    if (error)
                        return "covariance." + error;
                }
                return null;
            };

            /**
             * Creates a Field message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.localisation.Field} Field
             */
            Field.fromObject = function fromObject(object) {
                if (object instanceof $root.message.localisation.Field)
                    return object;
                var message = new $root.message.localisation.Field();
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".message.localisation.Field.position: object expected");
                    message.position = $root.vec3.fromObject(object.position);
                }
                if (object.covariance != null) {
                    if (typeof object.covariance !== "object")
                        throw TypeError(".message.localisation.Field.covariance: object expected");
                    message.covariance = $root.mat33.fromObject(object.covariance);
                }
                return message;
            };

            /**
             * Creates a Field message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.localisation.Field.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.localisation.Field} Field
             */
            Field.from = Field.fromObject;

            /**
             * Creates a plain object from a Field message. Also converts values to other types if specified.
             * @param {message.localisation.Field} message Field
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Field.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.position = null;
                    object.covariance = null;
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.vec3.toObject(message.position, options);
                if (message.covariance != null && message.hasOwnProperty("covariance"))
                    object.covariance = $root.mat33.toObject(message.covariance, options);
                return object;
            };

            /**
             * Creates a plain object from this Field message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Field.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Field to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Field.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Field;
        })();

        localisation.ResetRobotHypotheses = (function() {

            /**
             * Properties of a ResetRobotHypotheses.
             * @typedef message.localisation.ResetRobotHypotheses$Properties
             * @type {Object}
             * @property {Array.<message.localisation.ResetRobotHypotheses.Self$Properties>} [hypotheses] ResetRobotHypotheses hypotheses.
             */

            /**
             * Constructs a new ResetRobotHypotheses.
             * @exports message.localisation.ResetRobotHypotheses
             * @constructor
             * @param {message.localisation.ResetRobotHypotheses$Properties=} [properties] Properties to set
             */
            function ResetRobotHypotheses(properties) {
                this.hypotheses = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ResetRobotHypotheses hypotheses.
             * @type {Array.<message.localisation.ResetRobotHypotheses.Self$Properties>}
             */
            ResetRobotHypotheses.prototype.hypotheses = $util.emptyArray;

            /**
             * Creates a new ResetRobotHypotheses instance using the specified properties.
             * @param {message.localisation.ResetRobotHypotheses$Properties=} [properties] Properties to set
             * @returns {message.localisation.ResetRobotHypotheses} ResetRobotHypotheses instance
             */
            ResetRobotHypotheses.create = function create(properties) {
                return new ResetRobotHypotheses(properties);
            };

            /**
             * Encodes the specified ResetRobotHypotheses message. Does not implicitly {@link message.localisation.ResetRobotHypotheses.verify|verify} messages.
             * @param {message.localisation.ResetRobotHypotheses$Properties} message ResetRobotHypotheses message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResetRobotHypotheses.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hypotheses != null && message.hypotheses.length)
                    for (var i = 0; i < message.hypotheses.length; ++i)
                        $root.message.localisation.ResetRobotHypotheses.Self.encode(message.hypotheses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ResetRobotHypotheses message, length delimited. Does not implicitly {@link message.localisation.ResetRobotHypotheses.verify|verify} messages.
             * @param {message.localisation.ResetRobotHypotheses$Properties} message ResetRobotHypotheses message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResetRobotHypotheses.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ResetRobotHypotheses message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.localisation.ResetRobotHypotheses} ResetRobotHypotheses
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResetRobotHypotheses.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.localisation.ResetRobotHypotheses();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.hypotheses && message.hypotheses.length))
                            message.hypotheses = [];
                        message.hypotheses.push($root.message.localisation.ResetRobotHypotheses.Self.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ResetRobotHypotheses message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.localisation.ResetRobotHypotheses} ResetRobotHypotheses
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResetRobotHypotheses.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ResetRobotHypotheses message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ResetRobotHypotheses.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hypotheses != null && message.hasOwnProperty("hypotheses")) {
                    if (!Array.isArray(message.hypotheses))
                        return "hypotheses: array expected";
                    for (var i = 0; i < message.hypotheses.length; ++i) {
                        var error = $root.message.localisation.ResetRobotHypotheses.Self.verify(message.hypotheses[i]);
                        if (error)
                            return "hypotheses." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ResetRobotHypotheses message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.localisation.ResetRobotHypotheses} ResetRobotHypotheses
             */
            ResetRobotHypotheses.fromObject = function fromObject(object) {
                if (object instanceof $root.message.localisation.ResetRobotHypotheses)
                    return object;
                var message = new $root.message.localisation.ResetRobotHypotheses();
                if (object.hypotheses) {
                    if (!Array.isArray(object.hypotheses))
                        throw TypeError(".message.localisation.ResetRobotHypotheses.hypotheses: array expected");
                    message.hypotheses = [];
                    for (var i = 0; i < object.hypotheses.length; ++i) {
                        if (typeof object.hypotheses[i] !== "object")
                            throw TypeError(".message.localisation.ResetRobotHypotheses.hypotheses: object expected");
                        message.hypotheses[i] = $root.message.localisation.ResetRobotHypotheses.Self.fromObject(object.hypotheses[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a ResetRobotHypotheses message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.localisation.ResetRobotHypotheses.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.localisation.ResetRobotHypotheses} ResetRobotHypotheses
             */
            ResetRobotHypotheses.from = ResetRobotHypotheses.fromObject;

            /**
             * Creates a plain object from a ResetRobotHypotheses message. Also converts values to other types if specified.
             * @param {message.localisation.ResetRobotHypotheses} message ResetRobotHypotheses
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ResetRobotHypotheses.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.hypotheses = [];
                if (message.hypotheses && message.hypotheses.length) {
                    object.hypotheses = [];
                    for (var j = 0; j < message.hypotheses.length; ++j)
                        object.hypotheses[j] = $root.message.localisation.ResetRobotHypotheses.Self.toObject(message.hypotheses[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this ResetRobotHypotheses message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ResetRobotHypotheses.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ResetRobotHypotheses to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ResetRobotHypotheses.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            ResetRobotHypotheses.Self = (function() {

                /**
                 * Properties of a Self.
                 * @typedef message.localisation.ResetRobotHypotheses.Self$Properties
                 * @type {Object}
                 * @property {vec2$Properties} [position] Self position.
                 * @property {mat22$Properties} [positionCov] Self positionCov.
                 * @property {number} [heading] Self heading.
                 * @property {number} [headingVar] Self headingVar.
                 * @property {boolean} [absoluteYaw] Self absoluteYaw.
                 */

                /**
                 * Constructs a new Self.
                 * @exports message.localisation.ResetRobotHypotheses.Self
                 * @constructor
                 * @param {message.localisation.ResetRobotHypotheses.Self$Properties=} [properties] Properties to set
                 */
                function Self(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Self position.
                 * @type {(vec2$Properties|null)}
                 */
                Self.prototype.position = null;

                /**
                 * Self positionCov.
                 * @type {(mat22$Properties|null)}
                 */
                Self.prototype.positionCov = null;

                /**
                 * Self heading.
                 * @type {number}
                 */
                Self.prototype.heading = 0;

                /**
                 * Self headingVar.
                 * @type {number}
                 */
                Self.prototype.headingVar = 0;

                /**
                 * Self absoluteYaw.
                 * @type {boolean}
                 */
                Self.prototype.absoluteYaw = false;

                /**
                 * Creates a new Self instance using the specified properties.
                 * @param {message.localisation.ResetRobotHypotheses.Self$Properties=} [properties] Properties to set
                 * @returns {message.localisation.ResetRobotHypotheses.Self} Self instance
                 */
                Self.create = function create(properties) {
                    return new Self(properties);
                };

                /**
                 * Encodes the specified Self message. Does not implicitly {@link message.localisation.ResetRobotHypotheses.Self.verify|verify} messages.
                 * @param {message.localisation.ResetRobotHypotheses.Self$Properties} message Self message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Self.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.position != null && message.hasOwnProperty("position"))
                        $root.vec2.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.positionCov != null && message.hasOwnProperty("positionCov"))
                        $root.mat22.encode(message.positionCov, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.heading != null && message.hasOwnProperty("heading"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.heading);
                    if (message.headingVar != null && message.hasOwnProperty("headingVar"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.headingVar);
                    if (message.absoluteYaw != null && message.hasOwnProperty("absoluteYaw"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.absoluteYaw);
                    return writer;
                };

                /**
                 * Encodes the specified Self message, length delimited. Does not implicitly {@link message.localisation.ResetRobotHypotheses.Self.verify|verify} messages.
                 * @param {message.localisation.ResetRobotHypotheses.Self$Properties} message Self message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Self.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Self message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.localisation.ResetRobotHypotheses.Self} Self
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Self.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.localisation.ResetRobotHypotheses.Self();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.position = $root.vec2.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.positionCov = $root.mat22.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.heading = reader.double();
                            break;
                        case 4:
                            message.headingVar = reader.double();
                            break;
                        case 5:
                            message.absoluteYaw = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Self message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.localisation.ResetRobotHypotheses.Self} Self
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Self.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Self message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Self.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.position != null && message.hasOwnProperty("position")) {
                        var error = $root.vec2.verify(message.position);
                        if (error)
                            return "position." + error;
                    }
                    if (message.positionCov != null && message.hasOwnProperty("positionCov")) {
                        var error = $root.mat22.verify(message.positionCov);
                        if (error)
                            return "positionCov." + error;
                    }
                    if (message.heading != null && message.hasOwnProperty("heading"))
                        if (typeof message.heading !== "number")
                            return "heading: number expected";
                    if (message.headingVar != null && message.hasOwnProperty("headingVar"))
                        if (typeof message.headingVar !== "number")
                            return "headingVar: number expected";
                    if (message.absoluteYaw != null && message.hasOwnProperty("absoluteYaw"))
                        if (typeof message.absoluteYaw !== "boolean")
                            return "absoluteYaw: boolean expected";
                    return null;
                };

                /**
                 * Creates a Self message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.localisation.ResetRobotHypotheses.Self} Self
                 */
                Self.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.localisation.ResetRobotHypotheses.Self)
                        return object;
                    var message = new $root.message.localisation.ResetRobotHypotheses.Self();
                    if (object.position != null) {
                        if (typeof object.position !== "object")
                            throw TypeError(".message.localisation.ResetRobotHypotheses.Self.position: object expected");
                        message.position = $root.vec2.fromObject(object.position);
                    }
                    if (object.positionCov != null) {
                        if (typeof object.positionCov !== "object")
                            throw TypeError(".message.localisation.ResetRobotHypotheses.Self.positionCov: object expected");
                        message.positionCov = $root.mat22.fromObject(object.positionCov);
                    }
                    if (object.heading != null)
                        message.heading = Number(object.heading);
                    if (object.headingVar != null)
                        message.headingVar = Number(object.headingVar);
                    if (object.absoluteYaw != null)
                        message.absoluteYaw = Boolean(object.absoluteYaw);
                    return message;
                };

                /**
                 * Creates a Self message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.localisation.ResetRobotHypotheses.Self.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.localisation.ResetRobotHypotheses.Self} Self
                 */
                Self.from = Self.fromObject;

                /**
                 * Creates a plain object from a Self message. Also converts values to other types if specified.
                 * @param {message.localisation.ResetRobotHypotheses.Self} message Self
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Self.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.position = null;
                        object.positionCov = null;
                        object.heading = 0;
                        object.headingVar = 0;
                        object.absoluteYaw = false;
                    }
                    if (message.position != null && message.hasOwnProperty("position"))
                        object.position = $root.vec2.toObject(message.position, options);
                    if (message.positionCov != null && message.hasOwnProperty("positionCov"))
                        object.positionCov = $root.mat22.toObject(message.positionCov, options);
                    if (message.heading != null && message.hasOwnProperty("heading"))
                        object.heading = message.heading;
                    if (message.headingVar != null && message.hasOwnProperty("headingVar"))
                        object.headingVar = message.headingVar;
                    if (message.absoluteYaw != null && message.hasOwnProperty("absoluteYaw"))
                        object.absoluteYaw = message.absoluteYaw;
                    return object;
                };

                /**
                 * Creates a plain object from this Self message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Self.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Self to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Self.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Self;
            })();

            return ResetRobotHypotheses;
        })();

        return localisation;
    })();

    message.motion = (function() {

        /**
         * Namespace motion.
         * @exports message.motion
         * @namespace
         */
        var motion = {};

        motion.BalanceBodyUpdate = (function() {

            /**
             * Properties of a BalanceBodyUpdate.
             * @typedef message.motion.BalanceBodyUpdate$Properties
             * @type {Object}
             * @property {number} [phase] BalanceBodyUpdate phase.
             * @property {mat44$Properties} [leftFoot] BalanceBodyUpdate leftFoot.
             * @property {mat44$Properties} [rightFoot] BalanceBodyUpdate rightFoot.
             * @property {vec3$Properties} [armLPosition] BalanceBodyUpdate armLPosition.
             * @property {vec3$Properties} [armRPosition] BalanceBodyUpdate armRPosition.
             */

            /**
             * Constructs a new BalanceBodyUpdate.
             * @exports message.motion.BalanceBodyUpdate
             * @constructor
             * @param {message.motion.BalanceBodyUpdate$Properties=} [properties] Properties to set
             */
            function BalanceBodyUpdate(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BalanceBodyUpdate phase.
             * @type {number}
             */
            BalanceBodyUpdate.prototype.phase = 0;

            /**
             * BalanceBodyUpdate leftFoot.
             * @type {(mat44$Properties|null)}
             */
            BalanceBodyUpdate.prototype.leftFoot = null;

            /**
             * BalanceBodyUpdate rightFoot.
             * @type {(mat44$Properties|null)}
             */
            BalanceBodyUpdate.prototype.rightFoot = null;

            /**
             * BalanceBodyUpdate armLPosition.
             * @type {(vec3$Properties|null)}
             */
            BalanceBodyUpdate.prototype.armLPosition = null;

            /**
             * BalanceBodyUpdate armRPosition.
             * @type {(vec3$Properties|null)}
             */
            BalanceBodyUpdate.prototype.armRPosition = null;

            /**
             * Creates a new BalanceBodyUpdate instance using the specified properties.
             * @param {message.motion.BalanceBodyUpdate$Properties=} [properties] Properties to set
             * @returns {message.motion.BalanceBodyUpdate} BalanceBodyUpdate instance
             */
            BalanceBodyUpdate.create = function create(properties) {
                return new BalanceBodyUpdate(properties);
            };

            /**
             * Encodes the specified BalanceBodyUpdate message. Does not implicitly {@link message.motion.BalanceBodyUpdate.verify|verify} messages.
             * @param {message.motion.BalanceBodyUpdate$Properties} message BalanceBodyUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BalanceBodyUpdate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.phase != null && message.hasOwnProperty("phase"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.phase);
                if (message.leftFoot != null && message.hasOwnProperty("leftFoot"))
                    $root.mat44.encode(message.leftFoot, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.rightFoot != null && message.hasOwnProperty("rightFoot"))
                    $root.mat44.encode(message.rightFoot, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.armLPosition != null && message.hasOwnProperty("armLPosition"))
                    $root.vec3.encode(message.armLPosition, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.armRPosition != null && message.hasOwnProperty("armRPosition"))
                    $root.vec3.encode(message.armRPosition, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BalanceBodyUpdate message, length delimited. Does not implicitly {@link message.motion.BalanceBodyUpdate.verify|verify} messages.
             * @param {message.motion.BalanceBodyUpdate$Properties} message BalanceBodyUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BalanceBodyUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BalanceBodyUpdate message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.BalanceBodyUpdate} BalanceBodyUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BalanceBodyUpdate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.BalanceBodyUpdate();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.phase = reader.double();
                        break;
                    case 2:
                        message.leftFoot = $root.mat44.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.rightFoot = $root.mat44.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.armLPosition = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.armRPosition = $root.vec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BalanceBodyUpdate message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.BalanceBodyUpdate} BalanceBodyUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BalanceBodyUpdate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BalanceBodyUpdate message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            BalanceBodyUpdate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.phase != null && message.hasOwnProperty("phase"))
                    if (typeof message.phase !== "number")
                        return "phase: number expected";
                if (message.leftFoot != null && message.hasOwnProperty("leftFoot")) {
                    var error = $root.mat44.verify(message.leftFoot);
                    if (error)
                        return "leftFoot." + error;
                }
                if (message.rightFoot != null && message.hasOwnProperty("rightFoot")) {
                    var error = $root.mat44.verify(message.rightFoot);
                    if (error)
                        return "rightFoot." + error;
                }
                if (message.armLPosition != null && message.hasOwnProperty("armLPosition")) {
                    var error = $root.vec3.verify(message.armLPosition);
                    if (error)
                        return "armLPosition." + error;
                }
                if (message.armRPosition != null && message.hasOwnProperty("armRPosition")) {
                    var error = $root.vec3.verify(message.armRPosition);
                    if (error)
                        return "armRPosition." + error;
                }
                return null;
            };

            /**
             * Creates a BalanceBodyUpdate message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.BalanceBodyUpdate} BalanceBodyUpdate
             */
            BalanceBodyUpdate.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.BalanceBodyUpdate)
                    return object;
                var message = new $root.message.motion.BalanceBodyUpdate();
                if (object.phase != null)
                    message.phase = Number(object.phase);
                if (object.leftFoot != null) {
                    if (typeof object.leftFoot !== "object")
                        throw TypeError(".message.motion.BalanceBodyUpdate.leftFoot: object expected");
                    message.leftFoot = $root.mat44.fromObject(object.leftFoot);
                }
                if (object.rightFoot != null) {
                    if (typeof object.rightFoot !== "object")
                        throw TypeError(".message.motion.BalanceBodyUpdate.rightFoot: object expected");
                    message.rightFoot = $root.mat44.fromObject(object.rightFoot);
                }
                if (object.armLPosition != null) {
                    if (typeof object.armLPosition !== "object")
                        throw TypeError(".message.motion.BalanceBodyUpdate.armLPosition: object expected");
                    message.armLPosition = $root.vec3.fromObject(object.armLPosition);
                }
                if (object.armRPosition != null) {
                    if (typeof object.armRPosition !== "object")
                        throw TypeError(".message.motion.BalanceBodyUpdate.armRPosition: object expected");
                    message.armRPosition = $root.vec3.fromObject(object.armRPosition);
                }
                return message;
            };

            /**
             * Creates a BalanceBodyUpdate message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.BalanceBodyUpdate.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.BalanceBodyUpdate} BalanceBodyUpdate
             */
            BalanceBodyUpdate.from = BalanceBodyUpdate.fromObject;

            /**
             * Creates a plain object from a BalanceBodyUpdate message. Also converts values to other types if specified.
             * @param {message.motion.BalanceBodyUpdate} message BalanceBodyUpdate
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BalanceBodyUpdate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.phase = 0;
                    object.leftFoot = null;
                    object.rightFoot = null;
                    object.armLPosition = null;
                    object.armRPosition = null;
                }
                if (message.phase != null && message.hasOwnProperty("phase"))
                    object.phase = message.phase;
                if (message.leftFoot != null && message.hasOwnProperty("leftFoot"))
                    object.leftFoot = $root.mat44.toObject(message.leftFoot, options);
                if (message.rightFoot != null && message.hasOwnProperty("rightFoot"))
                    object.rightFoot = $root.mat44.toObject(message.rightFoot, options);
                if (message.armLPosition != null && message.hasOwnProperty("armLPosition"))
                    object.armLPosition = $root.vec3.toObject(message.armLPosition, options);
                if (message.armRPosition != null && message.hasOwnProperty("armRPosition"))
                    object.armRPosition = $root.vec3.toObject(message.armRPosition, options);
                return object;
            };

            /**
             * Creates a plain object from this BalanceBodyUpdate message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BalanceBodyUpdate.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this BalanceBodyUpdate to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            BalanceBodyUpdate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BalanceBodyUpdate;
        })();

        motion.EnableBalanceResponse = (function() {

            /**
             * Properties of an EnableBalanceResponse.
             * @typedef message.motion.EnableBalanceResponse$Properties
             * @type {Object}
             */

            /**
             * Constructs a new EnableBalanceResponse.
             * @exports message.motion.EnableBalanceResponse
             * @constructor
             * @param {message.motion.EnableBalanceResponse$Properties=} [properties] Properties to set
             */
            function EnableBalanceResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new EnableBalanceResponse instance using the specified properties.
             * @param {message.motion.EnableBalanceResponse$Properties=} [properties] Properties to set
             * @returns {message.motion.EnableBalanceResponse} EnableBalanceResponse instance
             */
            EnableBalanceResponse.create = function create(properties) {
                return new EnableBalanceResponse(properties);
            };

            /**
             * Encodes the specified EnableBalanceResponse message. Does not implicitly {@link message.motion.EnableBalanceResponse.verify|verify} messages.
             * @param {message.motion.EnableBalanceResponse$Properties} message EnableBalanceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnableBalanceResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified EnableBalanceResponse message, length delimited. Does not implicitly {@link message.motion.EnableBalanceResponse.verify|verify} messages.
             * @param {message.motion.EnableBalanceResponse$Properties} message EnableBalanceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnableBalanceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnableBalanceResponse message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.EnableBalanceResponse} EnableBalanceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnableBalanceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.EnableBalanceResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnableBalanceResponse message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.EnableBalanceResponse} EnableBalanceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnableBalanceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnableBalanceResponse message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            EnableBalanceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an EnableBalanceResponse message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableBalanceResponse} EnableBalanceResponse
             */
            EnableBalanceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.EnableBalanceResponse)
                    return object;
                return new $root.message.motion.EnableBalanceResponse();
            };

            /**
             * Creates an EnableBalanceResponse message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.EnableBalanceResponse.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableBalanceResponse} EnableBalanceResponse
             */
            EnableBalanceResponse.from = EnableBalanceResponse.fromObject;

            /**
             * Creates a plain object from an EnableBalanceResponse message. Also converts values to other types if specified.
             * @param {message.motion.EnableBalanceResponse} message EnableBalanceResponse
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnableBalanceResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this EnableBalanceResponse message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnableBalanceResponse.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this EnableBalanceResponse to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            EnableBalanceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnableBalanceResponse;
        })();

        motion.DisableBalanceResponse = (function() {

            /**
             * Properties of a DisableBalanceResponse.
             * @typedef message.motion.DisableBalanceResponse$Properties
             * @type {Object}
             */

            /**
             * Constructs a new DisableBalanceResponse.
             * @exports message.motion.DisableBalanceResponse
             * @constructor
             * @param {message.motion.DisableBalanceResponse$Properties=} [properties] Properties to set
             */
            function DisableBalanceResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DisableBalanceResponse instance using the specified properties.
             * @param {message.motion.DisableBalanceResponse$Properties=} [properties] Properties to set
             * @returns {message.motion.DisableBalanceResponse} DisableBalanceResponse instance
             */
            DisableBalanceResponse.create = function create(properties) {
                return new DisableBalanceResponse(properties);
            };

            /**
             * Encodes the specified DisableBalanceResponse message. Does not implicitly {@link message.motion.DisableBalanceResponse.verify|verify} messages.
             * @param {message.motion.DisableBalanceResponse$Properties} message DisableBalanceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisableBalanceResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DisableBalanceResponse message, length delimited. Does not implicitly {@link message.motion.DisableBalanceResponse.verify|verify} messages.
             * @param {message.motion.DisableBalanceResponse$Properties} message DisableBalanceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisableBalanceResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DisableBalanceResponse message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DisableBalanceResponse} DisableBalanceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisableBalanceResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.DisableBalanceResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DisableBalanceResponse message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DisableBalanceResponse} DisableBalanceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisableBalanceResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DisableBalanceResponse message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            DisableBalanceResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DisableBalanceResponse message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableBalanceResponse} DisableBalanceResponse
             */
            DisableBalanceResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.DisableBalanceResponse)
                    return object;
                return new $root.message.motion.DisableBalanceResponse();
            };

            /**
             * Creates a DisableBalanceResponse message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DisableBalanceResponse.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableBalanceResponse} DisableBalanceResponse
             */
            DisableBalanceResponse.from = DisableBalanceResponse.fromObject;

            /**
             * Creates a plain object from a DisableBalanceResponse message. Also converts values to other types if specified.
             * @param {message.motion.DisableBalanceResponse} message DisableBalanceResponse
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisableBalanceResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this DisableBalanceResponse message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisableBalanceResponse.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this DisableBalanceResponse to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            DisableBalanceResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DisableBalanceResponse;
        })();

        motion.DiveCommand = (function() {

            /**
             * Properties of a DiveCommand.
             * @typedef message.motion.DiveCommand$Properties
             * @type {Object}
             * @property {vec2$Properties} [direction] DiveCommand direction.
             */

            /**
             * Constructs a new DiveCommand.
             * @exports message.motion.DiveCommand
             * @constructor
             * @param {message.motion.DiveCommand$Properties=} [properties] Properties to set
             */
            function DiveCommand(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DiveCommand direction.
             * @type {(vec2$Properties|null)}
             */
            DiveCommand.prototype.direction = null;

            /**
             * Creates a new DiveCommand instance using the specified properties.
             * @param {message.motion.DiveCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.DiveCommand} DiveCommand instance
             */
            DiveCommand.create = function create(properties) {
                return new DiveCommand(properties);
            };

            /**
             * Encodes the specified DiveCommand message. Does not implicitly {@link message.motion.DiveCommand.verify|verify} messages.
             * @param {message.motion.DiveCommand$Properties} message DiveCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiveCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.direction != null && message.hasOwnProperty("direction"))
                    $root.vec2.encode(message.direction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DiveCommand message, length delimited. Does not implicitly {@link message.motion.DiveCommand.verify|verify} messages.
             * @param {message.motion.DiveCommand$Properties} message DiveCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiveCommand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DiveCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DiveCommand} DiveCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiveCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.DiveCommand();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.direction = $root.vec2.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DiveCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DiveCommand} DiveCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiveCommand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DiveCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            DiveCommand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.direction != null && message.hasOwnProperty("direction")) {
                    var error = $root.vec2.verify(message.direction);
                    if (error)
                        return "direction." + error;
                }
                return null;
            };

            /**
             * Creates a DiveCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DiveCommand} DiveCommand
             */
            DiveCommand.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.DiveCommand)
                    return object;
                var message = new $root.message.motion.DiveCommand();
                if (object.direction != null) {
                    if (typeof object.direction !== "object")
                        throw TypeError(".message.motion.DiveCommand.direction: object expected");
                    message.direction = $root.vec2.fromObject(object.direction);
                }
                return message;
            };

            /**
             * Creates a DiveCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DiveCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DiveCommand} DiveCommand
             */
            DiveCommand.from = DiveCommand.fromObject;

            /**
             * Creates a plain object from a DiveCommand message. Also converts values to other types if specified.
             * @param {message.motion.DiveCommand} message DiveCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DiveCommand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.direction = null;
                if (message.direction != null && message.hasOwnProperty("direction"))
                    object.direction = $root.vec2.toObject(message.direction, options);
                return object;
            };

            /**
             * Creates a plain object from this DiveCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DiveCommand.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this DiveCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            DiveCommand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DiveCommand;
        })();

        motion.DiveFinished = (function() {

            /**
             * Properties of a DiveFinished.
             * @typedef message.motion.DiveFinished$Properties
             * @type {Object}
             */

            /**
             * Constructs a new DiveFinished.
             * @exports message.motion.DiveFinished
             * @constructor
             * @param {message.motion.DiveFinished$Properties=} [properties] Properties to set
             */
            function DiveFinished(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DiveFinished instance using the specified properties.
             * @param {message.motion.DiveFinished$Properties=} [properties] Properties to set
             * @returns {message.motion.DiveFinished} DiveFinished instance
             */
            DiveFinished.create = function create(properties) {
                return new DiveFinished(properties);
            };

            /**
             * Encodes the specified DiveFinished message. Does not implicitly {@link message.motion.DiveFinished.verify|verify} messages.
             * @param {message.motion.DiveFinished$Properties} message DiveFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiveFinished.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DiveFinished message, length delimited. Does not implicitly {@link message.motion.DiveFinished.verify|verify} messages.
             * @param {message.motion.DiveFinished$Properties} message DiveFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiveFinished.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DiveFinished message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DiveFinished} DiveFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiveFinished.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.DiveFinished();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DiveFinished message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DiveFinished} DiveFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiveFinished.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DiveFinished message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            DiveFinished.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DiveFinished message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DiveFinished} DiveFinished
             */
            DiveFinished.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.DiveFinished)
                    return object;
                return new $root.message.motion.DiveFinished();
            };

            /**
             * Creates a DiveFinished message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DiveFinished.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DiveFinished} DiveFinished
             */
            DiveFinished.from = DiveFinished.fromObject;

            /**
             * Creates a plain object from a DiveFinished message. Also converts values to other types if specified.
             * @param {message.motion.DiveFinished} message DiveFinished
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DiveFinished.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this DiveFinished message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DiveFinished.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this DiveFinished to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            DiveFinished.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DiveFinished;
        })();

        motion.FootMotionStopped = (function() {

            /**
             * Properties of a FootMotionStopped.
             * @typedef message.motion.FootMotionStopped$Properties
             * @type {Object}
             */

            /**
             * Constructs a new FootMotionStopped.
             * @exports message.motion.FootMotionStopped
             * @constructor
             * @param {message.motion.FootMotionStopped$Properties=} [properties] Properties to set
             */
            function FootMotionStopped(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new FootMotionStopped instance using the specified properties.
             * @param {message.motion.FootMotionStopped$Properties=} [properties] Properties to set
             * @returns {message.motion.FootMotionStopped} FootMotionStopped instance
             */
            FootMotionStopped.create = function create(properties) {
                return new FootMotionStopped(properties);
            };

            /**
             * Encodes the specified FootMotionStopped message. Does not implicitly {@link message.motion.FootMotionStopped.verify|verify} messages.
             * @param {message.motion.FootMotionStopped$Properties} message FootMotionStopped message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FootMotionStopped.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified FootMotionStopped message, length delimited. Does not implicitly {@link message.motion.FootMotionStopped.verify|verify} messages.
             * @param {message.motion.FootMotionStopped$Properties} message FootMotionStopped message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FootMotionStopped.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FootMotionStopped message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.FootMotionStopped} FootMotionStopped
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FootMotionStopped.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.FootMotionStopped();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FootMotionStopped message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.FootMotionStopped} FootMotionStopped
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FootMotionStopped.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FootMotionStopped message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FootMotionStopped.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a FootMotionStopped message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootMotionStopped} FootMotionStopped
             */
            FootMotionStopped.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.FootMotionStopped)
                    return object;
                return new $root.message.motion.FootMotionStopped();
            };

            /**
             * Creates a FootMotionStopped message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.FootMotionStopped.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootMotionStopped} FootMotionStopped
             */
            FootMotionStopped.from = FootMotionStopped.fromObject;

            /**
             * Creates a plain object from a FootMotionStopped message. Also converts values to other types if specified.
             * @param {message.motion.FootMotionStopped} message FootMotionStopped
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FootMotionStopped.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this FootMotionStopped message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FootMotionStopped.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FootMotionStopped to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FootMotionStopped.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FootMotionStopped;
        })();

        motion.FootMotionUpdate = (function() {

            /**
             * Properties of a FootMotionUpdate.
             * @typedef message.motion.FootMotionUpdate$Properties
             * @type {Object}
             * @property {number} [phase] FootMotionUpdate phase.
             * @property {number} [activeForwardLimb] FootMotionUpdate activeForwardLimb.
             * @property {vec3$Properties} [leftFoot2D] FootMotionUpdate leftFoot2D.
             * @property {vec3$Properties} [rightFoot2D] FootMotionUpdate rightFoot2D.
             * @property {mat44$Properties} [leftFoot3D] FootMotionUpdate leftFoot3D.
             * @property {mat44$Properties} [rightFoot3D] FootMotionUpdate rightFoot3D.
             */

            /**
             * Constructs a new FootMotionUpdate.
             * @exports message.motion.FootMotionUpdate
             * @constructor
             * @param {message.motion.FootMotionUpdate$Properties=} [properties] Properties to set
             */
            function FootMotionUpdate(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FootMotionUpdate phase.
             * @type {number}
             */
            FootMotionUpdate.prototype.phase = 0;

            /**
             * FootMotionUpdate activeForwardLimb.
             * @type {number}
             */
            FootMotionUpdate.prototype.activeForwardLimb = 0;

            /**
             * FootMotionUpdate leftFoot2D.
             * @type {(vec3$Properties|null)}
             */
            FootMotionUpdate.prototype.leftFoot2D = null;

            /**
             * FootMotionUpdate rightFoot2D.
             * @type {(vec3$Properties|null)}
             */
            FootMotionUpdate.prototype.rightFoot2D = null;

            /**
             * FootMotionUpdate leftFoot3D.
             * @type {(mat44$Properties|null)}
             */
            FootMotionUpdate.prototype.leftFoot3D = null;

            /**
             * FootMotionUpdate rightFoot3D.
             * @type {(mat44$Properties|null)}
             */
            FootMotionUpdate.prototype.rightFoot3D = null;

            /**
             * Creates a new FootMotionUpdate instance using the specified properties.
             * @param {message.motion.FootMotionUpdate$Properties=} [properties] Properties to set
             * @returns {message.motion.FootMotionUpdate} FootMotionUpdate instance
             */
            FootMotionUpdate.create = function create(properties) {
                return new FootMotionUpdate(properties);
            };

            /**
             * Encodes the specified FootMotionUpdate message. Does not implicitly {@link message.motion.FootMotionUpdate.verify|verify} messages.
             * @param {message.motion.FootMotionUpdate$Properties} message FootMotionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FootMotionUpdate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.phase != null && message.hasOwnProperty("phase"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.phase);
                if (message.activeForwardLimb != null && message.hasOwnProperty("activeForwardLimb"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.activeForwardLimb);
                if (message.leftFoot2D != null && message.hasOwnProperty("leftFoot2D"))
                    $root.vec3.encode(message.leftFoot2D, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.rightFoot2D != null && message.hasOwnProperty("rightFoot2D"))
                    $root.vec3.encode(message.rightFoot2D, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.leftFoot3D != null && message.hasOwnProperty("leftFoot3D"))
                    $root.mat44.encode(message.leftFoot3D, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.rightFoot3D != null && message.hasOwnProperty("rightFoot3D"))
                    $root.mat44.encode(message.rightFoot3D, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FootMotionUpdate message, length delimited. Does not implicitly {@link message.motion.FootMotionUpdate.verify|verify} messages.
             * @param {message.motion.FootMotionUpdate$Properties} message FootMotionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FootMotionUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FootMotionUpdate message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.FootMotionUpdate} FootMotionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FootMotionUpdate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.FootMotionUpdate();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.phase = reader.double();
                        break;
                    case 2:
                        message.activeForwardLimb = reader.uint32();
                        break;
                    case 3:
                        message.leftFoot2D = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.rightFoot2D = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.leftFoot3D = $root.mat44.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.rightFoot3D = $root.mat44.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FootMotionUpdate message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.FootMotionUpdate} FootMotionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FootMotionUpdate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FootMotionUpdate message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FootMotionUpdate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.phase != null && message.hasOwnProperty("phase"))
                    if (typeof message.phase !== "number")
                        return "phase: number expected";
                if (message.activeForwardLimb != null && message.hasOwnProperty("activeForwardLimb"))
                    if (!$util.isInteger(message.activeForwardLimb))
                        return "activeForwardLimb: integer expected";
                if (message.leftFoot2D != null && message.hasOwnProperty("leftFoot2D")) {
                    var error = $root.vec3.verify(message.leftFoot2D);
                    if (error)
                        return "leftFoot2D." + error;
                }
                if (message.rightFoot2D != null && message.hasOwnProperty("rightFoot2D")) {
                    var error = $root.vec3.verify(message.rightFoot2D);
                    if (error)
                        return "rightFoot2D." + error;
                }
                if (message.leftFoot3D != null && message.hasOwnProperty("leftFoot3D")) {
                    var error = $root.mat44.verify(message.leftFoot3D);
                    if (error)
                        return "leftFoot3D." + error;
                }
                if (message.rightFoot3D != null && message.hasOwnProperty("rightFoot3D")) {
                    var error = $root.mat44.verify(message.rightFoot3D);
                    if (error)
                        return "rightFoot3D." + error;
                }
                return null;
            };

            /**
             * Creates a FootMotionUpdate message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootMotionUpdate} FootMotionUpdate
             */
            FootMotionUpdate.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.FootMotionUpdate)
                    return object;
                var message = new $root.message.motion.FootMotionUpdate();
                if (object.phase != null)
                    message.phase = Number(object.phase);
                if (object.activeForwardLimb != null)
                    message.activeForwardLimb = object.activeForwardLimb >>> 0;
                if (object.leftFoot2D != null) {
                    if (typeof object.leftFoot2D !== "object")
                        throw TypeError(".message.motion.FootMotionUpdate.leftFoot2D: object expected");
                    message.leftFoot2D = $root.vec3.fromObject(object.leftFoot2D);
                }
                if (object.rightFoot2D != null) {
                    if (typeof object.rightFoot2D !== "object")
                        throw TypeError(".message.motion.FootMotionUpdate.rightFoot2D: object expected");
                    message.rightFoot2D = $root.vec3.fromObject(object.rightFoot2D);
                }
                if (object.leftFoot3D != null) {
                    if (typeof object.leftFoot3D !== "object")
                        throw TypeError(".message.motion.FootMotionUpdate.leftFoot3D: object expected");
                    message.leftFoot3D = $root.mat44.fromObject(object.leftFoot3D);
                }
                if (object.rightFoot3D != null) {
                    if (typeof object.rightFoot3D !== "object")
                        throw TypeError(".message.motion.FootMotionUpdate.rightFoot3D: object expected");
                    message.rightFoot3D = $root.mat44.fromObject(object.rightFoot3D);
                }
                return message;
            };

            /**
             * Creates a FootMotionUpdate message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.FootMotionUpdate.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootMotionUpdate} FootMotionUpdate
             */
            FootMotionUpdate.from = FootMotionUpdate.fromObject;

            /**
             * Creates a plain object from a FootMotionUpdate message. Also converts values to other types if specified.
             * @param {message.motion.FootMotionUpdate} message FootMotionUpdate
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FootMotionUpdate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.phase = 0;
                    object.activeForwardLimb = 0;
                    object.leftFoot2D = null;
                    object.rightFoot2D = null;
                    object.leftFoot3D = null;
                    object.rightFoot3D = null;
                }
                if (message.phase != null && message.hasOwnProperty("phase"))
                    object.phase = message.phase;
                if (message.activeForwardLimb != null && message.hasOwnProperty("activeForwardLimb"))
                    object.activeForwardLimb = message.activeForwardLimb;
                if (message.leftFoot2D != null && message.hasOwnProperty("leftFoot2D"))
                    object.leftFoot2D = $root.vec3.toObject(message.leftFoot2D, options);
                if (message.rightFoot2D != null && message.hasOwnProperty("rightFoot2D"))
                    object.rightFoot2D = $root.vec3.toObject(message.rightFoot2D, options);
                if (message.leftFoot3D != null && message.hasOwnProperty("leftFoot3D"))
                    object.leftFoot3D = $root.mat44.toObject(message.leftFoot3D, options);
                if (message.rightFoot3D != null && message.hasOwnProperty("rightFoot3D"))
                    object.rightFoot3D = $root.mat44.toObject(message.rightFoot3D, options);
                return object;
            };

            /**
             * Creates a plain object from this FootMotionUpdate message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FootMotionUpdate.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FootMotionUpdate to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FootMotionUpdate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FootMotionUpdate;
        })();

        motion.NextFootTargetInfo = (function() {

            /**
             * Properties of a NextFootTargetInfo.
             * @typedef message.motion.NextFootTargetInfo$Properties
             * @type {Object}
             * @property {vec3$Properties} [leftFootSource] NextFootTargetInfo leftFootSource.
             * @property {vec3$Properties} [rightFootSource] NextFootTargetInfo rightFootSource.
             * @property {vec3$Properties} [supportMass] NextFootTargetInfo supportMass.
             * @property {vec3$Properties} [leftFootDestination] NextFootTargetInfo leftFootDestination.
             * @property {vec3$Properties} [rightFootDestination] NextFootTargetInfo rightFootDestination.
             */

            /**
             * Constructs a new NextFootTargetInfo.
             * @exports message.motion.NextFootTargetInfo
             * @constructor
             * @param {message.motion.NextFootTargetInfo$Properties=} [properties] Properties to set
             */
            function NextFootTargetInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NextFootTargetInfo leftFootSource.
             * @type {(vec3$Properties|null)}
             */
            NextFootTargetInfo.prototype.leftFootSource = null;

            /**
             * NextFootTargetInfo rightFootSource.
             * @type {(vec3$Properties|null)}
             */
            NextFootTargetInfo.prototype.rightFootSource = null;

            /**
             * NextFootTargetInfo supportMass.
             * @type {(vec3$Properties|null)}
             */
            NextFootTargetInfo.prototype.supportMass = null;

            /**
             * NextFootTargetInfo leftFootDestination.
             * @type {(vec3$Properties|null)}
             */
            NextFootTargetInfo.prototype.leftFootDestination = null;

            /**
             * NextFootTargetInfo rightFootDestination.
             * @type {(vec3$Properties|null)}
             */
            NextFootTargetInfo.prototype.rightFootDestination = null;

            /**
             * Creates a new NextFootTargetInfo instance using the specified properties.
             * @param {message.motion.NextFootTargetInfo$Properties=} [properties] Properties to set
             * @returns {message.motion.NextFootTargetInfo} NextFootTargetInfo instance
             */
            NextFootTargetInfo.create = function create(properties) {
                return new NextFootTargetInfo(properties);
            };

            /**
             * Encodes the specified NextFootTargetInfo message. Does not implicitly {@link message.motion.NextFootTargetInfo.verify|verify} messages.
             * @param {message.motion.NextFootTargetInfo$Properties} message NextFootTargetInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NextFootTargetInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.leftFootSource != null && message.hasOwnProperty("leftFootSource"))
                    $root.vec3.encode(message.leftFootSource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.rightFootSource != null && message.hasOwnProperty("rightFootSource"))
                    $root.vec3.encode(message.rightFootSource, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.supportMass != null && message.hasOwnProperty("supportMass"))
                    $root.vec3.encode(message.supportMass, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.leftFootDestination != null && message.hasOwnProperty("leftFootDestination"))
                    $root.vec3.encode(message.leftFootDestination, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.rightFootDestination != null && message.hasOwnProperty("rightFootDestination"))
                    $root.vec3.encode(message.rightFootDestination, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NextFootTargetInfo message, length delimited. Does not implicitly {@link message.motion.NextFootTargetInfo.verify|verify} messages.
             * @param {message.motion.NextFootTargetInfo$Properties} message NextFootTargetInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NextFootTargetInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NextFootTargetInfo message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.NextFootTargetInfo} NextFootTargetInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NextFootTargetInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.NextFootTargetInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.leftFootSource = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.rightFootSource = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.supportMass = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.leftFootDestination = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.rightFootDestination = $root.vec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NextFootTargetInfo message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.NextFootTargetInfo} NextFootTargetInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NextFootTargetInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NextFootTargetInfo message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            NextFootTargetInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.leftFootSource != null && message.hasOwnProperty("leftFootSource")) {
                    var error = $root.vec3.verify(message.leftFootSource);
                    if (error)
                        return "leftFootSource." + error;
                }
                if (message.rightFootSource != null && message.hasOwnProperty("rightFootSource")) {
                    var error = $root.vec3.verify(message.rightFootSource);
                    if (error)
                        return "rightFootSource." + error;
                }
                if (message.supportMass != null && message.hasOwnProperty("supportMass")) {
                    var error = $root.vec3.verify(message.supportMass);
                    if (error)
                        return "supportMass." + error;
                }
                if (message.leftFootDestination != null && message.hasOwnProperty("leftFootDestination")) {
                    var error = $root.vec3.verify(message.leftFootDestination);
                    if (error)
                        return "leftFootDestination." + error;
                }
                if (message.rightFootDestination != null && message.hasOwnProperty("rightFootDestination")) {
                    var error = $root.vec3.verify(message.rightFootDestination);
                    if (error)
                        return "rightFootDestination." + error;
                }
                return null;
            };

            /**
             * Creates a NextFootTargetInfo message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NextFootTargetInfo} NextFootTargetInfo
             */
            NextFootTargetInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.NextFootTargetInfo)
                    return object;
                var message = new $root.message.motion.NextFootTargetInfo();
                if (object.leftFootSource != null) {
                    if (typeof object.leftFootSource !== "object")
                        throw TypeError(".message.motion.NextFootTargetInfo.leftFootSource: object expected");
                    message.leftFootSource = $root.vec3.fromObject(object.leftFootSource);
                }
                if (object.rightFootSource != null) {
                    if (typeof object.rightFootSource !== "object")
                        throw TypeError(".message.motion.NextFootTargetInfo.rightFootSource: object expected");
                    message.rightFootSource = $root.vec3.fromObject(object.rightFootSource);
                }
                if (object.supportMass != null) {
                    if (typeof object.supportMass !== "object")
                        throw TypeError(".message.motion.NextFootTargetInfo.supportMass: object expected");
                    message.supportMass = $root.vec3.fromObject(object.supportMass);
                }
                if (object.leftFootDestination != null) {
                    if (typeof object.leftFootDestination !== "object")
                        throw TypeError(".message.motion.NextFootTargetInfo.leftFootDestination: object expected");
                    message.leftFootDestination = $root.vec3.fromObject(object.leftFootDestination);
                }
                if (object.rightFootDestination != null) {
                    if (typeof object.rightFootDestination !== "object")
                        throw TypeError(".message.motion.NextFootTargetInfo.rightFootDestination: object expected");
                    message.rightFootDestination = $root.vec3.fromObject(object.rightFootDestination);
                }
                return message;
            };

            /**
             * Creates a NextFootTargetInfo message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.NextFootTargetInfo.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NextFootTargetInfo} NextFootTargetInfo
             */
            NextFootTargetInfo.from = NextFootTargetInfo.fromObject;

            /**
             * Creates a plain object from a NextFootTargetInfo message. Also converts values to other types if specified.
             * @param {message.motion.NextFootTargetInfo} message NextFootTargetInfo
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NextFootTargetInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.leftFootSource = null;
                    object.rightFootSource = null;
                    object.supportMass = null;
                    object.leftFootDestination = null;
                    object.rightFootDestination = null;
                }
                if (message.leftFootSource != null && message.hasOwnProperty("leftFootSource"))
                    object.leftFootSource = $root.vec3.toObject(message.leftFootSource, options);
                if (message.rightFootSource != null && message.hasOwnProperty("rightFootSource"))
                    object.rightFootSource = $root.vec3.toObject(message.rightFootSource, options);
                if (message.supportMass != null && message.hasOwnProperty("supportMass"))
                    object.supportMass = $root.vec3.toObject(message.supportMass, options);
                if (message.leftFootDestination != null && message.hasOwnProperty("leftFootDestination"))
                    object.leftFootDestination = $root.vec3.toObject(message.leftFootDestination, options);
                if (message.rightFootDestination != null && message.hasOwnProperty("rightFootDestination"))
                    object.rightFootDestination = $root.vec3.toObject(message.rightFootDestination, options);
                return object;
            };

            /**
             * Creates a plain object from this NextFootTargetInfo message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NextFootTargetInfo.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this NextFootTargetInfo to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            NextFootTargetInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NextFootTargetInfo;
        })();

        motion.FootStepRequested = (function() {

            /**
             * Properties of a FootStepRequested.
             * @typedef message.motion.FootStepRequested$Properties
             * @type {Object}
             * @property {boolean} [status] FootStepRequested status.
             */

            /**
             * Constructs a new FootStepRequested.
             * @exports message.motion.FootStepRequested
             * @constructor
             * @param {message.motion.FootStepRequested$Properties=} [properties] Properties to set
             */
            function FootStepRequested(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FootStepRequested status.
             * @type {boolean}
             */
            FootStepRequested.prototype.status = false;

            /**
             * Creates a new FootStepRequested instance using the specified properties.
             * @param {message.motion.FootStepRequested$Properties=} [properties] Properties to set
             * @returns {message.motion.FootStepRequested} FootStepRequested instance
             */
            FootStepRequested.create = function create(properties) {
                return new FootStepRequested(properties);
            };

            /**
             * Encodes the specified FootStepRequested message. Does not implicitly {@link message.motion.FootStepRequested.verify|verify} messages.
             * @param {message.motion.FootStepRequested$Properties} message FootStepRequested message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FootStepRequested.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.status);
                return writer;
            };

            /**
             * Encodes the specified FootStepRequested message, length delimited. Does not implicitly {@link message.motion.FootStepRequested.verify|verify} messages.
             * @param {message.motion.FootStepRequested$Properties} message FootStepRequested message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FootStepRequested.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FootStepRequested message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.FootStepRequested} FootStepRequested
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FootStepRequested.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.FootStepRequested();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FootStepRequested message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.FootStepRequested} FootStepRequested
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FootStepRequested.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FootStepRequested message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FootStepRequested.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (typeof message.status !== "boolean")
                        return "status: boolean expected";
                return null;
            };

            /**
             * Creates a FootStepRequested message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootStepRequested} FootStepRequested
             */
            FootStepRequested.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.FootStepRequested)
                    return object;
                var message = new $root.message.motion.FootStepRequested();
                if (object.status != null)
                    message.status = Boolean(object.status);
                return message;
            };

            /**
             * Creates a FootStepRequested message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.FootStepRequested.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootStepRequested} FootStepRequested
             */
            FootStepRequested.from = FootStepRequested.fromObject;

            /**
             * Creates a plain object from a FootStepRequested message. Also converts values to other types if specified.
             * @param {message.motion.FootStepRequested} message FootStepRequested
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FootStepRequested.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.status = false;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                return object;
            };

            /**
             * Creates a plain object from this FootStepRequested message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FootStepRequested.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FootStepRequested to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FootStepRequested.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FootStepRequested;
        })();

        motion.FootStepCompleted = (function() {

            /**
             * Properties of a FootStepCompleted.
             * @typedef message.motion.FootStepCompleted$Properties
             * @type {Object}
             * @property {boolean} [status] FootStepCompleted status.
             */

            /**
             * Constructs a new FootStepCompleted.
             * @exports message.motion.FootStepCompleted
             * @constructor
             * @param {message.motion.FootStepCompleted$Properties=} [properties] Properties to set
             */
            function FootStepCompleted(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FootStepCompleted status.
             * @type {boolean}
             */
            FootStepCompleted.prototype.status = false;

            /**
             * Creates a new FootStepCompleted instance using the specified properties.
             * @param {message.motion.FootStepCompleted$Properties=} [properties] Properties to set
             * @returns {message.motion.FootStepCompleted} FootStepCompleted instance
             */
            FootStepCompleted.create = function create(properties) {
                return new FootStepCompleted(properties);
            };

            /**
             * Encodes the specified FootStepCompleted message. Does not implicitly {@link message.motion.FootStepCompleted.verify|verify} messages.
             * @param {message.motion.FootStepCompleted$Properties} message FootStepCompleted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FootStepCompleted.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.status);
                return writer;
            };

            /**
             * Encodes the specified FootStepCompleted message, length delimited. Does not implicitly {@link message.motion.FootStepCompleted.verify|verify} messages.
             * @param {message.motion.FootStepCompleted$Properties} message FootStepCompleted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FootStepCompleted.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FootStepCompleted message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.FootStepCompleted} FootStepCompleted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FootStepCompleted.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.FootStepCompleted();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FootStepCompleted message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.FootStepCompleted} FootStepCompleted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FootStepCompleted.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FootStepCompleted message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FootStepCompleted.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (typeof message.status !== "boolean")
                        return "status: boolean expected";
                return null;
            };

            /**
             * Creates a FootStepCompleted message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootStepCompleted} FootStepCompleted
             */
            FootStepCompleted.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.FootStepCompleted)
                    return object;
                var message = new $root.message.motion.FootStepCompleted();
                if (object.status != null)
                    message.status = Boolean(object.status);
                return message;
            };

            /**
             * Creates a FootStepCompleted message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.FootStepCompleted.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootStepCompleted} FootStepCompleted
             */
            FootStepCompleted.from = FootStepCompleted.fromObject;

            /**
             * Creates a plain object from a FootStepCompleted message. Also converts values to other types if specified.
             * @param {message.motion.FootStepCompleted} message FootStepCompleted
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FootStepCompleted.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.status = false;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                return object;
            };

            /**
             * Creates a plain object from this FootStepCompleted message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FootStepCompleted.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FootStepCompleted to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FootStepCompleted.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FootStepCompleted;
        })();

        motion.EnableFootMotion = (function() {

            /**
             * Properties of an EnableFootMotion.
             * @typedef message.motion.EnableFootMotion$Properties
             * @type {Object}
             */

            /**
             * Constructs a new EnableFootMotion.
             * @exports message.motion.EnableFootMotion
             * @constructor
             * @param {message.motion.EnableFootMotion$Properties=} [properties] Properties to set
             */
            function EnableFootMotion(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new EnableFootMotion instance using the specified properties.
             * @param {message.motion.EnableFootMotion$Properties=} [properties] Properties to set
             * @returns {message.motion.EnableFootMotion} EnableFootMotion instance
             */
            EnableFootMotion.create = function create(properties) {
                return new EnableFootMotion(properties);
            };

            /**
             * Encodes the specified EnableFootMotion message. Does not implicitly {@link message.motion.EnableFootMotion.verify|verify} messages.
             * @param {message.motion.EnableFootMotion$Properties} message EnableFootMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnableFootMotion.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified EnableFootMotion message, length delimited. Does not implicitly {@link message.motion.EnableFootMotion.verify|verify} messages.
             * @param {message.motion.EnableFootMotion$Properties} message EnableFootMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnableFootMotion.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnableFootMotion message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.EnableFootMotion} EnableFootMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnableFootMotion.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.EnableFootMotion();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnableFootMotion message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.EnableFootMotion} EnableFootMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnableFootMotion.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnableFootMotion message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            EnableFootMotion.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an EnableFootMotion message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableFootMotion} EnableFootMotion
             */
            EnableFootMotion.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.EnableFootMotion)
                    return object;
                return new $root.message.motion.EnableFootMotion();
            };

            /**
             * Creates an EnableFootMotion message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.EnableFootMotion.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableFootMotion} EnableFootMotion
             */
            EnableFootMotion.from = EnableFootMotion.fromObject;

            /**
             * Creates a plain object from an EnableFootMotion message. Also converts values to other types if specified.
             * @param {message.motion.EnableFootMotion} message EnableFootMotion
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnableFootMotion.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this EnableFootMotion message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnableFootMotion.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this EnableFootMotion to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            EnableFootMotion.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnableFootMotion;
        })();

        motion.DisableFootMotion = (function() {

            /**
             * Properties of a DisableFootMotion.
             * @typedef message.motion.DisableFootMotion$Properties
             * @type {Object}
             */

            /**
             * Constructs a new DisableFootMotion.
             * @exports message.motion.DisableFootMotion
             * @constructor
             * @param {message.motion.DisableFootMotion$Properties=} [properties] Properties to set
             */
            function DisableFootMotion(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DisableFootMotion instance using the specified properties.
             * @param {message.motion.DisableFootMotion$Properties=} [properties] Properties to set
             * @returns {message.motion.DisableFootMotion} DisableFootMotion instance
             */
            DisableFootMotion.create = function create(properties) {
                return new DisableFootMotion(properties);
            };

            /**
             * Encodes the specified DisableFootMotion message. Does not implicitly {@link message.motion.DisableFootMotion.verify|verify} messages.
             * @param {message.motion.DisableFootMotion$Properties} message DisableFootMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisableFootMotion.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DisableFootMotion message, length delimited. Does not implicitly {@link message.motion.DisableFootMotion.verify|verify} messages.
             * @param {message.motion.DisableFootMotion$Properties} message DisableFootMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisableFootMotion.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DisableFootMotion message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DisableFootMotion} DisableFootMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisableFootMotion.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.DisableFootMotion();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DisableFootMotion message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DisableFootMotion} DisableFootMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisableFootMotion.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DisableFootMotion message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            DisableFootMotion.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DisableFootMotion message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableFootMotion} DisableFootMotion
             */
            DisableFootMotion.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.DisableFootMotion)
                    return object;
                return new $root.message.motion.DisableFootMotion();
            };

            /**
             * Creates a DisableFootMotion message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DisableFootMotion.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableFootMotion} DisableFootMotion
             */
            DisableFootMotion.from = DisableFootMotion.fromObject;

            /**
             * Creates a plain object from a DisableFootMotion message. Also converts values to other types if specified.
             * @param {message.motion.DisableFootMotion} message DisableFootMotion
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisableFootMotion.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this DisableFootMotion message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisableFootMotion.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this DisableFootMotion to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            DisableFootMotion.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DisableFootMotion;
        })();

        motion.FootPlacementStopped = (function() {

            /**
             * Properties of a FootPlacementStopped.
             * @typedef message.motion.FootPlacementStopped$Properties
             * @type {Object}
             */

            /**
             * Constructs a new FootPlacementStopped.
             * @exports message.motion.FootPlacementStopped
             * @constructor
             * @param {message.motion.FootPlacementStopped$Properties=} [properties] Properties to set
             */
            function FootPlacementStopped(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new FootPlacementStopped instance using the specified properties.
             * @param {message.motion.FootPlacementStopped$Properties=} [properties] Properties to set
             * @returns {message.motion.FootPlacementStopped} FootPlacementStopped instance
             */
            FootPlacementStopped.create = function create(properties) {
                return new FootPlacementStopped(properties);
            };

            /**
             * Encodes the specified FootPlacementStopped message. Does not implicitly {@link message.motion.FootPlacementStopped.verify|verify} messages.
             * @param {message.motion.FootPlacementStopped$Properties} message FootPlacementStopped message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FootPlacementStopped.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified FootPlacementStopped message, length delimited. Does not implicitly {@link message.motion.FootPlacementStopped.verify|verify} messages.
             * @param {message.motion.FootPlacementStopped$Properties} message FootPlacementStopped message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FootPlacementStopped.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FootPlacementStopped message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.FootPlacementStopped} FootPlacementStopped
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FootPlacementStopped.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.FootPlacementStopped();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FootPlacementStopped message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.FootPlacementStopped} FootPlacementStopped
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FootPlacementStopped.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FootPlacementStopped message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FootPlacementStopped.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a FootPlacementStopped message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootPlacementStopped} FootPlacementStopped
             */
            FootPlacementStopped.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.FootPlacementStopped)
                    return object;
                return new $root.message.motion.FootPlacementStopped();
            };

            /**
             * Creates a FootPlacementStopped message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.FootPlacementStopped.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootPlacementStopped} FootPlacementStopped
             */
            FootPlacementStopped.from = FootPlacementStopped.fromObject;

            /**
             * Creates a plain object from a FootPlacementStopped message. Also converts values to other types if specified.
             * @param {message.motion.FootPlacementStopped} message FootPlacementStopped
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FootPlacementStopped.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this FootPlacementStopped message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FootPlacementStopped.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FootPlacementStopped to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FootPlacementStopped.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FootPlacementStopped;
        })();

        motion.NewStepTargetInfo = (function() {

            /**
             * Properties of a NewStepTargetInfo.
             * @typedef message.motion.NewStepTargetInfo$Properties
             * @type {Object}
             * @property {number} [targetTime] NewStepTargetInfo targetTime.
             * @property {vec3$Properties} [velocityCurrent] NewStepTargetInfo velocityCurrent.
             * @property {number} [activeForwardLimb] NewStepTargetInfo activeForwardLimb.
             */

            /**
             * Constructs a new NewStepTargetInfo.
             * @exports message.motion.NewStepTargetInfo
             * @constructor
             * @param {message.motion.NewStepTargetInfo$Properties=} [properties] Properties to set
             */
            function NewStepTargetInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NewStepTargetInfo targetTime.
             * @type {number}
             */
            NewStepTargetInfo.prototype.targetTime = 0;

            /**
             * NewStepTargetInfo velocityCurrent.
             * @type {(vec3$Properties|null)}
             */
            NewStepTargetInfo.prototype.velocityCurrent = null;

            /**
             * NewStepTargetInfo activeForwardLimb.
             * @type {number}
             */
            NewStepTargetInfo.prototype.activeForwardLimb = 0;

            /**
             * Creates a new NewStepTargetInfo instance using the specified properties.
             * @param {message.motion.NewStepTargetInfo$Properties=} [properties] Properties to set
             * @returns {message.motion.NewStepTargetInfo} NewStepTargetInfo instance
             */
            NewStepTargetInfo.create = function create(properties) {
                return new NewStepTargetInfo(properties);
            };

            /**
             * Encodes the specified NewStepTargetInfo message. Does not implicitly {@link message.motion.NewStepTargetInfo.verify|verify} messages.
             * @param {message.motion.NewStepTargetInfo$Properties} message NewStepTargetInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewStepTargetInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.targetTime != null && message.hasOwnProperty("targetTime"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.targetTime);
                if (message.velocityCurrent != null && message.hasOwnProperty("velocityCurrent"))
                    $root.vec3.encode(message.velocityCurrent, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.activeForwardLimb != null && message.hasOwnProperty("activeForwardLimb"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.activeForwardLimb);
                return writer;
            };

            /**
             * Encodes the specified NewStepTargetInfo message, length delimited. Does not implicitly {@link message.motion.NewStepTargetInfo.verify|verify} messages.
             * @param {message.motion.NewStepTargetInfo$Properties} message NewStepTargetInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewStepTargetInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NewStepTargetInfo message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.NewStepTargetInfo} NewStepTargetInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewStepTargetInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.NewStepTargetInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.targetTime = reader.double();
                        break;
                    case 2:
                        message.velocityCurrent = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.activeForwardLimb = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NewStepTargetInfo message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.NewStepTargetInfo} NewStepTargetInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewStepTargetInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NewStepTargetInfo message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            NewStepTargetInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.targetTime != null && message.hasOwnProperty("targetTime"))
                    if (typeof message.targetTime !== "number")
                        return "targetTime: number expected";
                if (message.velocityCurrent != null && message.hasOwnProperty("velocityCurrent")) {
                    var error = $root.vec3.verify(message.velocityCurrent);
                    if (error)
                        return "velocityCurrent." + error;
                }
                if (message.activeForwardLimb != null && message.hasOwnProperty("activeForwardLimb"))
                    if (!$util.isInteger(message.activeForwardLimb))
                        return "activeForwardLimb: integer expected";
                return null;
            };

            /**
             * Creates a NewStepTargetInfo message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NewStepTargetInfo} NewStepTargetInfo
             */
            NewStepTargetInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.NewStepTargetInfo)
                    return object;
                var message = new $root.message.motion.NewStepTargetInfo();
                if (object.targetTime != null)
                    message.targetTime = Number(object.targetTime);
                if (object.velocityCurrent != null) {
                    if (typeof object.velocityCurrent !== "object")
                        throw TypeError(".message.motion.NewStepTargetInfo.velocityCurrent: object expected");
                    message.velocityCurrent = $root.vec3.fromObject(object.velocityCurrent);
                }
                if (object.activeForwardLimb != null)
                    message.activeForwardLimb = object.activeForwardLimb >>> 0;
                return message;
            };

            /**
             * Creates a NewStepTargetInfo message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.NewStepTargetInfo.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NewStepTargetInfo} NewStepTargetInfo
             */
            NewStepTargetInfo.from = NewStepTargetInfo.fromObject;

            /**
             * Creates a plain object from a NewStepTargetInfo message. Also converts values to other types if specified.
             * @param {message.motion.NewStepTargetInfo} message NewStepTargetInfo
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NewStepTargetInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.targetTime = 0;
                    object.velocityCurrent = null;
                    object.activeForwardLimb = 0;
                }
                if (message.targetTime != null && message.hasOwnProperty("targetTime"))
                    object.targetTime = message.targetTime;
                if (message.velocityCurrent != null && message.hasOwnProperty("velocityCurrent"))
                    object.velocityCurrent = $root.vec3.toObject(message.velocityCurrent, options);
                if (message.activeForwardLimb != null && message.hasOwnProperty("activeForwardLimb"))
                    object.activeForwardLimb = message.activeForwardLimb;
                return object;
            };

            /**
             * Creates a plain object from this NewStepTargetInfo message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NewStepTargetInfo.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this NewStepTargetInfo to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            NewStepTargetInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NewStepTargetInfo;
        })();

        motion.NewFootTargetInfo = (function() {

            /**
             * Properties of a NewFootTargetInfo.
             * @typedef message.motion.NewFootTargetInfo$Properties
             * @type {Object}
             * @property {vec3$Properties} [leftFootSource] NewFootTargetInfo leftFootSource.
             * @property {vec3$Properties} [rightFootSource] NewFootTargetInfo rightFootSource.
             * @property {vec3$Properties} [supportMass] NewFootTargetInfo supportMass.
             * @property {vec3$Properties} [leftFootDestination] NewFootTargetInfo leftFootDestination.
             * @property {vec3$Properties} [rightFootDestination] NewFootTargetInfo rightFootDestination.
             */

            /**
             * Constructs a new NewFootTargetInfo.
             * @exports message.motion.NewFootTargetInfo
             * @constructor
             * @param {message.motion.NewFootTargetInfo$Properties=} [properties] Properties to set
             */
            function NewFootTargetInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NewFootTargetInfo leftFootSource.
             * @type {(vec3$Properties|null)}
             */
            NewFootTargetInfo.prototype.leftFootSource = null;

            /**
             * NewFootTargetInfo rightFootSource.
             * @type {(vec3$Properties|null)}
             */
            NewFootTargetInfo.prototype.rightFootSource = null;

            /**
             * NewFootTargetInfo supportMass.
             * @type {(vec3$Properties|null)}
             */
            NewFootTargetInfo.prototype.supportMass = null;

            /**
             * NewFootTargetInfo leftFootDestination.
             * @type {(vec3$Properties|null)}
             */
            NewFootTargetInfo.prototype.leftFootDestination = null;

            /**
             * NewFootTargetInfo rightFootDestination.
             * @type {(vec3$Properties|null)}
             */
            NewFootTargetInfo.prototype.rightFootDestination = null;

            /**
             * Creates a new NewFootTargetInfo instance using the specified properties.
             * @param {message.motion.NewFootTargetInfo$Properties=} [properties] Properties to set
             * @returns {message.motion.NewFootTargetInfo} NewFootTargetInfo instance
             */
            NewFootTargetInfo.create = function create(properties) {
                return new NewFootTargetInfo(properties);
            };

            /**
             * Encodes the specified NewFootTargetInfo message. Does not implicitly {@link message.motion.NewFootTargetInfo.verify|verify} messages.
             * @param {message.motion.NewFootTargetInfo$Properties} message NewFootTargetInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewFootTargetInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.leftFootSource != null && message.hasOwnProperty("leftFootSource"))
                    $root.vec3.encode(message.leftFootSource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.rightFootSource != null && message.hasOwnProperty("rightFootSource"))
                    $root.vec3.encode(message.rightFootSource, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.supportMass != null && message.hasOwnProperty("supportMass"))
                    $root.vec3.encode(message.supportMass, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.leftFootDestination != null && message.hasOwnProperty("leftFootDestination"))
                    $root.vec3.encode(message.leftFootDestination, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.rightFootDestination != null && message.hasOwnProperty("rightFootDestination"))
                    $root.vec3.encode(message.rightFootDestination, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NewFootTargetInfo message, length delimited. Does not implicitly {@link message.motion.NewFootTargetInfo.verify|verify} messages.
             * @param {message.motion.NewFootTargetInfo$Properties} message NewFootTargetInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewFootTargetInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NewFootTargetInfo message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.NewFootTargetInfo} NewFootTargetInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewFootTargetInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.NewFootTargetInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.leftFootSource = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.rightFootSource = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.supportMass = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.leftFootDestination = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.rightFootDestination = $root.vec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NewFootTargetInfo message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.NewFootTargetInfo} NewFootTargetInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewFootTargetInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NewFootTargetInfo message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            NewFootTargetInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.leftFootSource != null && message.hasOwnProperty("leftFootSource")) {
                    var error = $root.vec3.verify(message.leftFootSource);
                    if (error)
                        return "leftFootSource." + error;
                }
                if (message.rightFootSource != null && message.hasOwnProperty("rightFootSource")) {
                    var error = $root.vec3.verify(message.rightFootSource);
                    if (error)
                        return "rightFootSource." + error;
                }
                if (message.supportMass != null && message.hasOwnProperty("supportMass")) {
                    var error = $root.vec3.verify(message.supportMass);
                    if (error)
                        return "supportMass." + error;
                }
                if (message.leftFootDestination != null && message.hasOwnProperty("leftFootDestination")) {
                    var error = $root.vec3.verify(message.leftFootDestination);
                    if (error)
                        return "leftFootDestination." + error;
                }
                if (message.rightFootDestination != null && message.hasOwnProperty("rightFootDestination")) {
                    var error = $root.vec3.verify(message.rightFootDestination);
                    if (error)
                        return "rightFootDestination." + error;
                }
                return null;
            };

            /**
             * Creates a NewFootTargetInfo message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NewFootTargetInfo} NewFootTargetInfo
             */
            NewFootTargetInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.NewFootTargetInfo)
                    return object;
                var message = new $root.message.motion.NewFootTargetInfo();
                if (object.leftFootSource != null) {
                    if (typeof object.leftFootSource !== "object")
                        throw TypeError(".message.motion.NewFootTargetInfo.leftFootSource: object expected");
                    message.leftFootSource = $root.vec3.fromObject(object.leftFootSource);
                }
                if (object.rightFootSource != null) {
                    if (typeof object.rightFootSource !== "object")
                        throw TypeError(".message.motion.NewFootTargetInfo.rightFootSource: object expected");
                    message.rightFootSource = $root.vec3.fromObject(object.rightFootSource);
                }
                if (object.supportMass != null) {
                    if (typeof object.supportMass !== "object")
                        throw TypeError(".message.motion.NewFootTargetInfo.supportMass: object expected");
                    message.supportMass = $root.vec3.fromObject(object.supportMass);
                }
                if (object.leftFootDestination != null) {
                    if (typeof object.leftFootDestination !== "object")
                        throw TypeError(".message.motion.NewFootTargetInfo.leftFootDestination: object expected");
                    message.leftFootDestination = $root.vec3.fromObject(object.leftFootDestination);
                }
                if (object.rightFootDestination != null) {
                    if (typeof object.rightFootDestination !== "object")
                        throw TypeError(".message.motion.NewFootTargetInfo.rightFootDestination: object expected");
                    message.rightFootDestination = $root.vec3.fromObject(object.rightFootDestination);
                }
                return message;
            };

            /**
             * Creates a NewFootTargetInfo message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.NewFootTargetInfo.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NewFootTargetInfo} NewFootTargetInfo
             */
            NewFootTargetInfo.from = NewFootTargetInfo.fromObject;

            /**
             * Creates a plain object from a NewFootTargetInfo message. Also converts values to other types if specified.
             * @param {message.motion.NewFootTargetInfo} message NewFootTargetInfo
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NewFootTargetInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.leftFootSource = null;
                    object.rightFootSource = null;
                    object.supportMass = null;
                    object.leftFootDestination = null;
                    object.rightFootDestination = null;
                }
                if (message.leftFootSource != null && message.hasOwnProperty("leftFootSource"))
                    object.leftFootSource = $root.vec3.toObject(message.leftFootSource, options);
                if (message.rightFootSource != null && message.hasOwnProperty("rightFootSource"))
                    object.rightFootSource = $root.vec3.toObject(message.rightFootSource, options);
                if (message.supportMass != null && message.hasOwnProperty("supportMass"))
                    object.supportMass = $root.vec3.toObject(message.supportMass, options);
                if (message.leftFootDestination != null && message.hasOwnProperty("leftFootDestination"))
                    object.leftFootDestination = $root.vec3.toObject(message.leftFootDestination, options);
                if (message.rightFootDestination != null && message.hasOwnProperty("rightFootDestination"))
                    object.rightFootDestination = $root.vec3.toObject(message.rightFootDestination, options);
                return object;
            };

            /**
             * Creates a plain object from this NewFootTargetInfo message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NewFootTargetInfo.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this NewFootTargetInfo to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            NewFootTargetInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NewFootTargetInfo;
        })();

        motion.EnableFootPlacement = (function() {

            /**
             * Properties of an EnableFootPlacement.
             * @typedef message.motion.EnableFootPlacement$Properties
             * @type {Object}
             */

            /**
             * Constructs a new EnableFootPlacement.
             * @exports message.motion.EnableFootPlacement
             * @constructor
             * @param {message.motion.EnableFootPlacement$Properties=} [properties] Properties to set
             */
            function EnableFootPlacement(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new EnableFootPlacement instance using the specified properties.
             * @param {message.motion.EnableFootPlacement$Properties=} [properties] Properties to set
             * @returns {message.motion.EnableFootPlacement} EnableFootPlacement instance
             */
            EnableFootPlacement.create = function create(properties) {
                return new EnableFootPlacement(properties);
            };

            /**
             * Encodes the specified EnableFootPlacement message. Does not implicitly {@link message.motion.EnableFootPlacement.verify|verify} messages.
             * @param {message.motion.EnableFootPlacement$Properties} message EnableFootPlacement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnableFootPlacement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified EnableFootPlacement message, length delimited. Does not implicitly {@link message.motion.EnableFootPlacement.verify|verify} messages.
             * @param {message.motion.EnableFootPlacement$Properties} message EnableFootPlacement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnableFootPlacement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnableFootPlacement message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.EnableFootPlacement} EnableFootPlacement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnableFootPlacement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.EnableFootPlacement();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnableFootPlacement message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.EnableFootPlacement} EnableFootPlacement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnableFootPlacement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnableFootPlacement message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            EnableFootPlacement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an EnableFootPlacement message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableFootPlacement} EnableFootPlacement
             */
            EnableFootPlacement.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.EnableFootPlacement)
                    return object;
                return new $root.message.motion.EnableFootPlacement();
            };

            /**
             * Creates an EnableFootPlacement message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.EnableFootPlacement.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableFootPlacement} EnableFootPlacement
             */
            EnableFootPlacement.from = EnableFootPlacement.fromObject;

            /**
             * Creates a plain object from an EnableFootPlacement message. Also converts values to other types if specified.
             * @param {message.motion.EnableFootPlacement} message EnableFootPlacement
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnableFootPlacement.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this EnableFootPlacement message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnableFootPlacement.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this EnableFootPlacement to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            EnableFootPlacement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnableFootPlacement;
        })();

        motion.DisableFootPlacement = (function() {

            /**
             * Properties of a DisableFootPlacement.
             * @typedef message.motion.DisableFootPlacement$Properties
             * @type {Object}
             */

            /**
             * Constructs a new DisableFootPlacement.
             * @exports message.motion.DisableFootPlacement
             * @constructor
             * @param {message.motion.DisableFootPlacement$Properties=} [properties] Properties to set
             */
            function DisableFootPlacement(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DisableFootPlacement instance using the specified properties.
             * @param {message.motion.DisableFootPlacement$Properties=} [properties] Properties to set
             * @returns {message.motion.DisableFootPlacement} DisableFootPlacement instance
             */
            DisableFootPlacement.create = function create(properties) {
                return new DisableFootPlacement(properties);
            };

            /**
             * Encodes the specified DisableFootPlacement message. Does not implicitly {@link message.motion.DisableFootPlacement.verify|verify} messages.
             * @param {message.motion.DisableFootPlacement$Properties} message DisableFootPlacement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisableFootPlacement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DisableFootPlacement message, length delimited. Does not implicitly {@link message.motion.DisableFootPlacement.verify|verify} messages.
             * @param {message.motion.DisableFootPlacement$Properties} message DisableFootPlacement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisableFootPlacement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DisableFootPlacement message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DisableFootPlacement} DisableFootPlacement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisableFootPlacement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.DisableFootPlacement();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DisableFootPlacement message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DisableFootPlacement} DisableFootPlacement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisableFootPlacement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DisableFootPlacement message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            DisableFootPlacement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DisableFootPlacement message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableFootPlacement} DisableFootPlacement
             */
            DisableFootPlacement.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.DisableFootPlacement)
                    return object;
                return new $root.message.motion.DisableFootPlacement();
            };

            /**
             * Creates a DisableFootPlacement message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DisableFootPlacement.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableFootPlacement} DisableFootPlacement
             */
            DisableFootPlacement.from = DisableFootPlacement.fromObject;

            /**
             * Creates a plain object from a DisableFootPlacement message. Also converts values to other types if specified.
             * @param {message.motion.DisableFootPlacement} message DisableFootPlacement
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisableFootPlacement.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this DisableFootPlacement message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisableFootPlacement.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this DisableFootPlacement to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            DisableFootPlacement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DisableFootPlacement;
        })();

        motion.ExecuteGetup = (function() {

            /**
             * Properties of an ExecuteGetup.
             * @typedef message.motion.ExecuteGetup$Properties
             * @type {Object}
             */

            /**
             * Constructs a new ExecuteGetup.
             * @exports message.motion.ExecuteGetup
             * @constructor
             * @param {message.motion.ExecuteGetup$Properties=} [properties] Properties to set
             */
            function ExecuteGetup(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ExecuteGetup instance using the specified properties.
             * @param {message.motion.ExecuteGetup$Properties=} [properties] Properties to set
             * @returns {message.motion.ExecuteGetup} ExecuteGetup instance
             */
            ExecuteGetup.create = function create(properties) {
                return new ExecuteGetup(properties);
            };

            /**
             * Encodes the specified ExecuteGetup message. Does not implicitly {@link message.motion.ExecuteGetup.verify|verify} messages.
             * @param {message.motion.ExecuteGetup$Properties} message ExecuteGetup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteGetup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ExecuteGetup message, length delimited. Does not implicitly {@link message.motion.ExecuteGetup.verify|verify} messages.
             * @param {message.motion.ExecuteGetup$Properties} message ExecuteGetup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteGetup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteGetup message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.ExecuteGetup} ExecuteGetup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteGetup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.ExecuteGetup();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteGetup message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.ExecuteGetup} ExecuteGetup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteGetup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteGetup message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ExecuteGetup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an ExecuteGetup message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.ExecuteGetup} ExecuteGetup
             */
            ExecuteGetup.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.ExecuteGetup)
                    return object;
                return new $root.message.motion.ExecuteGetup();
            };

            /**
             * Creates an ExecuteGetup message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.ExecuteGetup.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.ExecuteGetup} ExecuteGetup
             */
            ExecuteGetup.from = ExecuteGetup.fromObject;

            /**
             * Creates a plain object from an ExecuteGetup message. Also converts values to other types if specified.
             * @param {message.motion.ExecuteGetup} message ExecuteGetup
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteGetup.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this ExecuteGetup message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteGetup.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ExecuteGetup to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteGetup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteGetup;
        })();

        motion.KillGetup = (function() {

            /**
             * Properties of a KillGetup.
             * @typedef message.motion.KillGetup$Properties
             * @type {Object}
             */

            /**
             * Constructs a new KillGetup.
             * @exports message.motion.KillGetup
             * @constructor
             * @param {message.motion.KillGetup$Properties=} [properties] Properties to set
             */
            function KillGetup(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new KillGetup instance using the specified properties.
             * @param {message.motion.KillGetup$Properties=} [properties] Properties to set
             * @returns {message.motion.KillGetup} KillGetup instance
             */
            KillGetup.create = function create(properties) {
                return new KillGetup(properties);
            };

            /**
             * Encodes the specified KillGetup message. Does not implicitly {@link message.motion.KillGetup.verify|verify} messages.
             * @param {message.motion.KillGetup$Properties} message KillGetup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KillGetup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified KillGetup message, length delimited. Does not implicitly {@link message.motion.KillGetup.verify|verify} messages.
             * @param {message.motion.KillGetup$Properties} message KillGetup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KillGetup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KillGetup message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KillGetup} KillGetup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KillGetup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KillGetup();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KillGetup message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.KillGetup} KillGetup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KillGetup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KillGetup message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            KillGetup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a KillGetup message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KillGetup} KillGetup
             */
            KillGetup.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.KillGetup)
                    return object;
                return new $root.message.motion.KillGetup();
            };

            /**
             * Creates a KillGetup message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.KillGetup.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KillGetup} KillGetup
             */
            KillGetup.from = KillGetup.fromObject;

            /**
             * Creates a plain object from a KillGetup message. Also converts values to other types if specified.
             * @param {message.motion.KillGetup} message KillGetup
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KillGetup.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this KillGetup message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KillGetup.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this KillGetup to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            KillGetup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KillGetup;
        })();

        motion.HeadCommand = (function() {

            /**
             * Properties of a HeadCommand.
             * @typedef message.motion.HeadCommand$Properties
             * @type {Object}
             * @property {number} [yaw] HeadCommand yaw.
             * @property {number} [pitch] HeadCommand pitch.
             * @property {boolean} [robotSpace] HeadCommand robotSpace.
             */

            /**
             * Constructs a new HeadCommand.
             * @classdesc Tell the head where to look in world space.
             * This command is interpreted such that the robot will use IMU data to fixate at these angles in the world even when rotating.
             * 
             * @author Jake Fountain
             * @exports message.motion.HeadCommand
             * @constructor
             * @param {message.motion.HeadCommand$Properties=} [properties] Properties to set
             */
            function HeadCommand(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HeadCommand yaw.
             * @type {number}
             */
            HeadCommand.prototype.yaw = 0;

            /**
             * HeadCommand pitch.
             * @type {number}
             */
            HeadCommand.prototype.pitch = 0;

            /**
             * HeadCommand robotSpace.
             * @type {boolean}
             */
            HeadCommand.prototype.robotSpace = false;

            /**
             * Creates a new HeadCommand instance using the specified properties.
             * @param {message.motion.HeadCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.HeadCommand} HeadCommand instance
             */
            HeadCommand.create = function create(properties) {
                return new HeadCommand(properties);
            };

            /**
             * Encodes the specified HeadCommand message. Does not implicitly {@link message.motion.HeadCommand.verify|verify} messages.
             * @param {message.motion.HeadCommand$Properties} message HeadCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeadCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.yaw != null && message.hasOwnProperty("yaw"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.yaw);
                if (message.pitch != null && message.hasOwnProperty("pitch"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.pitch);
                if (message.robotSpace != null && message.hasOwnProperty("robotSpace"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.robotSpace);
                return writer;
            };

            /**
             * Encodes the specified HeadCommand message, length delimited. Does not implicitly {@link message.motion.HeadCommand.verify|verify} messages.
             * @param {message.motion.HeadCommand$Properties} message HeadCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeadCommand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HeadCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.HeadCommand} HeadCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeadCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.HeadCommand();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.yaw = reader.float();
                        break;
                    case 2:
                        message.pitch = reader.float();
                        break;
                    case 3:
                        message.robotSpace = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HeadCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.HeadCommand} HeadCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeadCommand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HeadCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            HeadCommand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.yaw != null && message.hasOwnProperty("yaw"))
                    if (typeof message.yaw !== "number")
                        return "yaw: number expected";
                if (message.pitch != null && message.hasOwnProperty("pitch"))
                    if (typeof message.pitch !== "number")
                        return "pitch: number expected";
                if (message.robotSpace != null && message.hasOwnProperty("robotSpace"))
                    if (typeof message.robotSpace !== "boolean")
                        return "robotSpace: boolean expected";
                return null;
            };

            /**
             * Creates a HeadCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.HeadCommand} HeadCommand
             */
            HeadCommand.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.HeadCommand)
                    return object;
                var message = new $root.message.motion.HeadCommand();
                if (object.yaw != null)
                    message.yaw = Number(object.yaw);
                if (object.pitch != null)
                    message.pitch = Number(object.pitch);
                if (object.robotSpace != null)
                    message.robotSpace = Boolean(object.robotSpace);
                return message;
            };

            /**
             * Creates a HeadCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.HeadCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.HeadCommand} HeadCommand
             */
            HeadCommand.from = HeadCommand.fromObject;

            /**
             * Creates a plain object from a HeadCommand message. Also converts values to other types if specified.
             * @param {message.motion.HeadCommand} message HeadCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HeadCommand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.yaw = 0;
                    object.pitch = 0;
                    object.robotSpace = false;
                }
                if (message.yaw != null && message.hasOwnProperty("yaw"))
                    object.yaw = message.yaw;
                if (message.pitch != null && message.hasOwnProperty("pitch"))
                    object.pitch = message.pitch;
                if (message.robotSpace != null && message.hasOwnProperty("robotSpace"))
                    object.robotSpace = message.robotSpace;
                return object;
            };

            /**
             * Creates a plain object from this HeadCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HeadCommand.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this HeadCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            HeadCommand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HeadCommand;
        })();

        motion.HeadMotionUpdate = (function() {

            /**
             * Properties of a HeadMotionUpdate.
             * @typedef message.motion.HeadMotionUpdate$Properties
             * @type {Object}
             */

            /**
             * Constructs a new HeadMotionUpdate.
             * @exports message.motion.HeadMotionUpdate
             * @constructor
             * @param {message.motion.HeadMotionUpdate$Properties=} [properties] Properties to set
             */
            function HeadMotionUpdate(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new HeadMotionUpdate instance using the specified properties.
             * @param {message.motion.HeadMotionUpdate$Properties=} [properties] Properties to set
             * @returns {message.motion.HeadMotionUpdate} HeadMotionUpdate instance
             */
            HeadMotionUpdate.create = function create(properties) {
                return new HeadMotionUpdate(properties);
            };

            /**
             * Encodes the specified HeadMotionUpdate message. Does not implicitly {@link message.motion.HeadMotionUpdate.verify|verify} messages.
             * @param {message.motion.HeadMotionUpdate$Properties} message HeadMotionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeadMotionUpdate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified HeadMotionUpdate message, length delimited. Does not implicitly {@link message.motion.HeadMotionUpdate.verify|verify} messages.
             * @param {message.motion.HeadMotionUpdate$Properties} message HeadMotionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeadMotionUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HeadMotionUpdate message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.HeadMotionUpdate} HeadMotionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeadMotionUpdate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.HeadMotionUpdate();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HeadMotionUpdate message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.HeadMotionUpdate} HeadMotionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeadMotionUpdate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HeadMotionUpdate message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            HeadMotionUpdate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a HeadMotionUpdate message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.HeadMotionUpdate} HeadMotionUpdate
             */
            HeadMotionUpdate.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.HeadMotionUpdate)
                    return object;
                return new $root.message.motion.HeadMotionUpdate();
            };

            /**
             * Creates a HeadMotionUpdate message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.HeadMotionUpdate.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.HeadMotionUpdate} HeadMotionUpdate
             */
            HeadMotionUpdate.from = HeadMotionUpdate.fromObject;

            /**
             * Creates a plain object from a HeadMotionUpdate message. Also converts values to other types if specified.
             * @param {message.motion.HeadMotionUpdate} message HeadMotionUpdate
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HeadMotionUpdate.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this HeadMotionUpdate message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HeadMotionUpdate.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this HeadMotionUpdate to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            HeadMotionUpdate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HeadMotionUpdate;
        })();

        /**
         * TODO document
         * 
         * @author Trent Houliston
         * @author Brendan Annable
         * @name KickCommandType
         * @memberof message.motion
         * @enum {number}
         * @property {number} NORMAL=0 NORMAL value
         * @property {number} POWER=1 POWER value
         */
        motion.KickCommandType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NORMAL"] = 0;
            values[valuesById[1] = "POWER"] = 1;
            return values;
        })();

        motion.KickCommand = (function() {

            /**
             * Properties of a KickCommand.
             * @typedef message.motion.KickCommand$Properties
             * @type {Object}
             * @property {vec3$Properties} [target] KickCommand target.
             * @property {vec3$Properties} [direction] KickCommand direction.
             * @property {message.motion.KickCommandType} [kickCommandType] KickCommand kickCommandType.
             */

            /**
             * Constructs a new KickCommand.
             * @exports message.motion.KickCommand
             * @constructor
             * @param {message.motion.KickCommand$Properties=} [properties] Properties to set
             */
            function KickCommand(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KickCommand target.
             * @type {(vec3$Properties|null)}
             */
            KickCommand.prototype.target = null;

            /**
             * KickCommand direction.
             * @type {(vec3$Properties|null)}
             */
            KickCommand.prototype.direction = null;

            /**
             * KickCommand kickCommandType.
             * @type {message.motion.KickCommandType}
             */
            KickCommand.prototype.kickCommandType = 0;

            /**
             * Creates a new KickCommand instance using the specified properties.
             * @param {message.motion.KickCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.KickCommand} KickCommand instance
             */
            KickCommand.create = function create(properties) {
                return new KickCommand(properties);
            };

            /**
             * Encodes the specified KickCommand message. Does not implicitly {@link message.motion.KickCommand.verify|verify} messages.
             * @param {message.motion.KickCommand$Properties} message KickCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target != null && message.hasOwnProperty("target"))
                    $root.vec3.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.direction != null && message.hasOwnProperty("direction"))
                    $root.vec3.encode(message.direction, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.kickCommandType != null && message.hasOwnProperty("kickCommandType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.kickCommandType);
                return writer;
            };

            /**
             * Encodes the specified KickCommand message, length delimited. Does not implicitly {@link message.motion.KickCommand.verify|verify} messages.
             * @param {message.motion.KickCommand$Properties} message KickCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickCommand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KickCommand} KickCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KickCommand();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.target = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.direction = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.kickCommandType = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KickCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.KickCommand} KickCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickCommand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            KickCommand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target != null && message.hasOwnProperty("target")) {
                    var error = $root.vec3.verify(message.target);
                    if (error)
                        return "target." + error;
                }
                if (message.direction != null && message.hasOwnProperty("direction")) {
                    var error = $root.vec3.verify(message.direction);
                    if (error)
                        return "direction." + error;
                }
                if (message.kickCommandType != null && message.hasOwnProperty("kickCommandType"))
                    switch (message.kickCommandType) {
                    default:
                        return "kickCommandType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a KickCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickCommand} KickCommand
             */
            KickCommand.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.KickCommand)
                    return object;
                var message = new $root.message.motion.KickCommand();
                if (object.target != null) {
                    if (typeof object.target !== "object")
                        throw TypeError(".message.motion.KickCommand.target: object expected");
                    message.target = $root.vec3.fromObject(object.target);
                }
                if (object.direction != null) {
                    if (typeof object.direction !== "object")
                        throw TypeError(".message.motion.KickCommand.direction: object expected");
                    message.direction = $root.vec3.fromObject(object.direction);
                }
                switch (object.kickCommandType) {
                case "NORMAL":
                case 0:
                    message.kickCommandType = 0;
                    break;
                case "POWER":
                case 1:
                    message.kickCommandType = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a KickCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.KickCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickCommand} KickCommand
             */
            KickCommand.from = KickCommand.fromObject;

            /**
             * Creates a plain object from a KickCommand message. Also converts values to other types if specified.
             * @param {message.motion.KickCommand} message KickCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickCommand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.target = null;
                    object.direction = null;
                    object.kickCommandType = options.enums === String ? "NORMAL" : 0;
                }
                if (message.target != null && message.hasOwnProperty("target"))
                    object.target = $root.vec3.toObject(message.target, options);
                if (message.direction != null && message.hasOwnProperty("direction"))
                    object.direction = $root.vec3.toObject(message.direction, options);
                if (message.kickCommandType != null && message.hasOwnProperty("kickCommandType"))
                    object.kickCommandType = options.enums === String ? $root.message.motion.KickCommandType[message.kickCommandType] : message.kickCommandType;
                return object;
            };

            /**
             * Creates a plain object from this KickCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickCommand.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this KickCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            KickCommand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KickCommand;
        })();

        motion.KickScriptCommand = (function() {

            /**
             * Properties of a KickScriptCommand.
             * @typedef message.motion.KickScriptCommand$Properties
             * @type {Object}
             * @property {vec3$Properties} [direction] KickScriptCommand direction.
             * @property {number} [leg] KickScriptCommand leg.
             */

            /**
             * Constructs a new KickScriptCommand.
             * @classdesc TODO document
             * 
             * @author Trent Houliston
             * @author Brendan Annable
             * @exports message.motion.KickScriptCommand
             * @constructor
             * @param {message.motion.KickScriptCommand$Properties=} [properties] Properties to set
             */
            function KickScriptCommand(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KickScriptCommand direction.
             * @type {(vec3$Properties|null)}
             */
            KickScriptCommand.prototype.direction = null;

            /**
             * KickScriptCommand leg.
             * @type {number}
             */
            KickScriptCommand.prototype.leg = 0;

            /**
             * Creates a new KickScriptCommand instance using the specified properties.
             * @param {message.motion.KickScriptCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.KickScriptCommand} KickScriptCommand instance
             */
            KickScriptCommand.create = function create(properties) {
                return new KickScriptCommand(properties);
            };

            /**
             * Encodes the specified KickScriptCommand message. Does not implicitly {@link message.motion.KickScriptCommand.verify|verify} messages.
             * @param {message.motion.KickScriptCommand$Properties} message KickScriptCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickScriptCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.direction != null && message.hasOwnProperty("direction"))
                    $root.vec3.encode(message.direction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.leg != null && message.hasOwnProperty("leg"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.leg);
                return writer;
            };

            /**
             * Encodes the specified KickScriptCommand message, length delimited. Does not implicitly {@link message.motion.KickScriptCommand.verify|verify} messages.
             * @param {message.motion.KickScriptCommand$Properties} message KickScriptCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickScriptCommand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickScriptCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KickScriptCommand} KickScriptCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickScriptCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KickScriptCommand();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.direction = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.leg = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KickScriptCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.KickScriptCommand} KickScriptCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickScriptCommand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickScriptCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            KickScriptCommand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.direction != null && message.hasOwnProperty("direction")) {
                    var error = $root.vec3.verify(message.direction);
                    if (error)
                        return "direction." + error;
                }
                if (message.leg != null && message.hasOwnProperty("leg"))
                    if (!$util.isInteger(message.leg))
                        return "leg: integer expected";
                return null;
            };

            /**
             * Creates a KickScriptCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickScriptCommand} KickScriptCommand
             */
            KickScriptCommand.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.KickScriptCommand)
                    return object;
                var message = new $root.message.motion.KickScriptCommand();
                if (object.direction != null) {
                    if (typeof object.direction !== "object")
                        throw TypeError(".message.motion.KickScriptCommand.direction: object expected");
                    message.direction = $root.vec3.fromObject(object.direction);
                }
                if (object.leg != null)
                    message.leg = object.leg >>> 0;
                return message;
            };

            /**
             * Creates a KickScriptCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.KickScriptCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickScriptCommand} KickScriptCommand
             */
            KickScriptCommand.from = KickScriptCommand.fromObject;

            /**
             * Creates a plain object from a KickScriptCommand message. Also converts values to other types if specified.
             * @param {message.motion.KickScriptCommand} message KickScriptCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickScriptCommand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.direction = null;
                    object.leg = 0;
                }
                if (message.direction != null && message.hasOwnProperty("direction"))
                    object.direction = $root.vec3.toObject(message.direction, options);
                if (message.leg != null && message.hasOwnProperty("leg"))
                    object.leg = message.leg;
                return object;
            };

            /**
             * Creates a plain object from this KickScriptCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickScriptCommand.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this KickScriptCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            KickScriptCommand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KickScriptCommand;
        })();

        motion.KickPlannerConfig = (function() {

            /**
             * Properties of a KickPlannerConfig.
             * @typedef message.motion.KickPlannerConfig$Properties
             * @type {Object}
             * @property {number} [maxBallDistance] KickPlannerConfig maxBallDistance.
             * @property {number} [kickCorridorWidth] KickPlannerConfig kickCorridorWidth.
             * @property {number} [secondsNotSeenLimit] KickPlannerConfig secondsNotSeenLimit.
             * @property {number} [kickForwardAngleLimit] KickPlannerConfig kickForwardAngleLimit.
             */

            /**
             * Constructs a new KickPlannerConfig.
             * @exports message.motion.KickPlannerConfig
             * @constructor
             * @param {message.motion.KickPlannerConfig$Properties=} [properties] Properties to set
             */
            function KickPlannerConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KickPlannerConfig maxBallDistance.
             * @type {number}
             */
            KickPlannerConfig.prototype.maxBallDistance = 0;

            /**
             * KickPlannerConfig kickCorridorWidth.
             * @type {number}
             */
            KickPlannerConfig.prototype.kickCorridorWidth = 0;

            /**
             * KickPlannerConfig secondsNotSeenLimit.
             * @type {number}
             */
            KickPlannerConfig.prototype.secondsNotSeenLimit = 0;

            /**
             * KickPlannerConfig kickForwardAngleLimit.
             * @type {number}
             */
            KickPlannerConfig.prototype.kickForwardAngleLimit = 0;

            /**
             * Creates a new KickPlannerConfig instance using the specified properties.
             * @param {message.motion.KickPlannerConfig$Properties=} [properties] Properties to set
             * @returns {message.motion.KickPlannerConfig} KickPlannerConfig instance
             */
            KickPlannerConfig.create = function create(properties) {
                return new KickPlannerConfig(properties);
            };

            /**
             * Encodes the specified KickPlannerConfig message. Does not implicitly {@link message.motion.KickPlannerConfig.verify|verify} messages.
             * @param {message.motion.KickPlannerConfig$Properties} message KickPlannerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickPlannerConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.maxBallDistance != null && message.hasOwnProperty("maxBallDistance"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.maxBallDistance);
                if (message.kickCorridorWidth != null && message.hasOwnProperty("kickCorridorWidth"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.kickCorridorWidth);
                if (message.secondsNotSeenLimit != null && message.hasOwnProperty("secondsNotSeenLimit"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.secondsNotSeenLimit);
                if (message.kickForwardAngleLimit != null && message.hasOwnProperty("kickForwardAngleLimit"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.kickForwardAngleLimit);
                return writer;
            };

            /**
             * Encodes the specified KickPlannerConfig message, length delimited. Does not implicitly {@link message.motion.KickPlannerConfig.verify|verify} messages.
             * @param {message.motion.KickPlannerConfig$Properties} message KickPlannerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickPlannerConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickPlannerConfig message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KickPlannerConfig} KickPlannerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickPlannerConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KickPlannerConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.maxBallDistance = reader.float();
                        break;
                    case 2:
                        message.kickCorridorWidth = reader.float();
                        break;
                    case 3:
                        message.secondsNotSeenLimit = reader.float();
                        break;
                    case 4:
                        message.kickForwardAngleLimit = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KickPlannerConfig message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.KickPlannerConfig} KickPlannerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickPlannerConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickPlannerConfig message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            KickPlannerConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.maxBallDistance != null && message.hasOwnProperty("maxBallDistance"))
                    if (typeof message.maxBallDistance !== "number")
                        return "maxBallDistance: number expected";
                if (message.kickCorridorWidth != null && message.hasOwnProperty("kickCorridorWidth"))
                    if (typeof message.kickCorridorWidth !== "number")
                        return "kickCorridorWidth: number expected";
                if (message.secondsNotSeenLimit != null && message.hasOwnProperty("secondsNotSeenLimit"))
                    if (typeof message.secondsNotSeenLimit !== "number")
                        return "secondsNotSeenLimit: number expected";
                if (message.kickForwardAngleLimit != null && message.hasOwnProperty("kickForwardAngleLimit"))
                    if (typeof message.kickForwardAngleLimit !== "number")
                        return "kickForwardAngleLimit: number expected";
                return null;
            };

            /**
             * Creates a KickPlannerConfig message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickPlannerConfig} KickPlannerConfig
             */
            KickPlannerConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.KickPlannerConfig)
                    return object;
                var message = new $root.message.motion.KickPlannerConfig();
                if (object.maxBallDistance != null)
                    message.maxBallDistance = Number(object.maxBallDistance);
                if (object.kickCorridorWidth != null)
                    message.kickCorridorWidth = Number(object.kickCorridorWidth);
                if (object.secondsNotSeenLimit != null)
                    message.secondsNotSeenLimit = Number(object.secondsNotSeenLimit);
                if (object.kickForwardAngleLimit != null)
                    message.kickForwardAngleLimit = Number(object.kickForwardAngleLimit);
                return message;
            };

            /**
             * Creates a KickPlannerConfig message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.KickPlannerConfig.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickPlannerConfig} KickPlannerConfig
             */
            KickPlannerConfig.from = KickPlannerConfig.fromObject;

            /**
             * Creates a plain object from a KickPlannerConfig message. Also converts values to other types if specified.
             * @param {message.motion.KickPlannerConfig} message KickPlannerConfig
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickPlannerConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.maxBallDistance = 0;
                    object.kickCorridorWidth = 0;
                    object.secondsNotSeenLimit = 0;
                    object.kickForwardAngleLimit = 0;
                }
                if (message.maxBallDistance != null && message.hasOwnProperty("maxBallDistance"))
                    object.maxBallDistance = message.maxBallDistance;
                if (message.kickCorridorWidth != null && message.hasOwnProperty("kickCorridorWidth"))
                    object.kickCorridorWidth = message.kickCorridorWidth;
                if (message.secondsNotSeenLimit != null && message.hasOwnProperty("secondsNotSeenLimit"))
                    object.secondsNotSeenLimit = message.secondsNotSeenLimit;
                if (message.kickForwardAngleLimit != null && message.hasOwnProperty("kickForwardAngleLimit"))
                    object.kickForwardAngleLimit = message.kickForwardAngleLimit;
                return object;
            };

            /**
             * Creates a plain object from this KickPlannerConfig message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickPlannerConfig.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this KickPlannerConfig to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            KickPlannerConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KickPlannerConfig;
        })();

        motion.KickFinished = (function() {

            /**
             * Properties of a KickFinished.
             * @typedef message.motion.KickFinished$Properties
             * @type {Object}
             */

            /**
             * Constructs a new KickFinished.
             * @exports message.motion.KickFinished
             * @constructor
             * @param {message.motion.KickFinished$Properties=} [properties] Properties to set
             */
            function KickFinished(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new KickFinished instance using the specified properties.
             * @param {message.motion.KickFinished$Properties=} [properties] Properties to set
             * @returns {message.motion.KickFinished} KickFinished instance
             */
            KickFinished.create = function create(properties) {
                return new KickFinished(properties);
            };

            /**
             * Encodes the specified KickFinished message. Does not implicitly {@link message.motion.KickFinished.verify|verify} messages.
             * @param {message.motion.KickFinished$Properties} message KickFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickFinished.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified KickFinished message, length delimited. Does not implicitly {@link message.motion.KickFinished.verify|verify} messages.
             * @param {message.motion.KickFinished$Properties} message KickFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickFinished.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickFinished message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KickFinished} KickFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickFinished.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KickFinished();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KickFinished message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.KickFinished} KickFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickFinished.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickFinished message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            KickFinished.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a KickFinished message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickFinished} KickFinished
             */
            KickFinished.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.KickFinished)
                    return object;
                return new $root.message.motion.KickFinished();
            };

            /**
             * Creates a KickFinished message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.KickFinished.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickFinished} KickFinished
             */
            KickFinished.from = KickFinished.fromObject;

            /**
             * Creates a plain object from a KickFinished message. Also converts values to other types if specified.
             * @param {message.motion.KickFinished} message KickFinished
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickFinished.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this KickFinished message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickFinished.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this KickFinished to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            KickFinished.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KickFinished;
        })();

        motion.IKKickParams = (function() {

            /**
             * Properties of a IKKickParams.
             * @typedef message.motion.IKKickParams$Properties
             * @type {Object}
             * @property {number} [standHeight] IKKickParams standHeight.
             */

            /**
             * Constructs a new IKKickParams.
             * @exports message.motion.IKKickParams
             * @constructor
             * @param {message.motion.IKKickParams$Properties=} [properties] Properties to set
             */
            function IKKickParams(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IKKickParams standHeight.
             * @type {number}
             */
            IKKickParams.prototype.standHeight = 0;

            /**
             * Creates a new IKKickParams instance using the specified properties.
             * @param {message.motion.IKKickParams$Properties=} [properties] Properties to set
             * @returns {message.motion.IKKickParams} IKKickParams instance
             */
            IKKickParams.create = function create(properties) {
                return new IKKickParams(properties);
            };

            /**
             * Encodes the specified IKKickParams message. Does not implicitly {@link message.motion.IKKickParams.verify|verify} messages.
             * @param {message.motion.IKKickParams$Properties} message IKKickParams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IKKickParams.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.standHeight != null && message.hasOwnProperty("standHeight"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.standHeight);
                return writer;
            };

            /**
             * Encodes the specified IKKickParams message, length delimited. Does not implicitly {@link message.motion.IKKickParams.verify|verify} messages.
             * @param {message.motion.IKKickParams$Properties} message IKKickParams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IKKickParams.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a IKKickParams message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.IKKickParams} IKKickParams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IKKickParams.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.IKKickParams();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.standHeight = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a IKKickParams message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.IKKickParams} IKKickParams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IKKickParams.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a IKKickParams message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            IKKickParams.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.standHeight != null && message.hasOwnProperty("standHeight"))
                    if (typeof message.standHeight !== "number")
                        return "standHeight: number expected";
                return null;
            };

            /**
             * Creates a IKKickParams message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.IKKickParams} IKKickParams
             */
            IKKickParams.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.IKKickParams)
                    return object;
                var message = new $root.message.motion.IKKickParams();
                if (object.standHeight != null)
                    message.standHeight = Number(object.standHeight);
                return message;
            };

            /**
             * Creates a IKKickParams message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.IKKickParams.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.IKKickParams} IKKickParams
             */
            IKKickParams.from = IKKickParams.fromObject;

            /**
             * Creates a plain object from a IKKickParams message. Also converts values to other types if specified.
             * @param {message.motion.IKKickParams} message IKKickParams
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IKKickParams.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.standHeight = 0;
                if (message.standHeight != null && message.hasOwnProperty("standHeight"))
                    object.standHeight = message.standHeight;
                return object;
            };

            /**
             * Creates a plain object from this IKKickParams message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IKKickParams.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this IKKickParams to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            IKKickParams.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IKKickParams;
        })();

        /**
         * BodySide enum.
         * @name BodySide
         * @memberof message.motion
         * @enum {number}
         * @property {number} LEFT=0 LEFT value
         * @property {number} RIGHT=1 RIGHT value
         */
        motion.BodySide = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LEFT"] = 0;
            values[valuesById[1] = "RIGHT"] = 1;
            return values;
        })();

        motion.KinematicsModel = (function() {

            /**
             * Properties of a KinematicsModel.
             * @typedef message.motion.KinematicsModel$Properties
             * @type {Object}
             * @property {message.motion.KinematicsModel.Leg$Properties} [leg] KinematicsModel leg.
             * @property {message.motion.KinematicsModel.Head$Properties} [head] KinematicsModel head.
             * @property {message.motion.KinematicsModel.Arm$Properties} [arm] KinematicsModel arm.
             * @property {message.motion.KinematicsModel.MassModel$Properties} [massModel] KinematicsModel massModel.
             * @property {number} [TEAMDARWINCHEST_TO_ORIGIN] KinematicsModel TEAMDARWINCHEST_TO_ORIGIN.
             */

            /**
             * Constructs a new KinematicsModel.
             * @exports message.motion.KinematicsModel
             * @constructor
             * @param {message.motion.KinematicsModel$Properties=} [properties] Properties to set
             */
            function KinematicsModel(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KinematicsModel leg.
             * @type {(message.motion.KinematicsModel.Leg$Properties|null)}
             */
            KinematicsModel.prototype.leg = null;

            /**
             * KinematicsModel head.
             * @type {(message.motion.KinematicsModel.Head$Properties|null)}
             */
            KinematicsModel.prototype.head = null;

            /**
             * KinematicsModel arm.
             * @type {(message.motion.KinematicsModel.Arm$Properties|null)}
             */
            KinematicsModel.prototype.arm = null;

            /**
             * KinematicsModel massModel.
             * @type {(message.motion.KinematicsModel.MassModel$Properties|null)}
             */
            KinematicsModel.prototype.massModel = null;

            /**
             * KinematicsModel TEAMDARWINCHEST_TO_ORIGIN.
             * @type {number}
             */
            KinematicsModel.prototype.TEAMDARWINCHEST_TO_ORIGIN = 0;

            /**
             * Creates a new KinematicsModel instance using the specified properties.
             * @param {message.motion.KinematicsModel$Properties=} [properties] Properties to set
             * @returns {message.motion.KinematicsModel} KinematicsModel instance
             */
            KinematicsModel.create = function create(properties) {
                return new KinematicsModel(properties);
            };

            /**
             * Encodes the specified KinematicsModel message. Does not implicitly {@link message.motion.KinematicsModel.verify|verify} messages.
             * @param {message.motion.KinematicsModel$Properties} message KinematicsModel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KinematicsModel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.leg != null && message.hasOwnProperty("leg"))
                    $root.message.motion.KinematicsModel.Leg.encode(message.leg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.head != null && message.hasOwnProperty("head"))
                    $root.message.motion.KinematicsModel.Head.encode(message.head, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.arm != null && message.hasOwnProperty("arm"))
                    $root.message.motion.KinematicsModel.Arm.encode(message.arm, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.massModel != null && message.hasOwnProperty("massModel"))
                    $root.message.motion.KinematicsModel.MassModel.encode(message.massModel, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.TEAMDARWINCHEST_TO_ORIGIN != null && message.hasOwnProperty("TEAMDARWINCHEST_TO_ORIGIN"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.TEAMDARWINCHEST_TO_ORIGIN);
                return writer;
            };

            /**
             * Encodes the specified KinematicsModel message, length delimited. Does not implicitly {@link message.motion.KinematicsModel.verify|verify} messages.
             * @param {message.motion.KinematicsModel$Properties} message KinematicsModel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KinematicsModel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KinematicsModel message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KinematicsModel} KinematicsModel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KinematicsModel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KinematicsModel();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.leg = $root.message.motion.KinematicsModel.Leg.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.head = $root.message.motion.KinematicsModel.Head.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.arm = $root.message.motion.KinematicsModel.Arm.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.massModel = $root.message.motion.KinematicsModel.MassModel.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.TEAMDARWINCHEST_TO_ORIGIN = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KinematicsModel message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.KinematicsModel} KinematicsModel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KinematicsModel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KinematicsModel message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            KinematicsModel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.leg != null && message.hasOwnProperty("leg")) {
                    var error = $root.message.motion.KinematicsModel.Leg.verify(message.leg);
                    if (error)
                        return "leg." + error;
                }
                if (message.head != null && message.hasOwnProperty("head")) {
                    var error = $root.message.motion.KinematicsModel.Head.verify(message.head);
                    if (error)
                        return "head." + error;
                }
                if (message.arm != null && message.hasOwnProperty("arm")) {
                    var error = $root.message.motion.KinematicsModel.Arm.verify(message.arm);
                    if (error)
                        return "arm." + error;
                }
                if (message.massModel != null && message.hasOwnProperty("massModel")) {
                    var error = $root.message.motion.KinematicsModel.MassModel.verify(message.massModel);
                    if (error)
                        return "massModel." + error;
                }
                if (message.TEAMDARWINCHEST_TO_ORIGIN != null && message.hasOwnProperty("TEAMDARWINCHEST_TO_ORIGIN"))
                    if (typeof message.TEAMDARWINCHEST_TO_ORIGIN !== "number")
                        return "TEAMDARWINCHEST_TO_ORIGIN: number expected";
                return null;
            };

            /**
             * Creates a KinematicsModel message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KinematicsModel} KinematicsModel
             */
            KinematicsModel.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.KinematicsModel)
                    return object;
                var message = new $root.message.motion.KinematicsModel();
                if (object.leg != null) {
                    if (typeof object.leg !== "object")
                        throw TypeError(".message.motion.KinematicsModel.leg: object expected");
                    message.leg = $root.message.motion.KinematicsModel.Leg.fromObject(object.leg);
                }
                if (object.head != null) {
                    if (typeof object.head !== "object")
                        throw TypeError(".message.motion.KinematicsModel.head: object expected");
                    message.head = $root.message.motion.KinematicsModel.Head.fromObject(object.head);
                }
                if (object.arm != null) {
                    if (typeof object.arm !== "object")
                        throw TypeError(".message.motion.KinematicsModel.arm: object expected");
                    message.arm = $root.message.motion.KinematicsModel.Arm.fromObject(object.arm);
                }
                if (object.massModel != null) {
                    if (typeof object.massModel !== "object")
                        throw TypeError(".message.motion.KinematicsModel.massModel: object expected");
                    message.massModel = $root.message.motion.KinematicsModel.MassModel.fromObject(object.massModel);
                }
                if (object.TEAMDARWINCHEST_TO_ORIGIN != null)
                    message.TEAMDARWINCHEST_TO_ORIGIN = Number(object.TEAMDARWINCHEST_TO_ORIGIN);
                return message;
            };

            /**
             * Creates a KinematicsModel message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.KinematicsModel.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KinematicsModel} KinematicsModel
             */
            KinematicsModel.from = KinematicsModel.fromObject;

            /**
             * Creates a plain object from a KinematicsModel message. Also converts values to other types if specified.
             * @param {message.motion.KinematicsModel} message KinematicsModel
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KinematicsModel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.leg = null;
                    object.head = null;
                    object.arm = null;
                    object.massModel = null;
                    object.TEAMDARWINCHEST_TO_ORIGIN = 0;
                }
                if (message.leg != null && message.hasOwnProperty("leg"))
                    object.leg = $root.message.motion.KinematicsModel.Leg.toObject(message.leg, options);
                if (message.head != null && message.hasOwnProperty("head"))
                    object.head = $root.message.motion.KinematicsModel.Head.toObject(message.head, options);
                if (message.arm != null && message.hasOwnProperty("arm"))
                    object.arm = $root.message.motion.KinematicsModel.Arm.toObject(message.arm, options);
                if (message.massModel != null && message.hasOwnProperty("massModel"))
                    object.massModel = $root.message.motion.KinematicsModel.MassModel.toObject(message.massModel, options);
                if (message.TEAMDARWINCHEST_TO_ORIGIN != null && message.hasOwnProperty("TEAMDARWINCHEST_TO_ORIGIN"))
                    object.TEAMDARWINCHEST_TO_ORIGIN = message.TEAMDARWINCHEST_TO_ORIGIN;
                return object;
            };

            /**
             * Creates a plain object from this KinematicsModel message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KinematicsModel.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this KinematicsModel to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            KinematicsModel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            KinematicsModel.Leg = (function() {

                /**
                 * Properties of a Leg.
                 * @typedef message.motion.KinematicsModel.Leg$Properties
                 * @type {Object}
                 * @property {number} [HIP_OFFSET_X] Leg HIP_OFFSET_X.
                 * @property {number} [HIP_OFFSET_Y] Leg HIP_OFFSET_Y.
                 * @property {number} [HIP_OFFSET_Z] Leg HIP_OFFSET_Z.
                 * @property {number} [UPPER_LEG_LENGTH] Leg UPPER_LEG_LENGTH.
                 * @property {number} [LOWER_LEG_LENGTH] Leg LOWER_LEG_LENGTH.
                 * @property {number} [FOOT_HEIGHT] Leg FOOT_HEIGHT.
                 * @property {number} [FOOT_LENGTH] Leg FOOT_LENGTH.
                 * @property {number} [TOE_LENGTH] Leg TOE_LENGTH.
                 * @property {number} [HEEL_LENGTH] Leg HEEL_LENGTH.
                 * @property {number} [FOOT_WIDTH] Leg FOOT_WIDTH.
                 * @property {number} [FOOT_CENTRE_TO_ANKLE_CENTRE] Leg FOOT_CENTRE_TO_ANKLE_CENTRE.
                 * @property {number} [LENGTH_BETWEEN_LEGS] Leg LENGTH_BETWEEN_LEGS.
                 * @property {number} [LEFT_TO_RIGHT_HIP_YAW] Leg LEFT_TO_RIGHT_HIP_YAW.
                 * @property {number} [LEFT_TO_RIGHT_HIP_ROLL] Leg LEFT_TO_RIGHT_HIP_ROLL.
                 * @property {number} [LEFT_TO_RIGHT_HIP_PITCH] Leg LEFT_TO_RIGHT_HIP_PITCH.
                 * @property {number} [LEFT_TO_RIGHT_KNEE] Leg LEFT_TO_RIGHT_KNEE.
                 * @property {number} [LEFT_TO_RIGHT_ANKLE_PITCH] Leg LEFT_TO_RIGHT_ANKLE_PITCH.
                 * @property {number} [LEFT_TO_RIGHT_ANKLE_ROLL] Leg LEFT_TO_RIGHT_ANKLE_ROLL.
                 */

                /**
                 * Constructs a new Leg.
                 * @exports message.motion.KinematicsModel.Leg
                 * @constructor
                 * @param {message.motion.KinematicsModel.Leg$Properties=} [properties] Properties to set
                 */
                function Leg(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Leg HIP_OFFSET_X.
                 * @type {number}
                 */
                Leg.prototype.HIP_OFFSET_X = 0;

                /**
                 * Leg HIP_OFFSET_Y.
                 * @type {number}
                 */
                Leg.prototype.HIP_OFFSET_Y = 0;

                /**
                 * Leg HIP_OFFSET_Z.
                 * @type {number}
                 */
                Leg.prototype.HIP_OFFSET_Z = 0;

                /**
                 * Leg UPPER_LEG_LENGTH.
                 * @type {number}
                 */
                Leg.prototype.UPPER_LEG_LENGTH = 0;

                /**
                 * Leg LOWER_LEG_LENGTH.
                 * @type {number}
                 */
                Leg.prototype.LOWER_LEG_LENGTH = 0;

                /**
                 * Leg FOOT_HEIGHT.
                 * @type {number}
                 */
                Leg.prototype.FOOT_HEIGHT = 0;

                /**
                 * Leg FOOT_LENGTH.
                 * @type {number}
                 */
                Leg.prototype.FOOT_LENGTH = 0;

                /**
                 * Leg TOE_LENGTH.
                 * @type {number}
                 */
                Leg.prototype.TOE_LENGTH = 0;

                /**
                 * Leg HEEL_LENGTH.
                 * @type {number}
                 */
                Leg.prototype.HEEL_LENGTH = 0;

                /**
                 * Leg FOOT_WIDTH.
                 * @type {number}
                 */
                Leg.prototype.FOOT_WIDTH = 0;

                /**
                 * Leg FOOT_CENTRE_TO_ANKLE_CENTRE.
                 * @type {number}
                 */
                Leg.prototype.FOOT_CENTRE_TO_ANKLE_CENTRE = 0;

                /**
                 * Leg LENGTH_BETWEEN_LEGS.
                 * @type {number}
                 */
                Leg.prototype.LENGTH_BETWEEN_LEGS = 0;

                /**
                 * Leg LEFT_TO_RIGHT_HIP_YAW.
                 * @type {number}
                 */
                Leg.prototype.LEFT_TO_RIGHT_HIP_YAW = 0;

                /**
                 * Leg LEFT_TO_RIGHT_HIP_ROLL.
                 * @type {number}
                 */
                Leg.prototype.LEFT_TO_RIGHT_HIP_ROLL = 0;

                /**
                 * Leg LEFT_TO_RIGHT_HIP_PITCH.
                 * @type {number}
                 */
                Leg.prototype.LEFT_TO_RIGHT_HIP_PITCH = 0;

                /**
                 * Leg LEFT_TO_RIGHT_KNEE.
                 * @type {number}
                 */
                Leg.prototype.LEFT_TO_RIGHT_KNEE = 0;

                /**
                 * Leg LEFT_TO_RIGHT_ANKLE_PITCH.
                 * @type {number}
                 */
                Leg.prototype.LEFT_TO_RIGHT_ANKLE_PITCH = 0;

                /**
                 * Leg LEFT_TO_RIGHT_ANKLE_ROLL.
                 * @type {number}
                 */
                Leg.prototype.LEFT_TO_RIGHT_ANKLE_ROLL = 0;

                /**
                 * Creates a new Leg instance using the specified properties.
                 * @param {message.motion.KinematicsModel.Leg$Properties=} [properties] Properties to set
                 * @returns {message.motion.KinematicsModel.Leg} Leg instance
                 */
                Leg.create = function create(properties) {
                    return new Leg(properties);
                };

                /**
                 * Encodes the specified Leg message. Does not implicitly {@link message.motion.KinematicsModel.Leg.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.Leg$Properties} message Leg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Leg.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.HIP_OFFSET_X != null && message.hasOwnProperty("HIP_OFFSET_X"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.HIP_OFFSET_X);
                    if (message.HIP_OFFSET_Y != null && message.hasOwnProperty("HIP_OFFSET_Y"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.HIP_OFFSET_Y);
                    if (message.HIP_OFFSET_Z != null && message.hasOwnProperty("HIP_OFFSET_Z"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.HIP_OFFSET_Z);
                    if (message.UPPER_LEG_LENGTH != null && message.hasOwnProperty("UPPER_LEG_LENGTH"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.UPPER_LEG_LENGTH);
                    if (message.LOWER_LEG_LENGTH != null && message.hasOwnProperty("LOWER_LEG_LENGTH"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.LOWER_LEG_LENGTH);
                    if (message.FOOT_HEIGHT != null && message.hasOwnProperty("FOOT_HEIGHT"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.FOOT_HEIGHT);
                    if (message.FOOT_LENGTH != null && message.hasOwnProperty("FOOT_LENGTH"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.FOOT_LENGTH);
                    if (message.TOE_LENGTH != null && message.hasOwnProperty("TOE_LENGTH"))
                        writer.uint32(/* id 8, wireType 5 =*/69).float(message.TOE_LENGTH);
                    if (message.HEEL_LENGTH != null && message.hasOwnProperty("HEEL_LENGTH"))
                        writer.uint32(/* id 9, wireType 5 =*/77).float(message.HEEL_LENGTH);
                    if (message.FOOT_WIDTH != null && message.hasOwnProperty("FOOT_WIDTH"))
                        writer.uint32(/* id 10, wireType 5 =*/85).float(message.FOOT_WIDTH);
                    if (message.FOOT_CENTRE_TO_ANKLE_CENTRE != null && message.hasOwnProperty("FOOT_CENTRE_TO_ANKLE_CENTRE"))
                        writer.uint32(/* id 11, wireType 5 =*/93).float(message.FOOT_CENTRE_TO_ANKLE_CENTRE);
                    if (message.LENGTH_BETWEEN_LEGS != null && message.hasOwnProperty("LENGTH_BETWEEN_LEGS"))
                        writer.uint32(/* id 12, wireType 5 =*/101).float(message.LENGTH_BETWEEN_LEGS);
                    if (message.LEFT_TO_RIGHT_HIP_YAW != null && message.hasOwnProperty("LEFT_TO_RIGHT_HIP_YAW"))
                        writer.uint32(/* id 13, wireType 0 =*/104).int32(message.LEFT_TO_RIGHT_HIP_YAW);
                    if (message.LEFT_TO_RIGHT_HIP_ROLL != null && message.hasOwnProperty("LEFT_TO_RIGHT_HIP_ROLL"))
                        writer.uint32(/* id 14, wireType 0 =*/112).int32(message.LEFT_TO_RIGHT_HIP_ROLL);
                    if (message.LEFT_TO_RIGHT_HIP_PITCH != null && message.hasOwnProperty("LEFT_TO_RIGHT_HIP_PITCH"))
                        writer.uint32(/* id 15, wireType 0 =*/120).int32(message.LEFT_TO_RIGHT_HIP_PITCH);
                    if (message.LEFT_TO_RIGHT_KNEE != null && message.hasOwnProperty("LEFT_TO_RIGHT_KNEE"))
                        writer.uint32(/* id 16, wireType 0 =*/128).int32(message.LEFT_TO_RIGHT_KNEE);
                    if (message.LEFT_TO_RIGHT_ANKLE_PITCH != null && message.hasOwnProperty("LEFT_TO_RIGHT_ANKLE_PITCH"))
                        writer.uint32(/* id 17, wireType 0 =*/136).int32(message.LEFT_TO_RIGHT_ANKLE_PITCH);
                    if (message.LEFT_TO_RIGHT_ANKLE_ROLL != null && message.hasOwnProperty("LEFT_TO_RIGHT_ANKLE_ROLL"))
                        writer.uint32(/* id 18, wireType 0 =*/144).int32(message.LEFT_TO_RIGHT_ANKLE_ROLL);
                    return writer;
                };

                /**
                 * Encodes the specified Leg message, length delimited. Does not implicitly {@link message.motion.KinematicsModel.Leg.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.Leg$Properties} message Leg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Leg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Leg message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.motion.KinematicsModel.Leg} Leg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Leg.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KinematicsModel.Leg();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.HIP_OFFSET_X = reader.float();
                            break;
                        case 2:
                            message.HIP_OFFSET_Y = reader.float();
                            break;
                        case 3:
                            message.HIP_OFFSET_Z = reader.float();
                            break;
                        case 4:
                            message.UPPER_LEG_LENGTH = reader.float();
                            break;
                        case 5:
                            message.LOWER_LEG_LENGTH = reader.float();
                            break;
                        case 6:
                            message.FOOT_HEIGHT = reader.float();
                            break;
                        case 7:
                            message.FOOT_LENGTH = reader.float();
                            break;
                        case 8:
                            message.TOE_LENGTH = reader.float();
                            break;
                        case 9:
                            message.HEEL_LENGTH = reader.float();
                            break;
                        case 10:
                            message.FOOT_WIDTH = reader.float();
                            break;
                        case 11:
                            message.FOOT_CENTRE_TO_ANKLE_CENTRE = reader.float();
                            break;
                        case 12:
                            message.LENGTH_BETWEEN_LEGS = reader.float();
                            break;
                        case 13:
                            message.LEFT_TO_RIGHT_HIP_YAW = reader.int32();
                            break;
                        case 14:
                            message.LEFT_TO_RIGHT_HIP_ROLL = reader.int32();
                            break;
                        case 15:
                            message.LEFT_TO_RIGHT_HIP_PITCH = reader.int32();
                            break;
                        case 16:
                            message.LEFT_TO_RIGHT_KNEE = reader.int32();
                            break;
                        case 17:
                            message.LEFT_TO_RIGHT_ANKLE_PITCH = reader.int32();
                            break;
                        case 18:
                            message.LEFT_TO_RIGHT_ANKLE_ROLL = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Leg message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.motion.KinematicsModel.Leg} Leg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Leg.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Leg message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Leg.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.HIP_OFFSET_X != null && message.hasOwnProperty("HIP_OFFSET_X"))
                        if (typeof message.HIP_OFFSET_X !== "number")
                            return "HIP_OFFSET_X: number expected";
                    if (message.HIP_OFFSET_Y != null && message.hasOwnProperty("HIP_OFFSET_Y"))
                        if (typeof message.HIP_OFFSET_Y !== "number")
                            return "HIP_OFFSET_Y: number expected";
                    if (message.HIP_OFFSET_Z != null && message.hasOwnProperty("HIP_OFFSET_Z"))
                        if (typeof message.HIP_OFFSET_Z !== "number")
                            return "HIP_OFFSET_Z: number expected";
                    if (message.UPPER_LEG_LENGTH != null && message.hasOwnProperty("UPPER_LEG_LENGTH"))
                        if (typeof message.UPPER_LEG_LENGTH !== "number")
                            return "UPPER_LEG_LENGTH: number expected";
                    if (message.LOWER_LEG_LENGTH != null && message.hasOwnProperty("LOWER_LEG_LENGTH"))
                        if (typeof message.LOWER_LEG_LENGTH !== "number")
                            return "LOWER_LEG_LENGTH: number expected";
                    if (message.FOOT_HEIGHT != null && message.hasOwnProperty("FOOT_HEIGHT"))
                        if (typeof message.FOOT_HEIGHT !== "number")
                            return "FOOT_HEIGHT: number expected";
                    if (message.FOOT_LENGTH != null && message.hasOwnProperty("FOOT_LENGTH"))
                        if (typeof message.FOOT_LENGTH !== "number")
                            return "FOOT_LENGTH: number expected";
                    if (message.TOE_LENGTH != null && message.hasOwnProperty("TOE_LENGTH"))
                        if (typeof message.TOE_LENGTH !== "number")
                            return "TOE_LENGTH: number expected";
                    if (message.HEEL_LENGTH != null && message.hasOwnProperty("HEEL_LENGTH"))
                        if (typeof message.HEEL_LENGTH !== "number")
                            return "HEEL_LENGTH: number expected";
                    if (message.FOOT_WIDTH != null && message.hasOwnProperty("FOOT_WIDTH"))
                        if (typeof message.FOOT_WIDTH !== "number")
                            return "FOOT_WIDTH: number expected";
                    if (message.FOOT_CENTRE_TO_ANKLE_CENTRE != null && message.hasOwnProperty("FOOT_CENTRE_TO_ANKLE_CENTRE"))
                        if (typeof message.FOOT_CENTRE_TO_ANKLE_CENTRE !== "number")
                            return "FOOT_CENTRE_TO_ANKLE_CENTRE: number expected";
                    if (message.LENGTH_BETWEEN_LEGS != null && message.hasOwnProperty("LENGTH_BETWEEN_LEGS"))
                        if (typeof message.LENGTH_BETWEEN_LEGS !== "number")
                            return "LENGTH_BETWEEN_LEGS: number expected";
                    if (message.LEFT_TO_RIGHT_HIP_YAW != null && message.hasOwnProperty("LEFT_TO_RIGHT_HIP_YAW"))
                        if (!$util.isInteger(message.LEFT_TO_RIGHT_HIP_YAW))
                            return "LEFT_TO_RIGHT_HIP_YAW: integer expected";
                    if (message.LEFT_TO_RIGHT_HIP_ROLL != null && message.hasOwnProperty("LEFT_TO_RIGHT_HIP_ROLL"))
                        if (!$util.isInteger(message.LEFT_TO_RIGHT_HIP_ROLL))
                            return "LEFT_TO_RIGHT_HIP_ROLL: integer expected";
                    if (message.LEFT_TO_RIGHT_HIP_PITCH != null && message.hasOwnProperty("LEFT_TO_RIGHT_HIP_PITCH"))
                        if (!$util.isInteger(message.LEFT_TO_RIGHT_HIP_PITCH))
                            return "LEFT_TO_RIGHT_HIP_PITCH: integer expected";
                    if (message.LEFT_TO_RIGHT_KNEE != null && message.hasOwnProperty("LEFT_TO_RIGHT_KNEE"))
                        if (!$util.isInteger(message.LEFT_TO_RIGHT_KNEE))
                            return "LEFT_TO_RIGHT_KNEE: integer expected";
                    if (message.LEFT_TO_RIGHT_ANKLE_PITCH != null && message.hasOwnProperty("LEFT_TO_RIGHT_ANKLE_PITCH"))
                        if (!$util.isInteger(message.LEFT_TO_RIGHT_ANKLE_PITCH))
                            return "LEFT_TO_RIGHT_ANKLE_PITCH: integer expected";
                    if (message.LEFT_TO_RIGHT_ANKLE_ROLL != null && message.hasOwnProperty("LEFT_TO_RIGHT_ANKLE_ROLL"))
                        if (!$util.isInteger(message.LEFT_TO_RIGHT_ANKLE_ROLL))
                            return "LEFT_TO_RIGHT_ANKLE_ROLL: integer expected";
                    return null;
                };

                /**
                 * Creates a Leg message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.Leg} Leg
                 */
                Leg.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.motion.KinematicsModel.Leg)
                        return object;
                    var message = new $root.message.motion.KinematicsModel.Leg();
                    if (object.HIP_OFFSET_X != null)
                        message.HIP_OFFSET_X = Number(object.HIP_OFFSET_X);
                    if (object.HIP_OFFSET_Y != null)
                        message.HIP_OFFSET_Y = Number(object.HIP_OFFSET_Y);
                    if (object.HIP_OFFSET_Z != null)
                        message.HIP_OFFSET_Z = Number(object.HIP_OFFSET_Z);
                    if (object.UPPER_LEG_LENGTH != null)
                        message.UPPER_LEG_LENGTH = Number(object.UPPER_LEG_LENGTH);
                    if (object.LOWER_LEG_LENGTH != null)
                        message.LOWER_LEG_LENGTH = Number(object.LOWER_LEG_LENGTH);
                    if (object.FOOT_HEIGHT != null)
                        message.FOOT_HEIGHT = Number(object.FOOT_HEIGHT);
                    if (object.FOOT_LENGTH != null)
                        message.FOOT_LENGTH = Number(object.FOOT_LENGTH);
                    if (object.TOE_LENGTH != null)
                        message.TOE_LENGTH = Number(object.TOE_LENGTH);
                    if (object.HEEL_LENGTH != null)
                        message.HEEL_LENGTH = Number(object.HEEL_LENGTH);
                    if (object.FOOT_WIDTH != null)
                        message.FOOT_WIDTH = Number(object.FOOT_WIDTH);
                    if (object.FOOT_CENTRE_TO_ANKLE_CENTRE != null)
                        message.FOOT_CENTRE_TO_ANKLE_CENTRE = Number(object.FOOT_CENTRE_TO_ANKLE_CENTRE);
                    if (object.LENGTH_BETWEEN_LEGS != null)
                        message.LENGTH_BETWEEN_LEGS = Number(object.LENGTH_BETWEEN_LEGS);
                    if (object.LEFT_TO_RIGHT_HIP_YAW != null)
                        message.LEFT_TO_RIGHT_HIP_YAW = object.LEFT_TO_RIGHT_HIP_YAW | 0;
                    if (object.LEFT_TO_RIGHT_HIP_ROLL != null)
                        message.LEFT_TO_RIGHT_HIP_ROLL = object.LEFT_TO_RIGHT_HIP_ROLL | 0;
                    if (object.LEFT_TO_RIGHT_HIP_PITCH != null)
                        message.LEFT_TO_RIGHT_HIP_PITCH = object.LEFT_TO_RIGHT_HIP_PITCH | 0;
                    if (object.LEFT_TO_RIGHT_KNEE != null)
                        message.LEFT_TO_RIGHT_KNEE = object.LEFT_TO_RIGHT_KNEE | 0;
                    if (object.LEFT_TO_RIGHT_ANKLE_PITCH != null)
                        message.LEFT_TO_RIGHT_ANKLE_PITCH = object.LEFT_TO_RIGHT_ANKLE_PITCH | 0;
                    if (object.LEFT_TO_RIGHT_ANKLE_ROLL != null)
                        message.LEFT_TO_RIGHT_ANKLE_ROLL = object.LEFT_TO_RIGHT_ANKLE_ROLL | 0;
                    return message;
                };

                /**
                 * Creates a Leg message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.motion.KinematicsModel.Leg.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.Leg} Leg
                 */
                Leg.from = Leg.fromObject;

                /**
                 * Creates a plain object from a Leg message. Also converts values to other types if specified.
                 * @param {message.motion.KinematicsModel.Leg} message Leg
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Leg.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.HIP_OFFSET_X = 0;
                        object.HIP_OFFSET_Y = 0;
                        object.HIP_OFFSET_Z = 0;
                        object.UPPER_LEG_LENGTH = 0;
                        object.LOWER_LEG_LENGTH = 0;
                        object.FOOT_HEIGHT = 0;
                        object.FOOT_LENGTH = 0;
                        object.TOE_LENGTH = 0;
                        object.HEEL_LENGTH = 0;
                        object.FOOT_WIDTH = 0;
                        object.FOOT_CENTRE_TO_ANKLE_CENTRE = 0;
                        object.LENGTH_BETWEEN_LEGS = 0;
                        object.LEFT_TO_RIGHT_HIP_YAW = 0;
                        object.LEFT_TO_RIGHT_HIP_ROLL = 0;
                        object.LEFT_TO_RIGHT_HIP_PITCH = 0;
                        object.LEFT_TO_RIGHT_KNEE = 0;
                        object.LEFT_TO_RIGHT_ANKLE_PITCH = 0;
                        object.LEFT_TO_RIGHT_ANKLE_ROLL = 0;
                    }
                    if (message.HIP_OFFSET_X != null && message.hasOwnProperty("HIP_OFFSET_X"))
                        object.HIP_OFFSET_X = message.HIP_OFFSET_X;
                    if (message.HIP_OFFSET_Y != null && message.hasOwnProperty("HIP_OFFSET_Y"))
                        object.HIP_OFFSET_Y = message.HIP_OFFSET_Y;
                    if (message.HIP_OFFSET_Z != null && message.hasOwnProperty("HIP_OFFSET_Z"))
                        object.HIP_OFFSET_Z = message.HIP_OFFSET_Z;
                    if (message.UPPER_LEG_LENGTH != null && message.hasOwnProperty("UPPER_LEG_LENGTH"))
                        object.UPPER_LEG_LENGTH = message.UPPER_LEG_LENGTH;
                    if (message.LOWER_LEG_LENGTH != null && message.hasOwnProperty("LOWER_LEG_LENGTH"))
                        object.LOWER_LEG_LENGTH = message.LOWER_LEG_LENGTH;
                    if (message.FOOT_HEIGHT != null && message.hasOwnProperty("FOOT_HEIGHT"))
                        object.FOOT_HEIGHT = message.FOOT_HEIGHT;
                    if (message.FOOT_LENGTH != null && message.hasOwnProperty("FOOT_LENGTH"))
                        object.FOOT_LENGTH = message.FOOT_LENGTH;
                    if (message.TOE_LENGTH != null && message.hasOwnProperty("TOE_LENGTH"))
                        object.TOE_LENGTH = message.TOE_LENGTH;
                    if (message.HEEL_LENGTH != null && message.hasOwnProperty("HEEL_LENGTH"))
                        object.HEEL_LENGTH = message.HEEL_LENGTH;
                    if (message.FOOT_WIDTH != null && message.hasOwnProperty("FOOT_WIDTH"))
                        object.FOOT_WIDTH = message.FOOT_WIDTH;
                    if (message.FOOT_CENTRE_TO_ANKLE_CENTRE != null && message.hasOwnProperty("FOOT_CENTRE_TO_ANKLE_CENTRE"))
                        object.FOOT_CENTRE_TO_ANKLE_CENTRE = message.FOOT_CENTRE_TO_ANKLE_CENTRE;
                    if (message.LENGTH_BETWEEN_LEGS != null && message.hasOwnProperty("LENGTH_BETWEEN_LEGS"))
                        object.LENGTH_BETWEEN_LEGS = message.LENGTH_BETWEEN_LEGS;
                    if (message.LEFT_TO_RIGHT_HIP_YAW != null && message.hasOwnProperty("LEFT_TO_RIGHT_HIP_YAW"))
                        object.LEFT_TO_RIGHT_HIP_YAW = message.LEFT_TO_RIGHT_HIP_YAW;
                    if (message.LEFT_TO_RIGHT_HIP_ROLL != null && message.hasOwnProperty("LEFT_TO_RIGHT_HIP_ROLL"))
                        object.LEFT_TO_RIGHT_HIP_ROLL = message.LEFT_TO_RIGHT_HIP_ROLL;
                    if (message.LEFT_TO_RIGHT_HIP_PITCH != null && message.hasOwnProperty("LEFT_TO_RIGHT_HIP_PITCH"))
                        object.LEFT_TO_RIGHT_HIP_PITCH = message.LEFT_TO_RIGHT_HIP_PITCH;
                    if (message.LEFT_TO_RIGHT_KNEE != null && message.hasOwnProperty("LEFT_TO_RIGHT_KNEE"))
                        object.LEFT_TO_RIGHT_KNEE = message.LEFT_TO_RIGHT_KNEE;
                    if (message.LEFT_TO_RIGHT_ANKLE_PITCH != null && message.hasOwnProperty("LEFT_TO_RIGHT_ANKLE_PITCH"))
                        object.LEFT_TO_RIGHT_ANKLE_PITCH = message.LEFT_TO_RIGHT_ANKLE_PITCH;
                    if (message.LEFT_TO_RIGHT_ANKLE_ROLL != null && message.hasOwnProperty("LEFT_TO_RIGHT_ANKLE_ROLL"))
                        object.LEFT_TO_RIGHT_ANKLE_ROLL = message.LEFT_TO_RIGHT_ANKLE_ROLL;
                    return object;
                };

                /**
                 * Creates a plain object from this Leg message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Leg.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Leg to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Leg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Leg;
            })();

            KinematicsModel.Head = (function() {

                /**
                 * Properties of a Head.
                 * @typedef message.motion.KinematicsModel.Head$Properties
                 * @type {Object}
                 * @property {number} [NECK_BASE_POS_FROM_ORIGIN_X] Head NECK_BASE_POS_FROM_ORIGIN_X.
                 * @property {number} [NECK_BASE_POS_FROM_ORIGIN_Y] Head NECK_BASE_POS_FROM_ORIGIN_Y.
                 * @property {number} [NECK_BASE_POS_FROM_ORIGIN_Z] Head NECK_BASE_POS_FROM_ORIGIN_Z.
                 * @property {number} [NECK_LENGTH] Head NECK_LENGTH.
                 * @property {number} [NECK_TO_CAMERA_X] Head NECK_TO_CAMERA_X.
                 * @property {number} [NECK_TO_CAMERA_Y] Head NECK_TO_CAMERA_Y.
                 * @property {number} [NECK_TO_CAMERA_Z] Head NECK_TO_CAMERA_Z.
                 * @property {number} [CAMERA_DECLINATION_ANGLE_OFFSET] Head CAMERA_DECLINATION_ANGLE_OFFSET.
                 * @property {number} [MAX_YAW] Head MAX_YAW.
                 * @property {number} [MIN_YAW] Head MIN_YAW.
                 * @property {number} [MAX_PITCH] Head MAX_PITCH.
                 * @property {number} [MIN_PITCH] Head MIN_PITCH.
                 */

                /**
                 * Constructs a new Head.
                 * @exports message.motion.KinematicsModel.Head
                 * @constructor
                 * @param {message.motion.KinematicsModel.Head$Properties=} [properties] Properties to set
                 */
                function Head(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Head NECK_BASE_POS_FROM_ORIGIN_X.
                 * @type {number}
                 */
                Head.prototype.NECK_BASE_POS_FROM_ORIGIN_X = 0;

                /**
                 * Head NECK_BASE_POS_FROM_ORIGIN_Y.
                 * @type {number}
                 */
                Head.prototype.NECK_BASE_POS_FROM_ORIGIN_Y = 0;

                /**
                 * Head NECK_BASE_POS_FROM_ORIGIN_Z.
                 * @type {number}
                 */
                Head.prototype.NECK_BASE_POS_FROM_ORIGIN_Z = 0;

                /**
                 * Head NECK_LENGTH.
                 * @type {number}
                 */
                Head.prototype.NECK_LENGTH = 0;

                /**
                 * Head NECK_TO_CAMERA_X.
                 * @type {number}
                 */
                Head.prototype.NECK_TO_CAMERA_X = 0;

                /**
                 * Head NECK_TO_CAMERA_Y.
                 * @type {number}
                 */
                Head.prototype.NECK_TO_CAMERA_Y = 0;

                /**
                 * Head NECK_TO_CAMERA_Z.
                 * @type {number}
                 */
                Head.prototype.NECK_TO_CAMERA_Z = 0;

                /**
                 * Head CAMERA_DECLINATION_ANGLE_OFFSET.
                 * @type {number}
                 */
                Head.prototype.CAMERA_DECLINATION_ANGLE_OFFSET = 0;

                /**
                 * Head MAX_YAW.
                 * @type {number}
                 */
                Head.prototype.MAX_YAW = 0;

                /**
                 * Head MIN_YAW.
                 * @type {number}
                 */
                Head.prototype.MIN_YAW = 0;

                /**
                 * Head MAX_PITCH.
                 * @type {number}
                 */
                Head.prototype.MAX_PITCH = 0;

                /**
                 * Head MIN_PITCH.
                 * @type {number}
                 */
                Head.prototype.MIN_PITCH = 0;

                /**
                 * Creates a new Head instance using the specified properties.
                 * @param {message.motion.KinematicsModel.Head$Properties=} [properties] Properties to set
                 * @returns {message.motion.KinematicsModel.Head} Head instance
                 */
                Head.create = function create(properties) {
                    return new Head(properties);
                };

                /**
                 * Encodes the specified Head message. Does not implicitly {@link message.motion.KinematicsModel.Head.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.Head$Properties} message Head message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Head.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.NECK_BASE_POS_FROM_ORIGIN_X != null && message.hasOwnProperty("NECK_BASE_POS_FROM_ORIGIN_X"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.NECK_BASE_POS_FROM_ORIGIN_X);
                    if (message.NECK_BASE_POS_FROM_ORIGIN_Y != null && message.hasOwnProperty("NECK_BASE_POS_FROM_ORIGIN_Y"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.NECK_BASE_POS_FROM_ORIGIN_Y);
                    if (message.NECK_BASE_POS_FROM_ORIGIN_Z != null && message.hasOwnProperty("NECK_BASE_POS_FROM_ORIGIN_Z"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.NECK_BASE_POS_FROM_ORIGIN_Z);
                    if (message.NECK_LENGTH != null && message.hasOwnProperty("NECK_LENGTH"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.NECK_LENGTH);
                    if (message.NECK_TO_CAMERA_X != null && message.hasOwnProperty("NECK_TO_CAMERA_X"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.NECK_TO_CAMERA_X);
                    if (message.NECK_TO_CAMERA_Y != null && message.hasOwnProperty("NECK_TO_CAMERA_Y"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.NECK_TO_CAMERA_Y);
                    if (message.NECK_TO_CAMERA_Z != null && message.hasOwnProperty("NECK_TO_CAMERA_Z"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.NECK_TO_CAMERA_Z);
                    if (message.CAMERA_DECLINATION_ANGLE_OFFSET != null && message.hasOwnProperty("CAMERA_DECLINATION_ANGLE_OFFSET"))
                        writer.uint32(/* id 8, wireType 5 =*/69).float(message.CAMERA_DECLINATION_ANGLE_OFFSET);
                    if (message.MAX_YAW != null && message.hasOwnProperty("MAX_YAW"))
                        writer.uint32(/* id 9, wireType 5 =*/77).float(message.MAX_YAW);
                    if (message.MIN_YAW != null && message.hasOwnProperty("MIN_YAW"))
                        writer.uint32(/* id 10, wireType 5 =*/85).float(message.MIN_YAW);
                    if (message.MAX_PITCH != null && message.hasOwnProperty("MAX_PITCH"))
                        writer.uint32(/* id 11, wireType 5 =*/93).float(message.MAX_PITCH);
                    if (message.MIN_PITCH != null && message.hasOwnProperty("MIN_PITCH"))
                        writer.uint32(/* id 12, wireType 5 =*/101).float(message.MIN_PITCH);
                    return writer;
                };

                /**
                 * Encodes the specified Head message, length delimited. Does not implicitly {@link message.motion.KinematicsModel.Head.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.Head$Properties} message Head message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Head.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Head message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.motion.KinematicsModel.Head} Head
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Head.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KinematicsModel.Head();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.NECK_BASE_POS_FROM_ORIGIN_X = reader.float();
                            break;
                        case 2:
                            message.NECK_BASE_POS_FROM_ORIGIN_Y = reader.float();
                            break;
                        case 3:
                            message.NECK_BASE_POS_FROM_ORIGIN_Z = reader.float();
                            break;
                        case 4:
                            message.NECK_LENGTH = reader.float();
                            break;
                        case 5:
                            message.NECK_TO_CAMERA_X = reader.float();
                            break;
                        case 6:
                            message.NECK_TO_CAMERA_Y = reader.float();
                            break;
                        case 7:
                            message.NECK_TO_CAMERA_Z = reader.float();
                            break;
                        case 8:
                            message.CAMERA_DECLINATION_ANGLE_OFFSET = reader.float();
                            break;
                        case 9:
                            message.MAX_YAW = reader.float();
                            break;
                        case 10:
                            message.MIN_YAW = reader.float();
                            break;
                        case 11:
                            message.MAX_PITCH = reader.float();
                            break;
                        case 12:
                            message.MIN_PITCH = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Head message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.motion.KinematicsModel.Head} Head
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Head.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Head message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Head.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.NECK_BASE_POS_FROM_ORIGIN_X != null && message.hasOwnProperty("NECK_BASE_POS_FROM_ORIGIN_X"))
                        if (typeof message.NECK_BASE_POS_FROM_ORIGIN_X !== "number")
                            return "NECK_BASE_POS_FROM_ORIGIN_X: number expected";
                    if (message.NECK_BASE_POS_FROM_ORIGIN_Y != null && message.hasOwnProperty("NECK_BASE_POS_FROM_ORIGIN_Y"))
                        if (typeof message.NECK_BASE_POS_FROM_ORIGIN_Y !== "number")
                            return "NECK_BASE_POS_FROM_ORIGIN_Y: number expected";
                    if (message.NECK_BASE_POS_FROM_ORIGIN_Z != null && message.hasOwnProperty("NECK_BASE_POS_FROM_ORIGIN_Z"))
                        if (typeof message.NECK_BASE_POS_FROM_ORIGIN_Z !== "number")
                            return "NECK_BASE_POS_FROM_ORIGIN_Z: number expected";
                    if (message.NECK_LENGTH != null && message.hasOwnProperty("NECK_LENGTH"))
                        if (typeof message.NECK_LENGTH !== "number")
                            return "NECK_LENGTH: number expected";
                    if (message.NECK_TO_CAMERA_X != null && message.hasOwnProperty("NECK_TO_CAMERA_X"))
                        if (typeof message.NECK_TO_CAMERA_X !== "number")
                            return "NECK_TO_CAMERA_X: number expected";
                    if (message.NECK_TO_CAMERA_Y != null && message.hasOwnProperty("NECK_TO_CAMERA_Y"))
                        if (typeof message.NECK_TO_CAMERA_Y !== "number")
                            return "NECK_TO_CAMERA_Y: number expected";
                    if (message.NECK_TO_CAMERA_Z != null && message.hasOwnProperty("NECK_TO_CAMERA_Z"))
                        if (typeof message.NECK_TO_CAMERA_Z !== "number")
                            return "NECK_TO_CAMERA_Z: number expected";
                    if (message.CAMERA_DECLINATION_ANGLE_OFFSET != null && message.hasOwnProperty("CAMERA_DECLINATION_ANGLE_OFFSET"))
                        if (typeof message.CAMERA_DECLINATION_ANGLE_OFFSET !== "number")
                            return "CAMERA_DECLINATION_ANGLE_OFFSET: number expected";
                    if (message.MAX_YAW != null && message.hasOwnProperty("MAX_YAW"))
                        if (typeof message.MAX_YAW !== "number")
                            return "MAX_YAW: number expected";
                    if (message.MIN_YAW != null && message.hasOwnProperty("MIN_YAW"))
                        if (typeof message.MIN_YAW !== "number")
                            return "MIN_YAW: number expected";
                    if (message.MAX_PITCH != null && message.hasOwnProperty("MAX_PITCH"))
                        if (typeof message.MAX_PITCH !== "number")
                            return "MAX_PITCH: number expected";
                    if (message.MIN_PITCH != null && message.hasOwnProperty("MIN_PITCH"))
                        if (typeof message.MIN_PITCH !== "number")
                            return "MIN_PITCH: number expected";
                    return null;
                };

                /**
                 * Creates a Head message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.Head} Head
                 */
                Head.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.motion.KinematicsModel.Head)
                        return object;
                    var message = new $root.message.motion.KinematicsModel.Head();
                    if (object.NECK_BASE_POS_FROM_ORIGIN_X != null)
                        message.NECK_BASE_POS_FROM_ORIGIN_X = Number(object.NECK_BASE_POS_FROM_ORIGIN_X);
                    if (object.NECK_BASE_POS_FROM_ORIGIN_Y != null)
                        message.NECK_BASE_POS_FROM_ORIGIN_Y = Number(object.NECK_BASE_POS_FROM_ORIGIN_Y);
                    if (object.NECK_BASE_POS_FROM_ORIGIN_Z != null)
                        message.NECK_BASE_POS_FROM_ORIGIN_Z = Number(object.NECK_BASE_POS_FROM_ORIGIN_Z);
                    if (object.NECK_LENGTH != null)
                        message.NECK_LENGTH = Number(object.NECK_LENGTH);
                    if (object.NECK_TO_CAMERA_X != null)
                        message.NECK_TO_CAMERA_X = Number(object.NECK_TO_CAMERA_X);
                    if (object.NECK_TO_CAMERA_Y != null)
                        message.NECK_TO_CAMERA_Y = Number(object.NECK_TO_CAMERA_Y);
                    if (object.NECK_TO_CAMERA_Z != null)
                        message.NECK_TO_CAMERA_Z = Number(object.NECK_TO_CAMERA_Z);
                    if (object.CAMERA_DECLINATION_ANGLE_OFFSET != null)
                        message.CAMERA_DECLINATION_ANGLE_OFFSET = Number(object.CAMERA_DECLINATION_ANGLE_OFFSET);
                    if (object.MAX_YAW != null)
                        message.MAX_YAW = Number(object.MAX_YAW);
                    if (object.MIN_YAW != null)
                        message.MIN_YAW = Number(object.MIN_YAW);
                    if (object.MAX_PITCH != null)
                        message.MAX_PITCH = Number(object.MAX_PITCH);
                    if (object.MIN_PITCH != null)
                        message.MIN_PITCH = Number(object.MIN_PITCH);
                    return message;
                };

                /**
                 * Creates a Head message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.motion.KinematicsModel.Head.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.Head} Head
                 */
                Head.from = Head.fromObject;

                /**
                 * Creates a plain object from a Head message. Also converts values to other types if specified.
                 * @param {message.motion.KinematicsModel.Head} message Head
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Head.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.NECK_BASE_POS_FROM_ORIGIN_X = 0;
                        object.NECK_BASE_POS_FROM_ORIGIN_Y = 0;
                        object.NECK_BASE_POS_FROM_ORIGIN_Z = 0;
                        object.NECK_LENGTH = 0;
                        object.NECK_TO_CAMERA_X = 0;
                        object.NECK_TO_CAMERA_Y = 0;
                        object.NECK_TO_CAMERA_Z = 0;
                        object.CAMERA_DECLINATION_ANGLE_OFFSET = 0;
                        object.MAX_YAW = 0;
                        object.MIN_YAW = 0;
                        object.MAX_PITCH = 0;
                        object.MIN_PITCH = 0;
                    }
                    if (message.NECK_BASE_POS_FROM_ORIGIN_X != null && message.hasOwnProperty("NECK_BASE_POS_FROM_ORIGIN_X"))
                        object.NECK_BASE_POS_FROM_ORIGIN_X = message.NECK_BASE_POS_FROM_ORIGIN_X;
                    if (message.NECK_BASE_POS_FROM_ORIGIN_Y != null && message.hasOwnProperty("NECK_BASE_POS_FROM_ORIGIN_Y"))
                        object.NECK_BASE_POS_FROM_ORIGIN_Y = message.NECK_BASE_POS_FROM_ORIGIN_Y;
                    if (message.NECK_BASE_POS_FROM_ORIGIN_Z != null && message.hasOwnProperty("NECK_BASE_POS_FROM_ORIGIN_Z"))
                        object.NECK_BASE_POS_FROM_ORIGIN_Z = message.NECK_BASE_POS_FROM_ORIGIN_Z;
                    if (message.NECK_LENGTH != null && message.hasOwnProperty("NECK_LENGTH"))
                        object.NECK_LENGTH = message.NECK_LENGTH;
                    if (message.NECK_TO_CAMERA_X != null && message.hasOwnProperty("NECK_TO_CAMERA_X"))
                        object.NECK_TO_CAMERA_X = message.NECK_TO_CAMERA_X;
                    if (message.NECK_TO_CAMERA_Y != null && message.hasOwnProperty("NECK_TO_CAMERA_Y"))
                        object.NECK_TO_CAMERA_Y = message.NECK_TO_CAMERA_Y;
                    if (message.NECK_TO_CAMERA_Z != null && message.hasOwnProperty("NECK_TO_CAMERA_Z"))
                        object.NECK_TO_CAMERA_Z = message.NECK_TO_CAMERA_Z;
                    if (message.CAMERA_DECLINATION_ANGLE_OFFSET != null && message.hasOwnProperty("CAMERA_DECLINATION_ANGLE_OFFSET"))
                        object.CAMERA_DECLINATION_ANGLE_OFFSET = message.CAMERA_DECLINATION_ANGLE_OFFSET;
                    if (message.MAX_YAW != null && message.hasOwnProperty("MAX_YAW"))
                        object.MAX_YAW = message.MAX_YAW;
                    if (message.MIN_YAW != null && message.hasOwnProperty("MIN_YAW"))
                        object.MIN_YAW = message.MIN_YAW;
                    if (message.MAX_PITCH != null && message.hasOwnProperty("MAX_PITCH"))
                        object.MAX_PITCH = message.MAX_PITCH;
                    if (message.MIN_PITCH != null && message.hasOwnProperty("MIN_PITCH"))
                        object.MIN_PITCH = message.MIN_PITCH;
                    return object;
                };

                /**
                 * Creates a plain object from this Head message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Head.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Head to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Head.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Head;
            })();

            KinematicsModel.Arm = (function() {

                /**
                 * Properties of an Arm.
                 * @typedef message.motion.KinematicsModel.Arm$Properties
                 * @type {Object}
                 * @property {number} [DISTANCE_BETWEEN_SHOULDERS] Arm DISTANCE_BETWEEN_SHOULDERS.
                 * @property {number} [SHOULDER_Z_OFFSET] Arm SHOULDER_Z_OFFSET.
                 * @property {number} [SHOULDER_X_OFFSET] Arm SHOULDER_X_OFFSET.
                 * @property {number} [SHOULDER_LENGTH] Arm SHOULDER_LENGTH.
                 * @property {number} [SHOULDER_WIDTH] Arm SHOULDER_WIDTH.
                 * @property {number} [SHOULDER_HEIGHT] Arm SHOULDER_HEIGHT.
                 * @property {number} [UPPER_ARM_LENGTH] Arm UPPER_ARM_LENGTH.
                 * @property {number} [UPPER_ARM_Y_OFFSET] Arm UPPER_ARM_Y_OFFSET.
                 * @property {number} [UPPER_ARM_X_OFFSET] Arm UPPER_ARM_X_OFFSET.
                 * @property {number} [LOWER_ARM_LENGTH] Arm LOWER_ARM_LENGTH.
                 * @property {number} [LOWER_ARM_Y_OFFSET] Arm LOWER_ARM_Y_OFFSET.
                 * @property {number} [LOWER_ARM_Z_OFFSET] Arm LOWER_ARM_Z_OFFSET.
                 */

                /**
                 * Constructs a new Arm.
                 * @exports message.motion.KinematicsModel.Arm
                 * @constructor
                 * @param {message.motion.KinematicsModel.Arm$Properties=} [properties] Properties to set
                 */
                function Arm(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Arm DISTANCE_BETWEEN_SHOULDERS.
                 * @type {number}
                 */
                Arm.prototype.DISTANCE_BETWEEN_SHOULDERS = 0;

                /**
                 * Arm SHOULDER_Z_OFFSET.
                 * @type {number}
                 */
                Arm.prototype.SHOULDER_Z_OFFSET = 0;

                /**
                 * Arm SHOULDER_X_OFFSET.
                 * @type {number}
                 */
                Arm.prototype.SHOULDER_X_OFFSET = 0;

                /**
                 * Arm SHOULDER_LENGTH.
                 * @type {number}
                 */
                Arm.prototype.SHOULDER_LENGTH = 0;

                /**
                 * Arm SHOULDER_WIDTH.
                 * @type {number}
                 */
                Arm.prototype.SHOULDER_WIDTH = 0;

                /**
                 * Arm SHOULDER_HEIGHT.
                 * @type {number}
                 */
                Arm.prototype.SHOULDER_HEIGHT = 0;

                /**
                 * Arm UPPER_ARM_LENGTH.
                 * @type {number}
                 */
                Arm.prototype.UPPER_ARM_LENGTH = 0;

                /**
                 * Arm UPPER_ARM_Y_OFFSET.
                 * @type {number}
                 */
                Arm.prototype.UPPER_ARM_Y_OFFSET = 0;

                /**
                 * Arm UPPER_ARM_X_OFFSET.
                 * @type {number}
                 */
                Arm.prototype.UPPER_ARM_X_OFFSET = 0;

                /**
                 * Arm LOWER_ARM_LENGTH.
                 * @type {number}
                 */
                Arm.prototype.LOWER_ARM_LENGTH = 0;

                /**
                 * Arm LOWER_ARM_Y_OFFSET.
                 * @type {number}
                 */
                Arm.prototype.LOWER_ARM_Y_OFFSET = 0;

                /**
                 * Arm LOWER_ARM_Z_OFFSET.
                 * @type {number}
                 */
                Arm.prototype.LOWER_ARM_Z_OFFSET = 0;

                /**
                 * Creates a new Arm instance using the specified properties.
                 * @param {message.motion.KinematicsModel.Arm$Properties=} [properties] Properties to set
                 * @returns {message.motion.KinematicsModel.Arm} Arm instance
                 */
                Arm.create = function create(properties) {
                    return new Arm(properties);
                };

                /**
                 * Encodes the specified Arm message. Does not implicitly {@link message.motion.KinematicsModel.Arm.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.Arm$Properties} message Arm message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Arm.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.DISTANCE_BETWEEN_SHOULDERS != null && message.hasOwnProperty("DISTANCE_BETWEEN_SHOULDERS"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.DISTANCE_BETWEEN_SHOULDERS);
                    if (message.SHOULDER_Z_OFFSET != null && message.hasOwnProperty("SHOULDER_Z_OFFSET"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.SHOULDER_Z_OFFSET);
                    if (message.SHOULDER_X_OFFSET != null && message.hasOwnProperty("SHOULDER_X_OFFSET"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.SHOULDER_X_OFFSET);
                    if (message.SHOULDER_LENGTH != null && message.hasOwnProperty("SHOULDER_LENGTH"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.SHOULDER_LENGTH);
                    if (message.SHOULDER_WIDTH != null && message.hasOwnProperty("SHOULDER_WIDTH"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.SHOULDER_WIDTH);
                    if (message.SHOULDER_HEIGHT != null && message.hasOwnProperty("SHOULDER_HEIGHT"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.SHOULDER_HEIGHT);
                    if (message.UPPER_ARM_LENGTH != null && message.hasOwnProperty("UPPER_ARM_LENGTH"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.UPPER_ARM_LENGTH);
                    if (message.UPPER_ARM_Y_OFFSET != null && message.hasOwnProperty("UPPER_ARM_Y_OFFSET"))
                        writer.uint32(/* id 8, wireType 5 =*/69).float(message.UPPER_ARM_Y_OFFSET);
                    if (message.UPPER_ARM_X_OFFSET != null && message.hasOwnProperty("UPPER_ARM_X_OFFSET"))
                        writer.uint32(/* id 9, wireType 5 =*/77).float(message.UPPER_ARM_X_OFFSET);
                    if (message.LOWER_ARM_LENGTH != null && message.hasOwnProperty("LOWER_ARM_LENGTH"))
                        writer.uint32(/* id 10, wireType 5 =*/85).float(message.LOWER_ARM_LENGTH);
                    if (message.LOWER_ARM_Y_OFFSET != null && message.hasOwnProperty("LOWER_ARM_Y_OFFSET"))
                        writer.uint32(/* id 11, wireType 5 =*/93).float(message.LOWER_ARM_Y_OFFSET);
                    if (message.LOWER_ARM_Z_OFFSET != null && message.hasOwnProperty("LOWER_ARM_Z_OFFSET"))
                        writer.uint32(/* id 12, wireType 5 =*/101).float(message.LOWER_ARM_Z_OFFSET);
                    return writer;
                };

                /**
                 * Encodes the specified Arm message, length delimited. Does not implicitly {@link message.motion.KinematicsModel.Arm.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.Arm$Properties} message Arm message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Arm.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Arm message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.motion.KinematicsModel.Arm} Arm
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Arm.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KinematicsModel.Arm();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.DISTANCE_BETWEEN_SHOULDERS = reader.float();
                            break;
                        case 2:
                            message.SHOULDER_Z_OFFSET = reader.float();
                            break;
                        case 3:
                            message.SHOULDER_X_OFFSET = reader.float();
                            break;
                        case 4:
                            message.SHOULDER_LENGTH = reader.float();
                            break;
                        case 5:
                            message.SHOULDER_WIDTH = reader.float();
                            break;
                        case 6:
                            message.SHOULDER_HEIGHT = reader.float();
                            break;
                        case 7:
                            message.UPPER_ARM_LENGTH = reader.float();
                            break;
                        case 8:
                            message.UPPER_ARM_Y_OFFSET = reader.float();
                            break;
                        case 9:
                            message.UPPER_ARM_X_OFFSET = reader.float();
                            break;
                        case 10:
                            message.LOWER_ARM_LENGTH = reader.float();
                            break;
                        case 11:
                            message.LOWER_ARM_Y_OFFSET = reader.float();
                            break;
                        case 12:
                            message.LOWER_ARM_Z_OFFSET = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Arm message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.motion.KinematicsModel.Arm} Arm
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Arm.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Arm message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Arm.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.DISTANCE_BETWEEN_SHOULDERS != null && message.hasOwnProperty("DISTANCE_BETWEEN_SHOULDERS"))
                        if (typeof message.DISTANCE_BETWEEN_SHOULDERS !== "number")
                            return "DISTANCE_BETWEEN_SHOULDERS: number expected";
                    if (message.SHOULDER_Z_OFFSET != null && message.hasOwnProperty("SHOULDER_Z_OFFSET"))
                        if (typeof message.SHOULDER_Z_OFFSET !== "number")
                            return "SHOULDER_Z_OFFSET: number expected";
                    if (message.SHOULDER_X_OFFSET != null && message.hasOwnProperty("SHOULDER_X_OFFSET"))
                        if (typeof message.SHOULDER_X_OFFSET !== "number")
                            return "SHOULDER_X_OFFSET: number expected";
                    if (message.SHOULDER_LENGTH != null && message.hasOwnProperty("SHOULDER_LENGTH"))
                        if (typeof message.SHOULDER_LENGTH !== "number")
                            return "SHOULDER_LENGTH: number expected";
                    if (message.SHOULDER_WIDTH != null && message.hasOwnProperty("SHOULDER_WIDTH"))
                        if (typeof message.SHOULDER_WIDTH !== "number")
                            return "SHOULDER_WIDTH: number expected";
                    if (message.SHOULDER_HEIGHT != null && message.hasOwnProperty("SHOULDER_HEIGHT"))
                        if (typeof message.SHOULDER_HEIGHT !== "number")
                            return "SHOULDER_HEIGHT: number expected";
                    if (message.UPPER_ARM_LENGTH != null && message.hasOwnProperty("UPPER_ARM_LENGTH"))
                        if (typeof message.UPPER_ARM_LENGTH !== "number")
                            return "UPPER_ARM_LENGTH: number expected";
                    if (message.UPPER_ARM_Y_OFFSET != null && message.hasOwnProperty("UPPER_ARM_Y_OFFSET"))
                        if (typeof message.UPPER_ARM_Y_OFFSET !== "number")
                            return "UPPER_ARM_Y_OFFSET: number expected";
                    if (message.UPPER_ARM_X_OFFSET != null && message.hasOwnProperty("UPPER_ARM_X_OFFSET"))
                        if (typeof message.UPPER_ARM_X_OFFSET !== "number")
                            return "UPPER_ARM_X_OFFSET: number expected";
                    if (message.LOWER_ARM_LENGTH != null && message.hasOwnProperty("LOWER_ARM_LENGTH"))
                        if (typeof message.LOWER_ARM_LENGTH !== "number")
                            return "LOWER_ARM_LENGTH: number expected";
                    if (message.LOWER_ARM_Y_OFFSET != null && message.hasOwnProperty("LOWER_ARM_Y_OFFSET"))
                        if (typeof message.LOWER_ARM_Y_OFFSET !== "number")
                            return "LOWER_ARM_Y_OFFSET: number expected";
                    if (message.LOWER_ARM_Z_OFFSET != null && message.hasOwnProperty("LOWER_ARM_Z_OFFSET"))
                        if (typeof message.LOWER_ARM_Z_OFFSET !== "number")
                            return "LOWER_ARM_Z_OFFSET: number expected";
                    return null;
                };

                /**
                 * Creates an Arm message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.Arm} Arm
                 */
                Arm.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.motion.KinematicsModel.Arm)
                        return object;
                    var message = new $root.message.motion.KinematicsModel.Arm();
                    if (object.DISTANCE_BETWEEN_SHOULDERS != null)
                        message.DISTANCE_BETWEEN_SHOULDERS = Number(object.DISTANCE_BETWEEN_SHOULDERS);
                    if (object.SHOULDER_Z_OFFSET != null)
                        message.SHOULDER_Z_OFFSET = Number(object.SHOULDER_Z_OFFSET);
                    if (object.SHOULDER_X_OFFSET != null)
                        message.SHOULDER_X_OFFSET = Number(object.SHOULDER_X_OFFSET);
                    if (object.SHOULDER_LENGTH != null)
                        message.SHOULDER_LENGTH = Number(object.SHOULDER_LENGTH);
                    if (object.SHOULDER_WIDTH != null)
                        message.SHOULDER_WIDTH = Number(object.SHOULDER_WIDTH);
                    if (object.SHOULDER_HEIGHT != null)
                        message.SHOULDER_HEIGHT = Number(object.SHOULDER_HEIGHT);
                    if (object.UPPER_ARM_LENGTH != null)
                        message.UPPER_ARM_LENGTH = Number(object.UPPER_ARM_LENGTH);
                    if (object.UPPER_ARM_Y_OFFSET != null)
                        message.UPPER_ARM_Y_OFFSET = Number(object.UPPER_ARM_Y_OFFSET);
                    if (object.UPPER_ARM_X_OFFSET != null)
                        message.UPPER_ARM_X_OFFSET = Number(object.UPPER_ARM_X_OFFSET);
                    if (object.LOWER_ARM_LENGTH != null)
                        message.LOWER_ARM_LENGTH = Number(object.LOWER_ARM_LENGTH);
                    if (object.LOWER_ARM_Y_OFFSET != null)
                        message.LOWER_ARM_Y_OFFSET = Number(object.LOWER_ARM_Y_OFFSET);
                    if (object.LOWER_ARM_Z_OFFSET != null)
                        message.LOWER_ARM_Z_OFFSET = Number(object.LOWER_ARM_Z_OFFSET);
                    return message;
                };

                /**
                 * Creates an Arm message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.motion.KinematicsModel.Arm.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.Arm} Arm
                 */
                Arm.from = Arm.fromObject;

                /**
                 * Creates a plain object from an Arm message. Also converts values to other types if specified.
                 * @param {message.motion.KinematicsModel.Arm} message Arm
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Arm.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.DISTANCE_BETWEEN_SHOULDERS = 0;
                        object.SHOULDER_Z_OFFSET = 0;
                        object.SHOULDER_X_OFFSET = 0;
                        object.SHOULDER_LENGTH = 0;
                        object.SHOULDER_WIDTH = 0;
                        object.SHOULDER_HEIGHT = 0;
                        object.UPPER_ARM_LENGTH = 0;
                        object.UPPER_ARM_Y_OFFSET = 0;
                        object.UPPER_ARM_X_OFFSET = 0;
                        object.LOWER_ARM_LENGTH = 0;
                        object.LOWER_ARM_Y_OFFSET = 0;
                        object.LOWER_ARM_Z_OFFSET = 0;
                    }
                    if (message.DISTANCE_BETWEEN_SHOULDERS != null && message.hasOwnProperty("DISTANCE_BETWEEN_SHOULDERS"))
                        object.DISTANCE_BETWEEN_SHOULDERS = message.DISTANCE_BETWEEN_SHOULDERS;
                    if (message.SHOULDER_Z_OFFSET != null && message.hasOwnProperty("SHOULDER_Z_OFFSET"))
                        object.SHOULDER_Z_OFFSET = message.SHOULDER_Z_OFFSET;
                    if (message.SHOULDER_X_OFFSET != null && message.hasOwnProperty("SHOULDER_X_OFFSET"))
                        object.SHOULDER_X_OFFSET = message.SHOULDER_X_OFFSET;
                    if (message.SHOULDER_LENGTH != null && message.hasOwnProperty("SHOULDER_LENGTH"))
                        object.SHOULDER_LENGTH = message.SHOULDER_LENGTH;
                    if (message.SHOULDER_WIDTH != null && message.hasOwnProperty("SHOULDER_WIDTH"))
                        object.SHOULDER_WIDTH = message.SHOULDER_WIDTH;
                    if (message.SHOULDER_HEIGHT != null && message.hasOwnProperty("SHOULDER_HEIGHT"))
                        object.SHOULDER_HEIGHT = message.SHOULDER_HEIGHT;
                    if (message.UPPER_ARM_LENGTH != null && message.hasOwnProperty("UPPER_ARM_LENGTH"))
                        object.UPPER_ARM_LENGTH = message.UPPER_ARM_LENGTH;
                    if (message.UPPER_ARM_Y_OFFSET != null && message.hasOwnProperty("UPPER_ARM_Y_OFFSET"))
                        object.UPPER_ARM_Y_OFFSET = message.UPPER_ARM_Y_OFFSET;
                    if (message.UPPER_ARM_X_OFFSET != null && message.hasOwnProperty("UPPER_ARM_X_OFFSET"))
                        object.UPPER_ARM_X_OFFSET = message.UPPER_ARM_X_OFFSET;
                    if (message.LOWER_ARM_LENGTH != null && message.hasOwnProperty("LOWER_ARM_LENGTH"))
                        object.LOWER_ARM_LENGTH = message.LOWER_ARM_LENGTH;
                    if (message.LOWER_ARM_Y_OFFSET != null && message.hasOwnProperty("LOWER_ARM_Y_OFFSET"))
                        object.LOWER_ARM_Y_OFFSET = message.LOWER_ARM_Y_OFFSET;
                    if (message.LOWER_ARM_Z_OFFSET != null && message.hasOwnProperty("LOWER_ARM_Z_OFFSET"))
                        object.LOWER_ARM_Z_OFFSET = message.LOWER_ARM_Z_OFFSET;
                    return object;
                };

                /**
                 * Creates a plain object from this Arm message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Arm.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Arm to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Arm.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Arm;
            })();

            KinematicsModel.MassModel = (function() {

                /**
                 * Properties of a MassModel.
                 * @typedef message.motion.KinematicsModel.MassModel$Properties
                 * @type {Object}
                 * @property {Array.<vec4$Properties>} [masses] MassModel masses.
                 */

                /**
                 * Constructs a new MassModel.
                 * @exports message.motion.KinematicsModel.MassModel
                 * @constructor
                 * @param {message.motion.KinematicsModel.MassModel$Properties=} [properties] Properties to set
                 */
                function MassModel(properties) {
                    this.masses = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MassModel masses.
                 * @type {Array.<vec4$Properties>}
                 */
                MassModel.prototype.masses = $util.emptyArray;

                /**
                 * Creates a new MassModel instance using the specified properties.
                 * @param {message.motion.KinematicsModel.MassModel$Properties=} [properties] Properties to set
                 * @returns {message.motion.KinematicsModel.MassModel} MassModel instance
                 */
                MassModel.create = function create(properties) {
                    return new MassModel(properties);
                };

                /**
                 * Encodes the specified MassModel message. Does not implicitly {@link message.motion.KinematicsModel.MassModel.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.MassModel$Properties} message MassModel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MassModel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.masses != null && message.masses.length)
                        for (var i = 0; i < message.masses.length; ++i)
                            $root.vec4.encode(message.masses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MassModel message, length delimited. Does not implicitly {@link message.motion.KinematicsModel.MassModel.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.MassModel$Properties} message MassModel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MassModel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MassModel message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.motion.KinematicsModel.MassModel} MassModel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MassModel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.KinematicsModel.MassModel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.masses && message.masses.length))
                                message.masses = [];
                            message.masses.push($root.vec4.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MassModel message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.motion.KinematicsModel.MassModel} MassModel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MassModel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MassModel message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                MassModel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.masses != null && message.hasOwnProperty("masses")) {
                        if (!Array.isArray(message.masses))
                            return "masses: array expected";
                        for (var i = 0; i < message.masses.length; ++i) {
                            var error = $root.vec4.verify(message.masses[i]);
                            if (error)
                                return "masses." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MassModel message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.MassModel} MassModel
                 */
                MassModel.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.motion.KinematicsModel.MassModel)
                        return object;
                    var message = new $root.message.motion.KinematicsModel.MassModel();
                    if (object.masses) {
                        if (!Array.isArray(object.masses))
                            throw TypeError(".message.motion.KinematicsModel.MassModel.masses: array expected");
                        message.masses = [];
                        for (var i = 0; i < object.masses.length; ++i) {
                            if (typeof object.masses[i] !== "object")
                                throw TypeError(".message.motion.KinematicsModel.MassModel.masses: object expected");
                            message.masses[i] = $root.vec4.fromObject(object.masses[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a MassModel message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.motion.KinematicsModel.MassModel.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.MassModel} MassModel
                 */
                MassModel.from = MassModel.fromObject;

                /**
                 * Creates a plain object from a MassModel message. Also converts values to other types if specified.
                 * @param {message.motion.KinematicsModel.MassModel} message MassModel
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MassModel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.masses = [];
                    if (message.masses && message.masses.length) {
                        object.masses = [];
                        for (var j = 0; j < message.masses.length; ++j)
                            object.masses[j] = $root.vec4.toObject(message.masses[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this MassModel message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MassModel.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this MassModel to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                MassModel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MassModel;
            })();

            return KinematicsModel;
        })();

        motion.ServoTarget = (function() {

            /**
             * Properties of a ServoTarget.
             * @typedef message.motion.ServoTarget$Properties
             * @type {Object}
             * @property {google.protobuf.Timestamp$Properties} [time] ServoTarget time.
             * @property {number} [id] ServoTarget id.
             * @property {number} [position] ServoTarget position.
             * @property {number} [gain] ServoTarget gain.
             * @property {number} [torque] ServoTarget torque.
             */

            /**
             * Constructs a new ServoTarget.
             * @classdesc TODO document
             * 
             * @author Trent Houliston
             * @exports message.motion.ServoTarget
             * @constructor
             * @param {message.motion.ServoTarget$Properties=} [properties] Properties to set
             */
            function ServoTarget(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServoTarget time.
             * @type {(google.protobuf.Timestamp$Properties|null)}
             */
            ServoTarget.prototype.time = null;

            /**
             * ServoTarget id.
             * @type {number}
             */
            ServoTarget.prototype.id = 0;

            /**
             * ServoTarget position.
             * @type {number}
             */
            ServoTarget.prototype.position = 0;

            /**
             * ServoTarget gain.
             * @type {number}
             */
            ServoTarget.prototype.gain = 0;

            /**
             * ServoTarget torque.
             * @type {number}
             */
            ServoTarget.prototype.torque = 0;

            /**
             * Creates a new ServoTarget instance using the specified properties.
             * @param {message.motion.ServoTarget$Properties=} [properties] Properties to set
             * @returns {message.motion.ServoTarget} ServoTarget instance
             */
            ServoTarget.create = function create(properties) {
                return new ServoTarget(properties);
            };

            /**
             * Encodes the specified ServoTarget message. Does not implicitly {@link message.motion.ServoTarget.verify|verify} messages.
             * @param {message.motion.ServoTarget$Properties} message ServoTarget message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoTarget.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && message.hasOwnProperty("time"))
                    $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                if (message.position != null && message.hasOwnProperty("position"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.position);
                if (message.gain != null && message.hasOwnProperty("gain"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.gain);
                if (message.torque != null && message.hasOwnProperty("torque"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.torque);
                return writer;
            };

            /**
             * Encodes the specified ServoTarget message, length delimited. Does not implicitly {@link message.motion.ServoTarget.verify|verify} messages.
             * @param {message.motion.ServoTarget$Properties} message ServoTarget message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoTarget.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServoTarget message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.ServoTarget} ServoTarget
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoTarget.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.ServoTarget();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.id = reader.uint32();
                        break;
                    case 3:
                        message.position = reader.float();
                        break;
                    case 4:
                        message.gain = reader.float();
                        break;
                    case 5:
                        message.torque = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServoTarget message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.ServoTarget} ServoTarget
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoTarget.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServoTarget message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ServoTarget.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.time != null && message.hasOwnProperty("time")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.time);
                    if (error)
                        return "time." + error;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.position != null && message.hasOwnProperty("position"))
                    if (typeof message.position !== "number")
                        return "position: number expected";
                if (message.gain != null && message.hasOwnProperty("gain"))
                    if (typeof message.gain !== "number")
                        return "gain: number expected";
                if (message.torque != null && message.hasOwnProperty("torque"))
                    if (typeof message.torque !== "number")
                        return "torque: number expected";
                return null;
            };

            /**
             * Creates a ServoTarget message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.ServoTarget} ServoTarget
             */
            ServoTarget.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.ServoTarget)
                    return object;
                var message = new $root.message.motion.ServoTarget();
                if (object.time != null) {
                    if (typeof object.time !== "object")
                        throw TypeError(".message.motion.ServoTarget.time: object expected");
                    message.time = $root.google.protobuf.Timestamp.fromObject(object.time);
                }
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.position != null)
                    message.position = Number(object.position);
                if (object.gain != null)
                    message.gain = Number(object.gain);
                if (object.torque != null)
                    message.torque = Number(object.torque);
                return message;
            };

            /**
             * Creates a ServoTarget message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.ServoTarget.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.ServoTarget} ServoTarget
             */
            ServoTarget.from = ServoTarget.fromObject;

            /**
             * Creates a plain object from a ServoTarget message. Also converts values to other types if specified.
             * @param {message.motion.ServoTarget} message ServoTarget
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServoTarget.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.time = null;
                    object.id = 0;
                    object.position = 0;
                    object.gain = 0;
                    object.torque = 0;
                }
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = $root.google.protobuf.Timestamp.toObject(message.time, options);
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = message.position;
                if (message.gain != null && message.hasOwnProperty("gain"))
                    object.gain = message.gain;
                if (message.torque != null && message.hasOwnProperty("torque"))
                    object.torque = message.torque;
                return object;
            };

            /**
             * Creates a plain object from this ServoTarget message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServoTarget.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ServoTarget to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ServoTarget.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServoTarget;
        })();

        motion.TorsoMotionUpdate = (function() {

            /**
             * Properties of a TorsoMotionUpdate.
             * @typedef message.motion.TorsoMotionUpdate$Properties
             * @type {Object}
             * @property {vec3$Properties} [frameArms] TorsoMotionUpdate frameArms.
             * @property {vec3$Properties} [frameLegs] TorsoMotionUpdate frameLegs.
             * @property {mat44$Properties} [frame3D] TorsoMotionUpdate frame3D.
             */

            /**
             * Constructs a new TorsoMotionUpdate.
             * @exports message.motion.TorsoMotionUpdate
             * @constructor
             * @param {message.motion.TorsoMotionUpdate$Properties=} [properties] Properties to set
             */
            function TorsoMotionUpdate(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TorsoMotionUpdate frameArms.
             * @type {(vec3$Properties|null)}
             */
            TorsoMotionUpdate.prototype.frameArms = null;

            /**
             * TorsoMotionUpdate frameLegs.
             * @type {(vec3$Properties|null)}
             */
            TorsoMotionUpdate.prototype.frameLegs = null;

            /**
             * TorsoMotionUpdate frame3D.
             * @type {(mat44$Properties|null)}
             */
            TorsoMotionUpdate.prototype.frame3D = null;

            /**
             * Creates a new TorsoMotionUpdate instance using the specified properties.
             * @param {message.motion.TorsoMotionUpdate$Properties=} [properties] Properties to set
             * @returns {message.motion.TorsoMotionUpdate} TorsoMotionUpdate instance
             */
            TorsoMotionUpdate.create = function create(properties) {
                return new TorsoMotionUpdate(properties);
            };

            /**
             * Encodes the specified TorsoMotionUpdate message. Does not implicitly {@link message.motion.TorsoMotionUpdate.verify|verify} messages.
             * @param {message.motion.TorsoMotionUpdate$Properties} message TorsoMotionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TorsoMotionUpdate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frameArms != null && message.hasOwnProperty("frameArms"))
                    $root.vec3.encode(message.frameArms, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.frameLegs != null && message.hasOwnProperty("frameLegs"))
                    $root.vec3.encode(message.frameLegs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.frame3D != null && message.hasOwnProperty("frame3D"))
                    $root.mat44.encode(message.frame3D, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TorsoMotionUpdate message, length delimited. Does not implicitly {@link message.motion.TorsoMotionUpdate.verify|verify} messages.
             * @param {message.motion.TorsoMotionUpdate$Properties} message TorsoMotionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TorsoMotionUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TorsoMotionUpdate message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.TorsoMotionUpdate} TorsoMotionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TorsoMotionUpdate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.TorsoMotionUpdate();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.frameArms = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.frameLegs = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.frame3D = $root.mat44.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TorsoMotionUpdate message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.TorsoMotionUpdate} TorsoMotionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TorsoMotionUpdate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TorsoMotionUpdate message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            TorsoMotionUpdate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.frameArms != null && message.hasOwnProperty("frameArms")) {
                    var error = $root.vec3.verify(message.frameArms);
                    if (error)
                        return "frameArms." + error;
                }
                if (message.frameLegs != null && message.hasOwnProperty("frameLegs")) {
                    var error = $root.vec3.verify(message.frameLegs);
                    if (error)
                        return "frameLegs." + error;
                }
                if (message.frame3D != null && message.hasOwnProperty("frame3D")) {
                    var error = $root.mat44.verify(message.frame3D);
                    if (error)
                        return "frame3D." + error;
                }
                return null;
            };

            /**
             * Creates a TorsoMotionUpdate message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.TorsoMotionUpdate} TorsoMotionUpdate
             */
            TorsoMotionUpdate.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.TorsoMotionUpdate)
                    return object;
                var message = new $root.message.motion.TorsoMotionUpdate();
                if (object.frameArms != null) {
                    if (typeof object.frameArms !== "object")
                        throw TypeError(".message.motion.TorsoMotionUpdate.frameArms: object expected");
                    message.frameArms = $root.vec3.fromObject(object.frameArms);
                }
                if (object.frameLegs != null) {
                    if (typeof object.frameLegs !== "object")
                        throw TypeError(".message.motion.TorsoMotionUpdate.frameLegs: object expected");
                    message.frameLegs = $root.vec3.fromObject(object.frameLegs);
                }
                if (object.frame3D != null) {
                    if (typeof object.frame3D !== "object")
                        throw TypeError(".message.motion.TorsoMotionUpdate.frame3D: object expected");
                    message.frame3D = $root.mat44.fromObject(object.frame3D);
                }
                return message;
            };

            /**
             * Creates a TorsoMotionUpdate message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.TorsoMotionUpdate.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.TorsoMotionUpdate} TorsoMotionUpdate
             */
            TorsoMotionUpdate.from = TorsoMotionUpdate.fromObject;

            /**
             * Creates a plain object from a TorsoMotionUpdate message. Also converts values to other types if specified.
             * @param {message.motion.TorsoMotionUpdate} message TorsoMotionUpdate
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TorsoMotionUpdate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.frameArms = null;
                    object.frameLegs = null;
                    object.frame3D = null;
                }
                if (message.frameArms != null && message.hasOwnProperty("frameArms"))
                    object.frameArms = $root.vec3.toObject(message.frameArms, options);
                if (message.frameLegs != null && message.hasOwnProperty("frameLegs"))
                    object.frameLegs = $root.vec3.toObject(message.frameLegs, options);
                if (message.frame3D != null && message.hasOwnProperty("frame3D"))
                    object.frame3D = $root.mat44.toObject(message.frame3D, options);
                return object;
            };

            /**
             * Creates a plain object from this TorsoMotionUpdate message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TorsoMotionUpdate.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this TorsoMotionUpdate to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            TorsoMotionUpdate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TorsoMotionUpdate;
        })();

        motion.TorsoPositionUpdate = (function() {

            /**
             * Properties of a TorsoPositionUpdate.
             * @typedef message.motion.TorsoPositionUpdate$Properties
             * @type {Object}
             * @property {vec3$Properties} [position] TorsoPositionUpdate position.
             * @property {vec3$Properties} [destination] TorsoPositionUpdate destination.
             */

            /**
             * Constructs a new TorsoPositionUpdate.
             * @exports message.motion.TorsoPositionUpdate
             * @constructor
             * @param {message.motion.TorsoPositionUpdate$Properties=} [properties] Properties to set
             */
            function TorsoPositionUpdate(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TorsoPositionUpdate position.
             * @type {(vec3$Properties|null)}
             */
            TorsoPositionUpdate.prototype.position = null;

            /**
             * TorsoPositionUpdate destination.
             * @type {(vec3$Properties|null)}
             */
            TorsoPositionUpdate.prototype.destination = null;

            /**
             * Creates a new TorsoPositionUpdate instance using the specified properties.
             * @param {message.motion.TorsoPositionUpdate$Properties=} [properties] Properties to set
             * @returns {message.motion.TorsoPositionUpdate} TorsoPositionUpdate instance
             */
            TorsoPositionUpdate.create = function create(properties) {
                return new TorsoPositionUpdate(properties);
            };

            /**
             * Encodes the specified TorsoPositionUpdate message. Does not implicitly {@link message.motion.TorsoPositionUpdate.verify|verify} messages.
             * @param {message.motion.TorsoPositionUpdate$Properties} message TorsoPositionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TorsoPositionUpdate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && message.hasOwnProperty("position"))
                    $root.vec3.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.destination != null && message.hasOwnProperty("destination"))
                    $root.vec3.encode(message.destination, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TorsoPositionUpdate message, length delimited. Does not implicitly {@link message.motion.TorsoPositionUpdate.verify|verify} messages.
             * @param {message.motion.TorsoPositionUpdate$Properties} message TorsoPositionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TorsoPositionUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TorsoPositionUpdate message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.TorsoPositionUpdate} TorsoPositionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TorsoPositionUpdate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.TorsoPositionUpdate();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.position = $root.vec3.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.destination = $root.vec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TorsoPositionUpdate message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.TorsoPositionUpdate} TorsoPositionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TorsoPositionUpdate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TorsoPositionUpdate message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            TorsoPositionUpdate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.vec3.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.destination != null && message.hasOwnProperty("destination")) {
                    var error = $root.vec3.verify(message.destination);
                    if (error)
                        return "destination." + error;
                }
                return null;
            };

            /**
             * Creates a TorsoPositionUpdate message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.TorsoPositionUpdate} TorsoPositionUpdate
             */
            TorsoPositionUpdate.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.TorsoPositionUpdate)
                    return object;
                var message = new $root.message.motion.TorsoPositionUpdate();
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".message.motion.TorsoPositionUpdate.position: object expected");
                    message.position = $root.vec3.fromObject(object.position);
                }
                if (object.destination != null) {
                    if (typeof object.destination !== "object")
                        throw TypeError(".message.motion.TorsoPositionUpdate.destination: object expected");
                    message.destination = $root.vec3.fromObject(object.destination);
                }
                return message;
            };

            /**
             * Creates a TorsoPositionUpdate message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.TorsoPositionUpdate.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.TorsoPositionUpdate} TorsoPositionUpdate
             */
            TorsoPositionUpdate.from = TorsoPositionUpdate.fromObject;

            /**
             * Creates a plain object from a TorsoPositionUpdate message. Also converts values to other types if specified.
             * @param {message.motion.TorsoPositionUpdate} message TorsoPositionUpdate
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TorsoPositionUpdate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.position = null;
                    object.destination = null;
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.vec3.toObject(message.position, options);
                if (message.destination != null && message.hasOwnProperty("destination"))
                    object.destination = $root.vec3.toObject(message.destination, options);
                return object;
            };

            /**
             * Creates a plain object from this TorsoPositionUpdate message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TorsoPositionUpdate.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this TorsoPositionUpdate to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            TorsoPositionUpdate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TorsoPositionUpdate;
        })();

        motion.EnableTorsoMotion = (function() {

            /**
             * Properties of an EnableTorsoMotion.
             * @typedef message.motion.EnableTorsoMotion$Properties
             * @type {Object}
             */

            /**
             * Constructs a new EnableTorsoMotion.
             * @exports message.motion.EnableTorsoMotion
             * @constructor
             * @param {message.motion.EnableTorsoMotion$Properties=} [properties] Properties to set
             */
            function EnableTorsoMotion(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new EnableTorsoMotion instance using the specified properties.
             * @param {message.motion.EnableTorsoMotion$Properties=} [properties] Properties to set
             * @returns {message.motion.EnableTorsoMotion} EnableTorsoMotion instance
             */
            EnableTorsoMotion.create = function create(properties) {
                return new EnableTorsoMotion(properties);
            };

            /**
             * Encodes the specified EnableTorsoMotion message. Does not implicitly {@link message.motion.EnableTorsoMotion.verify|verify} messages.
             * @param {message.motion.EnableTorsoMotion$Properties} message EnableTorsoMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnableTorsoMotion.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified EnableTorsoMotion message, length delimited. Does not implicitly {@link message.motion.EnableTorsoMotion.verify|verify} messages.
             * @param {message.motion.EnableTorsoMotion$Properties} message EnableTorsoMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnableTorsoMotion.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnableTorsoMotion message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.EnableTorsoMotion} EnableTorsoMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnableTorsoMotion.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.EnableTorsoMotion();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnableTorsoMotion message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.EnableTorsoMotion} EnableTorsoMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnableTorsoMotion.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnableTorsoMotion message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            EnableTorsoMotion.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an EnableTorsoMotion message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableTorsoMotion} EnableTorsoMotion
             */
            EnableTorsoMotion.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.EnableTorsoMotion)
                    return object;
                return new $root.message.motion.EnableTorsoMotion();
            };

            /**
             * Creates an EnableTorsoMotion message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.EnableTorsoMotion.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableTorsoMotion} EnableTorsoMotion
             */
            EnableTorsoMotion.from = EnableTorsoMotion.fromObject;

            /**
             * Creates a plain object from an EnableTorsoMotion message. Also converts values to other types if specified.
             * @param {message.motion.EnableTorsoMotion} message EnableTorsoMotion
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnableTorsoMotion.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this EnableTorsoMotion message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnableTorsoMotion.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this EnableTorsoMotion to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            EnableTorsoMotion.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnableTorsoMotion;
        })();

        motion.DisableTorsoMotion = (function() {

            /**
             * Properties of a DisableTorsoMotion.
             * @typedef message.motion.DisableTorsoMotion$Properties
             * @type {Object}
             */

            /**
             * Constructs a new DisableTorsoMotion.
             * @exports message.motion.DisableTorsoMotion
             * @constructor
             * @param {message.motion.DisableTorsoMotion$Properties=} [properties] Properties to set
             */
            function DisableTorsoMotion(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DisableTorsoMotion instance using the specified properties.
             * @param {message.motion.DisableTorsoMotion$Properties=} [properties] Properties to set
             * @returns {message.motion.DisableTorsoMotion} DisableTorsoMotion instance
             */
            DisableTorsoMotion.create = function create(properties) {
                return new DisableTorsoMotion(properties);
            };

            /**
             * Encodes the specified DisableTorsoMotion message. Does not implicitly {@link message.motion.DisableTorsoMotion.verify|verify} messages.
             * @param {message.motion.DisableTorsoMotion$Properties} message DisableTorsoMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisableTorsoMotion.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DisableTorsoMotion message, length delimited. Does not implicitly {@link message.motion.DisableTorsoMotion.verify|verify} messages.
             * @param {message.motion.DisableTorsoMotion$Properties} message DisableTorsoMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisableTorsoMotion.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DisableTorsoMotion message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DisableTorsoMotion} DisableTorsoMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisableTorsoMotion.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.DisableTorsoMotion();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DisableTorsoMotion message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DisableTorsoMotion} DisableTorsoMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisableTorsoMotion.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DisableTorsoMotion message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            DisableTorsoMotion.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DisableTorsoMotion message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableTorsoMotion} DisableTorsoMotion
             */
            DisableTorsoMotion.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.DisableTorsoMotion)
                    return object;
                return new $root.message.motion.DisableTorsoMotion();
            };

            /**
             * Creates a DisableTorsoMotion message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DisableTorsoMotion.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableTorsoMotion} DisableTorsoMotion
             */
            DisableTorsoMotion.from = DisableTorsoMotion.fromObject;

            /**
             * Creates a plain object from a DisableTorsoMotion message. Also converts values to other types if specified.
             * @param {message.motion.DisableTorsoMotion} message DisableTorsoMotion
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisableTorsoMotion.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this DisableTorsoMotion message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisableTorsoMotion.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this DisableTorsoMotion to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            DisableTorsoMotion.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DisableTorsoMotion;
        })();

        motion.WalkStarted = (function() {

            /**
             * Properties of a WalkStarted.
             * @typedef message.motion.WalkStarted$Properties
             * @type {Object}
             */

            /**
             * Constructs a new WalkStarted.
             * @exports message.motion.WalkStarted
             * @constructor
             * @param {message.motion.WalkStarted$Properties=} [properties] Properties to set
             */
            function WalkStarted(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new WalkStarted instance using the specified properties.
             * @param {message.motion.WalkStarted$Properties=} [properties] Properties to set
             * @returns {message.motion.WalkStarted} WalkStarted instance
             */
            WalkStarted.create = function create(properties) {
                return new WalkStarted(properties);
            };

            /**
             * Encodes the specified WalkStarted message. Does not implicitly {@link message.motion.WalkStarted.verify|verify} messages.
             * @param {message.motion.WalkStarted$Properties} message WalkStarted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkStarted.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified WalkStarted message, length delimited. Does not implicitly {@link message.motion.WalkStarted.verify|verify} messages.
             * @param {message.motion.WalkStarted$Properties} message WalkStarted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkStarted.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WalkStarted message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.WalkStarted} WalkStarted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkStarted.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.WalkStarted();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WalkStarted message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.WalkStarted} WalkStarted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkStarted.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WalkStarted message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            WalkStarted.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a WalkStarted message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.WalkStarted} WalkStarted
             */
            WalkStarted.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.WalkStarted)
                    return object;
                return new $root.message.motion.WalkStarted();
            };

            /**
             * Creates a WalkStarted message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.WalkStarted.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.WalkStarted} WalkStarted
             */
            WalkStarted.from = WalkStarted.fromObject;

            /**
             * Creates a plain object from a WalkStarted message. Also converts values to other types if specified.
             * @param {message.motion.WalkStarted} message WalkStarted
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkStarted.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this WalkStarted message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkStarted.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this WalkStarted to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            WalkStarted.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WalkStarted;
        })();

        motion.WalkStopped = (function() {

            /**
             * Properties of a WalkStopped.
             * @typedef message.motion.WalkStopped$Properties
             * @type {Object}
             */

            /**
             * Constructs a new WalkStopped.
             * @exports message.motion.WalkStopped
             * @constructor
             * @param {message.motion.WalkStopped$Properties=} [properties] Properties to set
             */
            function WalkStopped(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new WalkStopped instance using the specified properties.
             * @param {message.motion.WalkStopped$Properties=} [properties] Properties to set
             * @returns {message.motion.WalkStopped} WalkStopped instance
             */
            WalkStopped.create = function create(properties) {
                return new WalkStopped(properties);
            };

            /**
             * Encodes the specified WalkStopped message. Does not implicitly {@link message.motion.WalkStopped.verify|verify} messages.
             * @param {message.motion.WalkStopped$Properties} message WalkStopped message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkStopped.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified WalkStopped message, length delimited. Does not implicitly {@link message.motion.WalkStopped.verify|verify} messages.
             * @param {message.motion.WalkStopped$Properties} message WalkStopped message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkStopped.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WalkStopped message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.WalkStopped} WalkStopped
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkStopped.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.WalkStopped();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WalkStopped message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.WalkStopped} WalkStopped
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkStopped.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WalkStopped message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            WalkStopped.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a WalkStopped message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.WalkStopped} WalkStopped
             */
            WalkStopped.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.WalkStopped)
                    return object;
                return new $root.message.motion.WalkStopped();
            };

            /**
             * Creates a WalkStopped message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.WalkStopped.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.WalkStopped} WalkStopped
             */
            WalkStopped.from = WalkStopped.fromObject;

            /**
             * Creates a plain object from a WalkStopped message. Also converts values to other types if specified.
             * @param {message.motion.WalkStopped} message WalkStopped
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkStopped.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this WalkStopped message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkStopped.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this WalkStopped to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            WalkStopped.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WalkStopped;
        })();

        motion.WalkCommand = (function() {

            /**
             * Properties of a WalkCommand.
             * @typedef message.motion.WalkCommand$Properties
             * @type {Object}
             * @property {number|Long} [subsumptionId] WalkCommand subsumptionId.
             * @property {vec3$Properties} [command] WalkCommand command.
             */

            /**
             * Constructs a new WalkCommand.
             * @exports message.motion.WalkCommand
             * @constructor
             * @param {message.motion.WalkCommand$Properties=} [properties] Properties to set
             */
            function WalkCommand(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WalkCommand subsumptionId.
             * @type {number|Long}
             */
            WalkCommand.prototype.subsumptionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * WalkCommand command.
             * @type {(vec3$Properties|null)}
             */
            WalkCommand.prototype.command = null;

            /**
             * Creates a new WalkCommand instance using the specified properties.
             * @param {message.motion.WalkCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.WalkCommand} WalkCommand instance
             */
            WalkCommand.create = function create(properties) {
                return new WalkCommand(properties);
            };

            /**
             * Encodes the specified WalkCommand message. Does not implicitly {@link message.motion.WalkCommand.verify|verify} messages.
             * @param {message.motion.WalkCommand$Properties} message WalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subsumptionId != null && message.hasOwnProperty("subsumptionId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.subsumptionId);
                if (message.command != null && message.hasOwnProperty("command"))
                    $root.vec3.encode(message.command, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WalkCommand message, length delimited. Does not implicitly {@link message.motion.WalkCommand.verify|verify} messages.
             * @param {message.motion.WalkCommand$Properties} message WalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WalkCommand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WalkCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.WalkCommand} WalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.WalkCommand();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subsumptionId = reader.uint64();
                        break;
                    case 2:
                        message.command = $root.vec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WalkCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.WalkCommand} WalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WalkCommand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WalkCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            WalkCommand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subsumptionId != null && message.hasOwnProperty("subsumptionId"))
                    if (!$util.isInteger(message.subsumptionId) && !(message.subsumptionId && $util.isInteger(message.subsumptionId.low) && $util.isInteger(message.subsumptionId.high)))
                        return "subsumptionId: integer|Long expected";
                if (message.command != null && message.hasOwnProperty("command")) {
                    var error = $root.vec3.verify(message.command);
                    if (error)
                        return "command." + error;
                }
                return null;
            };

            /**
             * Creates a WalkCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.WalkCommand} WalkCommand
             */
            WalkCommand.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.WalkCommand)
                    return object;
                var message = new $root.message.motion.WalkCommand();
                if (object.subsumptionId != null)
                    if ($util.Long)
                        (message.subsumptionId = $util.Long.fromValue(object.subsumptionId)).unsigned = true;
                    else if (typeof object.subsumptionId === "string")
                        message.subsumptionId = parseInt(object.subsumptionId, 10);
                    else if (typeof object.subsumptionId === "number")
                        message.subsumptionId = object.subsumptionId;
                    else if (typeof object.subsumptionId === "object")
                        message.subsumptionId = new $util.LongBits(object.subsumptionId.low >>> 0, object.subsumptionId.high >>> 0).toNumber(true);
                if (object.command != null) {
                    if (typeof object.command !== "object")
                        throw TypeError(".message.motion.WalkCommand.command: object expected");
                    message.command = $root.vec3.fromObject(object.command);
                }
                return message;
            };

            /**
             * Creates a WalkCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.WalkCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.WalkCommand} WalkCommand
             */
            WalkCommand.from = WalkCommand.fromObject;

            /**
             * Creates a plain object from a WalkCommand message. Also converts values to other types if specified.
             * @param {message.motion.WalkCommand} message WalkCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkCommand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.subsumptionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.subsumptionId = options.longs === String ? "0" : 0;
                    object.command = null;
                }
                if (message.subsumptionId != null && message.hasOwnProperty("subsumptionId"))
                    if (typeof message.subsumptionId === "number")
                        object.subsumptionId = options.longs === String ? String(message.subsumptionId) : message.subsumptionId;
                    else
                        object.subsumptionId = options.longs === String ? $util.Long.prototype.toString.call(message.subsumptionId) : options.longs === Number ? new $util.LongBits(message.subsumptionId.low >>> 0, message.subsumptionId.high >>> 0).toNumber(true) : message.subsumptionId;
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = $root.vec3.toObject(message.command, options);
                return object;
            };

            /**
             * Creates a plain object from this WalkCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WalkCommand.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this WalkCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            WalkCommand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WalkCommand;
        })();

        motion.StopCommand = (function() {

            /**
             * Properties of a StopCommand.
             * @typedef message.motion.StopCommand$Properties
             * @type {Object}
             * @property {number|Long} [subsumptionId] StopCommand subsumptionId.
             */

            /**
             * Constructs a new StopCommand.
             * @exports message.motion.StopCommand
             * @constructor
             * @param {message.motion.StopCommand$Properties=} [properties] Properties to set
             */
            function StopCommand(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StopCommand subsumptionId.
             * @type {number|Long}
             */
            StopCommand.prototype.subsumptionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new StopCommand instance using the specified properties.
             * @param {message.motion.StopCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.StopCommand} StopCommand instance
             */
            StopCommand.create = function create(properties) {
                return new StopCommand(properties);
            };

            /**
             * Encodes the specified StopCommand message. Does not implicitly {@link message.motion.StopCommand.verify|verify} messages.
             * @param {message.motion.StopCommand$Properties} message StopCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StopCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subsumptionId != null && message.hasOwnProperty("subsumptionId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.subsumptionId);
                return writer;
            };

            /**
             * Encodes the specified StopCommand message, length delimited. Does not implicitly {@link message.motion.StopCommand.verify|verify} messages.
             * @param {message.motion.StopCommand$Properties} message StopCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StopCommand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StopCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.StopCommand} StopCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StopCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.StopCommand();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subsumptionId = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StopCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.StopCommand} StopCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StopCommand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StopCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            StopCommand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subsumptionId != null && message.hasOwnProperty("subsumptionId"))
                    if (!$util.isInteger(message.subsumptionId) && !(message.subsumptionId && $util.isInteger(message.subsumptionId.low) && $util.isInteger(message.subsumptionId.high)))
                        return "subsumptionId: integer|Long expected";
                return null;
            };

            /**
             * Creates a StopCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.StopCommand} StopCommand
             */
            StopCommand.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.StopCommand)
                    return object;
                var message = new $root.message.motion.StopCommand();
                if (object.subsumptionId != null)
                    if ($util.Long)
                        (message.subsumptionId = $util.Long.fromValue(object.subsumptionId)).unsigned = true;
                    else if (typeof object.subsumptionId === "string")
                        message.subsumptionId = parseInt(object.subsumptionId, 10);
                    else if (typeof object.subsumptionId === "number")
                        message.subsumptionId = object.subsumptionId;
                    else if (typeof object.subsumptionId === "object")
                        message.subsumptionId = new $util.LongBits(object.subsumptionId.low >>> 0, object.subsumptionId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a StopCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.StopCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.StopCommand} StopCommand
             */
            StopCommand.from = StopCommand.fromObject;

            /**
             * Creates a plain object from a StopCommand message. Also converts values to other types if specified.
             * @param {message.motion.StopCommand} message StopCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StopCommand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.subsumptionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.subsumptionId = options.longs === String ? "0" : 0;
                if (message.subsumptionId != null && message.hasOwnProperty("subsumptionId"))
                    if (typeof message.subsumptionId === "number")
                        object.subsumptionId = options.longs === String ? String(message.subsumptionId) : message.subsumptionId;
                    else
                        object.subsumptionId = options.longs === String ? $util.Long.prototype.toString.call(message.subsumptionId) : options.longs === Number ? new $util.LongBits(message.subsumptionId.low >>> 0, message.subsumptionId.high >>> 0).toNumber(true) : message.subsumptionId;
                return object;
            };

            /**
             * Creates a plain object from this StopCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StopCommand.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this StopCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            StopCommand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StopCommand;
        })();

        motion.NewWalkCommand = (function() {

            /**
             * Properties of a NewWalkCommand.
             * @typedef message.motion.NewWalkCommand$Properties
             * @type {Object}
             * @property {vec3$Properties} [velocityTarget] NewWalkCommand velocityTarget.
             */

            /**
             * Constructs a new NewWalkCommand.
             * @exports message.motion.NewWalkCommand
             * @constructor
             * @param {message.motion.NewWalkCommand$Properties=} [properties] Properties to set
             */
            function NewWalkCommand(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NewWalkCommand velocityTarget.
             * @type {(vec3$Properties|null)}
             */
            NewWalkCommand.prototype.velocityTarget = null;

            /**
             * Creates a new NewWalkCommand instance using the specified properties.
             * @param {message.motion.NewWalkCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.NewWalkCommand} NewWalkCommand instance
             */
            NewWalkCommand.create = function create(properties) {
                return new NewWalkCommand(properties);
            };

            /**
             * Encodes the specified NewWalkCommand message. Does not implicitly {@link message.motion.NewWalkCommand.verify|verify} messages.
             * @param {message.motion.NewWalkCommand$Properties} message NewWalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewWalkCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.velocityTarget != null && message.hasOwnProperty("velocityTarget"))
                    $root.vec3.encode(message.velocityTarget, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NewWalkCommand message, length delimited. Does not implicitly {@link message.motion.NewWalkCommand.verify|verify} messages.
             * @param {message.motion.NewWalkCommand$Properties} message NewWalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewWalkCommand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NewWalkCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.NewWalkCommand} NewWalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewWalkCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.NewWalkCommand();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.velocityTarget = $root.vec3.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NewWalkCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.NewWalkCommand} NewWalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewWalkCommand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NewWalkCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            NewWalkCommand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.velocityTarget != null && message.hasOwnProperty("velocityTarget")) {
                    var error = $root.vec3.verify(message.velocityTarget);
                    if (error)
                        return "velocityTarget." + error;
                }
                return null;
            };

            /**
             * Creates a NewWalkCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NewWalkCommand} NewWalkCommand
             */
            NewWalkCommand.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.NewWalkCommand)
                    return object;
                var message = new $root.message.motion.NewWalkCommand();
                if (object.velocityTarget != null) {
                    if (typeof object.velocityTarget !== "object")
                        throw TypeError(".message.motion.NewWalkCommand.velocityTarget: object expected");
                    message.velocityTarget = $root.vec3.fromObject(object.velocityTarget);
                }
                return message;
            };

            /**
             * Creates a NewWalkCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.NewWalkCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NewWalkCommand} NewWalkCommand
             */
            NewWalkCommand.from = NewWalkCommand.fromObject;

            /**
             * Creates a plain object from a NewWalkCommand message. Also converts values to other types if specified.
             * @param {message.motion.NewWalkCommand} message NewWalkCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NewWalkCommand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.velocityTarget = null;
                if (message.velocityTarget != null && message.hasOwnProperty("velocityTarget"))
                    object.velocityTarget = $root.vec3.toObject(message.velocityTarget, options);
                return object;
            };

            /**
             * Creates a plain object from this NewWalkCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NewWalkCommand.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this NewWalkCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            NewWalkCommand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NewWalkCommand;
        })();

        motion.EnableWalkEngineCommand = (function() {

            /**
             * Properties of an EnableWalkEngineCommand.
             * @typedef message.motion.EnableWalkEngineCommand$Properties
             * @type {Object}
             * @property {number|Long} [subsumptionId] EnableWalkEngineCommand subsumptionId.
             */

            /**
             * Constructs a new EnableWalkEngineCommand.
             * @exports message.motion.EnableWalkEngineCommand
             * @constructor
             * @param {message.motion.EnableWalkEngineCommand$Properties=} [properties] Properties to set
             */
            function EnableWalkEngineCommand(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnableWalkEngineCommand subsumptionId.
             * @type {number|Long}
             */
            EnableWalkEngineCommand.prototype.subsumptionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new EnableWalkEngineCommand instance using the specified properties.
             * @param {message.motion.EnableWalkEngineCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.EnableWalkEngineCommand} EnableWalkEngineCommand instance
             */
            EnableWalkEngineCommand.create = function create(properties) {
                return new EnableWalkEngineCommand(properties);
            };

            /**
             * Encodes the specified EnableWalkEngineCommand message. Does not implicitly {@link message.motion.EnableWalkEngineCommand.verify|verify} messages.
             * @param {message.motion.EnableWalkEngineCommand$Properties} message EnableWalkEngineCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnableWalkEngineCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subsumptionId != null && message.hasOwnProperty("subsumptionId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.subsumptionId);
                return writer;
            };

            /**
             * Encodes the specified EnableWalkEngineCommand message, length delimited. Does not implicitly {@link message.motion.EnableWalkEngineCommand.verify|verify} messages.
             * @param {message.motion.EnableWalkEngineCommand$Properties} message EnableWalkEngineCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnableWalkEngineCommand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnableWalkEngineCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.EnableWalkEngineCommand} EnableWalkEngineCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnableWalkEngineCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.EnableWalkEngineCommand();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subsumptionId = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnableWalkEngineCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.EnableWalkEngineCommand} EnableWalkEngineCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnableWalkEngineCommand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnableWalkEngineCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            EnableWalkEngineCommand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subsumptionId != null && message.hasOwnProperty("subsumptionId"))
                    if (!$util.isInteger(message.subsumptionId) && !(message.subsumptionId && $util.isInteger(message.subsumptionId.low) && $util.isInteger(message.subsumptionId.high)))
                        return "subsumptionId: integer|Long expected";
                return null;
            };

            /**
             * Creates an EnableWalkEngineCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableWalkEngineCommand} EnableWalkEngineCommand
             */
            EnableWalkEngineCommand.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.EnableWalkEngineCommand)
                    return object;
                var message = new $root.message.motion.EnableWalkEngineCommand();
                if (object.subsumptionId != null)
                    if ($util.Long)
                        (message.subsumptionId = $util.Long.fromValue(object.subsumptionId)).unsigned = true;
                    else if (typeof object.subsumptionId === "string")
                        message.subsumptionId = parseInt(object.subsumptionId, 10);
                    else if (typeof object.subsumptionId === "number")
                        message.subsumptionId = object.subsumptionId;
                    else if (typeof object.subsumptionId === "object")
                        message.subsumptionId = new $util.LongBits(object.subsumptionId.low >>> 0, object.subsumptionId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates an EnableWalkEngineCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.EnableWalkEngineCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableWalkEngineCommand} EnableWalkEngineCommand
             */
            EnableWalkEngineCommand.from = EnableWalkEngineCommand.fromObject;

            /**
             * Creates a plain object from an EnableWalkEngineCommand message. Also converts values to other types if specified.
             * @param {message.motion.EnableWalkEngineCommand} message EnableWalkEngineCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnableWalkEngineCommand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.subsumptionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.subsumptionId = options.longs === String ? "0" : 0;
                if (message.subsumptionId != null && message.hasOwnProperty("subsumptionId"))
                    if (typeof message.subsumptionId === "number")
                        object.subsumptionId = options.longs === String ? String(message.subsumptionId) : message.subsumptionId;
                    else
                        object.subsumptionId = options.longs === String ? $util.Long.prototype.toString.call(message.subsumptionId) : options.longs === Number ? new $util.LongBits(message.subsumptionId.low >>> 0, message.subsumptionId.high >>> 0).toNumber(true) : message.subsumptionId;
                return object;
            };

            /**
             * Creates a plain object from this EnableWalkEngineCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnableWalkEngineCommand.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this EnableWalkEngineCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            EnableWalkEngineCommand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnableWalkEngineCommand;
        })();

        motion.DisableWalkEngineCommand = (function() {

            /**
             * Properties of a DisableWalkEngineCommand.
             * @typedef message.motion.DisableWalkEngineCommand$Properties
             * @type {Object}
             * @property {number|Long} [subsumptionId] DisableWalkEngineCommand subsumptionId.
             */

            /**
             * Constructs a new DisableWalkEngineCommand.
             * @exports message.motion.DisableWalkEngineCommand
             * @constructor
             * @param {message.motion.DisableWalkEngineCommand$Properties=} [properties] Properties to set
             */
            function DisableWalkEngineCommand(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DisableWalkEngineCommand subsumptionId.
             * @type {number|Long}
             */
            DisableWalkEngineCommand.prototype.subsumptionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new DisableWalkEngineCommand instance using the specified properties.
             * @param {message.motion.DisableWalkEngineCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.DisableWalkEngineCommand} DisableWalkEngineCommand instance
             */
            DisableWalkEngineCommand.create = function create(properties) {
                return new DisableWalkEngineCommand(properties);
            };

            /**
             * Encodes the specified DisableWalkEngineCommand message. Does not implicitly {@link message.motion.DisableWalkEngineCommand.verify|verify} messages.
             * @param {message.motion.DisableWalkEngineCommand$Properties} message DisableWalkEngineCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisableWalkEngineCommand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subsumptionId != null && message.hasOwnProperty("subsumptionId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.subsumptionId);
                return writer;
            };

            /**
             * Encodes the specified DisableWalkEngineCommand message, length delimited. Does not implicitly {@link message.motion.DisableWalkEngineCommand.verify|verify} messages.
             * @param {message.motion.DisableWalkEngineCommand$Properties} message DisableWalkEngineCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisableWalkEngineCommand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DisableWalkEngineCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DisableWalkEngineCommand} DisableWalkEngineCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisableWalkEngineCommand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.motion.DisableWalkEngineCommand();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subsumptionId = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DisableWalkEngineCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DisableWalkEngineCommand} DisableWalkEngineCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisableWalkEngineCommand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DisableWalkEngineCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            DisableWalkEngineCommand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subsumptionId != null && message.hasOwnProperty("subsumptionId"))
                    if (!$util.isInteger(message.subsumptionId) && !(message.subsumptionId && $util.isInteger(message.subsumptionId.low) && $util.isInteger(message.subsumptionId.high)))
                        return "subsumptionId: integer|Long expected";
                return null;
            };

            /**
             * Creates a DisableWalkEngineCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableWalkEngineCommand} DisableWalkEngineCommand
             */
            DisableWalkEngineCommand.fromObject = function fromObject(object) {
                if (object instanceof $root.message.motion.DisableWalkEngineCommand)
                    return object;
                var message = new $root.message.motion.DisableWalkEngineCommand();
                if (object.subsumptionId != null)
                    if ($util.Long)
                        (message.subsumptionId = $util.Long.fromValue(object.subsumptionId)).unsigned = true;
                    else if (typeof object.subsumptionId === "string")
                        message.subsumptionId = parseInt(object.subsumptionId, 10);
                    else if (typeof object.subsumptionId === "number")
                        message.subsumptionId = object.subsumptionId;
                    else if (typeof object.subsumptionId === "object")
                        message.subsumptionId = new $util.LongBits(object.subsumptionId.low >>> 0, object.subsumptionId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a DisableWalkEngineCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DisableWalkEngineCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableWalkEngineCommand} DisableWalkEngineCommand
             */
            DisableWalkEngineCommand.from = DisableWalkEngineCommand.fromObject;

            /**
             * Creates a plain object from a DisableWalkEngineCommand message. Also converts values to other types if specified.
             * @param {message.motion.DisableWalkEngineCommand} message DisableWalkEngineCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisableWalkEngineCommand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.subsumptionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.subsumptionId = options.longs === String ? "0" : 0;
                if (message.subsumptionId != null && message.hasOwnProperty("subsumptionId"))
                    if (typeof message.subsumptionId === "number")
                        object.subsumptionId = options.longs === String ? String(message.subsumptionId) : message.subsumptionId;
                    else
                        object.subsumptionId = options.longs === String ? $util.Long.prototype.toString.call(message.subsumptionId) : options.longs === Number ? new $util.LongBits(message.subsumptionId.low >>> 0, message.subsumptionId.high >>> 0).toNumber(true) : message.subsumptionId;
                return object;
            };

            /**
             * Creates a plain object from this DisableWalkEngineCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisableWalkEngineCommand.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this DisableWalkEngineCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            DisableWalkEngineCommand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DisableWalkEngineCommand;
        })();

        return motion;
    })();

    message.output = (function() {

        /**
         * Namespace output.
         * @exports message.output
         * @namespace
         */
        var output = {};

        output.Say = (function() {

            /**
             * Properties of a Say.
             * @typedef message.output.Say$Properties
             * @type {Object}
             * @property {string} [message] Say message.
             */

            /**
             * Constructs a new Say.
             * @classdesc TODO document
             * 
             * @author Trent Houliston
             * @exports message.output.Say
             * @constructor
             * @param {message.output.Say$Properties=} [properties] Properties to set
             */
            function Say(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Say message.
             * @type {string}
             */
            Say.prototype.message = "";

            /**
             * Creates a new Say instance using the specified properties.
             * @param {message.output.Say$Properties=} [properties] Properties to set
             * @returns {message.output.Say} Say instance
             */
            Say.create = function create(properties) {
                return new Say(properties);
            };

            /**
             * Encodes the specified Say message. Does not implicitly {@link message.output.Say.verify|verify} messages.
             * @param {message.output.Say$Properties} message Say message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Say.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message != null && message.hasOwnProperty("message"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
                return writer;
            };

            /**
             * Encodes the specified Say message, length delimited. Does not implicitly {@link message.output.Say.verify|verify} messages.
             * @param {message.output.Say$Properties} message Say message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Say.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Say message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.output.Say} Say
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Say.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.output.Say();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.message = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Say message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.output.Say} Say
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Say.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Say message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Say.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                return null;
            };

            /**
             * Creates a Say message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.output.Say} Say
             */
            Say.fromObject = function fromObject(object) {
                if (object instanceof $root.message.output.Say)
                    return object;
                var message = new $root.message.output.Say();
                if (object.message != null)
                    message.message = String(object.message);
                return message;
            };

            /**
             * Creates a Say message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.output.Say.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.output.Say} Say
             */
            Say.from = Say.fromObject;

            /**
             * Creates a plain object from a Say message. Also converts values to other types if specified.
             * @param {message.output.Say} message Say
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Say.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.message = "";
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                return object;
            };

            /**
             * Creates a plain object from this Say message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Say.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Say to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Say.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Say;
        })();

        return output;
    })();

    message.platform = (function() {

        /**
         * Namespace platform.
         * @exports message.platform
         * @namespace
         */
        var platform = {};

        platform.darwin = (function() {

            /**
             * Namespace darwin.
             * @exports message.platform.darwin
             * @namespace
             */
            var darwin = {};

            darwin.DarwinSensors = (function() {

                /**
                 * Properties of a DarwinSensors.
                 * @typedef message.platform.darwin.DarwinSensors$Properties
                 * @type {Object}
                 * @property {google.protobuf.Timestamp$Properties} [timestamp] DarwinSensors timestamp.
                 * @property {number} [cm730ErrorFlags] DarwinSensors cm730ErrorFlags.
                 * @property {message.platform.darwin.DarwinSensors.LEDPanel$Properties} [ledPanel] DarwinSensors ledPanel.
                 * @property {message.platform.darwin.DarwinSensors.HeadLED$Properties} [headLED] DarwinSensors headLED.
                 * @property {message.platform.darwin.DarwinSensors.EyeLED$Properties} [eyeLED] DarwinSensors eyeLED.
                 * @property {message.platform.darwin.DarwinSensors.Buttons$Properties} [buttons] DarwinSensors buttons.
                 * @property {number} [voltage] DarwinSensors voltage.
                 * @property {message.platform.darwin.DarwinSensors.Accelerometer$Properties} [accelerometer] DarwinSensors accelerometer.
                 * @property {message.platform.darwin.DarwinSensors.Gyroscope$Properties} [gyroscope] DarwinSensors gyroscope.
                 * @property {message.platform.darwin.DarwinSensors.FSRs$Properties} [fsr] DarwinSensors fsr.
                 * @property {message.platform.darwin.DarwinSensors.Servos$Properties} [servo] DarwinSensors servo.
                 */

                /**
                 * Constructs a new DarwinSensors.
                 * @classdesc TODO document
                 * 
                 * @author Trent Houliston
                 * @exports message.platform.darwin.DarwinSensors
                 * @constructor
                 * @param {message.platform.darwin.DarwinSensors$Properties=} [properties] Properties to set
                 */
                function DarwinSensors(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DarwinSensors timestamp.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                DarwinSensors.prototype.timestamp = null;

                /**
                 * DarwinSensors cm730ErrorFlags.
                 * @type {number}
                 */
                DarwinSensors.prototype.cm730ErrorFlags = 0;

                /**
                 * DarwinSensors ledPanel.
                 * @type {(message.platform.darwin.DarwinSensors.LEDPanel$Properties|null)}
                 */
                DarwinSensors.prototype.ledPanel = null;

                /**
                 * DarwinSensors headLED.
                 * @type {(message.platform.darwin.DarwinSensors.HeadLED$Properties|null)}
                 */
                DarwinSensors.prototype.headLED = null;

                /**
                 * DarwinSensors eyeLED.
                 * @type {(message.platform.darwin.DarwinSensors.EyeLED$Properties|null)}
                 */
                DarwinSensors.prototype.eyeLED = null;

                /**
                 * DarwinSensors buttons.
                 * @type {(message.platform.darwin.DarwinSensors.Buttons$Properties|null)}
                 */
                DarwinSensors.prototype.buttons = null;

                /**
                 * DarwinSensors voltage.
                 * @type {number}
                 */
                DarwinSensors.prototype.voltage = 0;

                /**
                 * DarwinSensors accelerometer.
                 * @type {(message.platform.darwin.DarwinSensors.Accelerometer$Properties|null)}
                 */
                DarwinSensors.prototype.accelerometer = null;

                /**
                 * DarwinSensors gyroscope.
                 * @type {(message.platform.darwin.DarwinSensors.Gyroscope$Properties|null)}
                 */
                DarwinSensors.prototype.gyroscope = null;

                /**
                 * DarwinSensors fsr.
                 * @type {(message.platform.darwin.DarwinSensors.FSRs$Properties|null)}
                 */
                DarwinSensors.prototype.fsr = null;

                /**
                 * DarwinSensors servo.
                 * @type {(message.platform.darwin.DarwinSensors.Servos$Properties|null)}
                 */
                DarwinSensors.prototype.servo = null;

                /**
                 * Creates a new DarwinSensors instance using the specified properties.
                 * @param {message.platform.darwin.DarwinSensors$Properties=} [properties] Properties to set
                 * @returns {message.platform.darwin.DarwinSensors} DarwinSensors instance
                 */
                DarwinSensors.create = function create(properties) {
                    return new DarwinSensors(properties);
                };

                /**
                 * Encodes the specified DarwinSensors message. Does not implicitly {@link message.platform.darwin.DarwinSensors.verify|verify} messages.
                 * @param {message.platform.darwin.DarwinSensors$Properties} message DarwinSensors message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DarwinSensors.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.cm730ErrorFlags != null && message.hasOwnProperty("cm730ErrorFlags"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cm730ErrorFlags);
                    if (message.ledPanel != null && message.hasOwnProperty("ledPanel"))
                        $root.message.platform.darwin.DarwinSensors.LEDPanel.encode(message.ledPanel, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.headLED != null && message.hasOwnProperty("headLED"))
                        $root.message.platform.darwin.DarwinSensors.HeadLED.encode(message.headLED, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.eyeLED != null && message.hasOwnProperty("eyeLED"))
                        $root.message.platform.darwin.DarwinSensors.EyeLED.encode(message.eyeLED, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.buttons != null && message.hasOwnProperty("buttons"))
                        $root.message.platform.darwin.DarwinSensors.Buttons.encode(message.buttons, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.voltage != null && message.hasOwnProperty("voltage"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.voltage);
                    if (message.accelerometer != null && message.hasOwnProperty("accelerometer"))
                        $root.message.platform.darwin.DarwinSensors.Accelerometer.encode(message.accelerometer, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.gyroscope != null && message.hasOwnProperty("gyroscope"))
                        $root.message.platform.darwin.DarwinSensors.Gyroscope.encode(message.gyroscope, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.fsr != null && message.hasOwnProperty("fsr"))
                        $root.message.platform.darwin.DarwinSensors.FSRs.encode(message.fsr, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.servo != null && message.hasOwnProperty("servo"))
                        $root.message.platform.darwin.DarwinSensors.Servos.encode(message.servo, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified DarwinSensors message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.verify|verify} messages.
                 * @param {message.platform.darwin.DarwinSensors$Properties} message DarwinSensors message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DarwinSensors.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DarwinSensors message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.darwin.DarwinSensors} DarwinSensors
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DarwinSensors.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.DarwinSensors();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.cm730ErrorFlags = reader.uint32();
                            break;
                        case 3:
                            message.ledPanel = $root.message.platform.darwin.DarwinSensors.LEDPanel.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.headLED = $root.message.platform.darwin.DarwinSensors.HeadLED.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.eyeLED = $root.message.platform.darwin.DarwinSensors.EyeLED.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.buttons = $root.message.platform.darwin.DarwinSensors.Buttons.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.voltage = reader.float();
                            break;
                        case 8:
                            message.accelerometer = $root.message.platform.darwin.DarwinSensors.Accelerometer.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.gyroscope = $root.message.platform.darwin.DarwinSensors.Gyroscope.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.fsr = $root.message.platform.darwin.DarwinSensors.FSRs.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.servo = $root.message.platform.darwin.DarwinSensors.Servos.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DarwinSensors message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.platform.darwin.DarwinSensors} DarwinSensors
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DarwinSensors.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DarwinSensors message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                DarwinSensors.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    if (message.cm730ErrorFlags != null && message.hasOwnProperty("cm730ErrorFlags"))
                        if (!$util.isInteger(message.cm730ErrorFlags))
                            return "cm730ErrorFlags: integer expected";
                    if (message.ledPanel != null && message.hasOwnProperty("ledPanel")) {
                        var error = $root.message.platform.darwin.DarwinSensors.LEDPanel.verify(message.ledPanel);
                        if (error)
                            return "ledPanel." + error;
                    }
                    if (message.headLED != null && message.hasOwnProperty("headLED")) {
                        var error = $root.message.platform.darwin.DarwinSensors.HeadLED.verify(message.headLED);
                        if (error)
                            return "headLED." + error;
                    }
                    if (message.eyeLED != null && message.hasOwnProperty("eyeLED")) {
                        var error = $root.message.platform.darwin.DarwinSensors.EyeLED.verify(message.eyeLED);
                        if (error)
                            return "eyeLED." + error;
                    }
                    if (message.buttons != null && message.hasOwnProperty("buttons")) {
                        var error = $root.message.platform.darwin.DarwinSensors.Buttons.verify(message.buttons);
                        if (error)
                            return "buttons." + error;
                    }
                    if (message.voltage != null && message.hasOwnProperty("voltage"))
                        if (typeof message.voltage !== "number")
                            return "voltage: number expected";
                    if (message.accelerometer != null && message.hasOwnProperty("accelerometer")) {
                        var error = $root.message.platform.darwin.DarwinSensors.Accelerometer.verify(message.accelerometer);
                        if (error)
                            return "accelerometer." + error;
                    }
                    if (message.gyroscope != null && message.hasOwnProperty("gyroscope")) {
                        var error = $root.message.platform.darwin.DarwinSensors.Gyroscope.verify(message.gyroscope);
                        if (error)
                            return "gyroscope." + error;
                    }
                    if (message.fsr != null && message.hasOwnProperty("fsr")) {
                        var error = $root.message.platform.darwin.DarwinSensors.FSRs.verify(message.fsr);
                        if (error)
                            return "fsr." + error;
                    }
                    if (message.servo != null && message.hasOwnProperty("servo")) {
                        var error = $root.message.platform.darwin.DarwinSensors.Servos.verify(message.servo);
                        if (error)
                            return "servo." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DarwinSensors message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.DarwinSensors} DarwinSensors
                 */
                DarwinSensors.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.platform.darwin.DarwinSensors)
                        return object;
                    var message = new $root.message.platform.darwin.DarwinSensors();
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".message.platform.darwin.DarwinSensors.timestamp: object expected");
                        message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                    }
                    if (object.cm730ErrorFlags != null)
                        message.cm730ErrorFlags = object.cm730ErrorFlags >>> 0;
                    if (object.ledPanel != null) {
                        if (typeof object.ledPanel !== "object")
                            throw TypeError(".message.platform.darwin.DarwinSensors.ledPanel: object expected");
                        message.ledPanel = $root.message.platform.darwin.DarwinSensors.LEDPanel.fromObject(object.ledPanel);
                    }
                    if (object.headLED != null) {
                        if (typeof object.headLED !== "object")
                            throw TypeError(".message.platform.darwin.DarwinSensors.headLED: object expected");
                        message.headLED = $root.message.platform.darwin.DarwinSensors.HeadLED.fromObject(object.headLED);
                    }
                    if (object.eyeLED != null) {
                        if (typeof object.eyeLED !== "object")
                            throw TypeError(".message.platform.darwin.DarwinSensors.eyeLED: object expected");
                        message.eyeLED = $root.message.platform.darwin.DarwinSensors.EyeLED.fromObject(object.eyeLED);
                    }
                    if (object.buttons != null) {
                        if (typeof object.buttons !== "object")
                            throw TypeError(".message.platform.darwin.DarwinSensors.buttons: object expected");
                        message.buttons = $root.message.platform.darwin.DarwinSensors.Buttons.fromObject(object.buttons);
                    }
                    if (object.voltage != null)
                        message.voltage = Number(object.voltage);
                    if (object.accelerometer != null) {
                        if (typeof object.accelerometer !== "object")
                            throw TypeError(".message.platform.darwin.DarwinSensors.accelerometer: object expected");
                        message.accelerometer = $root.message.platform.darwin.DarwinSensors.Accelerometer.fromObject(object.accelerometer);
                    }
                    if (object.gyroscope != null) {
                        if (typeof object.gyroscope !== "object")
                            throw TypeError(".message.platform.darwin.DarwinSensors.gyroscope: object expected");
                        message.gyroscope = $root.message.platform.darwin.DarwinSensors.Gyroscope.fromObject(object.gyroscope);
                    }
                    if (object.fsr != null) {
                        if (typeof object.fsr !== "object")
                            throw TypeError(".message.platform.darwin.DarwinSensors.fsr: object expected");
                        message.fsr = $root.message.platform.darwin.DarwinSensors.FSRs.fromObject(object.fsr);
                    }
                    if (object.servo != null) {
                        if (typeof object.servo !== "object")
                            throw TypeError(".message.platform.darwin.DarwinSensors.servo: object expected");
                        message.servo = $root.message.platform.darwin.DarwinSensors.Servos.fromObject(object.servo);
                    }
                    return message;
                };

                /**
                 * Creates a DarwinSensors message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.platform.darwin.DarwinSensors.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.DarwinSensors} DarwinSensors
                 */
                DarwinSensors.from = DarwinSensors.fromObject;

                /**
                 * Creates a plain object from a DarwinSensors message. Also converts values to other types if specified.
                 * @param {message.platform.darwin.DarwinSensors} message DarwinSensors
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DarwinSensors.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.timestamp = null;
                        object.cm730ErrorFlags = 0;
                        object.ledPanel = null;
                        object.headLED = null;
                        object.eyeLED = null;
                        object.buttons = null;
                        object.voltage = 0;
                        object.accelerometer = null;
                        object.gyroscope = null;
                        object.fsr = null;
                        object.servo = null;
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                    if (message.cm730ErrorFlags != null && message.hasOwnProperty("cm730ErrorFlags"))
                        object.cm730ErrorFlags = message.cm730ErrorFlags;
                    if (message.ledPanel != null && message.hasOwnProperty("ledPanel"))
                        object.ledPanel = $root.message.platform.darwin.DarwinSensors.LEDPanel.toObject(message.ledPanel, options);
                    if (message.headLED != null && message.hasOwnProperty("headLED"))
                        object.headLED = $root.message.platform.darwin.DarwinSensors.HeadLED.toObject(message.headLED, options);
                    if (message.eyeLED != null && message.hasOwnProperty("eyeLED"))
                        object.eyeLED = $root.message.platform.darwin.DarwinSensors.EyeLED.toObject(message.eyeLED, options);
                    if (message.buttons != null && message.hasOwnProperty("buttons"))
                        object.buttons = $root.message.platform.darwin.DarwinSensors.Buttons.toObject(message.buttons, options);
                    if (message.voltage != null && message.hasOwnProperty("voltage"))
                        object.voltage = message.voltage;
                    if (message.accelerometer != null && message.hasOwnProperty("accelerometer"))
                        object.accelerometer = $root.message.platform.darwin.DarwinSensors.Accelerometer.toObject(message.accelerometer, options);
                    if (message.gyroscope != null && message.hasOwnProperty("gyroscope"))
                        object.gyroscope = $root.message.platform.darwin.DarwinSensors.Gyroscope.toObject(message.gyroscope, options);
                    if (message.fsr != null && message.hasOwnProperty("fsr"))
                        object.fsr = $root.message.platform.darwin.DarwinSensors.FSRs.toObject(message.fsr, options);
                    if (message.servo != null && message.hasOwnProperty("servo"))
                        object.servo = $root.message.platform.darwin.DarwinSensors.Servos.toObject(message.servo, options);
                    return object;
                };

                /**
                 * Creates a plain object from this DarwinSensors message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DarwinSensors.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this DarwinSensors to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                DarwinSensors.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Error enum.
                 * @name Error
                 * @memberof message.platform.darwin.DarwinSensors
                 * @enum {number}
                 * @property {number} OK=0 OK value
                 * @property {number} INPUT_VOLTAGE=1 INPUT_VOLTAGE value
                 * @property {number} ANGLE_LIMIT=2 ANGLE_LIMIT value
                 * @property {number} OVERHEATING=4 OVERHEATING value
                 * @property {number} RANGE=8 RANGE value
                 * @property {number} CHECKSUM=16 CHECKSUM value
                 * @property {number} OVERLOAD=32 OVERLOAD value
                 * @property {number} INSTRUCTION=64 INSTRUCTION value
                 * @property {number} CORRUPT_DATA=128 CORRUPT_DATA value
                 * @property {number} TIMEOUT=256 TIMEOUT value
                 * @property {number} TIMEOUT_VICTIM=512 TIMEOUT_VICTIM value
                 */
                DarwinSensors.Error = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "OK"] = 0;
                    values[valuesById[1] = "INPUT_VOLTAGE"] = 1;
                    values[valuesById[2] = "ANGLE_LIMIT"] = 2;
                    values[valuesById[4] = "OVERHEATING"] = 4;
                    values[valuesById[8] = "RANGE"] = 8;
                    values[valuesById[16] = "CHECKSUM"] = 16;
                    values[valuesById[32] = "OVERLOAD"] = 32;
                    values[valuesById[64] = "INSTRUCTION"] = 64;
                    values[valuesById[128] = "CORRUPT_DATA"] = 128;
                    values[valuesById[256] = "TIMEOUT"] = 256;
                    values[valuesById[512] = "TIMEOUT_VICTIM"] = 512;
                    return values;
                })();

                DarwinSensors.LEDPanel = (function() {

                    /**
                     * Properties of a LEDPanel.
                     * @typedef message.platform.darwin.DarwinSensors.LEDPanel$Properties
                     * @type {Object}
                     * @property {boolean} [led2] LEDPanel led2.
                     * @property {boolean} [led3] LEDPanel led3.
                     * @property {boolean} [led4] LEDPanel led4.
                     */

                    /**
                     * Constructs a new LEDPanel.
                     * @exports message.platform.darwin.DarwinSensors.LEDPanel
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.LEDPanel$Properties=} [properties] Properties to set
                     */
                    function LEDPanel(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * LEDPanel led2.
                     * @type {boolean}
                     */
                    LEDPanel.prototype.led2 = false;

                    /**
                     * LEDPanel led3.
                     * @type {boolean}
                     */
                    LEDPanel.prototype.led3 = false;

                    /**
                     * LEDPanel led4.
                     * @type {boolean}
                     */
                    LEDPanel.prototype.led4 = false;

                    /**
                     * Creates a new LEDPanel instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.LEDPanel$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.LEDPanel} LEDPanel instance
                     */
                    LEDPanel.create = function create(properties) {
                        return new LEDPanel(properties);
                    };

                    /**
                     * Encodes the specified LEDPanel message. Does not implicitly {@link message.platform.darwin.DarwinSensors.LEDPanel.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.LEDPanel$Properties} message LEDPanel message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LEDPanel.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.led2 != null && message.hasOwnProperty("led2"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.led2);
                        if (message.led3 != null && message.hasOwnProperty("led3"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.led3);
                        if (message.led4 != null && message.hasOwnProperty("led4"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.led4);
                        return writer;
                    };

                    /**
                     * Encodes the specified LEDPanel message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.LEDPanel.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.LEDPanel$Properties} message LEDPanel message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    LEDPanel.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a LEDPanel message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.LEDPanel} LEDPanel
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LEDPanel.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.DarwinSensors.LEDPanel();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.led2 = reader.bool();
                                break;
                            case 2:
                                message.led3 = reader.bool();
                                break;
                            case 3:
                                message.led4 = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a LEDPanel message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.LEDPanel} LEDPanel
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    LEDPanel.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a LEDPanel message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    LEDPanel.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.led2 != null && message.hasOwnProperty("led2"))
                            if (typeof message.led2 !== "boolean")
                                return "led2: boolean expected";
                        if (message.led3 != null && message.hasOwnProperty("led3"))
                            if (typeof message.led3 !== "boolean")
                                return "led3: boolean expected";
                        if (message.led4 != null && message.hasOwnProperty("led4"))
                            if (typeof message.led4 !== "boolean")
                                return "led4: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a LEDPanel message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.LEDPanel} LEDPanel
                     */
                    LEDPanel.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.platform.darwin.DarwinSensors.LEDPanel)
                            return object;
                        var message = new $root.message.platform.darwin.DarwinSensors.LEDPanel();
                        if (object.led2 != null)
                            message.led2 = Boolean(object.led2);
                        if (object.led3 != null)
                            message.led3 = Boolean(object.led3);
                        if (object.led4 != null)
                            message.led4 = Boolean(object.led4);
                        return message;
                    };

                    /**
                     * Creates a LEDPanel message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.LEDPanel.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.LEDPanel} LEDPanel
                     */
                    LEDPanel.from = LEDPanel.fromObject;

                    /**
                     * Creates a plain object from a LEDPanel message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.LEDPanel} message LEDPanel
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    LEDPanel.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.led2 = false;
                            object.led3 = false;
                            object.led4 = false;
                        }
                        if (message.led2 != null && message.hasOwnProperty("led2"))
                            object.led2 = message.led2;
                        if (message.led3 != null && message.hasOwnProperty("led3"))
                            object.led3 = message.led3;
                        if (message.led4 != null && message.hasOwnProperty("led4"))
                            object.led4 = message.led4;
                        return object;
                    };

                    /**
                     * Creates a plain object from this LEDPanel message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    LEDPanel.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this LEDPanel to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    LEDPanel.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return LEDPanel;
                })();

                DarwinSensors.HeadLED = (function() {

                    /**
                     * Properties of a HeadLED.
                     * @typedef message.platform.darwin.DarwinSensors.HeadLED$Properties
                     * @type {Object}
                     * @property {number} [RGB] HeadLED RGB.
                     */

                    /**
                     * Constructs a new HeadLED.
                     * @exports message.platform.darwin.DarwinSensors.HeadLED
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.HeadLED$Properties=} [properties] Properties to set
                     */
                    function HeadLED(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * HeadLED RGB.
                     * @type {number}
                     */
                    HeadLED.prototype.RGB = 0;

                    /**
                     * Creates a new HeadLED instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.HeadLED$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.HeadLED} HeadLED instance
                     */
                    HeadLED.create = function create(properties) {
                        return new HeadLED(properties);
                    };

                    /**
                     * Encodes the specified HeadLED message. Does not implicitly {@link message.platform.darwin.DarwinSensors.HeadLED.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.HeadLED$Properties} message HeadLED message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    HeadLED.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.RGB != null && message.hasOwnProperty("RGB"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.RGB);
                        return writer;
                    };

                    /**
                     * Encodes the specified HeadLED message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.HeadLED.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.HeadLED$Properties} message HeadLED message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    HeadLED.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a HeadLED message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.HeadLED} HeadLED
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    HeadLED.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.DarwinSensors.HeadLED();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.RGB = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a HeadLED message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.HeadLED} HeadLED
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    HeadLED.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a HeadLED message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    HeadLED.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.RGB != null && message.hasOwnProperty("RGB"))
                            if (!$util.isInteger(message.RGB))
                                return "RGB: integer expected";
                        return null;
                    };

                    /**
                     * Creates a HeadLED message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.HeadLED} HeadLED
                     */
                    HeadLED.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.platform.darwin.DarwinSensors.HeadLED)
                            return object;
                        var message = new $root.message.platform.darwin.DarwinSensors.HeadLED();
                        if (object.RGB != null)
                            message.RGB = object.RGB >>> 0;
                        return message;
                    };

                    /**
                     * Creates a HeadLED message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.HeadLED.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.HeadLED} HeadLED
                     */
                    HeadLED.from = HeadLED.fromObject;

                    /**
                     * Creates a plain object from a HeadLED message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.HeadLED} message HeadLED
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    HeadLED.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.RGB = 0;
                        if (message.RGB != null && message.hasOwnProperty("RGB"))
                            object.RGB = message.RGB;
                        return object;
                    };

                    /**
                     * Creates a plain object from this HeadLED message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    HeadLED.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this HeadLED to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    HeadLED.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return HeadLED;
                })();

                DarwinSensors.EyeLED = (function() {

                    /**
                     * Properties of an EyeLED.
                     * @typedef message.platform.darwin.DarwinSensors.EyeLED$Properties
                     * @type {Object}
                     * @property {number} [RGB] EyeLED RGB.
                     */

                    /**
                     * Constructs a new EyeLED.
                     * @exports message.platform.darwin.DarwinSensors.EyeLED
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.EyeLED$Properties=} [properties] Properties to set
                     */
                    function EyeLED(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * EyeLED RGB.
                     * @type {number}
                     */
                    EyeLED.prototype.RGB = 0;

                    /**
                     * Creates a new EyeLED instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.EyeLED$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.EyeLED} EyeLED instance
                     */
                    EyeLED.create = function create(properties) {
                        return new EyeLED(properties);
                    };

                    /**
                     * Encodes the specified EyeLED message. Does not implicitly {@link message.platform.darwin.DarwinSensors.EyeLED.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.EyeLED$Properties} message EyeLED message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EyeLED.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.RGB != null && message.hasOwnProperty("RGB"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.RGB);
                        return writer;
                    };

                    /**
                     * Encodes the specified EyeLED message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.EyeLED.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.EyeLED$Properties} message EyeLED message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EyeLED.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an EyeLED message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.EyeLED} EyeLED
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EyeLED.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.DarwinSensors.EyeLED();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.RGB = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an EyeLED message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.EyeLED} EyeLED
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EyeLED.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an EyeLED message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    EyeLED.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.RGB != null && message.hasOwnProperty("RGB"))
                            if (!$util.isInteger(message.RGB))
                                return "RGB: integer expected";
                        return null;
                    };

                    /**
                     * Creates an EyeLED message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.EyeLED} EyeLED
                     */
                    EyeLED.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.platform.darwin.DarwinSensors.EyeLED)
                            return object;
                        var message = new $root.message.platform.darwin.DarwinSensors.EyeLED();
                        if (object.RGB != null)
                            message.RGB = object.RGB >>> 0;
                        return message;
                    };

                    /**
                     * Creates an EyeLED message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.EyeLED.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.EyeLED} EyeLED
                     */
                    EyeLED.from = EyeLED.fromObject;

                    /**
                     * Creates a plain object from an EyeLED message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.EyeLED} message EyeLED
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    EyeLED.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.RGB = 0;
                        if (message.RGB != null && message.hasOwnProperty("RGB"))
                            object.RGB = message.RGB;
                        return object;
                    };

                    /**
                     * Creates a plain object from this EyeLED message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    EyeLED.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this EyeLED to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    EyeLED.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return EyeLED;
                })();

                DarwinSensors.Buttons = (function() {

                    /**
                     * Properties of a Buttons.
                     * @typedef message.platform.darwin.DarwinSensors.Buttons$Properties
                     * @type {Object}
                     * @property {boolean} [left] Buttons left.
                     * @property {boolean} [middle] Buttons middle.
                     */

                    /**
                     * Constructs a new Buttons.
                     * @exports message.platform.darwin.DarwinSensors.Buttons
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.Buttons$Properties=} [properties] Properties to set
                     */
                    function Buttons(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Buttons left.
                     * @type {boolean}
                     */
                    Buttons.prototype.left = false;

                    /**
                     * Buttons middle.
                     * @type {boolean}
                     */
                    Buttons.prototype.middle = false;

                    /**
                     * Creates a new Buttons instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.Buttons$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.Buttons} Buttons instance
                     */
                    Buttons.create = function create(properties) {
                        return new Buttons(properties);
                    };

                    /**
                     * Encodes the specified Buttons message. Does not implicitly {@link message.platform.darwin.DarwinSensors.Buttons.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Buttons$Properties} message Buttons message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Buttons.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.left != null && message.hasOwnProperty("left"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.left);
                        if (message.middle != null && message.hasOwnProperty("middle"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.middle);
                        return writer;
                    };

                    /**
                     * Encodes the specified Buttons message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.Buttons.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Buttons$Properties} message Buttons message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Buttons.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Buttons message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.Buttons} Buttons
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Buttons.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.DarwinSensors.Buttons();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.left = reader.bool();
                                break;
                            case 2:
                                message.middle = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Buttons message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.Buttons} Buttons
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Buttons.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Buttons message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Buttons.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.left != null && message.hasOwnProperty("left"))
                            if (typeof message.left !== "boolean")
                                return "left: boolean expected";
                        if (message.middle != null && message.hasOwnProperty("middle"))
                            if (typeof message.middle !== "boolean")
                                return "middle: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a Buttons message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Buttons} Buttons
                     */
                    Buttons.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.platform.darwin.DarwinSensors.Buttons)
                            return object;
                        var message = new $root.message.platform.darwin.DarwinSensors.Buttons();
                        if (object.left != null)
                            message.left = Boolean(object.left);
                        if (object.middle != null)
                            message.middle = Boolean(object.middle);
                        return message;
                    };

                    /**
                     * Creates a Buttons message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.Buttons.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Buttons} Buttons
                     */
                    Buttons.from = Buttons.fromObject;

                    /**
                     * Creates a plain object from a Buttons message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.Buttons} message Buttons
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Buttons.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.left = false;
                            object.middle = false;
                        }
                        if (message.left != null && message.hasOwnProperty("left"))
                            object.left = message.left;
                        if (message.middle != null && message.hasOwnProperty("middle"))
                            object.middle = message.middle;
                        return object;
                    };

                    /**
                     * Creates a plain object from this Buttons message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Buttons.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Buttons to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Buttons.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Buttons;
                })();

                DarwinSensors.Accelerometer = (function() {

                    /**
                     * Properties of an Accelerometer.
                     * @typedef message.platform.darwin.DarwinSensors.Accelerometer$Properties
                     * @type {Object}
                     * @property {number} [x] Accelerometer x.
                     * @property {number} [y] Accelerometer y.
                     * @property {number} [z] Accelerometer z.
                     */

                    /**
                     * Constructs a new Accelerometer.
                     * @exports message.platform.darwin.DarwinSensors.Accelerometer
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.Accelerometer$Properties=} [properties] Properties to set
                     */
                    function Accelerometer(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Accelerometer x.
                     * @type {number}
                     */
                    Accelerometer.prototype.x = 0;

                    /**
                     * Accelerometer y.
                     * @type {number}
                     */
                    Accelerometer.prototype.y = 0;

                    /**
                     * Accelerometer z.
                     * @type {number}
                     */
                    Accelerometer.prototype.z = 0;

                    /**
                     * Creates a new Accelerometer instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.Accelerometer$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.Accelerometer} Accelerometer instance
                     */
                    Accelerometer.create = function create(properties) {
                        return new Accelerometer(properties);
                    };

                    /**
                     * Encodes the specified Accelerometer message. Does not implicitly {@link message.platform.darwin.DarwinSensors.Accelerometer.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Accelerometer$Properties} message Accelerometer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Accelerometer.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.x != null && message.hasOwnProperty("x"))
                            writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
                        if (message.y != null && message.hasOwnProperty("y"))
                            writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
                        if (message.z != null && message.hasOwnProperty("z"))
                            writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
                        return writer;
                    };

                    /**
                     * Encodes the specified Accelerometer message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.Accelerometer.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Accelerometer$Properties} message Accelerometer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Accelerometer.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Accelerometer message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.Accelerometer} Accelerometer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Accelerometer.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.DarwinSensors.Accelerometer();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.x = reader.float();
                                break;
                            case 2:
                                message.y = reader.float();
                                break;
                            case 3:
                                message.z = reader.float();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Accelerometer message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.Accelerometer} Accelerometer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Accelerometer.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Accelerometer message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Accelerometer.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.x != null && message.hasOwnProperty("x"))
                            if (typeof message.x !== "number")
                                return "x: number expected";
                        if (message.y != null && message.hasOwnProperty("y"))
                            if (typeof message.y !== "number")
                                return "y: number expected";
                        if (message.z != null && message.hasOwnProperty("z"))
                            if (typeof message.z !== "number")
                                return "z: number expected";
                        return null;
                    };

                    /**
                     * Creates an Accelerometer message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Accelerometer} Accelerometer
                     */
                    Accelerometer.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.platform.darwin.DarwinSensors.Accelerometer)
                            return object;
                        var message = new $root.message.platform.darwin.DarwinSensors.Accelerometer();
                        if (object.x != null)
                            message.x = Number(object.x);
                        if (object.y != null)
                            message.y = Number(object.y);
                        if (object.z != null)
                            message.z = Number(object.z);
                        return message;
                    };

                    /**
                     * Creates an Accelerometer message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.Accelerometer.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Accelerometer} Accelerometer
                     */
                    Accelerometer.from = Accelerometer.fromObject;

                    /**
                     * Creates a plain object from an Accelerometer message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.Accelerometer} message Accelerometer
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Accelerometer.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.x = 0;
                            object.y = 0;
                            object.z = 0;
                        }
                        if (message.x != null && message.hasOwnProperty("x"))
                            object.x = message.x;
                        if (message.y != null && message.hasOwnProperty("y"))
                            object.y = message.y;
                        if (message.z != null && message.hasOwnProperty("z"))
                            object.z = message.z;
                        return object;
                    };

                    /**
                     * Creates a plain object from this Accelerometer message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Accelerometer.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Accelerometer to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Accelerometer.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Accelerometer;
                })();

                DarwinSensors.Gyroscope = (function() {

                    /**
                     * Properties of a Gyroscope.
                     * @typedef message.platform.darwin.DarwinSensors.Gyroscope$Properties
                     * @type {Object}
                     * @property {number} [x] Gyroscope x.
                     * @property {number} [y] Gyroscope y.
                     * @property {number} [z] Gyroscope z.
                     */

                    /**
                     * Constructs a new Gyroscope.
                     * @exports message.platform.darwin.DarwinSensors.Gyroscope
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.Gyroscope$Properties=} [properties] Properties to set
                     */
                    function Gyroscope(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Gyroscope x.
                     * @type {number}
                     */
                    Gyroscope.prototype.x = 0;

                    /**
                     * Gyroscope y.
                     * @type {number}
                     */
                    Gyroscope.prototype.y = 0;

                    /**
                     * Gyroscope z.
                     * @type {number}
                     */
                    Gyroscope.prototype.z = 0;

                    /**
                     * Creates a new Gyroscope instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.Gyroscope$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.Gyroscope} Gyroscope instance
                     */
                    Gyroscope.create = function create(properties) {
                        return new Gyroscope(properties);
                    };

                    /**
                     * Encodes the specified Gyroscope message. Does not implicitly {@link message.platform.darwin.DarwinSensors.Gyroscope.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Gyroscope$Properties} message Gyroscope message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Gyroscope.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.x != null && message.hasOwnProperty("x"))
                            writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
                        if (message.y != null && message.hasOwnProperty("y"))
                            writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
                        if (message.z != null && message.hasOwnProperty("z"))
                            writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
                        return writer;
                    };

                    /**
                     * Encodes the specified Gyroscope message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.Gyroscope.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Gyroscope$Properties} message Gyroscope message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Gyroscope.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Gyroscope message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.Gyroscope} Gyroscope
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Gyroscope.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.DarwinSensors.Gyroscope();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.x = reader.float();
                                break;
                            case 2:
                                message.y = reader.float();
                                break;
                            case 3:
                                message.z = reader.float();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Gyroscope message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.Gyroscope} Gyroscope
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Gyroscope.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Gyroscope message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Gyroscope.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.x != null && message.hasOwnProperty("x"))
                            if (typeof message.x !== "number")
                                return "x: number expected";
                        if (message.y != null && message.hasOwnProperty("y"))
                            if (typeof message.y !== "number")
                                return "y: number expected";
                        if (message.z != null && message.hasOwnProperty("z"))
                            if (typeof message.z !== "number")
                                return "z: number expected";
                        return null;
                    };

                    /**
                     * Creates a Gyroscope message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Gyroscope} Gyroscope
                     */
                    Gyroscope.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.platform.darwin.DarwinSensors.Gyroscope)
                            return object;
                        var message = new $root.message.platform.darwin.DarwinSensors.Gyroscope();
                        if (object.x != null)
                            message.x = Number(object.x);
                        if (object.y != null)
                            message.y = Number(object.y);
                        if (object.z != null)
                            message.z = Number(object.z);
                        return message;
                    };

                    /**
                     * Creates a Gyroscope message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.Gyroscope.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Gyroscope} Gyroscope
                     */
                    Gyroscope.from = Gyroscope.fromObject;

                    /**
                     * Creates a plain object from a Gyroscope message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.Gyroscope} message Gyroscope
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Gyroscope.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.x = 0;
                            object.y = 0;
                            object.z = 0;
                        }
                        if (message.x != null && message.hasOwnProperty("x"))
                            object.x = message.x;
                        if (message.y != null && message.hasOwnProperty("y"))
                            object.y = message.y;
                        if (message.z != null && message.hasOwnProperty("z"))
                            object.z = message.z;
                        return object;
                    };

                    /**
                     * Creates a plain object from this Gyroscope message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Gyroscope.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Gyroscope to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Gyroscope.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Gyroscope;
                })();

                DarwinSensors.FSR = (function() {

                    /**
                     * Properties of a FSR.
                     * @typedef message.platform.darwin.DarwinSensors.FSR$Properties
                     * @type {Object}
                     * @property {number} [fsr1] FSR fsr1.
                     * @property {number} [fsr2] FSR fsr2.
                     * @property {number} [fsr3] FSR fsr3.
                     * @property {number} [fsr4] FSR fsr4.
                     * @property {number} [centreX] FSR centreX.
                     * @property {number} [centreY] FSR centreY.
                     * @property {number} [errorFlags] FSR errorFlags.
                     */

                    /**
                     * Constructs a new FSR.
                     * @exports message.platform.darwin.DarwinSensors.FSR
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.FSR$Properties=} [properties] Properties to set
                     */
                    function FSR(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * FSR fsr1.
                     * @type {number}
                     */
                    FSR.prototype.fsr1 = 0;

                    /**
                     * FSR fsr2.
                     * @type {number}
                     */
                    FSR.prototype.fsr2 = 0;

                    /**
                     * FSR fsr3.
                     * @type {number}
                     */
                    FSR.prototype.fsr3 = 0;

                    /**
                     * FSR fsr4.
                     * @type {number}
                     */
                    FSR.prototype.fsr4 = 0;

                    /**
                     * FSR centreX.
                     * @type {number}
                     */
                    FSR.prototype.centreX = 0;

                    /**
                     * FSR centreY.
                     * @type {number}
                     */
                    FSR.prototype.centreY = 0;

                    /**
                     * FSR errorFlags.
                     * @type {number}
                     */
                    FSR.prototype.errorFlags = 0;

                    /**
                     * Creates a new FSR instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.FSR$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.FSR} FSR instance
                     */
                    FSR.create = function create(properties) {
                        return new FSR(properties);
                    };

                    /**
                     * Encodes the specified FSR message. Does not implicitly {@link message.platform.darwin.DarwinSensors.FSR.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.FSR$Properties} message FSR message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    FSR.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fsr1 != null && message.hasOwnProperty("fsr1"))
                            writer.uint32(/* id 1, wireType 5 =*/13).float(message.fsr1);
                        if (message.fsr2 != null && message.hasOwnProperty("fsr2"))
                            writer.uint32(/* id 2, wireType 5 =*/21).float(message.fsr2);
                        if (message.fsr3 != null && message.hasOwnProperty("fsr3"))
                            writer.uint32(/* id 3, wireType 5 =*/29).float(message.fsr3);
                        if (message.fsr4 != null && message.hasOwnProperty("fsr4"))
                            writer.uint32(/* id 4, wireType 5 =*/37).float(message.fsr4);
                        if (message.centreX != null && message.hasOwnProperty("centreX"))
                            writer.uint32(/* id 5, wireType 5 =*/45).float(message.centreX);
                        if (message.centreY != null && message.hasOwnProperty("centreY"))
                            writer.uint32(/* id 6, wireType 5 =*/53).float(message.centreY);
                        if (message.errorFlags != null && message.hasOwnProperty("errorFlags"))
                            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.errorFlags);
                        return writer;
                    };

                    /**
                     * Encodes the specified FSR message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.FSR.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.FSR$Properties} message FSR message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    FSR.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a FSR message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.FSR} FSR
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    FSR.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.DarwinSensors.FSR();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fsr1 = reader.float();
                                break;
                            case 2:
                                message.fsr2 = reader.float();
                                break;
                            case 3:
                                message.fsr3 = reader.float();
                                break;
                            case 4:
                                message.fsr4 = reader.float();
                                break;
                            case 5:
                                message.centreX = reader.float();
                                break;
                            case 6:
                                message.centreY = reader.float();
                                break;
                            case 7:
                                message.errorFlags = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a FSR message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.FSR} FSR
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    FSR.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a FSR message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    FSR.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fsr1 != null && message.hasOwnProperty("fsr1"))
                            if (typeof message.fsr1 !== "number")
                                return "fsr1: number expected";
                        if (message.fsr2 != null && message.hasOwnProperty("fsr2"))
                            if (typeof message.fsr2 !== "number")
                                return "fsr2: number expected";
                        if (message.fsr3 != null && message.hasOwnProperty("fsr3"))
                            if (typeof message.fsr3 !== "number")
                                return "fsr3: number expected";
                        if (message.fsr4 != null && message.hasOwnProperty("fsr4"))
                            if (typeof message.fsr4 !== "number")
                                return "fsr4: number expected";
                        if (message.centreX != null && message.hasOwnProperty("centreX"))
                            if (typeof message.centreX !== "number")
                                return "centreX: number expected";
                        if (message.centreY != null && message.hasOwnProperty("centreY"))
                            if (typeof message.centreY !== "number")
                                return "centreY: number expected";
                        if (message.errorFlags != null && message.hasOwnProperty("errorFlags"))
                            if (!$util.isInteger(message.errorFlags))
                                return "errorFlags: integer expected";
                        return null;
                    };

                    /**
                     * Creates a FSR message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.FSR} FSR
                     */
                    FSR.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.platform.darwin.DarwinSensors.FSR)
                            return object;
                        var message = new $root.message.platform.darwin.DarwinSensors.FSR();
                        if (object.fsr1 != null)
                            message.fsr1 = Number(object.fsr1);
                        if (object.fsr2 != null)
                            message.fsr2 = Number(object.fsr2);
                        if (object.fsr3 != null)
                            message.fsr3 = Number(object.fsr3);
                        if (object.fsr4 != null)
                            message.fsr4 = Number(object.fsr4);
                        if (object.centreX != null)
                            message.centreX = Number(object.centreX);
                        if (object.centreY != null)
                            message.centreY = Number(object.centreY);
                        if (object.errorFlags != null)
                            message.errorFlags = object.errorFlags >>> 0;
                        return message;
                    };

                    /**
                     * Creates a FSR message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.FSR.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.FSR} FSR
                     */
                    FSR.from = FSR.fromObject;

                    /**
                     * Creates a plain object from a FSR message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.FSR} message FSR
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FSR.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fsr1 = 0;
                            object.fsr2 = 0;
                            object.fsr3 = 0;
                            object.fsr4 = 0;
                            object.centreX = 0;
                            object.centreY = 0;
                            object.errorFlags = 0;
                        }
                        if (message.fsr1 != null && message.hasOwnProperty("fsr1"))
                            object.fsr1 = message.fsr1;
                        if (message.fsr2 != null && message.hasOwnProperty("fsr2"))
                            object.fsr2 = message.fsr2;
                        if (message.fsr3 != null && message.hasOwnProperty("fsr3"))
                            object.fsr3 = message.fsr3;
                        if (message.fsr4 != null && message.hasOwnProperty("fsr4"))
                            object.fsr4 = message.fsr4;
                        if (message.centreX != null && message.hasOwnProperty("centreX"))
                            object.centreX = message.centreX;
                        if (message.centreY != null && message.hasOwnProperty("centreY"))
                            object.centreY = message.centreY;
                        if (message.errorFlags != null && message.hasOwnProperty("errorFlags"))
                            object.errorFlags = message.errorFlags;
                        return object;
                    };

                    /**
                     * Creates a plain object from this FSR message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FSR.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this FSR to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    FSR.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return FSR;
                })();

                DarwinSensors.FSRs = (function() {

                    /**
                     * Properties of a FSRs.
                     * @typedef message.platform.darwin.DarwinSensors.FSRs$Properties
                     * @type {Object}
                     * @property {message.platform.darwin.DarwinSensors.FSR$Properties} [left] FSRs left.
                     * @property {message.platform.darwin.DarwinSensors.FSR$Properties} [right] FSRs right.
                     */

                    /**
                     * Constructs a new FSRs.
                     * @exports message.platform.darwin.DarwinSensors.FSRs
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.FSRs$Properties=} [properties] Properties to set
                     */
                    function FSRs(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * FSRs left.
                     * @type {(message.platform.darwin.DarwinSensors.FSR$Properties|null)}
                     */
                    FSRs.prototype.left = null;

                    /**
                     * FSRs right.
                     * @type {(message.platform.darwin.DarwinSensors.FSR$Properties|null)}
                     */
                    FSRs.prototype.right = null;

                    /**
                     * Creates a new FSRs instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.FSRs$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.FSRs} FSRs instance
                     */
                    FSRs.create = function create(properties) {
                        return new FSRs(properties);
                    };

                    /**
                     * Encodes the specified FSRs message. Does not implicitly {@link message.platform.darwin.DarwinSensors.FSRs.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.FSRs$Properties} message FSRs message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    FSRs.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.left != null && message.hasOwnProperty("left"))
                            $root.message.platform.darwin.DarwinSensors.FSR.encode(message.left, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.right != null && message.hasOwnProperty("right"))
                            $root.message.platform.darwin.DarwinSensors.FSR.encode(message.right, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified FSRs message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.FSRs.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.FSRs$Properties} message FSRs message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    FSRs.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a FSRs message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.FSRs} FSRs
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    FSRs.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.DarwinSensors.FSRs();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.left = $root.message.platform.darwin.DarwinSensors.FSR.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.right = $root.message.platform.darwin.DarwinSensors.FSR.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a FSRs message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.FSRs} FSRs
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    FSRs.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a FSRs message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    FSRs.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.left != null && message.hasOwnProperty("left")) {
                            var error = $root.message.platform.darwin.DarwinSensors.FSR.verify(message.left);
                            if (error)
                                return "left." + error;
                        }
                        if (message.right != null && message.hasOwnProperty("right")) {
                            var error = $root.message.platform.darwin.DarwinSensors.FSR.verify(message.right);
                            if (error)
                                return "right." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a FSRs message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.FSRs} FSRs
                     */
                    FSRs.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.platform.darwin.DarwinSensors.FSRs)
                            return object;
                        var message = new $root.message.platform.darwin.DarwinSensors.FSRs();
                        if (object.left != null) {
                            if (typeof object.left !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.FSRs.left: object expected");
                            message.left = $root.message.platform.darwin.DarwinSensors.FSR.fromObject(object.left);
                        }
                        if (object.right != null) {
                            if (typeof object.right !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.FSRs.right: object expected");
                            message.right = $root.message.platform.darwin.DarwinSensors.FSR.fromObject(object.right);
                        }
                        return message;
                    };

                    /**
                     * Creates a FSRs message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.FSRs.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.FSRs} FSRs
                     */
                    FSRs.from = FSRs.fromObject;

                    /**
                     * Creates a plain object from a FSRs message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.FSRs} message FSRs
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FSRs.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.left = null;
                            object.right = null;
                        }
                        if (message.left != null && message.hasOwnProperty("left"))
                            object.left = $root.message.platform.darwin.DarwinSensors.FSR.toObject(message.left, options);
                        if (message.right != null && message.hasOwnProperty("right"))
                            object.right = $root.message.platform.darwin.DarwinSensors.FSR.toObject(message.right, options);
                        return object;
                    };

                    /**
                     * Creates a plain object from this FSRs message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FSRs.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this FSRs to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    FSRs.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return FSRs;
                })();

                DarwinSensors.Servo = (function() {

                    /**
                     * Properties of a Servo.
                     * @typedef message.platform.darwin.DarwinSensors.Servo$Properties
                     * @type {Object}
                     * @property {number} [errorFlags] Servo errorFlags.
                     * @property {boolean} [torqueEnabled] Servo torqueEnabled.
                     * @property {number} [pGain] Servo pGain.
                     * @property {number} [iGain] Servo iGain.
                     * @property {number} [dGain] Servo dGain.
                     * @property {number} [goalPosition] Servo goalPosition.
                     * @property {number} [movingSpeed] Servo movingSpeed.
                     * @property {number} [torque] Servo torque.
                     * @property {number} [presentPosition] Servo presentPosition.
                     * @property {number} [presentSpeed] Servo presentSpeed.
                     * @property {number} [load] Servo load.
                     * @property {number} [voltage] Servo voltage.
                     * @property {number} [temperature] Servo temperature.
                     */

                    /**
                     * Constructs a new Servo.
                     * @exports message.platform.darwin.DarwinSensors.Servo
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.Servo$Properties=} [properties] Properties to set
                     */
                    function Servo(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Servo errorFlags.
                     * @type {number}
                     */
                    Servo.prototype.errorFlags = 0;

                    /**
                     * Servo torqueEnabled.
                     * @type {boolean}
                     */
                    Servo.prototype.torqueEnabled = false;

                    /**
                     * Servo pGain.
                     * @type {number}
                     */
                    Servo.prototype.pGain = 0;

                    /**
                     * Servo iGain.
                     * @type {number}
                     */
                    Servo.prototype.iGain = 0;

                    /**
                     * Servo dGain.
                     * @type {number}
                     */
                    Servo.prototype.dGain = 0;

                    /**
                     * Servo goalPosition.
                     * @type {number}
                     */
                    Servo.prototype.goalPosition = 0;

                    /**
                     * Servo movingSpeed.
                     * @type {number}
                     */
                    Servo.prototype.movingSpeed = 0;

                    /**
                     * Servo torque.
                     * @type {number}
                     */
                    Servo.prototype.torque = 0;

                    /**
                     * Servo presentPosition.
                     * @type {number}
                     */
                    Servo.prototype.presentPosition = 0;

                    /**
                     * Servo presentSpeed.
                     * @type {number}
                     */
                    Servo.prototype.presentSpeed = 0;

                    /**
                     * Servo load.
                     * @type {number}
                     */
                    Servo.prototype.load = 0;

                    /**
                     * Servo voltage.
                     * @type {number}
                     */
                    Servo.prototype.voltage = 0;

                    /**
                     * Servo temperature.
                     * @type {number}
                     */
                    Servo.prototype.temperature = 0;

                    /**
                     * Creates a new Servo instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.Servo$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.Servo} Servo instance
                     */
                    Servo.create = function create(properties) {
                        return new Servo(properties);
                    };

                    /**
                     * Encodes the specified Servo message. Does not implicitly {@link message.platform.darwin.DarwinSensors.Servo.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Servo$Properties} message Servo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Servo.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.errorFlags != null && message.hasOwnProperty("errorFlags"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.errorFlags);
                        if (message.torqueEnabled != null && message.hasOwnProperty("torqueEnabled"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.torqueEnabled);
                        if (message.pGain != null && message.hasOwnProperty("pGain"))
                            writer.uint32(/* id 3, wireType 5 =*/29).float(message.pGain);
                        if (message.iGain != null && message.hasOwnProperty("iGain"))
                            writer.uint32(/* id 4, wireType 5 =*/37).float(message.iGain);
                        if (message.dGain != null && message.hasOwnProperty("dGain"))
                            writer.uint32(/* id 5, wireType 5 =*/45).float(message.dGain);
                        if (message.goalPosition != null && message.hasOwnProperty("goalPosition"))
                            writer.uint32(/* id 6, wireType 5 =*/53).float(message.goalPosition);
                        if (message.movingSpeed != null && message.hasOwnProperty("movingSpeed"))
                            writer.uint32(/* id 7, wireType 5 =*/61).float(message.movingSpeed);
                        if (message.torque != null && message.hasOwnProperty("torque"))
                            writer.uint32(/* id 8, wireType 5 =*/69).float(message.torque);
                        if (message.presentPosition != null && message.hasOwnProperty("presentPosition"))
                            writer.uint32(/* id 9, wireType 5 =*/77).float(message.presentPosition);
                        if (message.presentSpeed != null && message.hasOwnProperty("presentSpeed"))
                            writer.uint32(/* id 10, wireType 5 =*/85).float(message.presentSpeed);
                        if (message.load != null && message.hasOwnProperty("load"))
                            writer.uint32(/* id 11, wireType 5 =*/93).float(message.load);
                        if (message.voltage != null && message.hasOwnProperty("voltage"))
                            writer.uint32(/* id 12, wireType 5 =*/101).float(message.voltage);
                        if (message.temperature != null && message.hasOwnProperty("temperature"))
                            writer.uint32(/* id 13, wireType 5 =*/109).float(message.temperature);
                        return writer;
                    };

                    /**
                     * Encodes the specified Servo message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.Servo.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Servo$Properties} message Servo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Servo.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Servo message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.Servo} Servo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Servo.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.DarwinSensors.Servo();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.errorFlags = reader.uint32();
                                break;
                            case 2:
                                message.torqueEnabled = reader.bool();
                                break;
                            case 3:
                                message.pGain = reader.float();
                                break;
                            case 4:
                                message.iGain = reader.float();
                                break;
                            case 5:
                                message.dGain = reader.float();
                                break;
                            case 6:
                                message.goalPosition = reader.float();
                                break;
                            case 7:
                                message.movingSpeed = reader.float();
                                break;
                            case 8:
                                message.torque = reader.float();
                                break;
                            case 9:
                                message.presentPosition = reader.float();
                                break;
                            case 10:
                                message.presentSpeed = reader.float();
                                break;
                            case 11:
                                message.load = reader.float();
                                break;
                            case 12:
                                message.voltage = reader.float();
                                break;
                            case 13:
                                message.temperature = reader.float();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Servo message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.Servo} Servo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Servo.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Servo message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Servo.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.errorFlags != null && message.hasOwnProperty("errorFlags"))
                            if (!$util.isInteger(message.errorFlags))
                                return "errorFlags: integer expected";
                        if (message.torqueEnabled != null && message.hasOwnProperty("torqueEnabled"))
                            if (typeof message.torqueEnabled !== "boolean")
                                return "torqueEnabled: boolean expected";
                        if (message.pGain != null && message.hasOwnProperty("pGain"))
                            if (typeof message.pGain !== "number")
                                return "pGain: number expected";
                        if (message.iGain != null && message.hasOwnProperty("iGain"))
                            if (typeof message.iGain !== "number")
                                return "iGain: number expected";
                        if (message.dGain != null && message.hasOwnProperty("dGain"))
                            if (typeof message.dGain !== "number")
                                return "dGain: number expected";
                        if (message.goalPosition != null && message.hasOwnProperty("goalPosition"))
                            if (typeof message.goalPosition !== "number")
                                return "goalPosition: number expected";
                        if (message.movingSpeed != null && message.hasOwnProperty("movingSpeed"))
                            if (typeof message.movingSpeed !== "number")
                                return "movingSpeed: number expected";
                        if (message.torque != null && message.hasOwnProperty("torque"))
                            if (typeof message.torque !== "number")
                                return "torque: number expected";
                        if (message.presentPosition != null && message.hasOwnProperty("presentPosition"))
                            if (typeof message.presentPosition !== "number")
                                return "presentPosition: number expected";
                        if (message.presentSpeed != null && message.hasOwnProperty("presentSpeed"))
                            if (typeof message.presentSpeed !== "number")
                                return "presentSpeed: number expected";
                        if (message.load != null && message.hasOwnProperty("load"))
                            if (typeof message.load !== "number")
                                return "load: number expected";
                        if (message.voltage != null && message.hasOwnProperty("voltage"))
                            if (typeof message.voltage !== "number")
                                return "voltage: number expected";
                        if (message.temperature != null && message.hasOwnProperty("temperature"))
                            if (typeof message.temperature !== "number")
                                return "temperature: number expected";
                        return null;
                    };

                    /**
                     * Creates a Servo message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Servo} Servo
                     */
                    Servo.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.platform.darwin.DarwinSensors.Servo)
                            return object;
                        var message = new $root.message.platform.darwin.DarwinSensors.Servo();
                        if (object.errorFlags != null)
                            message.errorFlags = object.errorFlags >>> 0;
                        if (object.torqueEnabled != null)
                            message.torqueEnabled = Boolean(object.torqueEnabled);
                        if (object.pGain != null)
                            message.pGain = Number(object.pGain);
                        if (object.iGain != null)
                            message.iGain = Number(object.iGain);
                        if (object.dGain != null)
                            message.dGain = Number(object.dGain);
                        if (object.goalPosition != null)
                            message.goalPosition = Number(object.goalPosition);
                        if (object.movingSpeed != null)
                            message.movingSpeed = Number(object.movingSpeed);
                        if (object.torque != null)
                            message.torque = Number(object.torque);
                        if (object.presentPosition != null)
                            message.presentPosition = Number(object.presentPosition);
                        if (object.presentSpeed != null)
                            message.presentSpeed = Number(object.presentSpeed);
                        if (object.load != null)
                            message.load = Number(object.load);
                        if (object.voltage != null)
                            message.voltage = Number(object.voltage);
                        if (object.temperature != null)
                            message.temperature = Number(object.temperature);
                        return message;
                    };

                    /**
                     * Creates a Servo message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.Servo.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Servo} Servo
                     */
                    Servo.from = Servo.fromObject;

                    /**
                     * Creates a plain object from a Servo message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.Servo} message Servo
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Servo.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.errorFlags = 0;
                            object.torqueEnabled = false;
                            object.pGain = 0;
                            object.iGain = 0;
                            object.dGain = 0;
                            object.goalPosition = 0;
                            object.movingSpeed = 0;
                            object.torque = 0;
                            object.presentPosition = 0;
                            object.presentSpeed = 0;
                            object.load = 0;
                            object.voltage = 0;
                            object.temperature = 0;
                        }
                        if (message.errorFlags != null && message.hasOwnProperty("errorFlags"))
                            object.errorFlags = message.errorFlags;
                        if (message.torqueEnabled != null && message.hasOwnProperty("torqueEnabled"))
                            object.torqueEnabled = message.torqueEnabled;
                        if (message.pGain != null && message.hasOwnProperty("pGain"))
                            object.pGain = message.pGain;
                        if (message.iGain != null && message.hasOwnProperty("iGain"))
                            object.iGain = message.iGain;
                        if (message.dGain != null && message.hasOwnProperty("dGain"))
                            object.dGain = message.dGain;
                        if (message.goalPosition != null && message.hasOwnProperty("goalPosition"))
                            object.goalPosition = message.goalPosition;
                        if (message.movingSpeed != null && message.hasOwnProperty("movingSpeed"))
                            object.movingSpeed = message.movingSpeed;
                        if (message.torque != null && message.hasOwnProperty("torque"))
                            object.torque = message.torque;
                        if (message.presentPosition != null && message.hasOwnProperty("presentPosition"))
                            object.presentPosition = message.presentPosition;
                        if (message.presentSpeed != null && message.hasOwnProperty("presentSpeed"))
                            object.presentSpeed = message.presentSpeed;
                        if (message.load != null && message.hasOwnProperty("load"))
                            object.load = message.load;
                        if (message.voltage != null && message.hasOwnProperty("voltage"))
                            object.voltage = message.voltage;
                        if (message.temperature != null && message.hasOwnProperty("temperature"))
                            object.temperature = message.temperature;
                        return object;
                    };

                    /**
                     * Creates a plain object from this Servo message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Servo.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Servo to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Servo.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Servo;
                })();

                DarwinSensors.Servos = (function() {

                    /**
                     * Properties of a Servos.
                     * @typedef message.platform.darwin.DarwinSensors.Servos$Properties
                     * @type {Object}
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [rShoulderPitch] Servos rShoulderPitch.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [lShoulderPitch] Servos lShoulderPitch.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [rShoulderRoll] Servos rShoulderRoll.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [lShoulderRoll] Servos lShoulderRoll.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [rElbow] Servos rElbow.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [lElbow] Servos lElbow.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [rHipYaw] Servos rHipYaw.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [lHipYaw] Servos lHipYaw.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [rHipRoll] Servos rHipRoll.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [lHipRoll] Servos lHipRoll.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [rHipPitch] Servos rHipPitch.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [lHipPitch] Servos lHipPitch.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [rKnee] Servos rKnee.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [lKnee] Servos lKnee.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [rAnklePitch] Servos rAnklePitch.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [lAnklePitch] Servos lAnklePitch.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [rAnkleRoll] Servos rAnkleRoll.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [lAnkleRoll] Servos lAnkleRoll.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [headPan] Servos headPan.
                     * @property {message.platform.darwin.DarwinSensors.Servo$Properties} [headTilt] Servos headTilt.
                     */

                    /**
                     * Constructs a new Servos.
                     * @exports message.platform.darwin.DarwinSensors.Servos
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.Servos$Properties=} [properties] Properties to set
                     */
                    function Servos(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Servos rShoulderPitch.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.rShoulderPitch = null;

                    /**
                     * Servos lShoulderPitch.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.lShoulderPitch = null;

                    /**
                     * Servos rShoulderRoll.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.rShoulderRoll = null;

                    /**
                     * Servos lShoulderRoll.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.lShoulderRoll = null;

                    /**
                     * Servos rElbow.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.rElbow = null;

                    /**
                     * Servos lElbow.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.lElbow = null;

                    /**
                     * Servos rHipYaw.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.rHipYaw = null;

                    /**
                     * Servos lHipYaw.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.lHipYaw = null;

                    /**
                     * Servos rHipRoll.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.rHipRoll = null;

                    /**
                     * Servos lHipRoll.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.lHipRoll = null;

                    /**
                     * Servos rHipPitch.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.rHipPitch = null;

                    /**
                     * Servos lHipPitch.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.lHipPitch = null;

                    /**
                     * Servos rKnee.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.rKnee = null;

                    /**
                     * Servos lKnee.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.lKnee = null;

                    /**
                     * Servos rAnklePitch.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.rAnklePitch = null;

                    /**
                     * Servos lAnklePitch.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.lAnklePitch = null;

                    /**
                     * Servos rAnkleRoll.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.rAnkleRoll = null;

                    /**
                     * Servos lAnkleRoll.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.lAnkleRoll = null;

                    /**
                     * Servos headPan.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.headPan = null;

                    /**
                     * Servos headTilt.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    Servos.prototype.headTilt = null;

                    /**
                     * Creates a new Servos instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.Servos$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.Servos} Servos instance
                     */
                    Servos.create = function create(properties) {
                        return new Servos(properties);
                    };

                    /**
                     * Encodes the specified Servos message. Does not implicitly {@link message.platform.darwin.DarwinSensors.Servos.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Servos$Properties} message Servos message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Servos.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.rShoulderPitch != null && message.hasOwnProperty("rShoulderPitch"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.rShoulderPitch, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.lShoulderPitch != null && message.hasOwnProperty("lShoulderPitch"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.lShoulderPitch, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.rShoulderRoll != null && message.hasOwnProperty("rShoulderRoll"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.rShoulderRoll, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.lShoulderRoll != null && message.hasOwnProperty("lShoulderRoll"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.lShoulderRoll, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.rElbow != null && message.hasOwnProperty("rElbow"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.rElbow, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.lElbow != null && message.hasOwnProperty("lElbow"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.lElbow, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.rHipYaw != null && message.hasOwnProperty("rHipYaw"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.rHipYaw, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.lHipYaw != null && message.hasOwnProperty("lHipYaw"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.lHipYaw, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.rHipRoll != null && message.hasOwnProperty("rHipRoll"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.rHipRoll, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.lHipRoll != null && message.hasOwnProperty("lHipRoll"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.lHipRoll, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.rHipPitch != null && message.hasOwnProperty("rHipPitch"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.rHipPitch, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        if (message.lHipPitch != null && message.hasOwnProperty("lHipPitch"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.lHipPitch, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                        if (message.rKnee != null && message.hasOwnProperty("rKnee"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.rKnee, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                        if (message.lKnee != null && message.hasOwnProperty("lKnee"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.lKnee, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                        if (message.rAnklePitch != null && message.hasOwnProperty("rAnklePitch"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.rAnklePitch, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                        if (message.lAnklePitch != null && message.hasOwnProperty("lAnklePitch"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.lAnklePitch, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                        if (message.rAnkleRoll != null && message.hasOwnProperty("rAnkleRoll"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.rAnkleRoll, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                        if (message.lAnkleRoll != null && message.hasOwnProperty("lAnkleRoll"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.lAnkleRoll, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                        if (message.headPan != null && message.hasOwnProperty("headPan"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.headPan, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                        if (message.headTilt != null && message.hasOwnProperty("headTilt"))
                            $root.message.platform.darwin.DarwinSensors.Servo.encode(message.headTilt, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Servos message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.Servos.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Servos$Properties} message Servos message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Servos.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Servos message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.Servos} Servos
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Servos.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.DarwinSensors.Servos();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.rShoulderPitch = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.lShoulderPitch = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.rShoulderRoll = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.lShoulderRoll = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.rElbow = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.lElbow = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.rHipYaw = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.lHipYaw = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.rHipRoll = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.lHipRoll = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.rHipPitch = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.lHipPitch = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 13:
                                message.rKnee = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 14:
                                message.lKnee = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 15:
                                message.rAnklePitch = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 16:
                                message.lAnklePitch = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 17:
                                message.rAnkleRoll = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 18:
                                message.lAnkleRoll = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 19:
                                message.headPan = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            case 20:
                                message.headTilt = $root.message.platform.darwin.DarwinSensors.Servo.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Servos message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.Servos} Servos
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Servos.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Servos message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Servos.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.rShoulderPitch != null && message.hasOwnProperty("rShoulderPitch")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.rShoulderPitch);
                            if (error)
                                return "rShoulderPitch." + error;
                        }
                        if (message.lShoulderPitch != null && message.hasOwnProperty("lShoulderPitch")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.lShoulderPitch);
                            if (error)
                                return "lShoulderPitch." + error;
                        }
                        if (message.rShoulderRoll != null && message.hasOwnProperty("rShoulderRoll")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.rShoulderRoll);
                            if (error)
                                return "rShoulderRoll." + error;
                        }
                        if (message.lShoulderRoll != null && message.hasOwnProperty("lShoulderRoll")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.lShoulderRoll);
                            if (error)
                                return "lShoulderRoll." + error;
                        }
                        if (message.rElbow != null && message.hasOwnProperty("rElbow")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.rElbow);
                            if (error)
                                return "rElbow." + error;
                        }
                        if (message.lElbow != null && message.hasOwnProperty("lElbow")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.lElbow);
                            if (error)
                                return "lElbow." + error;
                        }
                        if (message.rHipYaw != null && message.hasOwnProperty("rHipYaw")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.rHipYaw);
                            if (error)
                                return "rHipYaw." + error;
                        }
                        if (message.lHipYaw != null && message.hasOwnProperty("lHipYaw")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.lHipYaw);
                            if (error)
                                return "lHipYaw." + error;
                        }
                        if (message.rHipRoll != null && message.hasOwnProperty("rHipRoll")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.rHipRoll);
                            if (error)
                                return "rHipRoll." + error;
                        }
                        if (message.lHipRoll != null && message.hasOwnProperty("lHipRoll")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.lHipRoll);
                            if (error)
                                return "lHipRoll." + error;
                        }
                        if (message.rHipPitch != null && message.hasOwnProperty("rHipPitch")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.rHipPitch);
                            if (error)
                                return "rHipPitch." + error;
                        }
                        if (message.lHipPitch != null && message.hasOwnProperty("lHipPitch")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.lHipPitch);
                            if (error)
                                return "lHipPitch." + error;
                        }
                        if (message.rKnee != null && message.hasOwnProperty("rKnee")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.rKnee);
                            if (error)
                                return "rKnee." + error;
                        }
                        if (message.lKnee != null && message.hasOwnProperty("lKnee")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.lKnee);
                            if (error)
                                return "lKnee." + error;
                        }
                        if (message.rAnklePitch != null && message.hasOwnProperty("rAnklePitch")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.rAnklePitch);
                            if (error)
                                return "rAnklePitch." + error;
                        }
                        if (message.lAnklePitch != null && message.hasOwnProperty("lAnklePitch")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.lAnklePitch);
                            if (error)
                                return "lAnklePitch." + error;
                        }
                        if (message.rAnkleRoll != null && message.hasOwnProperty("rAnkleRoll")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.rAnkleRoll);
                            if (error)
                                return "rAnkleRoll." + error;
                        }
                        if (message.lAnkleRoll != null && message.hasOwnProperty("lAnkleRoll")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.lAnkleRoll);
                            if (error)
                                return "lAnkleRoll." + error;
                        }
                        if (message.headPan != null && message.hasOwnProperty("headPan")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.headPan);
                            if (error)
                                return "headPan." + error;
                        }
                        if (message.headTilt != null && message.hasOwnProperty("headTilt")) {
                            var error = $root.message.platform.darwin.DarwinSensors.Servo.verify(message.headTilt);
                            if (error)
                                return "headTilt." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Servos message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Servos} Servos
                     */
                    Servos.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.platform.darwin.DarwinSensors.Servos)
                            return object;
                        var message = new $root.message.platform.darwin.DarwinSensors.Servos();
                        if (object.rShoulderPitch != null) {
                            if (typeof object.rShoulderPitch !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.rShoulderPitch: object expected");
                            message.rShoulderPitch = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.rShoulderPitch);
                        }
                        if (object.lShoulderPitch != null) {
                            if (typeof object.lShoulderPitch !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.lShoulderPitch: object expected");
                            message.lShoulderPitch = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.lShoulderPitch);
                        }
                        if (object.rShoulderRoll != null) {
                            if (typeof object.rShoulderRoll !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.rShoulderRoll: object expected");
                            message.rShoulderRoll = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.rShoulderRoll);
                        }
                        if (object.lShoulderRoll != null) {
                            if (typeof object.lShoulderRoll !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.lShoulderRoll: object expected");
                            message.lShoulderRoll = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.lShoulderRoll);
                        }
                        if (object.rElbow != null) {
                            if (typeof object.rElbow !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.rElbow: object expected");
                            message.rElbow = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.rElbow);
                        }
                        if (object.lElbow != null) {
                            if (typeof object.lElbow !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.lElbow: object expected");
                            message.lElbow = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.lElbow);
                        }
                        if (object.rHipYaw != null) {
                            if (typeof object.rHipYaw !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.rHipYaw: object expected");
                            message.rHipYaw = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.rHipYaw);
                        }
                        if (object.lHipYaw != null) {
                            if (typeof object.lHipYaw !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.lHipYaw: object expected");
                            message.lHipYaw = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.lHipYaw);
                        }
                        if (object.rHipRoll != null) {
                            if (typeof object.rHipRoll !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.rHipRoll: object expected");
                            message.rHipRoll = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.rHipRoll);
                        }
                        if (object.lHipRoll != null) {
                            if (typeof object.lHipRoll !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.lHipRoll: object expected");
                            message.lHipRoll = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.lHipRoll);
                        }
                        if (object.rHipPitch != null) {
                            if (typeof object.rHipPitch !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.rHipPitch: object expected");
                            message.rHipPitch = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.rHipPitch);
                        }
                        if (object.lHipPitch != null) {
                            if (typeof object.lHipPitch !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.lHipPitch: object expected");
                            message.lHipPitch = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.lHipPitch);
                        }
                        if (object.rKnee != null) {
                            if (typeof object.rKnee !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.rKnee: object expected");
                            message.rKnee = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.rKnee);
                        }
                        if (object.lKnee != null) {
                            if (typeof object.lKnee !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.lKnee: object expected");
                            message.lKnee = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.lKnee);
                        }
                        if (object.rAnklePitch != null) {
                            if (typeof object.rAnklePitch !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.rAnklePitch: object expected");
                            message.rAnklePitch = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.rAnklePitch);
                        }
                        if (object.lAnklePitch != null) {
                            if (typeof object.lAnklePitch !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.lAnklePitch: object expected");
                            message.lAnklePitch = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.lAnklePitch);
                        }
                        if (object.rAnkleRoll != null) {
                            if (typeof object.rAnkleRoll !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.rAnkleRoll: object expected");
                            message.rAnkleRoll = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.rAnkleRoll);
                        }
                        if (object.lAnkleRoll != null) {
                            if (typeof object.lAnkleRoll !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.lAnkleRoll: object expected");
                            message.lAnkleRoll = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.lAnkleRoll);
                        }
                        if (object.headPan != null) {
                            if (typeof object.headPan !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.headPan: object expected");
                            message.headPan = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.headPan);
                        }
                        if (object.headTilt != null) {
                            if (typeof object.headTilt !== "object")
                                throw TypeError(".message.platform.darwin.DarwinSensors.Servos.headTilt: object expected");
                            message.headTilt = $root.message.platform.darwin.DarwinSensors.Servo.fromObject(object.headTilt);
                        }
                        return message;
                    };

                    /**
                     * Creates a Servos message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.Servos.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Servos} Servos
                     */
                    Servos.from = Servos.fromObject;

                    /**
                     * Creates a plain object from a Servos message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.Servos} message Servos
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Servos.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.rShoulderPitch = null;
                            object.lShoulderPitch = null;
                            object.rShoulderRoll = null;
                            object.lShoulderRoll = null;
                            object.rElbow = null;
                            object.lElbow = null;
                            object.rHipYaw = null;
                            object.lHipYaw = null;
                            object.rHipRoll = null;
                            object.lHipRoll = null;
                            object.rHipPitch = null;
                            object.lHipPitch = null;
                            object.rKnee = null;
                            object.lKnee = null;
                            object.rAnklePitch = null;
                            object.lAnklePitch = null;
                            object.rAnkleRoll = null;
                            object.lAnkleRoll = null;
                            object.headPan = null;
                            object.headTilt = null;
                        }
                        if (message.rShoulderPitch != null && message.hasOwnProperty("rShoulderPitch"))
                            object.rShoulderPitch = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.rShoulderPitch, options);
                        if (message.lShoulderPitch != null && message.hasOwnProperty("lShoulderPitch"))
                            object.lShoulderPitch = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.lShoulderPitch, options);
                        if (message.rShoulderRoll != null && message.hasOwnProperty("rShoulderRoll"))
                            object.rShoulderRoll = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.rShoulderRoll, options);
                        if (message.lShoulderRoll != null && message.hasOwnProperty("lShoulderRoll"))
                            object.lShoulderRoll = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.lShoulderRoll, options);
                        if (message.rElbow != null && message.hasOwnProperty("rElbow"))
                            object.rElbow = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.rElbow, options);
                        if (message.lElbow != null && message.hasOwnProperty("lElbow"))
                            object.lElbow = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.lElbow, options);
                        if (message.rHipYaw != null && message.hasOwnProperty("rHipYaw"))
                            object.rHipYaw = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.rHipYaw, options);
                        if (message.lHipYaw != null && message.hasOwnProperty("lHipYaw"))
                            object.lHipYaw = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.lHipYaw, options);
                        if (message.rHipRoll != null && message.hasOwnProperty("rHipRoll"))
                            object.rHipRoll = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.rHipRoll, options);
                        if (message.lHipRoll != null && message.hasOwnProperty("lHipRoll"))
                            object.lHipRoll = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.lHipRoll, options);
                        if (message.rHipPitch != null && message.hasOwnProperty("rHipPitch"))
                            object.rHipPitch = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.rHipPitch, options);
                        if (message.lHipPitch != null && message.hasOwnProperty("lHipPitch"))
                            object.lHipPitch = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.lHipPitch, options);
                        if (message.rKnee != null && message.hasOwnProperty("rKnee"))
                            object.rKnee = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.rKnee, options);
                        if (message.lKnee != null && message.hasOwnProperty("lKnee"))
                            object.lKnee = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.lKnee, options);
                        if (message.rAnklePitch != null && message.hasOwnProperty("rAnklePitch"))
                            object.rAnklePitch = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.rAnklePitch, options);
                        if (message.lAnklePitch != null && message.hasOwnProperty("lAnklePitch"))
                            object.lAnklePitch = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.lAnklePitch, options);
                        if (message.rAnkleRoll != null && message.hasOwnProperty("rAnkleRoll"))
                            object.rAnkleRoll = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.rAnkleRoll, options);
                        if (message.lAnkleRoll != null && message.hasOwnProperty("lAnkleRoll"))
                            object.lAnkleRoll = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.lAnkleRoll, options);
                        if (message.headPan != null && message.hasOwnProperty("headPan"))
                            object.headPan = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.headPan, options);
                        if (message.headTilt != null && message.hasOwnProperty("headTilt"))
                            object.headTilt = $root.message.platform.darwin.DarwinSensors.Servo.toObject(message.headTilt, options);
                        return object;
                    };

                    /**
                     * Creates a plain object from this Servos message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Servos.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Servos to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Servos.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Servos;
                })();

                return DarwinSensors;
            })();

            darwin.ButtonLeftDown = (function() {

                /**
                 * Properties of a ButtonLeftDown.
                 * @typedef message.platform.darwin.ButtonLeftDown$Properties
                 * @type {Object}
                 */

                /**
                 * Constructs a new ButtonLeftDown.
                 * @exports message.platform.darwin.ButtonLeftDown
                 * @constructor
                 * @param {message.platform.darwin.ButtonLeftDown$Properties=} [properties] Properties to set
                 */
                function ButtonLeftDown(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new ButtonLeftDown instance using the specified properties.
                 * @param {message.platform.darwin.ButtonLeftDown$Properties=} [properties] Properties to set
                 * @returns {message.platform.darwin.ButtonLeftDown} ButtonLeftDown instance
                 */
                ButtonLeftDown.create = function create(properties) {
                    return new ButtonLeftDown(properties);
                };

                /**
                 * Encodes the specified ButtonLeftDown message. Does not implicitly {@link message.platform.darwin.ButtonLeftDown.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonLeftDown$Properties} message ButtonLeftDown message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ButtonLeftDown.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified ButtonLeftDown message, length delimited. Does not implicitly {@link message.platform.darwin.ButtonLeftDown.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonLeftDown$Properties} message ButtonLeftDown message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ButtonLeftDown.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ButtonLeftDown message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.darwin.ButtonLeftDown} ButtonLeftDown
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ButtonLeftDown.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.ButtonLeftDown();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ButtonLeftDown message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.platform.darwin.ButtonLeftDown} ButtonLeftDown
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ButtonLeftDown.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ButtonLeftDown message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ButtonLeftDown.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a ButtonLeftDown message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonLeftDown} ButtonLeftDown
                 */
                ButtonLeftDown.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.platform.darwin.ButtonLeftDown)
                        return object;
                    return new $root.message.platform.darwin.ButtonLeftDown();
                };

                /**
                 * Creates a ButtonLeftDown message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.platform.darwin.ButtonLeftDown.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonLeftDown} ButtonLeftDown
                 */
                ButtonLeftDown.from = ButtonLeftDown.fromObject;

                /**
                 * Creates a plain object from a ButtonLeftDown message. Also converts values to other types if specified.
                 * @param {message.platform.darwin.ButtonLeftDown} message ButtonLeftDown
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ButtonLeftDown.toObject = function toObject() {
                    return {};
                };

                /**
                 * Creates a plain object from this ButtonLeftDown message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ButtonLeftDown.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ButtonLeftDown to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ButtonLeftDown.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ButtonLeftDown;
            })();

            darwin.ButtonLeftUp = (function() {

                /**
                 * Properties of a ButtonLeftUp.
                 * @typedef message.platform.darwin.ButtonLeftUp$Properties
                 * @type {Object}
                 */

                /**
                 * Constructs a new ButtonLeftUp.
                 * @exports message.platform.darwin.ButtonLeftUp
                 * @constructor
                 * @param {message.platform.darwin.ButtonLeftUp$Properties=} [properties] Properties to set
                 */
                function ButtonLeftUp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new ButtonLeftUp instance using the specified properties.
                 * @param {message.platform.darwin.ButtonLeftUp$Properties=} [properties] Properties to set
                 * @returns {message.platform.darwin.ButtonLeftUp} ButtonLeftUp instance
                 */
                ButtonLeftUp.create = function create(properties) {
                    return new ButtonLeftUp(properties);
                };

                /**
                 * Encodes the specified ButtonLeftUp message. Does not implicitly {@link message.platform.darwin.ButtonLeftUp.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonLeftUp$Properties} message ButtonLeftUp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ButtonLeftUp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified ButtonLeftUp message, length delimited. Does not implicitly {@link message.platform.darwin.ButtonLeftUp.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonLeftUp$Properties} message ButtonLeftUp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ButtonLeftUp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ButtonLeftUp message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.darwin.ButtonLeftUp} ButtonLeftUp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ButtonLeftUp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.ButtonLeftUp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ButtonLeftUp message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.platform.darwin.ButtonLeftUp} ButtonLeftUp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ButtonLeftUp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ButtonLeftUp message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ButtonLeftUp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a ButtonLeftUp message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonLeftUp} ButtonLeftUp
                 */
                ButtonLeftUp.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.platform.darwin.ButtonLeftUp)
                        return object;
                    return new $root.message.platform.darwin.ButtonLeftUp();
                };

                /**
                 * Creates a ButtonLeftUp message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.platform.darwin.ButtonLeftUp.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonLeftUp} ButtonLeftUp
                 */
                ButtonLeftUp.from = ButtonLeftUp.fromObject;

                /**
                 * Creates a plain object from a ButtonLeftUp message. Also converts values to other types if specified.
                 * @param {message.platform.darwin.ButtonLeftUp} message ButtonLeftUp
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ButtonLeftUp.toObject = function toObject() {
                    return {};
                };

                /**
                 * Creates a plain object from this ButtonLeftUp message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ButtonLeftUp.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ButtonLeftUp to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ButtonLeftUp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ButtonLeftUp;
            })();

            darwin.ButtonMiddleDown = (function() {

                /**
                 * Properties of a ButtonMiddleDown.
                 * @typedef message.platform.darwin.ButtonMiddleDown$Properties
                 * @type {Object}
                 */

                /**
                 * Constructs a new ButtonMiddleDown.
                 * @exports message.platform.darwin.ButtonMiddleDown
                 * @constructor
                 * @param {message.platform.darwin.ButtonMiddleDown$Properties=} [properties] Properties to set
                 */
                function ButtonMiddleDown(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new ButtonMiddleDown instance using the specified properties.
                 * @param {message.platform.darwin.ButtonMiddleDown$Properties=} [properties] Properties to set
                 * @returns {message.platform.darwin.ButtonMiddleDown} ButtonMiddleDown instance
                 */
                ButtonMiddleDown.create = function create(properties) {
                    return new ButtonMiddleDown(properties);
                };

                /**
                 * Encodes the specified ButtonMiddleDown message. Does not implicitly {@link message.platform.darwin.ButtonMiddleDown.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonMiddleDown$Properties} message ButtonMiddleDown message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ButtonMiddleDown.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified ButtonMiddleDown message, length delimited. Does not implicitly {@link message.platform.darwin.ButtonMiddleDown.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonMiddleDown$Properties} message ButtonMiddleDown message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ButtonMiddleDown.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ButtonMiddleDown message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.darwin.ButtonMiddleDown} ButtonMiddleDown
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ButtonMiddleDown.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.ButtonMiddleDown();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ButtonMiddleDown message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.platform.darwin.ButtonMiddleDown} ButtonMiddleDown
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ButtonMiddleDown.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ButtonMiddleDown message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ButtonMiddleDown.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a ButtonMiddleDown message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonMiddleDown} ButtonMiddleDown
                 */
                ButtonMiddleDown.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.platform.darwin.ButtonMiddleDown)
                        return object;
                    return new $root.message.platform.darwin.ButtonMiddleDown();
                };

                /**
                 * Creates a ButtonMiddleDown message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.platform.darwin.ButtonMiddleDown.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonMiddleDown} ButtonMiddleDown
                 */
                ButtonMiddleDown.from = ButtonMiddleDown.fromObject;

                /**
                 * Creates a plain object from a ButtonMiddleDown message. Also converts values to other types if specified.
                 * @param {message.platform.darwin.ButtonMiddleDown} message ButtonMiddleDown
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ButtonMiddleDown.toObject = function toObject() {
                    return {};
                };

                /**
                 * Creates a plain object from this ButtonMiddleDown message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ButtonMiddleDown.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ButtonMiddleDown to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ButtonMiddleDown.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ButtonMiddleDown;
            })();

            darwin.ButtonMiddleUp = (function() {

                /**
                 * Properties of a ButtonMiddleUp.
                 * @typedef message.platform.darwin.ButtonMiddleUp$Properties
                 * @type {Object}
                 */

                /**
                 * Constructs a new ButtonMiddleUp.
                 * @exports message.platform.darwin.ButtonMiddleUp
                 * @constructor
                 * @param {message.platform.darwin.ButtonMiddleUp$Properties=} [properties] Properties to set
                 */
                function ButtonMiddleUp(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new ButtonMiddleUp instance using the specified properties.
                 * @param {message.platform.darwin.ButtonMiddleUp$Properties=} [properties] Properties to set
                 * @returns {message.platform.darwin.ButtonMiddleUp} ButtonMiddleUp instance
                 */
                ButtonMiddleUp.create = function create(properties) {
                    return new ButtonMiddleUp(properties);
                };

                /**
                 * Encodes the specified ButtonMiddleUp message. Does not implicitly {@link message.platform.darwin.ButtonMiddleUp.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonMiddleUp$Properties} message ButtonMiddleUp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ButtonMiddleUp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified ButtonMiddleUp message, length delimited. Does not implicitly {@link message.platform.darwin.ButtonMiddleUp.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonMiddleUp$Properties} message ButtonMiddleUp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ButtonMiddleUp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ButtonMiddleUp message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.darwin.ButtonMiddleUp} ButtonMiddleUp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ButtonMiddleUp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.platform.darwin.ButtonMiddleUp();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ButtonMiddleUp message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.platform.darwin.ButtonMiddleUp} ButtonMiddleUp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ButtonMiddleUp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ButtonMiddleUp message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ButtonMiddleUp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a ButtonMiddleUp message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonMiddleUp} ButtonMiddleUp
                 */
                ButtonMiddleUp.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.platform.darwin.ButtonMiddleUp)
                        return object;
                    return new $root.message.platform.darwin.ButtonMiddleUp();
                };

                /**
                 * Creates a ButtonMiddleUp message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.platform.darwin.ButtonMiddleUp.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonMiddleUp} ButtonMiddleUp
                 */
                ButtonMiddleUp.from = ButtonMiddleUp.fromObject;

                /**
                 * Creates a plain object from a ButtonMiddleUp message. Also converts values to other types if specified.
                 * @param {message.platform.darwin.ButtonMiddleUp} message ButtonMiddleUp
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ButtonMiddleUp.toObject = function toObject() {
                    return {};
                };

                /**
                 * Creates a plain object from this ButtonMiddleUp message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ButtonMiddleUp.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ButtonMiddleUp to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ButtonMiddleUp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ButtonMiddleUp;
            })();

            return darwin;
        })();

        return platform;
    })();

    message.research = (function() {

        /**
         * Namespace research.
         * @exports message.research
         * @namespace
         */
        var research = {};

        research.AutoClassifierPixels = (function() {

            /**
             * Properties of an AutoClassifierPixels.
             * @typedef message.research.AutoClassifierPixels$Properties
             * @type {Object}
             * @property {Array.<number>} [pixels] AutoClassifierPixels pixels.
             * @property {number} [classification] AutoClassifierPixels classification.
             */

            /**
             * Constructs a new AutoClassifierPixels.
             * @exports message.research.AutoClassifierPixels
             * @constructor
             * @param {message.research.AutoClassifierPixels$Properties=} [properties] Properties to set
             */
            function AutoClassifierPixels(properties) {
                this.pixels = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AutoClassifierPixels pixels.
             * @type {Array.<number>}
             */
            AutoClassifierPixels.prototype.pixels = $util.emptyArray;

            /**
             * AutoClassifierPixels classification.
             * @type {number}
             */
            AutoClassifierPixels.prototype.classification = 0;

            /**
             * Creates a new AutoClassifierPixels instance using the specified properties.
             * @param {message.research.AutoClassifierPixels$Properties=} [properties] Properties to set
             * @returns {message.research.AutoClassifierPixels} AutoClassifierPixels instance
             */
            AutoClassifierPixels.create = function create(properties) {
                return new AutoClassifierPixels(properties);
            };

            /**
             * Encodes the specified AutoClassifierPixels message. Does not implicitly {@link message.research.AutoClassifierPixels.verify|verify} messages.
             * @param {message.research.AutoClassifierPixels$Properties} message AutoClassifierPixels message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AutoClassifierPixels.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pixels != null && message.pixels.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.pixels.length; ++i)
                        writer.uint32(message.pixels[i]);
                    writer.ldelim();
                }
                if (message.classification != null && message.hasOwnProperty("classification"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.classification);
                return writer;
            };

            /**
             * Encodes the specified AutoClassifierPixels message, length delimited. Does not implicitly {@link message.research.AutoClassifierPixels.verify|verify} messages.
             * @param {message.research.AutoClassifierPixels$Properties} message AutoClassifierPixels message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AutoClassifierPixels.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AutoClassifierPixels message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.research.AutoClassifierPixels} AutoClassifierPixels
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AutoClassifierPixels.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.research.AutoClassifierPixels();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.pixels && message.pixels.length))
                            message.pixels = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.pixels.push(reader.uint32());
                        } else
                            message.pixels.push(reader.uint32());
                        break;
                    case 2:
                        message.classification = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AutoClassifierPixels message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.research.AutoClassifierPixels} AutoClassifierPixels
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AutoClassifierPixels.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AutoClassifierPixels message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            AutoClassifierPixels.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pixels != null && message.hasOwnProperty("pixels")) {
                    if (!Array.isArray(message.pixels))
                        return "pixels: array expected";
                    for (var i = 0; i < message.pixels.length; ++i)
                        if (!$util.isInteger(message.pixels[i]))
                            return "pixels: integer[] expected";
                }
                if (message.classification != null && message.hasOwnProperty("classification"))
                    if (!$util.isInteger(message.classification))
                        return "classification: integer expected";
                return null;
            };

            /**
             * Creates an AutoClassifierPixels message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.research.AutoClassifierPixels} AutoClassifierPixels
             */
            AutoClassifierPixels.fromObject = function fromObject(object) {
                if (object instanceof $root.message.research.AutoClassifierPixels)
                    return object;
                var message = new $root.message.research.AutoClassifierPixels();
                if (object.pixels) {
                    if (!Array.isArray(object.pixels))
                        throw TypeError(".message.research.AutoClassifierPixels.pixels: array expected");
                    message.pixels = [];
                    for (var i = 0; i < object.pixels.length; ++i)
                        message.pixels[i] = object.pixels[i] >>> 0;
                }
                if (object.classification != null)
                    message.classification = object.classification >>> 0;
                return message;
            };

            /**
             * Creates an AutoClassifierPixels message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.research.AutoClassifierPixels.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.research.AutoClassifierPixels} AutoClassifierPixels
             */
            AutoClassifierPixels.from = AutoClassifierPixels.fromObject;

            /**
             * Creates a plain object from an AutoClassifierPixels message. Also converts values to other types if specified.
             * @param {message.research.AutoClassifierPixels} message AutoClassifierPixels
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AutoClassifierPixels.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.pixels = [];
                if (options.defaults)
                    object.classification = 0;
                if (message.pixels && message.pixels.length) {
                    object.pixels = [];
                    for (var j = 0; j < message.pixels.length; ++j)
                        object.pixels[j] = message.pixels[j];
                }
                if (message.classification != null && message.hasOwnProperty("classification"))
                    object.classification = message.classification;
                return object;
            };

            /**
             * Creates a plain object from this AutoClassifierPixels message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AutoClassifierPixels.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this AutoClassifierPixels to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            AutoClassifierPixels.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AutoClassifierPixels;
        })();

        research.scriptoptimizer = (function() {

            /**
             * Namespace scriptoptimizer.
             * @exports message.research.scriptoptimizer
             * @namespace
             */
            var scriptoptimizer = {};

            scriptoptimizer.OptimizeScript = (function() {

                /**
                 * Properties of an OptimizeScript.
                 * @typedef message.research.scriptoptimizer.OptimizeScript$Properties
                 * @type {Object}
                 * @property {string} [target] OptimizeScript target.
                 * @property {number} [iteration] OptimizeScript iteration.
                 * @property {string} [metadata] OptimizeScript metadata.
                 * @property {Array.<message.research.scriptoptimizer.OptimizeScript.Frame$Properties>} [frames] OptimizeScript frames.
                 */

                /**
                 * Constructs a new OptimizeScript.
                 * @exports message.research.scriptoptimizer.OptimizeScript
                 * @constructor
                 * @param {message.research.scriptoptimizer.OptimizeScript$Properties=} [properties] Properties to set
                 */
                function OptimizeScript(properties) {
                    this.frames = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * OptimizeScript target.
                 * @type {string}
                 */
                OptimizeScript.prototype.target = "";

                /**
                 * OptimizeScript iteration.
                 * @type {number}
                 */
                OptimizeScript.prototype.iteration = 0;

                /**
                 * OptimizeScript metadata.
                 * @type {string}
                 */
                OptimizeScript.prototype.metadata = "";

                /**
                 * OptimizeScript frames.
                 * @type {Array.<message.research.scriptoptimizer.OptimizeScript.Frame$Properties>}
                 */
                OptimizeScript.prototype.frames = $util.emptyArray;

                /**
                 * Creates a new OptimizeScript instance using the specified properties.
                 * @param {message.research.scriptoptimizer.OptimizeScript$Properties=} [properties] Properties to set
                 * @returns {message.research.scriptoptimizer.OptimizeScript} OptimizeScript instance
                 */
                OptimizeScript.create = function create(properties) {
                    return new OptimizeScript(properties);
                };

                /**
                 * Encodes the specified OptimizeScript message. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScript.verify|verify} messages.
                 * @param {message.research.scriptoptimizer.OptimizeScript$Properties} message OptimizeScript message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OptimizeScript.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.target != null && message.hasOwnProperty("target"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.target);
                    if (message.iteration != null && message.hasOwnProperty("iteration"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.iteration);
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.metadata);
                    if (message.frames != null && message.frames.length)
                        for (var i = 0; i < message.frames.length; ++i)
                            $root.message.research.scriptoptimizer.OptimizeScript.Frame.encode(message.frames[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified OptimizeScript message, length delimited. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScript.verify|verify} messages.
                 * @param {message.research.scriptoptimizer.OptimizeScript$Properties} message OptimizeScript message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OptimizeScript.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an OptimizeScript message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.research.scriptoptimizer.OptimizeScript} OptimizeScript
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OptimizeScript.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.research.scriptoptimizer.OptimizeScript();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.target = reader.string();
                            break;
                        case 2:
                            message.iteration = reader.uint32();
                            break;
                        case 3:
                            message.metadata = reader.string();
                            break;
                        case 4:
                            if (!(message.frames && message.frames.length))
                                message.frames = [];
                            message.frames.push($root.message.research.scriptoptimizer.OptimizeScript.Frame.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an OptimizeScript message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.research.scriptoptimizer.OptimizeScript} OptimizeScript
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OptimizeScript.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an OptimizeScript message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                OptimizeScript.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.target != null && message.hasOwnProperty("target"))
                        if (!$util.isString(message.target))
                            return "target: string expected";
                    if (message.iteration != null && message.hasOwnProperty("iteration"))
                        if (!$util.isInteger(message.iteration))
                            return "iteration: integer expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        if (!$util.isString(message.metadata))
                            return "metadata: string expected";
                    if (message.frames != null && message.hasOwnProperty("frames")) {
                        if (!Array.isArray(message.frames))
                            return "frames: array expected";
                        for (var i = 0; i < message.frames.length; ++i) {
                            var error = $root.message.research.scriptoptimizer.OptimizeScript.Frame.verify(message.frames[i]);
                            if (error)
                                return "frames." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an OptimizeScript message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.research.scriptoptimizer.OptimizeScript} OptimizeScript
                 */
                OptimizeScript.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.research.scriptoptimizer.OptimizeScript)
                        return object;
                    var message = new $root.message.research.scriptoptimizer.OptimizeScript();
                    if (object.target != null)
                        message.target = String(object.target);
                    if (object.iteration != null)
                        message.iteration = object.iteration >>> 0;
                    if (object.metadata != null)
                        message.metadata = String(object.metadata);
                    if (object.frames) {
                        if (!Array.isArray(object.frames))
                            throw TypeError(".message.research.scriptoptimizer.OptimizeScript.frames: array expected");
                        message.frames = [];
                        for (var i = 0; i < object.frames.length; ++i) {
                            if (typeof object.frames[i] !== "object")
                                throw TypeError(".message.research.scriptoptimizer.OptimizeScript.frames: object expected");
                            message.frames[i] = $root.message.research.scriptoptimizer.OptimizeScript.Frame.fromObject(object.frames[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates an OptimizeScript message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.research.scriptoptimizer.OptimizeScript.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.research.scriptoptimizer.OptimizeScript} OptimizeScript
                 */
                OptimizeScript.from = OptimizeScript.fromObject;

                /**
                 * Creates a plain object from an OptimizeScript message. Also converts values to other types if specified.
                 * @param {message.research.scriptoptimizer.OptimizeScript} message OptimizeScript
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OptimizeScript.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.frames = [];
                    if (options.defaults) {
                        object.target = "";
                        object.iteration = 0;
                        object.metadata = "";
                    }
                    if (message.target != null && message.hasOwnProperty("target"))
                        object.target = message.target;
                    if (message.iteration != null && message.hasOwnProperty("iteration"))
                        object.iteration = message.iteration;
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        object.metadata = message.metadata;
                    if (message.frames && message.frames.length) {
                        object.frames = [];
                        for (var j = 0; j < message.frames.length; ++j)
                            object.frames[j] = $root.message.research.scriptoptimizer.OptimizeScript.Frame.toObject(message.frames[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this OptimizeScript message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OptimizeScript.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this OptimizeScript to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                OptimizeScript.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                OptimizeScript.Target = (function() {

                    /**
                     * Properties of a Target.
                     * @typedef message.research.scriptoptimizer.OptimizeScript.Target$Properties
                     * @type {Object}
                     * @property {number} [id] Target id.
                     * @property {number} [position] Target position.
                     * @property {number} [gain] Target gain.
                     */

                    /**
                     * Constructs a new Target.
                     * @exports message.research.scriptoptimizer.OptimizeScript.Target
                     * @constructor
                     * @param {message.research.scriptoptimizer.OptimizeScript.Target$Properties=} [properties] Properties to set
                     */
                    function Target(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Target id.
                     * @type {number}
                     */
                    Target.prototype.id = 0;

                    /**
                     * Target position.
                     * @type {number}
                     */
                    Target.prototype.position = 0;

                    /**
                     * Target gain.
                     * @type {number}
                     */
                    Target.prototype.gain = 0;

                    /**
                     * Creates a new Target instance using the specified properties.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Target$Properties=} [properties] Properties to set
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Target} Target instance
                     */
                    Target.create = function create(properties) {
                        return new Target(properties);
                    };

                    /**
                     * Encodes the specified Target message. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScript.Target.verify|verify} messages.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Target$Properties} message Target message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Target.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                        if (message.position != null && message.hasOwnProperty("position"))
                            writer.uint32(/* id 2, wireType 5 =*/21).float(message.position);
                        if (message.gain != null && message.hasOwnProperty("gain"))
                            writer.uint32(/* id 3, wireType 5 =*/29).float(message.gain);
                        return writer;
                    };

                    /**
                     * Encodes the specified Target message, length delimited. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScript.Target.verify|verify} messages.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Target$Properties} message Target message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Target.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Target message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Target} Target
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Target.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.research.scriptoptimizer.OptimizeScript.Target();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.uint32();
                                break;
                            case 2:
                                message.position = reader.float();
                                break;
                            case 3:
                                message.gain = reader.float();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Target message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Target} Target
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Target.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Target message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Target.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isInteger(message.id))
                                return "id: integer expected";
                        if (message.position != null && message.hasOwnProperty("position"))
                            if (typeof message.position !== "number")
                                return "position: number expected";
                        if (message.gain != null && message.hasOwnProperty("gain"))
                            if (typeof message.gain !== "number")
                                return "gain: number expected";
                        return null;
                    };

                    /**
                     * Creates a Target message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Target} Target
                     */
                    Target.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.research.scriptoptimizer.OptimizeScript.Target)
                            return object;
                        var message = new $root.message.research.scriptoptimizer.OptimizeScript.Target();
                        if (object.id != null)
                            message.id = object.id >>> 0;
                        if (object.position != null)
                            message.position = Number(object.position);
                        if (object.gain != null)
                            message.gain = Number(object.gain);
                        return message;
                    };

                    /**
                     * Creates a Target message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.research.scriptoptimizer.OptimizeScript.Target.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Target} Target
                     */
                    Target.from = Target.fromObject;

                    /**
                     * Creates a plain object from a Target message. Also converts values to other types if specified.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Target} message Target
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Target.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.id = 0;
                            object.position = 0;
                            object.gain = 0;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.position != null && message.hasOwnProperty("position"))
                            object.position = message.position;
                        if (message.gain != null && message.hasOwnProperty("gain"))
                            object.gain = message.gain;
                        return object;
                    };

                    /**
                     * Creates a plain object from this Target message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Target.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Target to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Target.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Target;
                })();

                OptimizeScript.Frame = (function() {

                    /**
                     * Properties of a Frame.
                     * @typedef message.research.scriptoptimizer.OptimizeScript.Frame$Properties
                     * @type {Object}
                     * @property {number} [duration] Frame duration.
                     * @property {Array.<message.research.scriptoptimizer.OptimizeScript.Target$Properties>} [targets] Frame targets.
                     */

                    /**
                     * Constructs a new Frame.
                     * @exports message.research.scriptoptimizer.OptimizeScript.Frame
                     * @constructor
                     * @param {message.research.scriptoptimizer.OptimizeScript.Frame$Properties=} [properties] Properties to set
                     */
                    function Frame(properties) {
                        this.targets = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Frame duration.
                     * @type {number}
                     */
                    Frame.prototype.duration = 0;

                    /**
                     * Frame targets.
                     * @type {Array.<message.research.scriptoptimizer.OptimizeScript.Target$Properties>}
                     */
                    Frame.prototype.targets = $util.emptyArray;

                    /**
                     * Creates a new Frame instance using the specified properties.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Frame$Properties=} [properties] Properties to set
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Frame} Frame instance
                     */
                    Frame.create = function create(properties) {
                        return new Frame(properties);
                    };

                    /**
                     * Encodes the specified Frame message. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScript.Frame.verify|verify} messages.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Frame$Properties} message Frame message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Frame.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.duration != null && message.hasOwnProperty("duration"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.duration);
                        if (message.targets != null && message.targets.length)
                            for (var i = 0; i < message.targets.length; ++i)
                                $root.message.research.scriptoptimizer.OptimizeScript.Target.encode(message.targets[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Frame message, length delimited. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScript.Frame.verify|verify} messages.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Frame$Properties} message Frame message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Frame.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Frame message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Frame} Frame
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Frame.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.research.scriptoptimizer.OptimizeScript.Frame();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.duration = reader.uint32();
                                break;
                            case 2:
                                if (!(message.targets && message.targets.length))
                                    message.targets = [];
                                message.targets.push($root.message.research.scriptoptimizer.OptimizeScript.Target.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Frame message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Frame} Frame
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Frame.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Frame message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Frame.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.duration != null && message.hasOwnProperty("duration"))
                            if (!$util.isInteger(message.duration))
                                return "duration: integer expected";
                        if (message.targets != null && message.hasOwnProperty("targets")) {
                            if (!Array.isArray(message.targets))
                                return "targets: array expected";
                            for (var i = 0; i < message.targets.length; ++i) {
                                var error = $root.message.research.scriptoptimizer.OptimizeScript.Target.verify(message.targets[i]);
                                if (error)
                                    return "targets." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Frame message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Frame} Frame
                     */
                    Frame.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.research.scriptoptimizer.OptimizeScript.Frame)
                            return object;
                        var message = new $root.message.research.scriptoptimizer.OptimizeScript.Frame();
                        if (object.duration != null)
                            message.duration = object.duration >>> 0;
                        if (object.targets) {
                            if (!Array.isArray(object.targets))
                                throw TypeError(".message.research.scriptoptimizer.OptimizeScript.Frame.targets: array expected");
                            message.targets = [];
                            for (var i = 0; i < object.targets.length; ++i) {
                                if (typeof object.targets[i] !== "object")
                                    throw TypeError(".message.research.scriptoptimizer.OptimizeScript.Frame.targets: object expected");
                                message.targets[i] = $root.message.research.scriptoptimizer.OptimizeScript.Target.fromObject(object.targets[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a Frame message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.research.scriptoptimizer.OptimizeScript.Frame.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Frame} Frame
                     */
                    Frame.from = Frame.fromObject;

                    /**
                     * Creates a plain object from a Frame message. Also converts values to other types if specified.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Frame} message Frame
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Frame.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.targets = [];
                        if (options.defaults)
                            object.duration = 0;
                        if (message.duration != null && message.hasOwnProperty("duration"))
                            object.duration = message.duration;
                        if (message.targets && message.targets.length) {
                            object.targets = [];
                            for (var j = 0; j < message.targets.length; ++j)
                                object.targets[j] = $root.message.research.scriptoptimizer.OptimizeScript.Target.toObject(message.targets[j], options);
                        }
                        return object;
                    };

                    /**
                     * Creates a plain object from this Frame message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Frame.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Frame to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Frame.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Frame;
                })();

                return OptimizeScript;
            })();

            scriptoptimizer.OptimizeScriptResult = (function() {

                /**
                 * Properties of an OptimizeScriptResult.
                 * @typedef message.research.scriptoptimizer.OptimizeScriptResult$Properties
                 * @type {Object}
                 * @property {number} [iteration] OptimizeScriptResult iteration.
                 * @property {string} [metadata] OptimizeScriptResult metadata.
                 * @property {Array.<message.input.Sensors$Properties>} [sensors] OptimizeScriptResult sensors.
                 */

                /**
                 * Constructs a new OptimizeScriptResult.
                 * @exports message.research.scriptoptimizer.OptimizeScriptResult
                 * @constructor
                 * @param {message.research.scriptoptimizer.OptimizeScriptResult$Properties=} [properties] Properties to set
                 */
                function OptimizeScriptResult(properties) {
                    this.sensors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * OptimizeScriptResult iteration.
                 * @type {number}
                 */
                OptimizeScriptResult.prototype.iteration = 0;

                /**
                 * OptimizeScriptResult metadata.
                 * @type {string}
                 */
                OptimizeScriptResult.prototype.metadata = "";

                /**
                 * OptimizeScriptResult sensors.
                 * @type {Array.<message.input.Sensors$Properties>}
                 */
                OptimizeScriptResult.prototype.sensors = $util.emptyArray;

                /**
                 * Creates a new OptimizeScriptResult instance using the specified properties.
                 * @param {message.research.scriptoptimizer.OptimizeScriptResult$Properties=} [properties] Properties to set
                 * @returns {message.research.scriptoptimizer.OptimizeScriptResult} OptimizeScriptResult instance
                 */
                OptimizeScriptResult.create = function create(properties) {
                    return new OptimizeScriptResult(properties);
                };

                /**
                 * Encodes the specified OptimizeScriptResult message. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScriptResult.verify|verify} messages.
                 * @param {message.research.scriptoptimizer.OptimizeScriptResult$Properties} message OptimizeScriptResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OptimizeScriptResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.iteration != null && message.hasOwnProperty("iteration"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.iteration);
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.metadata);
                    if (message.sensors != null && message.sensors.length)
                        for (var i = 0; i < message.sensors.length; ++i)
                            $root.message.input.Sensors.encode(message.sensors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified OptimizeScriptResult message, length delimited. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScriptResult.verify|verify} messages.
                 * @param {message.research.scriptoptimizer.OptimizeScriptResult$Properties} message OptimizeScriptResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OptimizeScriptResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an OptimizeScriptResult message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.research.scriptoptimizer.OptimizeScriptResult} OptimizeScriptResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OptimizeScriptResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.research.scriptoptimizer.OptimizeScriptResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.iteration = reader.uint32();
                            break;
                        case 2:
                            message.metadata = reader.string();
                            break;
                        case 3:
                            if (!(message.sensors && message.sensors.length))
                                message.sensors = [];
                            message.sensors.push($root.message.input.Sensors.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an OptimizeScriptResult message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.research.scriptoptimizer.OptimizeScriptResult} OptimizeScriptResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OptimizeScriptResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an OptimizeScriptResult message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                OptimizeScriptResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.iteration != null && message.hasOwnProperty("iteration"))
                        if (!$util.isInteger(message.iteration))
                            return "iteration: integer expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        if (!$util.isString(message.metadata))
                            return "metadata: string expected";
                    if (message.sensors != null && message.hasOwnProperty("sensors")) {
                        if (!Array.isArray(message.sensors))
                            return "sensors: array expected";
                        for (var i = 0; i < message.sensors.length; ++i) {
                            var error = $root.message.input.Sensors.verify(message.sensors[i]);
                            if (error)
                                return "sensors." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an OptimizeScriptResult message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.research.scriptoptimizer.OptimizeScriptResult} OptimizeScriptResult
                 */
                OptimizeScriptResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.research.scriptoptimizer.OptimizeScriptResult)
                        return object;
                    var message = new $root.message.research.scriptoptimizer.OptimizeScriptResult();
                    if (object.iteration != null)
                        message.iteration = object.iteration >>> 0;
                    if (object.metadata != null)
                        message.metadata = String(object.metadata);
                    if (object.sensors) {
                        if (!Array.isArray(object.sensors))
                            throw TypeError(".message.research.scriptoptimizer.OptimizeScriptResult.sensors: array expected");
                        message.sensors = [];
                        for (var i = 0; i < object.sensors.length; ++i) {
                            if (typeof object.sensors[i] !== "object")
                                throw TypeError(".message.research.scriptoptimizer.OptimizeScriptResult.sensors: object expected");
                            message.sensors[i] = $root.message.input.Sensors.fromObject(object.sensors[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates an OptimizeScriptResult message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.research.scriptoptimizer.OptimizeScriptResult.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.research.scriptoptimizer.OptimizeScriptResult} OptimizeScriptResult
                 */
                OptimizeScriptResult.from = OptimizeScriptResult.fromObject;

                /**
                 * Creates a plain object from an OptimizeScriptResult message. Also converts values to other types if specified.
                 * @param {message.research.scriptoptimizer.OptimizeScriptResult} message OptimizeScriptResult
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OptimizeScriptResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.sensors = [];
                    if (options.defaults) {
                        object.iteration = 0;
                        object.metadata = "";
                    }
                    if (message.iteration != null && message.hasOwnProperty("iteration"))
                        object.iteration = message.iteration;
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        object.metadata = message.metadata;
                    if (message.sensors && message.sensors.length) {
                        object.sensors = [];
                        for (var j = 0; j < message.sensors.length; ++j)
                            object.sensors[j] = $root.message.input.Sensors.toObject(message.sensors[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this OptimizeScriptResult message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OptimizeScriptResult.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this OptimizeScriptResult to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                OptimizeScriptResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return OptimizeScriptResult;
            })();

            return scriptoptimizer;
        })();

        return research;
    })();

    message.support = (function() {

        /**
         * Namespace support.
         * @exports message.support
         * @namespace
         */
        var support = {};

        support.FieldDescription = (function() {

            /**
             * Properties of a FieldDescription.
             * @typedef message.support.FieldDescription$Properties
             * @type {Object}
             * @property {number} [ballRadius] FieldDescription ballRadius.
             * @property {number} [goalpostTopHeight] FieldDescription goalpostTopHeight.
             * @property {number} [penaltyRobotStart] FieldDescription penaltyRobotStart.
             * @property {vec2$Properties} [goalpostOwnL] FieldDescription goalpostOwnL.
             * @property {vec2$Properties} [goalpostOwnR] FieldDescription goalpostOwnR.
             * @property {vec2$Properties} [goalpostOppL] FieldDescription goalpostOppL.
             * @property {vec2$Properties} [goalpostOppR] FieldDescription goalpostOppR.
             * @property {message.support.FieldDescription.FieldDimensions$Properties} [dimensions] FieldDescription dimensions.
             */

            /**
             * Constructs a new FieldDescription.
             * @exports message.support.FieldDescription
             * @constructor
             * @param {message.support.FieldDescription$Properties=} [properties] Properties to set
             */
            function FieldDescription(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescription ballRadius.
             * @type {number}
             */
            FieldDescription.prototype.ballRadius = 0;

            /**
             * FieldDescription goalpostTopHeight.
             * @type {number}
             */
            FieldDescription.prototype.goalpostTopHeight = 0;

            /**
             * FieldDescription penaltyRobotStart.
             * @type {number}
             */
            FieldDescription.prototype.penaltyRobotStart = 0;

            /**
             * FieldDescription goalpostOwnL.
             * @type {(vec2$Properties|null)}
             */
            FieldDescription.prototype.goalpostOwnL = null;

            /**
             * FieldDescription goalpostOwnR.
             * @type {(vec2$Properties|null)}
             */
            FieldDescription.prototype.goalpostOwnR = null;

            /**
             * FieldDescription goalpostOppL.
             * @type {(vec2$Properties|null)}
             */
            FieldDescription.prototype.goalpostOppL = null;

            /**
             * FieldDescription goalpostOppR.
             * @type {(vec2$Properties|null)}
             */
            FieldDescription.prototype.goalpostOppR = null;

            /**
             * FieldDescription dimensions.
             * @type {(message.support.FieldDescription.FieldDimensions$Properties|null)}
             */
            FieldDescription.prototype.dimensions = null;

            /**
             * Creates a new FieldDescription instance using the specified properties.
             * @param {message.support.FieldDescription$Properties=} [properties] Properties to set
             * @returns {message.support.FieldDescription} FieldDescription instance
             */
            FieldDescription.create = function create(properties) {
                return new FieldDescription(properties);
            };

            /**
             * Encodes the specified FieldDescription message. Does not implicitly {@link message.support.FieldDescription.verify|verify} messages.
             * @param {message.support.FieldDescription$Properties} message FieldDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ballRadius != null && message.hasOwnProperty("ballRadius"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.ballRadius);
                if (message.goalpostTopHeight != null && message.hasOwnProperty("goalpostTopHeight"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.goalpostTopHeight);
                if (message.penaltyRobotStart != null && message.hasOwnProperty("penaltyRobotStart"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.penaltyRobotStart);
                if (message.goalpostOwnL != null && message.hasOwnProperty("goalpostOwnL"))
                    $root.vec2.encode(message.goalpostOwnL, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.goalpostOwnR != null && message.hasOwnProperty("goalpostOwnR"))
                    $root.vec2.encode(message.goalpostOwnR, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.goalpostOppL != null && message.hasOwnProperty("goalpostOppL"))
                    $root.vec2.encode(message.goalpostOppL, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.goalpostOppR != null && message.hasOwnProperty("goalpostOppR"))
                    $root.vec2.encode(message.goalpostOppR, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.dimensions != null && message.hasOwnProperty("dimensions"))
                    $root.message.support.FieldDescription.FieldDimensions.encode(message.dimensions, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FieldDescription message, length delimited. Does not implicitly {@link message.support.FieldDescription.verify|verify} messages.
             * @param {message.support.FieldDescription$Properties} message FieldDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldDescription message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.support.FieldDescription} FieldDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.FieldDescription();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ballRadius = reader.double();
                        break;
                    case 2:
                        message.goalpostTopHeight = reader.double();
                        break;
                    case 3:
                        message.penaltyRobotStart = reader.double();
                        break;
                    case 4:
                        message.goalpostOwnL = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.goalpostOwnR = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.goalpostOppL = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.goalpostOppR = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.dimensions = $root.message.support.FieldDescription.FieldDimensions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldDescription message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.support.FieldDescription} FieldDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldDescription message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FieldDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ballRadius != null && message.hasOwnProperty("ballRadius"))
                    if (typeof message.ballRadius !== "number")
                        return "ballRadius: number expected";
                if (message.goalpostTopHeight != null && message.hasOwnProperty("goalpostTopHeight"))
                    if (typeof message.goalpostTopHeight !== "number")
                        return "goalpostTopHeight: number expected";
                if (message.penaltyRobotStart != null && message.hasOwnProperty("penaltyRobotStart"))
                    if (typeof message.penaltyRobotStart !== "number")
                        return "penaltyRobotStart: number expected";
                if (message.goalpostOwnL != null && message.hasOwnProperty("goalpostOwnL")) {
                    var error = $root.vec2.verify(message.goalpostOwnL);
                    if (error)
                        return "goalpostOwnL." + error;
                }
                if (message.goalpostOwnR != null && message.hasOwnProperty("goalpostOwnR")) {
                    var error = $root.vec2.verify(message.goalpostOwnR);
                    if (error)
                        return "goalpostOwnR." + error;
                }
                if (message.goalpostOppL != null && message.hasOwnProperty("goalpostOppL")) {
                    var error = $root.vec2.verify(message.goalpostOppL);
                    if (error)
                        return "goalpostOppL." + error;
                }
                if (message.goalpostOppR != null && message.hasOwnProperty("goalpostOppR")) {
                    var error = $root.vec2.verify(message.goalpostOppR);
                    if (error)
                        return "goalpostOppR." + error;
                }
                if (message.dimensions != null && message.hasOwnProperty("dimensions")) {
                    var error = $root.message.support.FieldDescription.FieldDimensions.verify(message.dimensions);
                    if (error)
                        return "dimensions." + error;
                }
                return null;
            };

            /**
             * Creates a FieldDescription message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.FieldDescription} FieldDescription
             */
            FieldDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.message.support.FieldDescription)
                    return object;
                var message = new $root.message.support.FieldDescription();
                if (object.ballRadius != null)
                    message.ballRadius = Number(object.ballRadius);
                if (object.goalpostTopHeight != null)
                    message.goalpostTopHeight = Number(object.goalpostTopHeight);
                if (object.penaltyRobotStart != null)
                    message.penaltyRobotStart = Number(object.penaltyRobotStart);
                if (object.goalpostOwnL != null) {
                    if (typeof object.goalpostOwnL !== "object")
                        throw TypeError(".message.support.FieldDescription.goalpostOwnL: object expected");
                    message.goalpostOwnL = $root.vec2.fromObject(object.goalpostOwnL);
                }
                if (object.goalpostOwnR != null) {
                    if (typeof object.goalpostOwnR !== "object")
                        throw TypeError(".message.support.FieldDescription.goalpostOwnR: object expected");
                    message.goalpostOwnR = $root.vec2.fromObject(object.goalpostOwnR);
                }
                if (object.goalpostOppL != null) {
                    if (typeof object.goalpostOppL !== "object")
                        throw TypeError(".message.support.FieldDescription.goalpostOppL: object expected");
                    message.goalpostOppL = $root.vec2.fromObject(object.goalpostOppL);
                }
                if (object.goalpostOppR != null) {
                    if (typeof object.goalpostOppR !== "object")
                        throw TypeError(".message.support.FieldDescription.goalpostOppR: object expected");
                    message.goalpostOppR = $root.vec2.fromObject(object.goalpostOppR);
                }
                if (object.dimensions != null) {
                    if (typeof object.dimensions !== "object")
                        throw TypeError(".message.support.FieldDescription.dimensions: object expected");
                    message.dimensions = $root.message.support.FieldDescription.FieldDimensions.fromObject(object.dimensions);
                }
                return message;
            };

            /**
             * Creates a FieldDescription message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.support.FieldDescription.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.FieldDescription} FieldDescription
             */
            FieldDescription.from = FieldDescription.fromObject;

            /**
             * Creates a plain object from a FieldDescription message. Also converts values to other types if specified.
             * @param {message.support.FieldDescription} message FieldDescription
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.ballRadius = 0;
                    object.goalpostTopHeight = 0;
                    object.penaltyRobotStart = 0;
                    object.goalpostOwnL = null;
                    object.goalpostOwnR = null;
                    object.goalpostOppL = null;
                    object.goalpostOppR = null;
                    object.dimensions = null;
                }
                if (message.ballRadius != null && message.hasOwnProperty("ballRadius"))
                    object.ballRadius = message.ballRadius;
                if (message.goalpostTopHeight != null && message.hasOwnProperty("goalpostTopHeight"))
                    object.goalpostTopHeight = message.goalpostTopHeight;
                if (message.penaltyRobotStart != null && message.hasOwnProperty("penaltyRobotStart"))
                    object.penaltyRobotStart = message.penaltyRobotStart;
                if (message.goalpostOwnL != null && message.hasOwnProperty("goalpostOwnL"))
                    object.goalpostOwnL = $root.vec2.toObject(message.goalpostOwnL, options);
                if (message.goalpostOwnR != null && message.hasOwnProperty("goalpostOwnR"))
                    object.goalpostOwnR = $root.vec2.toObject(message.goalpostOwnR, options);
                if (message.goalpostOppL != null && message.hasOwnProperty("goalpostOppL"))
                    object.goalpostOppL = $root.vec2.toObject(message.goalpostOppL, options);
                if (message.goalpostOppR != null && message.hasOwnProperty("goalpostOppR"))
                    object.goalpostOppR = $root.vec2.toObject(message.goalpostOppR, options);
                if (message.dimensions != null && message.hasOwnProperty("dimensions"))
                    object.dimensions = $root.message.support.FieldDescription.FieldDimensions.toObject(message.dimensions, options);
                return object;
            };

            /**
             * Creates a plain object from this FieldDescription message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescription.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FieldDescription to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * GoalpostType enum.
             * @name GoalpostType
             * @memberof message.support.FieldDescription
             * @enum {number}
             * @property {number} RECTANGLE=0 RECTANGLE value
             * @property {number} CIRCLE=1 CIRCLE value
             */
            FieldDescription.GoalpostType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "RECTANGLE"] = 0;
                values[valuesById[1] = "CIRCLE"] = 1;
                return values;
            })();

            FieldDescription.FieldDimensions = (function() {

                /**
                 * Properties of a FieldDimensions.
                 * @typedef message.support.FieldDescription.FieldDimensions$Properties
                 * @type {Object}
                 * @property {number} [lineWidth] FieldDimensions lineWidth.
                 * @property {number} [markWidth] FieldDimensions markWidth.
                 * @property {number} [fieldLength] FieldDimensions fieldLength.
                 * @property {number} [fieldWidth] FieldDimensions fieldWidth.
                 * @property {message.support.FieldDescription.GoalpostType} [goalpostType] FieldDimensions goalpostType.
                 * @property {number} [goalDepth] FieldDimensions goalDepth.
                 * @property {number} [goalWidth] FieldDimensions goalWidth.
                 * @property {number} [goalAreaLength] FieldDimensions goalAreaLength.
                 * @property {number} [goalAreaWidth] FieldDimensions goalAreaWidth.
                 * @property {number} [goalCrossbarHeight] FieldDimensions goalCrossbarHeight.
                 * @property {number} [goalpostWidth] FieldDimensions goalpostWidth.
                 * @property {number} [goalpostDepth] FieldDimensions goalpostDepth.
                 * @property {number} [goalCrossbarWidth] FieldDimensions goalCrossbarWidth.
                 * @property {number} [goalCrossbarDepth] FieldDimensions goalCrossbarDepth.
                 * @property {number} [goalNetHeight] FieldDimensions goalNetHeight.
                 * @property {number} [penaltyMarkDistance] FieldDimensions penaltyMarkDistance.
                 * @property {number} [centerCircleDiameter] FieldDimensions centerCircleDiameter.
                 * @property {number} [borderStripMinWidth] FieldDimensions borderStripMinWidth.
                 */

                /**
                 * Constructs a new FieldDimensions.
                 * @exports message.support.FieldDescription.FieldDimensions
                 * @constructor
                 * @param {message.support.FieldDescription.FieldDimensions$Properties=} [properties] Properties to set
                 */
                function FieldDimensions(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FieldDimensions lineWidth.
                 * @type {number}
                 */
                FieldDimensions.prototype.lineWidth = 0;

                /**
                 * FieldDimensions markWidth.
                 * @type {number}
                 */
                FieldDimensions.prototype.markWidth = 0;

                /**
                 * FieldDimensions fieldLength.
                 * @type {number}
                 */
                FieldDimensions.prototype.fieldLength = 0;

                /**
                 * FieldDimensions fieldWidth.
                 * @type {number}
                 */
                FieldDimensions.prototype.fieldWidth = 0;

                /**
                 * FieldDimensions goalpostType.
                 * @type {message.support.FieldDescription.GoalpostType}
                 */
                FieldDimensions.prototype.goalpostType = 0;

                /**
                 * FieldDimensions goalDepth.
                 * @type {number}
                 */
                FieldDimensions.prototype.goalDepth = 0;

                /**
                 * FieldDimensions goalWidth.
                 * @type {number}
                 */
                FieldDimensions.prototype.goalWidth = 0;

                /**
                 * FieldDimensions goalAreaLength.
                 * @type {number}
                 */
                FieldDimensions.prototype.goalAreaLength = 0;

                /**
                 * FieldDimensions goalAreaWidth.
                 * @type {number}
                 */
                FieldDimensions.prototype.goalAreaWidth = 0;

                /**
                 * FieldDimensions goalCrossbarHeight.
                 * @type {number}
                 */
                FieldDimensions.prototype.goalCrossbarHeight = 0;

                /**
                 * FieldDimensions goalpostWidth.
                 * @type {number}
                 */
                FieldDimensions.prototype.goalpostWidth = 0;

                /**
                 * FieldDimensions goalpostDepth.
                 * @type {number}
                 */
                FieldDimensions.prototype.goalpostDepth = 0;

                /**
                 * FieldDimensions goalCrossbarWidth.
                 * @type {number}
                 */
                FieldDimensions.prototype.goalCrossbarWidth = 0;

                /**
                 * FieldDimensions goalCrossbarDepth.
                 * @type {number}
                 */
                FieldDimensions.prototype.goalCrossbarDepth = 0;

                /**
                 * FieldDimensions goalNetHeight.
                 * @type {number}
                 */
                FieldDimensions.prototype.goalNetHeight = 0;

                /**
                 * FieldDimensions penaltyMarkDistance.
                 * @type {number}
                 */
                FieldDimensions.prototype.penaltyMarkDistance = 0;

                /**
                 * FieldDimensions centerCircleDiameter.
                 * @type {number}
                 */
                FieldDimensions.prototype.centerCircleDiameter = 0;

                /**
                 * FieldDimensions borderStripMinWidth.
                 * @type {number}
                 */
                FieldDimensions.prototype.borderStripMinWidth = 0;

                /**
                 * Creates a new FieldDimensions instance using the specified properties.
                 * @param {message.support.FieldDescription.FieldDimensions$Properties=} [properties] Properties to set
                 * @returns {message.support.FieldDescription.FieldDimensions} FieldDimensions instance
                 */
                FieldDimensions.create = function create(properties) {
                    return new FieldDimensions(properties);
                };

                /**
                 * Encodes the specified FieldDimensions message. Does not implicitly {@link message.support.FieldDescription.FieldDimensions.verify|verify} messages.
                 * @param {message.support.FieldDescription.FieldDimensions$Properties} message FieldDimensions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDimensions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.lineWidth != null && message.hasOwnProperty("lineWidth"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.lineWidth);
                    if (message.markWidth != null && message.hasOwnProperty("markWidth"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.markWidth);
                    if (message.fieldLength != null && message.hasOwnProperty("fieldLength"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.fieldLength);
                    if (message.fieldWidth != null && message.hasOwnProperty("fieldWidth"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.fieldWidth);
                    if (message.goalpostType != null && message.hasOwnProperty("goalpostType"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.goalpostType);
                    if (message.goalDepth != null && message.hasOwnProperty("goalDepth"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.goalDepth);
                    if (message.goalWidth != null && message.hasOwnProperty("goalWidth"))
                        writer.uint32(/* id 7, wireType 1 =*/57).double(message.goalWidth);
                    if (message.goalAreaLength != null && message.hasOwnProperty("goalAreaLength"))
                        writer.uint32(/* id 8, wireType 1 =*/65).double(message.goalAreaLength);
                    if (message.goalAreaWidth != null && message.hasOwnProperty("goalAreaWidth"))
                        writer.uint32(/* id 9, wireType 1 =*/73).double(message.goalAreaWidth);
                    if (message.goalCrossbarHeight != null && message.hasOwnProperty("goalCrossbarHeight"))
                        writer.uint32(/* id 10, wireType 1 =*/81).double(message.goalCrossbarHeight);
                    if (message.goalpostWidth != null && message.hasOwnProperty("goalpostWidth"))
                        writer.uint32(/* id 11, wireType 1 =*/89).double(message.goalpostWidth);
                    if (message.goalpostDepth != null && message.hasOwnProperty("goalpostDepth"))
                        writer.uint32(/* id 12, wireType 1 =*/97).double(message.goalpostDepth);
                    if (message.goalCrossbarWidth != null && message.hasOwnProperty("goalCrossbarWidth"))
                        writer.uint32(/* id 13, wireType 1 =*/105).double(message.goalCrossbarWidth);
                    if (message.goalCrossbarDepth != null && message.hasOwnProperty("goalCrossbarDepth"))
                        writer.uint32(/* id 14, wireType 1 =*/113).double(message.goalCrossbarDepth);
                    if (message.goalNetHeight != null && message.hasOwnProperty("goalNetHeight"))
                        writer.uint32(/* id 15, wireType 1 =*/121).double(message.goalNetHeight);
                    if (message.penaltyMarkDistance != null && message.hasOwnProperty("penaltyMarkDistance"))
                        writer.uint32(/* id 16, wireType 1 =*/129).double(message.penaltyMarkDistance);
                    if (message.centerCircleDiameter != null && message.hasOwnProperty("centerCircleDiameter"))
                        writer.uint32(/* id 17, wireType 1 =*/137).double(message.centerCircleDiameter);
                    if (message.borderStripMinWidth != null && message.hasOwnProperty("borderStripMinWidth"))
                        writer.uint32(/* id 18, wireType 1 =*/145).double(message.borderStripMinWidth);
                    return writer;
                };

                /**
                 * Encodes the specified FieldDimensions message, length delimited. Does not implicitly {@link message.support.FieldDescription.FieldDimensions.verify|verify} messages.
                 * @param {message.support.FieldDescription.FieldDimensions$Properties} message FieldDimensions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDimensions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FieldDimensions message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.FieldDescription.FieldDimensions} FieldDimensions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDimensions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.FieldDescription.FieldDimensions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.lineWidth = reader.double();
                            break;
                        case 2:
                            message.markWidth = reader.double();
                            break;
                        case 3:
                            message.fieldLength = reader.double();
                            break;
                        case 4:
                            message.fieldWidth = reader.double();
                            break;
                        case 5:
                            message.goalpostType = reader.uint32();
                            break;
                        case 6:
                            message.goalDepth = reader.double();
                            break;
                        case 7:
                            message.goalWidth = reader.double();
                            break;
                        case 8:
                            message.goalAreaLength = reader.double();
                            break;
                        case 9:
                            message.goalAreaWidth = reader.double();
                            break;
                        case 10:
                            message.goalCrossbarHeight = reader.double();
                            break;
                        case 11:
                            message.goalpostWidth = reader.double();
                            break;
                        case 12:
                            message.goalpostDepth = reader.double();
                            break;
                        case 13:
                            message.goalCrossbarWidth = reader.double();
                            break;
                        case 14:
                            message.goalCrossbarDepth = reader.double();
                            break;
                        case 15:
                            message.goalNetHeight = reader.double();
                            break;
                        case 16:
                            message.penaltyMarkDistance = reader.double();
                            break;
                        case 17:
                            message.centerCircleDiameter = reader.double();
                            break;
                        case 18:
                            message.borderStripMinWidth = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FieldDimensions message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.FieldDescription.FieldDimensions} FieldDimensions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDimensions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FieldDimensions message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                FieldDimensions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.lineWidth != null && message.hasOwnProperty("lineWidth"))
                        if (typeof message.lineWidth !== "number")
                            return "lineWidth: number expected";
                    if (message.markWidth != null && message.hasOwnProperty("markWidth"))
                        if (typeof message.markWidth !== "number")
                            return "markWidth: number expected";
                    if (message.fieldLength != null && message.hasOwnProperty("fieldLength"))
                        if (typeof message.fieldLength !== "number")
                            return "fieldLength: number expected";
                    if (message.fieldWidth != null && message.hasOwnProperty("fieldWidth"))
                        if (typeof message.fieldWidth !== "number")
                            return "fieldWidth: number expected";
                    if (message.goalpostType != null && message.hasOwnProperty("goalpostType"))
                        switch (message.goalpostType) {
                        default:
                            return "goalpostType: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.goalDepth != null && message.hasOwnProperty("goalDepth"))
                        if (typeof message.goalDepth !== "number")
                            return "goalDepth: number expected";
                    if (message.goalWidth != null && message.hasOwnProperty("goalWidth"))
                        if (typeof message.goalWidth !== "number")
                            return "goalWidth: number expected";
                    if (message.goalAreaLength != null && message.hasOwnProperty("goalAreaLength"))
                        if (typeof message.goalAreaLength !== "number")
                            return "goalAreaLength: number expected";
                    if (message.goalAreaWidth != null && message.hasOwnProperty("goalAreaWidth"))
                        if (typeof message.goalAreaWidth !== "number")
                            return "goalAreaWidth: number expected";
                    if (message.goalCrossbarHeight != null && message.hasOwnProperty("goalCrossbarHeight"))
                        if (typeof message.goalCrossbarHeight !== "number")
                            return "goalCrossbarHeight: number expected";
                    if (message.goalpostWidth != null && message.hasOwnProperty("goalpostWidth"))
                        if (typeof message.goalpostWidth !== "number")
                            return "goalpostWidth: number expected";
                    if (message.goalpostDepth != null && message.hasOwnProperty("goalpostDepth"))
                        if (typeof message.goalpostDepth !== "number")
                            return "goalpostDepth: number expected";
                    if (message.goalCrossbarWidth != null && message.hasOwnProperty("goalCrossbarWidth"))
                        if (typeof message.goalCrossbarWidth !== "number")
                            return "goalCrossbarWidth: number expected";
                    if (message.goalCrossbarDepth != null && message.hasOwnProperty("goalCrossbarDepth"))
                        if (typeof message.goalCrossbarDepth !== "number")
                            return "goalCrossbarDepth: number expected";
                    if (message.goalNetHeight != null && message.hasOwnProperty("goalNetHeight"))
                        if (typeof message.goalNetHeight !== "number")
                            return "goalNetHeight: number expected";
                    if (message.penaltyMarkDistance != null && message.hasOwnProperty("penaltyMarkDistance"))
                        if (typeof message.penaltyMarkDistance !== "number")
                            return "penaltyMarkDistance: number expected";
                    if (message.centerCircleDiameter != null && message.hasOwnProperty("centerCircleDiameter"))
                        if (typeof message.centerCircleDiameter !== "number")
                            return "centerCircleDiameter: number expected";
                    if (message.borderStripMinWidth != null && message.hasOwnProperty("borderStripMinWidth"))
                        if (typeof message.borderStripMinWidth !== "number")
                            return "borderStripMinWidth: number expected";
                    return null;
                };

                /**
                 * Creates a FieldDimensions message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.FieldDescription.FieldDimensions} FieldDimensions
                 */
                FieldDimensions.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.FieldDescription.FieldDimensions)
                        return object;
                    var message = new $root.message.support.FieldDescription.FieldDimensions();
                    if (object.lineWidth != null)
                        message.lineWidth = Number(object.lineWidth);
                    if (object.markWidth != null)
                        message.markWidth = Number(object.markWidth);
                    if (object.fieldLength != null)
                        message.fieldLength = Number(object.fieldLength);
                    if (object.fieldWidth != null)
                        message.fieldWidth = Number(object.fieldWidth);
                    switch (object.goalpostType) {
                    case "RECTANGLE":
                    case 0:
                        message.goalpostType = 0;
                        break;
                    case "CIRCLE":
                    case 1:
                        message.goalpostType = 1;
                        break;
                    }
                    if (object.goalDepth != null)
                        message.goalDepth = Number(object.goalDepth);
                    if (object.goalWidth != null)
                        message.goalWidth = Number(object.goalWidth);
                    if (object.goalAreaLength != null)
                        message.goalAreaLength = Number(object.goalAreaLength);
                    if (object.goalAreaWidth != null)
                        message.goalAreaWidth = Number(object.goalAreaWidth);
                    if (object.goalCrossbarHeight != null)
                        message.goalCrossbarHeight = Number(object.goalCrossbarHeight);
                    if (object.goalpostWidth != null)
                        message.goalpostWidth = Number(object.goalpostWidth);
                    if (object.goalpostDepth != null)
                        message.goalpostDepth = Number(object.goalpostDepth);
                    if (object.goalCrossbarWidth != null)
                        message.goalCrossbarWidth = Number(object.goalCrossbarWidth);
                    if (object.goalCrossbarDepth != null)
                        message.goalCrossbarDepth = Number(object.goalCrossbarDepth);
                    if (object.goalNetHeight != null)
                        message.goalNetHeight = Number(object.goalNetHeight);
                    if (object.penaltyMarkDistance != null)
                        message.penaltyMarkDistance = Number(object.penaltyMarkDistance);
                    if (object.centerCircleDiameter != null)
                        message.centerCircleDiameter = Number(object.centerCircleDiameter);
                    if (object.borderStripMinWidth != null)
                        message.borderStripMinWidth = Number(object.borderStripMinWidth);
                    return message;
                };

                /**
                 * Creates a FieldDimensions message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.FieldDescription.FieldDimensions.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.FieldDescription.FieldDimensions} FieldDimensions
                 */
                FieldDimensions.from = FieldDimensions.fromObject;

                /**
                 * Creates a plain object from a FieldDimensions message. Also converts values to other types if specified.
                 * @param {message.support.FieldDescription.FieldDimensions} message FieldDimensions
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldDimensions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.lineWidth = 0;
                        object.markWidth = 0;
                        object.fieldLength = 0;
                        object.fieldWidth = 0;
                        object.goalpostType = options.enums === String ? "RECTANGLE" : 0;
                        object.goalDepth = 0;
                        object.goalWidth = 0;
                        object.goalAreaLength = 0;
                        object.goalAreaWidth = 0;
                        object.goalCrossbarHeight = 0;
                        object.goalpostWidth = 0;
                        object.goalpostDepth = 0;
                        object.goalCrossbarWidth = 0;
                        object.goalCrossbarDepth = 0;
                        object.goalNetHeight = 0;
                        object.penaltyMarkDistance = 0;
                        object.centerCircleDiameter = 0;
                        object.borderStripMinWidth = 0;
                    }
                    if (message.lineWidth != null && message.hasOwnProperty("lineWidth"))
                        object.lineWidth = message.lineWidth;
                    if (message.markWidth != null && message.hasOwnProperty("markWidth"))
                        object.markWidth = message.markWidth;
                    if (message.fieldLength != null && message.hasOwnProperty("fieldLength"))
                        object.fieldLength = message.fieldLength;
                    if (message.fieldWidth != null && message.hasOwnProperty("fieldWidth"))
                        object.fieldWidth = message.fieldWidth;
                    if (message.goalpostType != null && message.hasOwnProperty("goalpostType"))
                        object.goalpostType = options.enums === String ? $root.message.support.FieldDescription.GoalpostType[message.goalpostType] : message.goalpostType;
                    if (message.goalDepth != null && message.hasOwnProperty("goalDepth"))
                        object.goalDepth = message.goalDepth;
                    if (message.goalWidth != null && message.hasOwnProperty("goalWidth"))
                        object.goalWidth = message.goalWidth;
                    if (message.goalAreaLength != null && message.hasOwnProperty("goalAreaLength"))
                        object.goalAreaLength = message.goalAreaLength;
                    if (message.goalAreaWidth != null && message.hasOwnProperty("goalAreaWidth"))
                        object.goalAreaWidth = message.goalAreaWidth;
                    if (message.goalCrossbarHeight != null && message.hasOwnProperty("goalCrossbarHeight"))
                        object.goalCrossbarHeight = message.goalCrossbarHeight;
                    if (message.goalpostWidth != null && message.hasOwnProperty("goalpostWidth"))
                        object.goalpostWidth = message.goalpostWidth;
                    if (message.goalpostDepth != null && message.hasOwnProperty("goalpostDepth"))
                        object.goalpostDepth = message.goalpostDepth;
                    if (message.goalCrossbarWidth != null && message.hasOwnProperty("goalCrossbarWidth"))
                        object.goalCrossbarWidth = message.goalCrossbarWidth;
                    if (message.goalCrossbarDepth != null && message.hasOwnProperty("goalCrossbarDepth"))
                        object.goalCrossbarDepth = message.goalCrossbarDepth;
                    if (message.goalNetHeight != null && message.hasOwnProperty("goalNetHeight"))
                        object.goalNetHeight = message.goalNetHeight;
                    if (message.penaltyMarkDistance != null && message.hasOwnProperty("penaltyMarkDistance"))
                        object.penaltyMarkDistance = message.penaltyMarkDistance;
                    if (message.centerCircleDiameter != null && message.hasOwnProperty("centerCircleDiameter"))
                        object.centerCircleDiameter = message.centerCircleDiameter;
                    if (message.borderStripMinWidth != null && message.hasOwnProperty("borderStripMinWidth"))
                        object.borderStripMinWidth = message.borderStripMinWidth;
                    return object;
                };

                /**
                 * Creates a plain object from this FieldDimensions message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldDimensions.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this FieldDimensions to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldDimensions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FieldDimensions;
            })();

            return FieldDescription;
        })();

        support.GlobalConfig = (function() {

            /**
             * Properties of a GlobalConfig.
             * @typedef message.support.GlobalConfig$Properties
             * @type {Object}
             * @property {number} [playerId] GlobalConfig playerId.
             * @property {number} [teamId] GlobalConfig teamId.
             */

            /**
             * Constructs a new GlobalConfig.
             * @exports message.support.GlobalConfig
             * @constructor
             * @param {message.support.GlobalConfig$Properties=} [properties] Properties to set
             */
            function GlobalConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GlobalConfig playerId.
             * @type {number}
             */
            GlobalConfig.prototype.playerId = 0;

            /**
             * GlobalConfig teamId.
             * @type {number}
             */
            GlobalConfig.prototype.teamId = 0;

            /**
             * Creates a new GlobalConfig instance using the specified properties.
             * @param {message.support.GlobalConfig$Properties=} [properties] Properties to set
             * @returns {message.support.GlobalConfig} GlobalConfig instance
             */
            GlobalConfig.create = function create(properties) {
                return new GlobalConfig(properties);
            };

            /**
             * Encodes the specified GlobalConfig message. Does not implicitly {@link message.support.GlobalConfig.verify|verify} messages.
             * @param {message.support.GlobalConfig$Properties} message GlobalConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.playerId != null && message.hasOwnProperty("playerId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.playerId);
                if (message.teamId != null && message.hasOwnProperty("teamId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.teamId);
                return writer;
            };

            /**
             * Encodes the specified GlobalConfig message, length delimited. Does not implicitly {@link message.support.GlobalConfig.verify|verify} messages.
             * @param {message.support.GlobalConfig$Properties} message GlobalConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GlobalConfig message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.support.GlobalConfig} GlobalConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.GlobalConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.playerId = reader.uint32();
                        break;
                    case 2:
                        message.teamId = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GlobalConfig message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.support.GlobalConfig} GlobalConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GlobalConfig message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            GlobalConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.playerId != null && message.hasOwnProperty("playerId"))
                    if (!$util.isInteger(message.playerId))
                        return "playerId: integer expected";
                if (message.teamId != null && message.hasOwnProperty("teamId"))
                    if (!$util.isInteger(message.teamId))
                        return "teamId: integer expected";
                return null;
            };

            /**
             * Creates a GlobalConfig message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.GlobalConfig} GlobalConfig
             */
            GlobalConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.message.support.GlobalConfig)
                    return object;
                var message = new $root.message.support.GlobalConfig();
                if (object.playerId != null)
                    message.playerId = object.playerId >>> 0;
                if (object.teamId != null)
                    message.teamId = object.teamId >>> 0;
                return message;
            };

            /**
             * Creates a GlobalConfig message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.support.GlobalConfig.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.GlobalConfig} GlobalConfig
             */
            GlobalConfig.from = GlobalConfig.fromObject;

            /**
             * Creates a plain object from a GlobalConfig message. Also converts values to other types if specified.
             * @param {message.support.GlobalConfig} message GlobalConfig
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GlobalConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.playerId = 0;
                    object.teamId = 0;
                }
                if (message.playerId != null && message.hasOwnProperty("playerId"))
                    object.playerId = message.playerId;
                if (message.teamId != null && message.hasOwnProperty("teamId"))
                    object.teamId = message.teamId;
                return object;
            };

            /**
             * Creates a plain object from this GlobalConfig message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GlobalConfig.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this GlobalConfig to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            GlobalConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GlobalConfig;
        })();

        support.nubugger = (function() {

            /**
             * Namespace nubugger.
             * @exports message.support.nubugger
             * @namespace
             */
            var nubugger = {};

            nubugger.Command = (function() {

                /**
                 * Properties of a Command.
                 * @typedef message.support.nubugger.Command$Properties
                 * @type {Object}
                 * @property {string} [command] Command command.
                 */

                /**
                 * Constructs a new Command.
                 * @exports message.support.nubugger.Command
                 * @constructor
                 * @param {message.support.nubugger.Command$Properties=} [properties] Properties to set
                 */
                function Command(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Command command.
                 * @type {string}
                 */
                Command.prototype.command = "";

                /**
                 * Creates a new Command instance using the specified properties.
                 * @param {message.support.nubugger.Command$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.Command} Command instance
                 */
                Command.create = function create(properties) {
                    return new Command(properties);
                };

                /**
                 * Encodes the specified Command message. Does not implicitly {@link message.support.nubugger.Command.verify|verify} messages.
                 * @param {message.support.nubugger.Command$Properties} message Command message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Command.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.command != null && message.hasOwnProperty("command"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                    return writer;
                };

                /**
                 * Encodes the specified Command message, length delimited. Does not implicitly {@link message.support.nubugger.Command.verify|verify} messages.
                 * @param {message.support.nubugger.Command$Properties} message Command message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Command.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Command message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.Command} Command
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Command.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nubugger.Command();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.command = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Command message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.Command} Command
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Command.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Command message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Command.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.command != null && message.hasOwnProperty("command"))
                        if (!$util.isString(message.command))
                            return "command: string expected";
                    return null;
                };

                /**
                 * Creates a Command message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.Command} Command
                 */
                Command.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.nubugger.Command)
                        return object;
                    var message = new $root.message.support.nubugger.Command();
                    if (object.command != null)
                        message.command = String(object.command);
                    return message;
                };

                /**
                 * Creates a Command message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.Command.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.Command} Command
                 */
                Command.from = Command.fromObject;

                /**
                 * Creates a plain object from a Command message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.Command} message Command
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Command.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.command = "";
                    if (message.command != null && message.hasOwnProperty("command"))
                        object.command = message.command;
                    return object;
                };

                /**
                 * Creates a plain object from this Command message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Command.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Command to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Command.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Command;
            })();

            nubugger.DataPoint = (function() {

                /**
                 * Properties of a DataPoint.
                 * @typedef message.support.nubugger.DataPoint$Properties
                 * @type {Object}
                 * @property {string} [label] DataPoint label.
                 * @property {Array.<number>} [value] DataPoint value.
                 * @property {google.protobuf.Timestamp$Properties} [timestamp] DataPoint timestamp.
                 */

                /**
                 * Constructs a new DataPoint.
                 * @exports message.support.nubugger.DataPoint
                 * @constructor
                 * @param {message.support.nubugger.DataPoint$Properties=} [properties] Properties to set
                 */
                function DataPoint(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DataPoint label.
                 * @type {string}
                 */
                DataPoint.prototype.label = "";

                /**
                 * DataPoint value.
                 * @type {Array.<number>}
                 */
                DataPoint.prototype.value = $util.emptyArray;

                /**
                 * DataPoint timestamp.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                DataPoint.prototype.timestamp = null;

                /**
                 * Creates a new DataPoint instance using the specified properties.
                 * @param {message.support.nubugger.DataPoint$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.DataPoint} DataPoint instance
                 */
                DataPoint.create = function create(properties) {
                    return new DataPoint(properties);
                };

                /**
                 * Encodes the specified DataPoint message. Does not implicitly {@link message.support.nubugger.DataPoint.verify|verify} messages.
                 * @param {message.support.nubugger.DataPoint$Properties} message DataPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataPoint.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.label != null && message.hasOwnProperty("label"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
                    if (message.value != null && message.value.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.value.length; ++i)
                            writer.float(message.value[i]);
                        writer.ldelim();
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified DataPoint message, length delimited. Does not implicitly {@link message.support.nubugger.DataPoint.verify|verify} messages.
                 * @param {message.support.nubugger.DataPoint$Properties} message DataPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DataPoint.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DataPoint message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.DataPoint} DataPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataPoint.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nubugger.DataPoint();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.label = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.value.push(reader.float());
                            } else
                                message.value.push(reader.float());
                            break;
                        case 4:
                            message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DataPoint message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.DataPoint} DataPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DataPoint.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DataPoint message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                DataPoint.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i)
                            if (typeof message.value[i] !== "number")
                                return "value: number[] expected";
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DataPoint message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.DataPoint} DataPoint
                 */
                DataPoint.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.nubugger.DataPoint)
                        return object;
                    var message = new $root.message.support.nubugger.DataPoint();
                    if (object.label != null)
                        message.label = String(object.label);
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".message.support.nubugger.DataPoint.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i)
                            message.value[i] = Number(object.value[i]);
                    }
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".message.support.nubugger.DataPoint.timestamp: object expected");
                        message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                    }
                    return message;
                };

                /**
                 * Creates a DataPoint message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.DataPoint.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.DataPoint} DataPoint
                 */
                DataPoint.from = DataPoint.fromObject;

                /**
                 * Creates a plain object from a DataPoint message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.DataPoint} message DataPoint
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DataPoint.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (options.defaults) {
                        object.label = "";
                        object.timestamp = null;
                    }
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = message.value[j];
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                    return object;
                };

                /**
                 * Creates a plain object from this DataPoint message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DataPoint.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this DataPoint to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                DataPoint.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DataPoint;
            })();

            nubugger.DrawObject = (function() {

                /**
                 * Properties of a DrawObject.
                 * @typedef message.support.nubugger.DrawObject$Properties
                 * @type {Object}
                 * @property {message.support.nubugger.DrawObject.Shape} [shape] DrawObject shape.
                 * @property {string} [name] DrawObject name.
                 * @property {vec3$Properties} [position] DrawObject position.
                 * @property {vec3$Properties} [direction] DrawObject direction.
                 * @property {vec3$Properties} [target] DrawObject target.
                 * @property {number} [width] DrawObject width.
                 * @property {number} [height] DrawObject height.
                 * @property {vec3$Properties} [rotation] DrawObject rotation.
                 * @property {vec3$Properties} [colour] DrawObject colour.
                 * @property {number} [radius] DrawObject radius.
                 * @property {number} [topRadius] DrawObject topRadius.
                 * @property {number} [bottomRadius] DrawObject bottomRadius.
                 * @property {Array.<vec3$Properties>} [vertices] DrawObject vertices.
                 * @property {Array.<message.support.nubugger.DrawObject.Path$Properties>} [path] DrawObject path.
                 * @property {number} [faces] DrawObject faces.
                 * @property {number} [lineWidth] DrawObject lineWidth.
                 * @property {number} [length] DrawObject length.
                 * @property {number} [depth] DrawObject depth.
                 * @property {boolean} [fill] DrawObject fill.
                 * @property {number} [timeout] DrawObject timeout.
                 */

                /**
                 * Constructs a new DrawObject.
                 * @exports message.support.nubugger.DrawObject
                 * @constructor
                 * @param {message.support.nubugger.DrawObject$Properties=} [properties] Properties to set
                 */
                function DrawObject(properties) {
                    this.vertices = [];
                    this.path = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DrawObject shape.
                 * @type {message.support.nubugger.DrawObject.Shape}
                 */
                DrawObject.prototype.shape = 0;

                /**
                 * DrawObject name.
                 * @type {string}
                 */
                DrawObject.prototype.name = "";

                /**
                 * DrawObject position.
                 * @type {(vec3$Properties|null)}
                 */
                DrawObject.prototype.position = null;

                /**
                 * DrawObject direction.
                 * @type {(vec3$Properties|null)}
                 */
                DrawObject.prototype.direction = null;

                /**
                 * DrawObject target.
                 * @type {(vec3$Properties|null)}
                 */
                DrawObject.prototype.target = null;

                /**
                 * DrawObject width.
                 * @type {number}
                 */
                DrawObject.prototype.width = 0;

                /**
                 * DrawObject height.
                 * @type {number}
                 */
                DrawObject.prototype.height = 0;

                /**
                 * DrawObject rotation.
                 * @type {(vec3$Properties|null)}
                 */
                DrawObject.prototype.rotation = null;

                /**
                 * DrawObject colour.
                 * @type {(vec3$Properties|null)}
                 */
                DrawObject.prototype.colour = null;

                /**
                 * DrawObject radius.
                 * @type {number}
                 */
                DrawObject.prototype.radius = 0;

                /**
                 * DrawObject topRadius.
                 * @type {number}
                 */
                DrawObject.prototype.topRadius = 0;

                /**
                 * DrawObject bottomRadius.
                 * @type {number}
                 */
                DrawObject.prototype.bottomRadius = 0;

                /**
                 * DrawObject vertices.
                 * @type {Array.<vec3$Properties>}
                 */
                DrawObject.prototype.vertices = $util.emptyArray;

                /**
                 * DrawObject path.
                 * @type {Array.<message.support.nubugger.DrawObject.Path$Properties>}
                 */
                DrawObject.prototype.path = $util.emptyArray;

                /**
                 * DrawObject faces.
                 * @type {number}
                 */
                DrawObject.prototype.faces = 0;

                /**
                 * DrawObject lineWidth.
                 * @type {number}
                 */
                DrawObject.prototype.lineWidth = 0;

                /**
                 * DrawObject length.
                 * @type {number}
                 */
                DrawObject.prototype.length = 0;

                /**
                 * DrawObject depth.
                 * @type {number}
                 */
                DrawObject.prototype.depth = 0;

                /**
                 * DrawObject fill.
                 * @type {boolean}
                 */
                DrawObject.prototype.fill = false;

                /**
                 * DrawObject timeout.
                 * @type {number}
                 */
                DrawObject.prototype.timeout = 0;

                /**
                 * Creates a new DrawObject instance using the specified properties.
                 * @param {message.support.nubugger.DrawObject$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.DrawObject} DrawObject instance
                 */
                DrawObject.create = function create(properties) {
                    return new DrawObject(properties);
                };

                /**
                 * Encodes the specified DrawObject message. Does not implicitly {@link message.support.nubugger.DrawObject.verify|verify} messages.
                 * @param {message.support.nubugger.DrawObject$Properties} message DrawObject message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DrawObject.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.shape != null && message.hasOwnProperty("shape"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.shape);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.position != null && message.hasOwnProperty("position"))
                        $root.vec3.encode(message.position, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.direction != null && message.hasOwnProperty("direction"))
                        $root.vec3.encode(message.direction, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.target != null && message.hasOwnProperty("target"))
                        $root.vec3.encode(message.target, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.width != null && message.hasOwnProperty("width"))
                        writer.uint32(/* id 6, wireType 5 =*/53).float(message.width);
                    if (message.height != null && message.hasOwnProperty("height"))
                        writer.uint32(/* id 7, wireType 5 =*/61).float(message.height);
                    if (message.rotation != null && message.hasOwnProperty("rotation"))
                        $root.vec3.encode(message.rotation, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.colour != null && message.hasOwnProperty("colour"))
                        $root.vec3.encode(message.colour, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.radius != null && message.hasOwnProperty("radius"))
                        writer.uint32(/* id 10, wireType 5 =*/85).float(message.radius);
                    if (message.topRadius != null && message.hasOwnProperty("topRadius"))
                        writer.uint32(/* id 11, wireType 5 =*/93).float(message.topRadius);
                    if (message.bottomRadius != null && message.hasOwnProperty("bottomRadius"))
                        writer.uint32(/* id 12, wireType 5 =*/101).float(message.bottomRadius);
                    if (message.vertices != null && message.vertices.length)
                        for (var i = 0; i < message.vertices.length; ++i)
                            $root.vec3.encode(message.vertices[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if (message.path != null && message.path.length)
                        for (var i = 0; i < message.path.length; ++i)
                            $root.message.support.nubugger.DrawObject.Path.encode(message.path[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.faces != null && message.hasOwnProperty("faces"))
                        writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.faces);
                    if (message.lineWidth != null && message.hasOwnProperty("lineWidth"))
                        writer.uint32(/* id 16, wireType 5 =*/133).float(message.lineWidth);
                    if (message.length != null && message.hasOwnProperty("length"))
                        writer.uint32(/* id 17, wireType 5 =*/141).float(message.length);
                    if (message.depth != null && message.hasOwnProperty("depth"))
                        writer.uint32(/* id 18, wireType 5 =*/149).float(message.depth);
                    if (message.fill != null && message.hasOwnProperty("fill"))
                        writer.uint32(/* id 19, wireType 0 =*/152).bool(message.fill);
                    if (message.timeout != null && message.hasOwnProperty("timeout"))
                        writer.uint32(/* id 20, wireType 5 =*/165).float(message.timeout);
                    return writer;
                };

                /**
                 * Encodes the specified DrawObject message, length delimited. Does not implicitly {@link message.support.nubugger.DrawObject.verify|verify} messages.
                 * @param {message.support.nubugger.DrawObject$Properties} message DrawObject message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DrawObject.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DrawObject message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.DrawObject} DrawObject
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DrawObject.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nubugger.DrawObject();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.shape = reader.uint32();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.position = $root.vec3.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.direction = $root.vec3.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.target = $root.vec3.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.width = reader.float();
                            break;
                        case 7:
                            message.height = reader.float();
                            break;
                        case 8:
                            message.rotation = $root.vec3.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.colour = $root.vec3.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.radius = reader.float();
                            break;
                        case 11:
                            message.topRadius = reader.float();
                            break;
                        case 12:
                            message.bottomRadius = reader.float();
                            break;
                        case 13:
                            if (!(message.vertices && message.vertices.length))
                                message.vertices = [];
                            message.vertices.push($root.vec3.decode(reader, reader.uint32()));
                            break;
                        case 14:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            message.path.push($root.message.support.nubugger.DrawObject.Path.decode(reader, reader.uint32()));
                            break;
                        case 15:
                            message.faces = reader.uint32();
                            break;
                        case 16:
                            message.lineWidth = reader.float();
                            break;
                        case 17:
                            message.length = reader.float();
                            break;
                        case 18:
                            message.depth = reader.float();
                            break;
                        case 19:
                            message.fill = reader.bool();
                            break;
                        case 20:
                            message.timeout = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DrawObject message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.DrawObject} DrawObject
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DrawObject.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DrawObject message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                DrawObject.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.shape != null && message.hasOwnProperty("shape"))
                        switch (message.shape) {
                        default:
                            return "shape: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                            break;
                        }
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.position != null && message.hasOwnProperty("position")) {
                        var error = $root.vec3.verify(message.position);
                        if (error)
                            return "position." + error;
                    }
                    if (message.direction != null && message.hasOwnProperty("direction")) {
                        var error = $root.vec3.verify(message.direction);
                        if (error)
                            return "direction." + error;
                    }
                    if (message.target != null && message.hasOwnProperty("target")) {
                        var error = $root.vec3.verify(message.target);
                        if (error)
                            return "target." + error;
                    }
                    if (message.width != null && message.hasOwnProperty("width"))
                        if (typeof message.width !== "number")
                            return "width: number expected";
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (typeof message.height !== "number")
                            return "height: number expected";
                    if (message.rotation != null && message.hasOwnProperty("rotation")) {
                        var error = $root.vec3.verify(message.rotation);
                        if (error)
                            return "rotation." + error;
                    }
                    if (message.colour != null && message.hasOwnProperty("colour")) {
                        var error = $root.vec3.verify(message.colour);
                        if (error)
                            return "colour." + error;
                    }
                    if (message.radius != null && message.hasOwnProperty("radius"))
                        if (typeof message.radius !== "number")
                            return "radius: number expected";
                    if (message.topRadius != null && message.hasOwnProperty("topRadius"))
                        if (typeof message.topRadius !== "number")
                            return "topRadius: number expected";
                    if (message.bottomRadius != null && message.hasOwnProperty("bottomRadius"))
                        if (typeof message.bottomRadius !== "number")
                            return "bottomRadius: number expected";
                    if (message.vertices != null && message.hasOwnProperty("vertices")) {
                        if (!Array.isArray(message.vertices))
                            return "vertices: array expected";
                        for (var i = 0; i < message.vertices.length; ++i) {
                            var error = $root.vec3.verify(message.vertices[i]);
                            if (error)
                                return "vertices." + error;
                        }
                    }
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i) {
                            var error = $root.message.support.nubugger.DrawObject.Path.verify(message.path[i]);
                            if (error)
                                return "path." + error;
                        }
                    }
                    if (message.faces != null && message.hasOwnProperty("faces"))
                        if (!$util.isInteger(message.faces))
                            return "faces: integer expected";
                    if (message.lineWidth != null && message.hasOwnProperty("lineWidth"))
                        if (typeof message.lineWidth !== "number")
                            return "lineWidth: number expected";
                    if (message.length != null && message.hasOwnProperty("length"))
                        if (typeof message.length !== "number")
                            return "length: number expected";
                    if (message.depth != null && message.hasOwnProperty("depth"))
                        if (typeof message.depth !== "number")
                            return "depth: number expected";
                    if (message.fill != null && message.hasOwnProperty("fill"))
                        if (typeof message.fill !== "boolean")
                            return "fill: boolean expected";
                    if (message.timeout != null && message.hasOwnProperty("timeout"))
                        if (typeof message.timeout !== "number")
                            return "timeout: number expected";
                    return null;
                };

                /**
                 * Creates a DrawObject message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.DrawObject} DrawObject
                 */
                DrawObject.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.nubugger.DrawObject)
                        return object;
                    var message = new $root.message.support.nubugger.DrawObject();
                    switch (object.shape) {
                    case "UNKNOWN":
                    case 0:
                        message.shape = 0;
                        break;
                    case "ARROW":
                    case 1:
                        message.shape = 1;
                        break;
                    case "BOX":
                    case 2:
                        message.shape = 2;
                        break;
                    case "CIRCLE":
                    case 3:
                        message.shape = 3;
                        break;
                    case "CYLINDER":
                    case 4:
                        message.shape = 4;
                        break;
                    case "POLYLINE":
                    case 5:
                        message.shape = 5;
                        break;
                    case "PYRAMID":
                    case 6:
                        message.shape = 6;
                        break;
                    case "RECTANGLE":
                    case 7:
                        message.shape = 7;
                        break;
                    case "SPHERE":
                    case 8:
                        message.shape = 8;
                        break;
                    }
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.position != null) {
                        if (typeof object.position !== "object")
                            throw TypeError(".message.support.nubugger.DrawObject.position: object expected");
                        message.position = $root.vec3.fromObject(object.position);
                    }
                    if (object.direction != null) {
                        if (typeof object.direction !== "object")
                            throw TypeError(".message.support.nubugger.DrawObject.direction: object expected");
                        message.direction = $root.vec3.fromObject(object.direction);
                    }
                    if (object.target != null) {
                        if (typeof object.target !== "object")
                            throw TypeError(".message.support.nubugger.DrawObject.target: object expected");
                        message.target = $root.vec3.fromObject(object.target);
                    }
                    if (object.width != null)
                        message.width = Number(object.width);
                    if (object.height != null)
                        message.height = Number(object.height);
                    if (object.rotation != null) {
                        if (typeof object.rotation !== "object")
                            throw TypeError(".message.support.nubugger.DrawObject.rotation: object expected");
                        message.rotation = $root.vec3.fromObject(object.rotation);
                    }
                    if (object.colour != null) {
                        if (typeof object.colour !== "object")
                            throw TypeError(".message.support.nubugger.DrawObject.colour: object expected");
                        message.colour = $root.vec3.fromObject(object.colour);
                    }
                    if (object.radius != null)
                        message.radius = Number(object.radius);
                    if (object.topRadius != null)
                        message.topRadius = Number(object.topRadius);
                    if (object.bottomRadius != null)
                        message.bottomRadius = Number(object.bottomRadius);
                    if (object.vertices) {
                        if (!Array.isArray(object.vertices))
                            throw TypeError(".message.support.nubugger.DrawObject.vertices: array expected");
                        message.vertices = [];
                        for (var i = 0; i < object.vertices.length; ++i) {
                            if (typeof object.vertices[i] !== "object")
                                throw TypeError(".message.support.nubugger.DrawObject.vertices: object expected");
                            message.vertices[i] = $root.vec3.fromObject(object.vertices[i]);
                        }
                    }
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".message.support.nubugger.DrawObject.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i) {
                            if (typeof object.path[i] !== "object")
                                throw TypeError(".message.support.nubugger.DrawObject.path: object expected");
                            message.path[i] = $root.message.support.nubugger.DrawObject.Path.fromObject(object.path[i]);
                        }
                    }
                    if (object.faces != null)
                        message.faces = object.faces >>> 0;
                    if (object.lineWidth != null)
                        message.lineWidth = Number(object.lineWidth);
                    if (object.length != null)
                        message.length = Number(object.length);
                    if (object.depth != null)
                        message.depth = Number(object.depth);
                    if (object.fill != null)
                        message.fill = Boolean(object.fill);
                    if (object.timeout != null)
                        message.timeout = Number(object.timeout);
                    return message;
                };

                /**
                 * Creates a DrawObject message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.DrawObject.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.DrawObject} DrawObject
                 */
                DrawObject.from = DrawObject.fromObject;

                /**
                 * Creates a plain object from a DrawObject message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.DrawObject} message DrawObject
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DrawObject.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.vertices = [];
                        object.path = [];
                    }
                    if (options.defaults) {
                        object.shape = options.enums === String ? "UNKNOWN" : 0;
                        object.name = "";
                        object.position = null;
                        object.direction = null;
                        object.target = null;
                        object.width = 0;
                        object.height = 0;
                        object.rotation = null;
                        object.colour = null;
                        object.radius = 0;
                        object.topRadius = 0;
                        object.bottomRadius = 0;
                        object.faces = 0;
                        object.lineWidth = 0;
                        object.length = 0;
                        object.depth = 0;
                        object.fill = false;
                        object.timeout = 0;
                    }
                    if (message.shape != null && message.hasOwnProperty("shape"))
                        object.shape = options.enums === String ? $root.message.support.nubugger.DrawObject.Shape[message.shape] : message.shape;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.position != null && message.hasOwnProperty("position"))
                        object.position = $root.vec3.toObject(message.position, options);
                    if (message.direction != null && message.hasOwnProperty("direction"))
                        object.direction = $root.vec3.toObject(message.direction, options);
                    if (message.target != null && message.hasOwnProperty("target"))
                        object.target = $root.vec3.toObject(message.target, options);
                    if (message.width != null && message.hasOwnProperty("width"))
                        object.width = message.width;
                    if (message.height != null && message.hasOwnProperty("height"))
                        object.height = message.height;
                    if (message.rotation != null && message.hasOwnProperty("rotation"))
                        object.rotation = $root.vec3.toObject(message.rotation, options);
                    if (message.colour != null && message.hasOwnProperty("colour"))
                        object.colour = $root.vec3.toObject(message.colour, options);
                    if (message.radius != null && message.hasOwnProperty("radius"))
                        object.radius = message.radius;
                    if (message.topRadius != null && message.hasOwnProperty("topRadius"))
                        object.topRadius = message.topRadius;
                    if (message.bottomRadius != null && message.hasOwnProperty("bottomRadius"))
                        object.bottomRadius = message.bottomRadius;
                    if (message.vertices && message.vertices.length) {
                        object.vertices = [];
                        for (var j = 0; j < message.vertices.length; ++j)
                            object.vertices[j] = $root.vec3.toObject(message.vertices[j], options);
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = $root.message.support.nubugger.DrawObject.Path.toObject(message.path[j], options);
                    }
                    if (message.faces != null && message.hasOwnProperty("faces"))
                        object.faces = message.faces;
                    if (message.lineWidth != null && message.hasOwnProperty("lineWidth"))
                        object.lineWidth = message.lineWidth;
                    if (message.length != null && message.hasOwnProperty("length"))
                        object.length = message.length;
                    if (message.depth != null && message.hasOwnProperty("depth"))
                        object.depth = message.depth;
                    if (message.fill != null && message.hasOwnProperty("fill"))
                        object.fill = message.fill;
                    if (message.timeout != null && message.hasOwnProperty("timeout"))
                        object.timeout = message.timeout;
                    return object;
                };

                /**
                 * Creates a plain object from this DrawObject message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DrawObject.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this DrawObject to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                DrawObject.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Shape enum.
                 * @name Shape
                 * @memberof message.support.nubugger.DrawObject
                 * @enum {number}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} ARROW=1 ARROW value
                 * @property {number} BOX=2 BOX value
                 * @property {number} CIRCLE=3 CIRCLE value
                 * @property {number} CYLINDER=4 CYLINDER value
                 * @property {number} POLYLINE=5 POLYLINE value
                 * @property {number} PYRAMID=6 PYRAMID value
                 * @property {number} RECTANGLE=7 RECTANGLE value
                 * @property {number} SPHERE=8 SPHERE value
                 */
                DrawObject.Shape = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "ARROW"] = 1;
                    values[valuesById[2] = "BOX"] = 2;
                    values[valuesById[3] = "CIRCLE"] = 3;
                    values[valuesById[4] = "CYLINDER"] = 4;
                    values[valuesById[5] = "POLYLINE"] = 5;
                    values[valuesById[6] = "PYRAMID"] = 6;
                    values[valuesById[7] = "RECTANGLE"] = 7;
                    values[valuesById[8] = "SPHERE"] = 8;
                    return values;
                })();

                DrawObject.Path = (function() {

                    /**
                     * Properties of a Path.
                     * @typedef message.support.nubugger.DrawObject.Path$Properties
                     * @type {Object}
                     * @property {vec2$Properties} [position] Path position.
                     * @property {number} [parentIndex] Path parentIndex.
                     */

                    /**
                     * Constructs a new Path.
                     * @exports message.support.nubugger.DrawObject.Path
                     * @constructor
                     * @param {message.support.nubugger.DrawObject.Path$Properties=} [properties] Properties to set
                     */
                    function Path(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Path position.
                     * @type {(vec2$Properties|null)}
                     */
                    Path.prototype.position = null;

                    /**
                     * Path parentIndex.
                     * @type {number}
                     */
                    Path.prototype.parentIndex = 0;

                    /**
                     * Creates a new Path instance using the specified properties.
                     * @param {message.support.nubugger.DrawObject.Path$Properties=} [properties] Properties to set
                     * @returns {message.support.nubugger.DrawObject.Path} Path instance
                     */
                    Path.create = function create(properties) {
                        return new Path(properties);
                    };

                    /**
                     * Encodes the specified Path message. Does not implicitly {@link message.support.nubugger.DrawObject.Path.verify|verify} messages.
                     * @param {message.support.nubugger.DrawObject.Path$Properties} message Path message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Path.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.position != null && message.hasOwnProperty("position"))
                            $root.vec2.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.parentIndex != null && message.hasOwnProperty("parentIndex"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.parentIndex);
                        return writer;
                    };

                    /**
                     * Encodes the specified Path message, length delimited. Does not implicitly {@link message.support.nubugger.DrawObject.Path.verify|verify} messages.
                     * @param {message.support.nubugger.DrawObject.Path$Properties} message Path message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Path.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Path message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.support.nubugger.DrawObject.Path} Path
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Path.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nubugger.DrawObject.Path();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.position = $root.vec2.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.parentIndex = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Path message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.support.nubugger.DrawObject.Path} Path
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Path.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Path message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Path.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.position != null && message.hasOwnProperty("position")) {
                            var error = $root.vec2.verify(message.position);
                            if (error)
                                return "position." + error;
                        }
                        if (message.parentIndex != null && message.hasOwnProperty("parentIndex"))
                            if (!$util.isInteger(message.parentIndex))
                                return "parentIndex: integer expected";
                        return null;
                    };

                    /**
                     * Creates a Path message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.support.nubugger.DrawObject.Path} Path
                     */
                    Path.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.support.nubugger.DrawObject.Path)
                            return object;
                        var message = new $root.message.support.nubugger.DrawObject.Path();
                        if (object.position != null) {
                            if (typeof object.position !== "object")
                                throw TypeError(".message.support.nubugger.DrawObject.Path.position: object expected");
                            message.position = $root.vec2.fromObject(object.position);
                        }
                        if (object.parentIndex != null)
                            message.parentIndex = object.parentIndex >>> 0;
                        return message;
                    };

                    /**
                     * Creates a Path message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.support.nubugger.DrawObject.Path.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.support.nubugger.DrawObject.Path} Path
                     */
                    Path.from = Path.fromObject;

                    /**
                     * Creates a plain object from a Path message. Also converts values to other types if specified.
                     * @param {message.support.nubugger.DrawObject.Path} message Path
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Path.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.position = null;
                            object.parentIndex = 0;
                        }
                        if (message.position != null && message.hasOwnProperty("position"))
                            object.position = $root.vec2.toObject(message.position, options);
                        if (message.parentIndex != null && message.hasOwnProperty("parentIndex"))
                            object.parentIndex = message.parentIndex;
                        return object;
                    };

                    /**
                     * Creates a plain object from this Path message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Path.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Path to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Path.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Path;
                })();

                return DrawObject;
            })();

            nubugger.DrawObjects = (function() {

                /**
                 * Properties of a DrawObjects.
                 * @typedef message.support.nubugger.DrawObjects$Properties
                 * @type {Object}
                 * @property {Array.<message.support.nubugger.DrawObject$Properties>} [objects] DrawObjects objects.
                 */

                /**
                 * Constructs a new DrawObjects.
                 * @exports message.support.nubugger.DrawObjects
                 * @constructor
                 * @param {message.support.nubugger.DrawObjects$Properties=} [properties] Properties to set
                 */
                function DrawObjects(properties) {
                    this.objects = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DrawObjects objects.
                 * @type {Array.<message.support.nubugger.DrawObject$Properties>}
                 */
                DrawObjects.prototype.objects = $util.emptyArray;

                /**
                 * Creates a new DrawObjects instance using the specified properties.
                 * @param {message.support.nubugger.DrawObjects$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.DrawObjects} DrawObjects instance
                 */
                DrawObjects.create = function create(properties) {
                    return new DrawObjects(properties);
                };

                /**
                 * Encodes the specified DrawObjects message. Does not implicitly {@link message.support.nubugger.DrawObjects.verify|verify} messages.
                 * @param {message.support.nubugger.DrawObjects$Properties} message DrawObjects message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DrawObjects.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.objects != null && message.objects.length)
                        for (var i = 0; i < message.objects.length; ++i)
                            $root.message.support.nubugger.DrawObject.encode(message.objects[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified DrawObjects message, length delimited. Does not implicitly {@link message.support.nubugger.DrawObjects.verify|verify} messages.
                 * @param {message.support.nubugger.DrawObjects$Properties} message DrawObjects message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DrawObjects.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DrawObjects message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.DrawObjects} DrawObjects
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DrawObjects.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nubugger.DrawObjects();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.objects && message.objects.length))
                                message.objects = [];
                            message.objects.push($root.message.support.nubugger.DrawObject.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DrawObjects message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.DrawObjects} DrawObjects
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DrawObjects.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DrawObjects message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                DrawObjects.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.objects != null && message.hasOwnProperty("objects")) {
                        if (!Array.isArray(message.objects))
                            return "objects: array expected";
                        for (var i = 0; i < message.objects.length; ++i) {
                            var error = $root.message.support.nubugger.DrawObject.verify(message.objects[i]);
                            if (error)
                                return "objects." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a DrawObjects message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.DrawObjects} DrawObjects
                 */
                DrawObjects.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.nubugger.DrawObjects)
                        return object;
                    var message = new $root.message.support.nubugger.DrawObjects();
                    if (object.objects) {
                        if (!Array.isArray(object.objects))
                            throw TypeError(".message.support.nubugger.DrawObjects.objects: array expected");
                        message.objects = [];
                        for (var i = 0; i < object.objects.length; ++i) {
                            if (typeof object.objects[i] !== "object")
                                throw TypeError(".message.support.nubugger.DrawObjects.objects: object expected");
                            message.objects[i] = $root.message.support.nubugger.DrawObject.fromObject(object.objects[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a DrawObjects message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.DrawObjects.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.DrawObjects} DrawObjects
                 */
                DrawObjects.from = DrawObjects.fromObject;

                /**
                 * Creates a plain object from a DrawObjects message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.DrawObjects} message DrawObjects
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DrawObjects.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.objects = [];
                    if (message.objects && message.objects.length) {
                        object.objects = [];
                        for (var j = 0; j < message.objects.length; ++j)
                            object.objects[j] = $root.message.support.nubugger.DrawObject.toObject(message.objects[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this DrawObjects message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DrawObjects.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this DrawObjects to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                DrawObjects.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DrawObjects;
            })();

            nubugger.Overview = (function() {

                /**
                 * Properties of an Overview.
                 * @typedef message.support.nubugger.Overview$Properties
                 * @type {Object}
                 * @property {google.protobuf.Timestamp$Properties} [timestamp] Overview timestamp.
                 * @property {number} [robotId] Overview robotId.
                 * @property {string} [roleName] Overview roleName.
                 * @property {number} [battery] Overview battery.
                 * @property {number} [voltage] Overview voltage.
                 * @property {message.behaviour.Behaviour.State} [behaviourState] Overview behaviourState.
                 * @property {fvec3$Properties} [robotPosition] Overview robotPosition.
                 * @property {fmat33$Properties} [robotPositionCovariance] Overview robotPositionCovariance.
                 * @property {fvec2$Properties} [ballPosition] Overview ballPosition.
                 * @property {fmat22$Properties} [ballPositionCovariance] Overview ballPositionCovariance.
                 * @property {fvec2$Properties} [kickTarget] Overview kickTarget.
                 * @property {message.input.GameState.Data.Mode} [gameMode] Overview gameMode.
                 * @property {message.input.GameState.Data.Phase} [gamePhase] Overview gamePhase.
                 * @property {message.input.GameState.Data.PenaltyReason} [penaltyReason] Overview penaltyReason.
                 * @property {google.protobuf.Timestamp$Properties} [lastCameraImage] Overview lastCameraImage.
                 * @property {google.protobuf.Timestamp$Properties} [lastSeenBall] Overview lastSeenBall.
                 * @property {google.protobuf.Timestamp$Properties} [lastSeenGoal] Overview lastSeenGoal.
                 * @property {Array.<fvec2$Properties>} [walkPathPlan] Overview walkPathPlan.
                 * @property {fvec3$Properties} [walkCommand] Overview walkCommand.
                 */

                /**
                 * Constructs a new Overview.
                 * @exports message.support.nubugger.Overview
                 * @constructor
                 * @param {message.support.nubugger.Overview$Properties=} [properties] Properties to set
                 */
                function Overview(properties) {
                    this.walkPathPlan = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Overview timestamp.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                Overview.prototype.timestamp = null;

                /**
                 * Overview robotId.
                 * @type {number}
                 */
                Overview.prototype.robotId = 0;

                /**
                 * Overview roleName.
                 * @type {string}
                 */
                Overview.prototype.roleName = "";

                /**
                 * Overview battery.
                 * @type {number}
                 */
                Overview.prototype.battery = 0;

                /**
                 * Overview voltage.
                 * @type {number}
                 */
                Overview.prototype.voltage = 0;

                /**
                 * Overview behaviourState.
                 * @type {message.behaviour.Behaviour.State}
                 */
                Overview.prototype.behaviourState = 0;

                /**
                 * Overview robotPosition.
                 * @type {(fvec3$Properties|null)}
                 */
                Overview.prototype.robotPosition = null;

                /**
                 * Overview robotPositionCovariance.
                 * @type {(fmat33$Properties|null)}
                 */
                Overview.prototype.robotPositionCovariance = null;

                /**
                 * Overview ballPosition.
                 * @type {(fvec2$Properties|null)}
                 */
                Overview.prototype.ballPosition = null;

                /**
                 * Overview ballPositionCovariance.
                 * @type {(fmat22$Properties|null)}
                 */
                Overview.prototype.ballPositionCovariance = null;

                /**
                 * Overview kickTarget.
                 * @type {(fvec2$Properties|null)}
                 */
                Overview.prototype.kickTarget = null;

                /**
                 * Overview gameMode.
                 * @type {message.input.GameState.Data.Mode}
                 */
                Overview.prototype.gameMode = 0;

                /**
                 * Overview gamePhase.
                 * @type {message.input.GameState.Data.Phase}
                 */
                Overview.prototype.gamePhase = 0;

                /**
                 * Overview penaltyReason.
                 * @type {message.input.GameState.Data.PenaltyReason}
                 */
                Overview.prototype.penaltyReason = 0;

                /**
                 * Overview lastCameraImage.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                Overview.prototype.lastCameraImage = null;

                /**
                 * Overview lastSeenBall.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                Overview.prototype.lastSeenBall = null;

                /**
                 * Overview lastSeenGoal.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                Overview.prototype.lastSeenGoal = null;

                /**
                 * Overview walkPathPlan.
                 * @type {Array.<fvec2$Properties>}
                 */
                Overview.prototype.walkPathPlan = $util.emptyArray;

                /**
                 * Overview walkCommand.
                 * @type {(fvec3$Properties|null)}
                 */
                Overview.prototype.walkCommand = null;

                /**
                 * Creates a new Overview instance using the specified properties.
                 * @param {message.support.nubugger.Overview$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.Overview} Overview instance
                 */
                Overview.create = function create(properties) {
                    return new Overview(properties);
                };

                /**
                 * Encodes the specified Overview message. Does not implicitly {@link message.support.nubugger.Overview.verify|verify} messages.
                 * @param {message.support.nubugger.Overview$Properties} message Overview message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Overview.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.robotId != null && message.hasOwnProperty("robotId"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.robotId);
                    if (message.roleName != null && message.hasOwnProperty("roleName"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.roleName);
                    if (message.battery != null && message.hasOwnProperty("battery"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.battery);
                    if (message.voltage != null && message.hasOwnProperty("voltage"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.voltage);
                    if (message.behaviourState != null && message.hasOwnProperty("behaviourState"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.behaviourState);
                    if (message.robotPosition != null && message.hasOwnProperty("robotPosition"))
                        $root.fvec3.encode(message.robotPosition, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.robotPositionCovariance != null && message.hasOwnProperty("robotPositionCovariance"))
                        $root.fmat33.encode(message.robotPositionCovariance, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.ballPosition != null && message.hasOwnProperty("ballPosition"))
                        $root.fvec2.encode(message.ballPosition, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.ballPositionCovariance != null && message.hasOwnProperty("ballPositionCovariance"))
                        $root.fmat22.encode(message.ballPositionCovariance, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.kickTarget != null && message.hasOwnProperty("kickTarget"))
                        $root.fvec2.encode(message.kickTarget, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.gameMode != null && message.hasOwnProperty("gameMode"))
                        writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.gameMode);
                    if (message.gamePhase != null && message.hasOwnProperty("gamePhase"))
                        writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.gamePhase);
                    if (message.penaltyReason != null && message.hasOwnProperty("penaltyReason"))
                        writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.penaltyReason);
                    if (message.lastCameraImage != null && message.hasOwnProperty("lastCameraImage"))
                        $root.google.protobuf.Timestamp.encode(message.lastCameraImage, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.lastSeenBall != null && message.hasOwnProperty("lastSeenBall"))
                        $root.google.protobuf.Timestamp.encode(message.lastSeenBall, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.lastSeenGoal != null && message.hasOwnProperty("lastSeenGoal"))
                        $root.google.protobuf.Timestamp.encode(message.lastSeenGoal, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if (message.walkPathPlan != null && message.walkPathPlan.length)
                        for (var i = 0; i < message.walkPathPlan.length; ++i)
                            $root.fvec2.encode(message.walkPathPlan[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    if (message.walkCommand != null && message.hasOwnProperty("walkCommand"))
                        $root.fvec3.encode(message.walkCommand, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Overview message, length delimited. Does not implicitly {@link message.support.nubugger.Overview.verify|verify} messages.
                 * @param {message.support.nubugger.Overview$Properties} message Overview message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Overview.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Overview message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.Overview} Overview
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Overview.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nubugger.Overview();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.robotId = reader.uint32();
                            break;
                        case 3:
                            message.roleName = reader.string();
                            break;
                        case 4:
                            message.battery = reader.float();
                            break;
                        case 5:
                            message.voltage = reader.float();
                            break;
                        case 6:
                            message.behaviourState = reader.uint32();
                            break;
                        case 7:
                            message.robotPosition = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.robotPositionCovariance = $root.fmat33.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.ballPosition = $root.fvec2.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.ballPositionCovariance = $root.fmat22.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.kickTarget = $root.fvec2.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.gameMode = reader.uint32();
                            break;
                        case 13:
                            message.gamePhase = reader.uint32();
                            break;
                        case 14:
                            message.penaltyReason = reader.uint32();
                            break;
                        case 15:
                            message.lastCameraImage = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.lastSeenBall = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.lastSeenGoal = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 18:
                            if (!(message.walkPathPlan && message.walkPathPlan.length))
                                message.walkPathPlan = [];
                            message.walkPathPlan.push($root.fvec2.decode(reader, reader.uint32()));
                            break;
                        case 19:
                            message.walkCommand = $root.fvec3.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Overview message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.Overview} Overview
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Overview.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Overview message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Overview.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    if (message.robotId != null && message.hasOwnProperty("robotId"))
                        if (!$util.isInteger(message.robotId))
                            return "robotId: integer expected";
                    if (message.roleName != null && message.hasOwnProperty("roleName"))
                        if (!$util.isString(message.roleName))
                            return "roleName: string expected";
                    if (message.battery != null && message.hasOwnProperty("battery"))
                        if (typeof message.battery !== "number")
                            return "battery: number expected";
                    if (message.voltage != null && message.hasOwnProperty("voltage"))
                        if (typeof message.voltage !== "number")
                            return "voltage: number expected";
                    if (message.behaviourState != null && message.hasOwnProperty("behaviourState"))
                        switch (message.behaviourState) {
                        default:
                            return "behaviourState: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                            break;
                        }
                    if (message.robotPosition != null && message.hasOwnProperty("robotPosition")) {
                        var error = $root.fvec3.verify(message.robotPosition);
                        if (error)
                            return "robotPosition." + error;
                    }
                    if (message.robotPositionCovariance != null && message.hasOwnProperty("robotPositionCovariance")) {
                        var error = $root.fmat33.verify(message.robotPositionCovariance);
                        if (error)
                            return "robotPositionCovariance." + error;
                    }
                    if (message.ballPosition != null && message.hasOwnProperty("ballPosition")) {
                        var error = $root.fvec2.verify(message.ballPosition);
                        if (error)
                            return "ballPosition." + error;
                    }
                    if (message.ballPositionCovariance != null && message.hasOwnProperty("ballPositionCovariance")) {
                        var error = $root.fmat22.verify(message.ballPositionCovariance);
                        if (error)
                            return "ballPositionCovariance." + error;
                    }
                    if (message.kickTarget != null && message.hasOwnProperty("kickTarget")) {
                        var error = $root.fvec2.verify(message.kickTarget);
                        if (error)
                            return "kickTarget." + error;
                    }
                    if (message.gameMode != null && message.hasOwnProperty("gameMode"))
                        switch (message.gameMode) {
                        default:
                            return "gameMode: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.gamePhase != null && message.hasOwnProperty("gamePhase"))
                        switch (message.gamePhase) {
                        default:
                            return "gamePhase: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.penaltyReason != null && message.hasOwnProperty("penaltyReason"))
                        switch (message.penaltyReason) {
                        default:
                            return "penaltyReason: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                            break;
                        }
                    if (message.lastCameraImage != null && message.hasOwnProperty("lastCameraImage")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.lastCameraImage);
                        if (error)
                            return "lastCameraImage." + error;
                    }
                    if (message.lastSeenBall != null && message.hasOwnProperty("lastSeenBall")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.lastSeenBall);
                        if (error)
                            return "lastSeenBall." + error;
                    }
                    if (message.lastSeenGoal != null && message.hasOwnProperty("lastSeenGoal")) {
                        var error = $root.google.protobuf.Timestamp.verify(message.lastSeenGoal);
                        if (error)
                            return "lastSeenGoal." + error;
                    }
                    if (message.walkPathPlan != null && message.hasOwnProperty("walkPathPlan")) {
                        if (!Array.isArray(message.walkPathPlan))
                            return "walkPathPlan: array expected";
                        for (var i = 0; i < message.walkPathPlan.length; ++i) {
                            var error = $root.fvec2.verify(message.walkPathPlan[i]);
                            if (error)
                                return "walkPathPlan." + error;
                        }
                    }
                    if (message.walkCommand != null && message.hasOwnProperty("walkCommand")) {
                        var error = $root.fvec3.verify(message.walkCommand);
                        if (error)
                            return "walkCommand." + error;
                    }
                    return null;
                };

                /**
                 * Creates an Overview message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.Overview} Overview
                 */
                Overview.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.nubugger.Overview)
                        return object;
                    var message = new $root.message.support.nubugger.Overview();
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".message.support.nubugger.Overview.timestamp: object expected");
                        message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                    }
                    if (object.robotId != null)
                        message.robotId = object.robotId >>> 0;
                    if (object.roleName != null)
                        message.roleName = String(object.roleName);
                    if (object.battery != null)
                        message.battery = Number(object.battery);
                    if (object.voltage != null)
                        message.voltage = Number(object.voltage);
                    switch (object.behaviourState) {
                    case "UNKNOWN":
                    case 0:
                        message.behaviourState = 0;
                        break;
                    case "INIT":
                    case 1:
                        message.behaviourState = 1;
                        break;
                    case "SEARCH_FOR_BALL":
                    case 2:
                        message.behaviourState = 2;
                        break;
                    case "SEARCH_FOR_GOALS":
                    case 3:
                        message.behaviourState = 3;
                        break;
                    case "WALK_TO_BALL":
                    case 4:
                        message.behaviourState = 4;
                        break;
                    case "PICKED_UP":
                    case 5:
                        message.behaviourState = 5;
                        break;
                    case "INITIAL":
                    case 6:
                        message.behaviourState = 6;
                        break;
                    case "READY":
                    case 7:
                        message.behaviourState = 7;
                        break;
                    case "SET":
                    case 8:
                        message.behaviourState = 8;
                        break;
                    case "TIMEOUT":
                    case 9:
                        message.behaviourState = 9;
                        break;
                    case "FINISHED":
                    case 10:
                        message.behaviourState = 10;
                        break;
                    case "PENALISED":
                    case 11:
                        message.behaviourState = 11;
                        break;
                    case "GOALIE_WALK":
                    case 12:
                        message.behaviourState = 12;
                        break;
                    case "MOVE_TO_CENTRE":
                    case 13:
                        message.behaviourState = 13;
                        break;
                    case "LOCALISING":
                    case 14:
                        message.behaviourState = 14;
                        break;
                    }
                    if (object.robotPosition != null) {
                        if (typeof object.robotPosition !== "object")
                            throw TypeError(".message.support.nubugger.Overview.robotPosition: object expected");
                        message.robotPosition = $root.fvec3.fromObject(object.robotPosition);
                    }
                    if (object.robotPositionCovariance != null) {
                        if (typeof object.robotPositionCovariance !== "object")
                            throw TypeError(".message.support.nubugger.Overview.robotPositionCovariance: object expected");
                        message.robotPositionCovariance = $root.fmat33.fromObject(object.robotPositionCovariance);
                    }
                    if (object.ballPosition != null) {
                        if (typeof object.ballPosition !== "object")
                            throw TypeError(".message.support.nubugger.Overview.ballPosition: object expected");
                        message.ballPosition = $root.fvec2.fromObject(object.ballPosition);
                    }
                    if (object.ballPositionCovariance != null) {
                        if (typeof object.ballPositionCovariance !== "object")
                            throw TypeError(".message.support.nubugger.Overview.ballPositionCovariance: object expected");
                        message.ballPositionCovariance = $root.fmat22.fromObject(object.ballPositionCovariance);
                    }
                    if (object.kickTarget != null) {
                        if (typeof object.kickTarget !== "object")
                            throw TypeError(".message.support.nubugger.Overview.kickTarget: object expected");
                        message.kickTarget = $root.fvec2.fromObject(object.kickTarget);
                    }
                    switch (object.gameMode) {
                    case "UNKNOWN_MODE":
                    case 0:
                        message.gameMode = 0;
                        break;
                    case "NORMAL":
                    case 1:
                        message.gameMode = 1;
                        break;
                    case "PENALTY_SHOOTOUT":
                    case 2:
                        message.gameMode = 2;
                        break;
                    case "OVERTIME":
                    case 3:
                        message.gameMode = 3;
                        break;
                    }
                    switch (object.gamePhase) {
                    case "UNKNOWN_PHASE":
                    case 0:
                        message.gamePhase = 0;
                        break;
                    case "INITIAL":
                    case 1:
                        message.gamePhase = 1;
                        break;
                    case "READY":
                    case 2:
                        message.gamePhase = 2;
                        break;
                    case "SET":
                    case 3:
                        message.gamePhase = 3;
                        break;
                    case "PLAYING":
                    case 4:
                        message.gamePhase = 4;
                        break;
                    case "TIMEOUT":
                    case 5:
                        message.gamePhase = 5;
                        break;
                    case "FINISHED":
                    case 6:
                        message.gamePhase = 6;
                        break;
                    }
                    switch (object.penaltyReason) {
                    case "UNKNOWN_PENALTY_REASON":
                    case 0:
                        message.penaltyReason = 0;
                        break;
                    case "UNPENALISED":
                    case 1:
                        message.penaltyReason = 1;
                        break;
                    case "BALL_MANIPULATION":
                    case 2:
                        message.penaltyReason = 2;
                        break;
                    case "PHYSICAL_CONTACT":
                    case 3:
                        message.penaltyReason = 3;
                        break;
                    case "ILLEGAL_ATTACK":
                    case 4:
                        message.penaltyReason = 4;
                        break;
                    case "ILLEGAL_DEFENSE":
                    case 5:
                        message.penaltyReason = 5;
                        break;
                    case "REQUEST_FOR_PICKUP":
                    case 6:
                        message.penaltyReason = 6;
                        break;
                    case "REQUEST_FOR_SERVICE":
                    case 7:
                        message.penaltyReason = 7;
                        break;
                    case "REQUEST_FOR_PICKUP_TO_SERVICE":
                    case 8:
                        message.penaltyReason = 8;
                        break;
                    case "SUBSTITUTE":
                    case 9:
                        message.penaltyReason = 9;
                        break;
                    case "MANUAL":
                    case 10:
                        message.penaltyReason = 10;
                        break;
                    case "PLAYER_PUSHING":
                    case 11:
                        message.penaltyReason = 11;
                        break;
                    }
                    if (object.lastCameraImage != null) {
                        if (typeof object.lastCameraImage !== "object")
                            throw TypeError(".message.support.nubugger.Overview.lastCameraImage: object expected");
                        message.lastCameraImage = $root.google.protobuf.Timestamp.fromObject(object.lastCameraImage);
                    }
                    if (object.lastSeenBall != null) {
                        if (typeof object.lastSeenBall !== "object")
                            throw TypeError(".message.support.nubugger.Overview.lastSeenBall: object expected");
                        message.lastSeenBall = $root.google.protobuf.Timestamp.fromObject(object.lastSeenBall);
                    }
                    if (object.lastSeenGoal != null) {
                        if (typeof object.lastSeenGoal !== "object")
                            throw TypeError(".message.support.nubugger.Overview.lastSeenGoal: object expected");
                        message.lastSeenGoal = $root.google.protobuf.Timestamp.fromObject(object.lastSeenGoal);
                    }
                    if (object.walkPathPlan) {
                        if (!Array.isArray(object.walkPathPlan))
                            throw TypeError(".message.support.nubugger.Overview.walkPathPlan: array expected");
                        message.walkPathPlan = [];
                        for (var i = 0; i < object.walkPathPlan.length; ++i) {
                            if (typeof object.walkPathPlan[i] !== "object")
                                throw TypeError(".message.support.nubugger.Overview.walkPathPlan: object expected");
                            message.walkPathPlan[i] = $root.fvec2.fromObject(object.walkPathPlan[i]);
                        }
                    }
                    if (object.walkCommand != null) {
                        if (typeof object.walkCommand !== "object")
                            throw TypeError(".message.support.nubugger.Overview.walkCommand: object expected");
                        message.walkCommand = $root.fvec3.fromObject(object.walkCommand);
                    }
                    return message;
                };

                /**
                 * Creates an Overview message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.Overview.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.Overview} Overview
                 */
                Overview.from = Overview.fromObject;

                /**
                 * Creates a plain object from an Overview message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.Overview} message Overview
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Overview.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.walkPathPlan = [];
                    if (options.defaults) {
                        object.timestamp = null;
                        object.robotId = 0;
                        object.roleName = "";
                        object.battery = 0;
                        object.voltage = 0;
                        object.behaviourState = options.enums === String ? "UNKNOWN" : 0;
                        object.robotPosition = null;
                        object.robotPositionCovariance = null;
                        object.ballPosition = null;
                        object.ballPositionCovariance = null;
                        object.kickTarget = null;
                        object.gameMode = options.enums === String ? "UNKNOWN_MODE" : 0;
                        object.gamePhase = options.enums === String ? "UNKNOWN_PHASE" : 0;
                        object.penaltyReason = options.enums === String ? "UNKNOWN_PENALTY_REASON" : 0;
                        object.lastCameraImage = null;
                        object.lastSeenBall = null;
                        object.lastSeenGoal = null;
                        object.walkCommand = null;
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                    if (message.robotId != null && message.hasOwnProperty("robotId"))
                        object.robotId = message.robotId;
                    if (message.roleName != null && message.hasOwnProperty("roleName"))
                        object.roleName = message.roleName;
                    if (message.battery != null && message.hasOwnProperty("battery"))
                        object.battery = message.battery;
                    if (message.voltage != null && message.hasOwnProperty("voltage"))
                        object.voltage = message.voltage;
                    if (message.behaviourState != null && message.hasOwnProperty("behaviourState"))
                        object.behaviourState = options.enums === String ? $root.message.behaviour.Behaviour.State[message.behaviourState] : message.behaviourState;
                    if (message.robotPosition != null && message.hasOwnProperty("robotPosition"))
                        object.robotPosition = $root.fvec3.toObject(message.robotPosition, options);
                    if (message.robotPositionCovariance != null && message.hasOwnProperty("robotPositionCovariance"))
                        object.robotPositionCovariance = $root.fmat33.toObject(message.robotPositionCovariance, options);
                    if (message.ballPosition != null && message.hasOwnProperty("ballPosition"))
                        object.ballPosition = $root.fvec2.toObject(message.ballPosition, options);
                    if (message.ballPositionCovariance != null && message.hasOwnProperty("ballPositionCovariance"))
                        object.ballPositionCovariance = $root.fmat22.toObject(message.ballPositionCovariance, options);
                    if (message.kickTarget != null && message.hasOwnProperty("kickTarget"))
                        object.kickTarget = $root.fvec2.toObject(message.kickTarget, options);
                    if (message.gameMode != null && message.hasOwnProperty("gameMode"))
                        object.gameMode = options.enums === String ? $root.message.input.GameState.Data.Mode[message.gameMode] : message.gameMode;
                    if (message.gamePhase != null && message.hasOwnProperty("gamePhase"))
                        object.gamePhase = options.enums === String ? $root.message.input.GameState.Data.Phase[message.gamePhase] : message.gamePhase;
                    if (message.penaltyReason != null && message.hasOwnProperty("penaltyReason"))
                        object.penaltyReason = options.enums === String ? $root.message.input.GameState.Data.PenaltyReason[message.penaltyReason] : message.penaltyReason;
                    if (message.lastCameraImage != null && message.hasOwnProperty("lastCameraImage"))
                        object.lastCameraImage = $root.google.protobuf.Timestamp.toObject(message.lastCameraImage, options);
                    if (message.lastSeenBall != null && message.hasOwnProperty("lastSeenBall"))
                        object.lastSeenBall = $root.google.protobuf.Timestamp.toObject(message.lastSeenBall, options);
                    if (message.lastSeenGoal != null && message.hasOwnProperty("lastSeenGoal"))
                        object.lastSeenGoal = $root.google.protobuf.Timestamp.toObject(message.lastSeenGoal, options);
                    if (message.walkPathPlan && message.walkPathPlan.length) {
                        object.walkPathPlan = [];
                        for (var j = 0; j < message.walkPathPlan.length; ++j)
                            object.walkPathPlan[j] = $root.fvec2.toObject(message.walkPathPlan[j], options);
                    }
                    if (message.walkCommand != null && message.hasOwnProperty("walkCommand"))
                        object.walkCommand = $root.fvec3.toObject(message.walkCommand, options);
                    return object;
                };

                /**
                 * Creates a plain object from this Overview message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Overview.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Overview to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Overview.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Overview;
            })();

            nubugger.Ping = (function() {

                /**
                 * Properties of a Ping.
                 * @typedef message.support.nubugger.Ping$Properties
                 * @type {Object}
                 * @property {number|Long} [time] Ping time.
                 */

                /**
                 * Constructs a new Ping.
                 * @exports message.support.nubugger.Ping
                 * @constructor
                 * @param {message.support.nubugger.Ping$Properties=} [properties] Properties to set
                 */
                function Ping(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Ping time.
                 * @type {number|Long}
                 */
                Ping.prototype.time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new Ping instance using the specified properties.
                 * @param {message.support.nubugger.Ping$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.Ping} Ping instance
                 */
                Ping.create = function create(properties) {
                    return new Ping(properties);
                };

                /**
                 * Encodes the specified Ping message. Does not implicitly {@link message.support.nubugger.Ping.verify|verify} messages.
                 * @param {message.support.nubugger.Ping$Properties} message Ping message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ping.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.time != null && message.hasOwnProperty("time"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.time);
                    return writer;
                };

                /**
                 * Encodes the specified Ping message, length delimited. Does not implicitly {@link message.support.nubugger.Ping.verify|verify} messages.
                 * @param {message.support.nubugger.Ping$Properties} message Ping message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ping.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Ping message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.Ping} Ping
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ping.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nubugger.Ping();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.time = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Ping message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.Ping} Ping
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ping.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Ping message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Ping.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.time != null && message.hasOwnProperty("time"))
                        if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                            return "time: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a Ping message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.Ping} Ping
                 */
                Ping.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.nubugger.Ping)
                        return object;
                    var message = new $root.message.support.nubugger.Ping();
                    if (object.time != null)
                        if ($util.Long)
                            (message.time = $util.Long.fromValue(object.time)).unsigned = true;
                        else if (typeof object.time === "string")
                            message.time = parseInt(object.time, 10);
                        else if (typeof object.time === "number")
                            message.time = object.time;
                        else if (typeof object.time === "object")
                            message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a Ping message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.Ping.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.Ping} Ping
                 */
                Ping.from = Ping.fromObject;

                /**
                 * Creates a plain object from a Ping message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.Ping} message Ping
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Ping.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.time = options.longs === String ? "0" : 0;
                    if (message.time != null && message.hasOwnProperty("time"))
                        if (typeof message.time === "number")
                            object.time = options.longs === String ? String(message.time) : message.time;
                        else
                            object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber(true) : message.time;
                    return object;
                };

                /**
                 * Creates a plain object from this Ping message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Ping.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Ping to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Ping.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Ping;
            })();

            nubugger.ReactionHandles = (function() {

                /**
                 * Properties of a ReactionHandles.
                 * @typedef message.support.nubugger.ReactionHandles$Properties
                 * @type {Object}
                 * @property {Array.<message.support.nubugger.ReactionHandles.Handle$Properties>} [handles] ReactionHandles handles.
                 */

                /**
                 * Constructs a new ReactionHandles.
                 * @exports message.support.nubugger.ReactionHandles
                 * @constructor
                 * @param {message.support.nubugger.ReactionHandles$Properties=} [properties] Properties to set
                 */
                function ReactionHandles(properties) {
                    this.handles = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReactionHandles handles.
                 * @type {Array.<message.support.nubugger.ReactionHandles.Handle$Properties>}
                 */
                ReactionHandles.prototype.handles = $util.emptyArray;

                /**
                 * Creates a new ReactionHandles instance using the specified properties.
                 * @param {message.support.nubugger.ReactionHandles$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.ReactionHandles} ReactionHandles instance
                 */
                ReactionHandles.create = function create(properties) {
                    return new ReactionHandles(properties);
                };

                /**
                 * Encodes the specified ReactionHandles message. Does not implicitly {@link message.support.nubugger.ReactionHandles.verify|verify} messages.
                 * @param {message.support.nubugger.ReactionHandles$Properties} message ReactionHandles message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReactionHandles.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.handles != null && message.handles.length)
                        for (var i = 0; i < message.handles.length; ++i)
                            $root.message.support.nubugger.ReactionHandles.Handle.encode(message.handles[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ReactionHandles message, length delimited. Does not implicitly {@link message.support.nubugger.ReactionHandles.verify|verify} messages.
                 * @param {message.support.nubugger.ReactionHandles$Properties} message ReactionHandles message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReactionHandles.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReactionHandles message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.ReactionHandles} ReactionHandles
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReactionHandles.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nubugger.ReactionHandles();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.handles && message.handles.length))
                                message.handles = [];
                            message.handles.push($root.message.support.nubugger.ReactionHandles.Handle.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReactionHandles message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.ReactionHandles} ReactionHandles
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReactionHandles.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReactionHandles message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ReactionHandles.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.handles != null && message.hasOwnProperty("handles")) {
                        if (!Array.isArray(message.handles))
                            return "handles: array expected";
                        for (var i = 0; i < message.handles.length; ++i) {
                            var error = $root.message.support.nubugger.ReactionHandles.Handle.verify(message.handles[i]);
                            if (error)
                                return "handles." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ReactionHandles message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.ReactionHandles} ReactionHandles
                 */
                ReactionHandles.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.nubugger.ReactionHandles)
                        return object;
                    var message = new $root.message.support.nubugger.ReactionHandles();
                    if (object.handles) {
                        if (!Array.isArray(object.handles))
                            throw TypeError(".message.support.nubugger.ReactionHandles.handles: array expected");
                        message.handles = [];
                        for (var i = 0; i < object.handles.length; ++i) {
                            if (typeof object.handles[i] !== "object")
                                throw TypeError(".message.support.nubugger.ReactionHandles.handles: object expected");
                            message.handles[i] = $root.message.support.nubugger.ReactionHandles.Handle.fromObject(object.handles[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a ReactionHandles message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.ReactionHandles.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.ReactionHandles} ReactionHandles
                 */
                ReactionHandles.from = ReactionHandles.fromObject;

                /**
                 * Creates a plain object from a ReactionHandles message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.ReactionHandles} message ReactionHandles
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReactionHandles.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.handles = [];
                    if (message.handles && message.handles.length) {
                        object.handles = [];
                        for (var j = 0; j < message.handles.length; ++j)
                            object.handles[j] = $root.message.support.nubugger.ReactionHandles.Handle.toObject(message.handles[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this ReactionHandles message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReactionHandles.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ReactionHandles to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ReactionHandles.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                ReactionHandles.Handle = (function() {

                    /**
                     * Properties of a Handle.
                     * @typedef message.support.nubugger.ReactionHandles.Handle$Properties
                     * @type {Object}
                     * @property {string} [type] Handle type.
                     * @property {boolean} [enabled] Handle enabled.
                     */

                    /**
                     * Constructs a new Handle.
                     * @exports message.support.nubugger.ReactionHandles.Handle
                     * @constructor
                     * @param {message.support.nubugger.ReactionHandles.Handle$Properties=} [properties] Properties to set
                     */
                    function Handle(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Handle type.
                     * @type {string}
                     */
                    Handle.prototype.type = "";

                    /**
                     * Handle enabled.
                     * @type {boolean}
                     */
                    Handle.prototype.enabled = false;

                    /**
                     * Creates a new Handle instance using the specified properties.
                     * @param {message.support.nubugger.ReactionHandles.Handle$Properties=} [properties] Properties to set
                     * @returns {message.support.nubugger.ReactionHandles.Handle} Handle instance
                     */
                    Handle.create = function create(properties) {
                        return new Handle(properties);
                    };

                    /**
                     * Encodes the specified Handle message. Does not implicitly {@link message.support.nubugger.ReactionHandles.Handle.verify|verify} messages.
                     * @param {message.support.nubugger.ReactionHandles.Handle$Properties} message Handle message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Handle.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && message.hasOwnProperty("type"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                        if (message.enabled != null && message.hasOwnProperty("enabled"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
                        return writer;
                    };

                    /**
                     * Encodes the specified Handle message, length delimited. Does not implicitly {@link message.support.nubugger.ReactionHandles.Handle.verify|verify} messages.
                     * @param {message.support.nubugger.ReactionHandles.Handle$Properties} message Handle message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Handle.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Handle message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.support.nubugger.ReactionHandles.Handle} Handle
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Handle.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nubugger.ReactionHandles.Handle();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.type = reader.string();
                                break;
                            case 2:
                                message.enabled = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Handle message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.support.nubugger.ReactionHandles.Handle} Handle
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Handle.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Handle message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Handle.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        if (message.enabled != null && message.hasOwnProperty("enabled"))
                            if (typeof message.enabled !== "boolean")
                                return "enabled: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a Handle message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.support.nubugger.ReactionHandles.Handle} Handle
                     */
                    Handle.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.support.nubugger.ReactionHandles.Handle)
                            return object;
                        var message = new $root.message.support.nubugger.ReactionHandles.Handle();
                        if (object.type != null)
                            message.type = String(object.type);
                        if (object.enabled != null)
                            message.enabled = Boolean(object.enabled);
                        return message;
                    };

                    /**
                     * Creates a Handle message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.support.nubugger.ReactionHandles.Handle.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.support.nubugger.ReactionHandles.Handle} Handle
                     */
                    Handle.from = Handle.fromObject;

                    /**
                     * Creates a plain object from a Handle message. Also converts values to other types if specified.
                     * @param {message.support.nubugger.ReactionHandles.Handle} message Handle
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Handle.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.type = "";
                            object.enabled = false;
                        }
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        if (message.enabled != null && message.hasOwnProperty("enabled"))
                            object.enabled = message.enabled;
                        return object;
                    };

                    /**
                     * Creates a plain object from this Handle message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Handle.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Handle to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Handle.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Handle;
                })();

                return ReactionHandles;
            })();

            return nubugger;
        })();

        support.nuclear = (function() {

            /**
             * Namespace nuclear.
             * @exports message.support.nuclear
             * @namespace
             */
            var nuclear = {};

            nuclear.ReactionStatistics = (function() {

                /**
                 * Properties of a ReactionStatistics.
                 * @typedef message.support.nuclear.ReactionStatistics$Properties
                 * @type {Object}
                 * @property {string} [name] ReactionStatistics name.
                 * @property {string} [triggerName] ReactionStatistics triggerName.
                 * @property {string} [functionName] ReactionStatistics functionName.
                 * @property {number|Long} [reactionId] ReactionStatistics reactionId.
                 * @property {number|Long} [taskId] ReactionStatistics taskId.
                 * @property {number|Long} [causeReactionId] ReactionStatistics causeReactionId.
                 * @property {number|Long} [causeTaskId] ReactionStatistics causeTaskId.
                 * @property {number|Long} [emitted] ReactionStatistics emitted.
                 * @property {number|Long} [started] ReactionStatistics started.
                 * @property {number|Long} [finished] ReactionStatistics finished.
                 */

                /**
                 * Constructs a new ReactionStatistics.
                 * @exports message.support.nuclear.ReactionStatistics
                 * @constructor
                 * @param {message.support.nuclear.ReactionStatistics$Properties=} [properties] Properties to set
                 */
                function ReactionStatistics(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReactionStatistics name.
                 * @type {string}
                 */
                ReactionStatistics.prototype.name = "";

                /**
                 * ReactionStatistics triggerName.
                 * @type {string}
                 */
                ReactionStatistics.prototype.triggerName = "";

                /**
                 * ReactionStatistics functionName.
                 * @type {string}
                 */
                ReactionStatistics.prototype.functionName = "";

                /**
                 * ReactionStatistics reactionId.
                 * @type {number|Long}
                 */
                ReactionStatistics.prototype.reactionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ReactionStatistics taskId.
                 * @type {number|Long}
                 */
                ReactionStatistics.prototype.taskId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ReactionStatistics causeReactionId.
                 * @type {number|Long}
                 */
                ReactionStatistics.prototype.causeReactionId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ReactionStatistics causeTaskId.
                 * @type {number|Long}
                 */
                ReactionStatistics.prototype.causeTaskId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ReactionStatistics emitted.
                 * @type {number|Long}
                 */
                ReactionStatistics.prototype.emitted = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ReactionStatistics started.
                 * @type {number|Long}
                 */
                ReactionStatistics.prototype.started = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ReactionStatistics finished.
                 * @type {number|Long}
                 */
                ReactionStatistics.prototype.finished = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new ReactionStatistics instance using the specified properties.
                 * @param {message.support.nuclear.ReactionStatistics$Properties=} [properties] Properties to set
                 * @returns {message.support.nuclear.ReactionStatistics} ReactionStatistics instance
                 */
                ReactionStatistics.create = function create(properties) {
                    return new ReactionStatistics(properties);
                };

                /**
                 * Encodes the specified ReactionStatistics message. Does not implicitly {@link message.support.nuclear.ReactionStatistics.verify|verify} messages.
                 * @param {message.support.nuclear.ReactionStatistics$Properties} message ReactionStatistics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReactionStatistics.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.triggerName != null && message.hasOwnProperty("triggerName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.triggerName);
                    if (message.functionName != null && message.hasOwnProperty("functionName"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.functionName);
                    if (message.reactionId != null && message.hasOwnProperty("reactionId"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.reactionId);
                    if (message.taskId != null && message.hasOwnProperty("taskId"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.taskId);
                    if (message.causeReactionId != null && message.hasOwnProperty("causeReactionId"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.causeReactionId);
                    if (message.causeTaskId != null && message.hasOwnProperty("causeTaskId"))
                        writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.causeTaskId);
                    if (message.emitted != null && message.hasOwnProperty("emitted"))
                        writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.emitted);
                    if (message.started != null && message.hasOwnProperty("started"))
                        writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.started);
                    if (message.finished != null && message.hasOwnProperty("finished"))
                        writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.finished);
                    return writer;
                };

                /**
                 * Encodes the specified ReactionStatistics message, length delimited. Does not implicitly {@link message.support.nuclear.ReactionStatistics.verify|verify} messages.
                 * @param {message.support.nuclear.ReactionStatistics$Properties} message ReactionStatistics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReactionStatistics.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReactionStatistics message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nuclear.ReactionStatistics} ReactionStatistics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReactionStatistics.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.nuclear.ReactionStatistics();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.triggerName = reader.string();
                            break;
                        case 3:
                            message.functionName = reader.string();
                            break;
                        case 4:
                            message.reactionId = reader.uint64();
                            break;
                        case 5:
                            message.taskId = reader.uint64();
                            break;
                        case 6:
                            message.causeReactionId = reader.uint64();
                            break;
                        case 7:
                            message.causeTaskId = reader.uint64();
                            break;
                        case 8:
                            message.emitted = reader.uint64();
                            break;
                        case 9:
                            message.started = reader.uint64();
                            break;
                        case 10:
                            message.finished = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReactionStatistics message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nuclear.ReactionStatistics} ReactionStatistics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReactionStatistics.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReactionStatistics message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ReactionStatistics.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.triggerName != null && message.hasOwnProperty("triggerName"))
                        if (!$util.isString(message.triggerName))
                            return "triggerName: string expected";
                    if (message.functionName != null && message.hasOwnProperty("functionName"))
                        if (!$util.isString(message.functionName))
                            return "functionName: string expected";
                    if (message.reactionId != null && message.hasOwnProperty("reactionId"))
                        if (!$util.isInteger(message.reactionId) && !(message.reactionId && $util.isInteger(message.reactionId.low) && $util.isInteger(message.reactionId.high)))
                            return "reactionId: integer|Long expected";
                    if (message.taskId != null && message.hasOwnProperty("taskId"))
                        if (!$util.isInteger(message.taskId) && !(message.taskId && $util.isInteger(message.taskId.low) && $util.isInteger(message.taskId.high)))
                            return "taskId: integer|Long expected";
                    if (message.causeReactionId != null && message.hasOwnProperty("causeReactionId"))
                        if (!$util.isInteger(message.causeReactionId) && !(message.causeReactionId && $util.isInteger(message.causeReactionId.low) && $util.isInteger(message.causeReactionId.high)))
                            return "causeReactionId: integer|Long expected";
                    if (message.causeTaskId != null && message.hasOwnProperty("causeTaskId"))
                        if (!$util.isInteger(message.causeTaskId) && !(message.causeTaskId && $util.isInteger(message.causeTaskId.low) && $util.isInteger(message.causeTaskId.high)))
                            return "causeTaskId: integer|Long expected";
                    if (message.emitted != null && message.hasOwnProperty("emitted"))
                        if (!$util.isInteger(message.emitted) && !(message.emitted && $util.isInteger(message.emitted.low) && $util.isInteger(message.emitted.high)))
                            return "emitted: integer|Long expected";
                    if (message.started != null && message.hasOwnProperty("started"))
                        if (!$util.isInteger(message.started) && !(message.started && $util.isInteger(message.started.low) && $util.isInteger(message.started.high)))
                            return "started: integer|Long expected";
                    if (message.finished != null && message.hasOwnProperty("finished"))
                        if (!$util.isInteger(message.finished) && !(message.finished && $util.isInteger(message.finished.low) && $util.isInteger(message.finished.high)))
                            return "finished: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a ReactionStatistics message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nuclear.ReactionStatistics} ReactionStatistics
                 */
                ReactionStatistics.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.nuclear.ReactionStatistics)
                        return object;
                    var message = new $root.message.support.nuclear.ReactionStatistics();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.triggerName != null)
                        message.triggerName = String(object.triggerName);
                    if (object.functionName != null)
                        message.functionName = String(object.functionName);
                    if (object.reactionId != null)
                        if ($util.Long)
                            (message.reactionId = $util.Long.fromValue(object.reactionId)).unsigned = true;
                        else if (typeof object.reactionId === "string")
                            message.reactionId = parseInt(object.reactionId, 10);
                        else if (typeof object.reactionId === "number")
                            message.reactionId = object.reactionId;
                        else if (typeof object.reactionId === "object")
                            message.reactionId = new $util.LongBits(object.reactionId.low >>> 0, object.reactionId.high >>> 0).toNumber(true);
                    if (object.taskId != null)
                        if ($util.Long)
                            (message.taskId = $util.Long.fromValue(object.taskId)).unsigned = true;
                        else if (typeof object.taskId === "string")
                            message.taskId = parseInt(object.taskId, 10);
                        else if (typeof object.taskId === "number")
                            message.taskId = object.taskId;
                        else if (typeof object.taskId === "object")
                            message.taskId = new $util.LongBits(object.taskId.low >>> 0, object.taskId.high >>> 0).toNumber(true);
                    if (object.causeReactionId != null)
                        if ($util.Long)
                            (message.causeReactionId = $util.Long.fromValue(object.causeReactionId)).unsigned = true;
                        else if (typeof object.causeReactionId === "string")
                            message.causeReactionId = parseInt(object.causeReactionId, 10);
                        else if (typeof object.causeReactionId === "number")
                            message.causeReactionId = object.causeReactionId;
                        else if (typeof object.causeReactionId === "object")
                            message.causeReactionId = new $util.LongBits(object.causeReactionId.low >>> 0, object.causeReactionId.high >>> 0).toNumber(true);
                    if (object.causeTaskId != null)
                        if ($util.Long)
                            (message.causeTaskId = $util.Long.fromValue(object.causeTaskId)).unsigned = true;
                        else if (typeof object.causeTaskId === "string")
                            message.causeTaskId = parseInt(object.causeTaskId, 10);
                        else if (typeof object.causeTaskId === "number")
                            message.causeTaskId = object.causeTaskId;
                        else if (typeof object.causeTaskId === "object")
                            message.causeTaskId = new $util.LongBits(object.causeTaskId.low >>> 0, object.causeTaskId.high >>> 0).toNumber(true);
                    if (object.emitted != null)
                        if ($util.Long)
                            (message.emitted = $util.Long.fromValue(object.emitted)).unsigned = true;
                        else if (typeof object.emitted === "string")
                            message.emitted = parseInt(object.emitted, 10);
                        else if (typeof object.emitted === "number")
                            message.emitted = object.emitted;
                        else if (typeof object.emitted === "object")
                            message.emitted = new $util.LongBits(object.emitted.low >>> 0, object.emitted.high >>> 0).toNumber(true);
                    if (object.started != null)
                        if ($util.Long)
                            (message.started = $util.Long.fromValue(object.started)).unsigned = true;
                        else if (typeof object.started === "string")
                            message.started = parseInt(object.started, 10);
                        else if (typeof object.started === "number")
                            message.started = object.started;
                        else if (typeof object.started === "object")
                            message.started = new $util.LongBits(object.started.low >>> 0, object.started.high >>> 0).toNumber(true);
                    if (object.finished != null)
                        if ($util.Long)
                            (message.finished = $util.Long.fromValue(object.finished)).unsigned = true;
                        else if (typeof object.finished === "string")
                            message.finished = parseInt(object.finished, 10);
                        else if (typeof object.finished === "number")
                            message.finished = object.finished;
                        else if (typeof object.finished === "object")
                            message.finished = new $util.LongBits(object.finished.low >>> 0, object.finished.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a ReactionStatistics message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nuclear.ReactionStatistics.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nuclear.ReactionStatistics} ReactionStatistics
                 */
                ReactionStatistics.from = ReactionStatistics.fromObject;

                /**
                 * Creates a plain object from a ReactionStatistics message. Also converts values to other types if specified.
                 * @param {message.support.nuclear.ReactionStatistics} message ReactionStatistics
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReactionStatistics.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.triggerName = "";
                        object.functionName = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.reactionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.reactionId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.taskId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.taskId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.causeReactionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.causeReactionId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.causeTaskId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.causeTaskId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.emitted = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.emitted = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.started = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.started = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.finished = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.finished = options.longs === String ? "0" : 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.triggerName != null && message.hasOwnProperty("triggerName"))
                        object.triggerName = message.triggerName;
                    if (message.functionName != null && message.hasOwnProperty("functionName"))
                        object.functionName = message.functionName;
                    if (message.reactionId != null && message.hasOwnProperty("reactionId"))
                        if (typeof message.reactionId === "number")
                            object.reactionId = options.longs === String ? String(message.reactionId) : message.reactionId;
                        else
                            object.reactionId = options.longs === String ? $util.Long.prototype.toString.call(message.reactionId) : options.longs === Number ? new $util.LongBits(message.reactionId.low >>> 0, message.reactionId.high >>> 0).toNumber(true) : message.reactionId;
                    if (message.taskId != null && message.hasOwnProperty("taskId"))
                        if (typeof message.taskId === "number")
                            object.taskId = options.longs === String ? String(message.taskId) : message.taskId;
                        else
                            object.taskId = options.longs === String ? $util.Long.prototype.toString.call(message.taskId) : options.longs === Number ? new $util.LongBits(message.taskId.low >>> 0, message.taskId.high >>> 0).toNumber(true) : message.taskId;
                    if (message.causeReactionId != null && message.hasOwnProperty("causeReactionId"))
                        if (typeof message.causeReactionId === "number")
                            object.causeReactionId = options.longs === String ? String(message.causeReactionId) : message.causeReactionId;
                        else
                            object.causeReactionId = options.longs === String ? $util.Long.prototype.toString.call(message.causeReactionId) : options.longs === Number ? new $util.LongBits(message.causeReactionId.low >>> 0, message.causeReactionId.high >>> 0).toNumber(true) : message.causeReactionId;
                    if (message.causeTaskId != null && message.hasOwnProperty("causeTaskId"))
                        if (typeof message.causeTaskId === "number")
                            object.causeTaskId = options.longs === String ? String(message.causeTaskId) : message.causeTaskId;
                        else
                            object.causeTaskId = options.longs === String ? $util.Long.prototype.toString.call(message.causeTaskId) : options.longs === Number ? new $util.LongBits(message.causeTaskId.low >>> 0, message.causeTaskId.high >>> 0).toNumber(true) : message.causeTaskId;
                    if (message.emitted != null && message.hasOwnProperty("emitted"))
                        if (typeof message.emitted === "number")
                            object.emitted = options.longs === String ? String(message.emitted) : message.emitted;
                        else
                            object.emitted = options.longs === String ? $util.Long.prototype.toString.call(message.emitted) : options.longs === Number ? new $util.LongBits(message.emitted.low >>> 0, message.emitted.high >>> 0).toNumber(true) : message.emitted;
                    if (message.started != null && message.hasOwnProperty("started"))
                        if (typeof message.started === "number")
                            object.started = options.longs === String ? String(message.started) : message.started;
                        else
                            object.started = options.longs === String ? $util.Long.prototype.toString.call(message.started) : options.longs === Number ? new $util.LongBits(message.started.low >>> 0, message.started.high >>> 0).toNumber(true) : message.started;
                    if (message.finished != null && message.hasOwnProperty("finished"))
                        if (typeof message.finished === "number")
                            object.finished = options.longs === String ? String(message.finished) : message.finished;
                        else
                            object.finished = options.longs === String ? $util.Long.prototype.toString.call(message.finished) : options.longs === Number ? new $util.LongBits(message.finished.low >>> 0, message.finished.high >>> 0).toNumber(true) : message.finished;
                    return object;
                };

                /**
                 * Creates a plain object from this ReactionStatistics message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReactionStatistics.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ReactionStatistics to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ReactionStatistics.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReactionStatistics;
            })();

            return nuclear;
        })();

        support.optimisation = (function() {

            /**
             * Namespace optimisation.
             * @exports message.support.optimisation
             * @namespace
             */
            var optimisation = {};

            optimisation.RegisterOptimisation = (function() {

                /**
                 * Properties of a RegisterOptimisation.
                 * @typedef message.support.optimisation.RegisterOptimisation$Properties
                 * @type {Object}
                 * @property {string} [group] RegisterOptimisation group.
                 * @property {boolean} [network] RegisterOptimisation network.
                 * @property {message.support.optimisation.OptimiserParameters$Properties} [parameters] RegisterOptimisation parameters.
                 */

                /**
                 * Constructs a new RegisterOptimisation.
                 * @exports message.support.optimisation.RegisterOptimisation
                 * @constructor
                 * @param {message.support.optimisation.RegisterOptimisation$Properties=} [properties] Properties to set
                 */
                function RegisterOptimisation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RegisterOptimisation group.
                 * @type {string}
                 */
                RegisterOptimisation.prototype.group = "";

                /**
                 * RegisterOptimisation network.
                 * @type {boolean}
                 */
                RegisterOptimisation.prototype.network = false;

                /**
                 * RegisterOptimisation parameters.
                 * @type {(message.support.optimisation.OptimiserParameters$Properties|null)}
                 */
                RegisterOptimisation.prototype.parameters = null;

                /**
                 * Creates a new RegisterOptimisation instance using the specified properties.
                 * @param {message.support.optimisation.RegisterOptimisation$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.RegisterOptimisation} RegisterOptimisation instance
                 */
                RegisterOptimisation.create = function create(properties) {
                    return new RegisterOptimisation(properties);
                };

                /**
                 * Encodes the specified RegisterOptimisation message. Does not implicitly {@link message.support.optimisation.RegisterOptimisation.verify|verify} messages.
                 * @param {message.support.optimisation.RegisterOptimisation$Properties} message RegisterOptimisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RegisterOptimisation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.group != null && message.hasOwnProperty("group"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.group);
                    if (message.network != null && message.hasOwnProperty("network"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.network);
                    if (message.parameters != null && message.hasOwnProperty("parameters"))
                        $root.message.support.optimisation.OptimiserParameters.encode(message.parameters, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RegisterOptimisation message, length delimited. Does not implicitly {@link message.support.optimisation.RegisterOptimisation.verify|verify} messages.
                 * @param {message.support.optimisation.RegisterOptimisation$Properties} message RegisterOptimisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RegisterOptimisation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RegisterOptimisation message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.RegisterOptimisation} RegisterOptimisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RegisterOptimisation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.optimisation.RegisterOptimisation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.group = reader.string();
                            break;
                        case 2:
                            message.network = reader.bool();
                            break;
                        case 3:
                            message.parameters = $root.message.support.optimisation.OptimiserParameters.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RegisterOptimisation message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.RegisterOptimisation} RegisterOptimisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RegisterOptimisation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RegisterOptimisation message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RegisterOptimisation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.group != null && message.hasOwnProperty("group"))
                        if (!$util.isString(message.group))
                            return "group: string expected";
                    if (message.network != null && message.hasOwnProperty("network"))
                        if (typeof message.network !== "boolean")
                            return "network: boolean expected";
                    if (message.parameters != null && message.hasOwnProperty("parameters")) {
                        var error = $root.message.support.optimisation.OptimiserParameters.verify(message.parameters);
                        if (error)
                            return "parameters." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RegisterOptimisation message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.RegisterOptimisation} RegisterOptimisation
                 */
                RegisterOptimisation.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.optimisation.RegisterOptimisation)
                        return object;
                    var message = new $root.message.support.optimisation.RegisterOptimisation();
                    if (object.group != null)
                        message.group = String(object.group);
                    if (object.network != null)
                        message.network = Boolean(object.network);
                    if (object.parameters != null) {
                        if (typeof object.parameters !== "object")
                            throw TypeError(".message.support.optimisation.RegisterOptimisation.parameters: object expected");
                        message.parameters = $root.message.support.optimisation.OptimiserParameters.fromObject(object.parameters);
                    }
                    return message;
                };

                /**
                 * Creates a RegisterOptimisation message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.RegisterOptimisation.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.RegisterOptimisation} RegisterOptimisation
                 */
                RegisterOptimisation.from = RegisterOptimisation.fromObject;

                /**
                 * Creates a plain object from a RegisterOptimisation message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.RegisterOptimisation} message RegisterOptimisation
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RegisterOptimisation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.group = "";
                        object.network = false;
                        object.parameters = null;
                    }
                    if (message.group != null && message.hasOwnProperty("group"))
                        object.group = message.group;
                    if (message.network != null && message.hasOwnProperty("network"))
                        object.network = message.network;
                    if (message.parameters != null && message.hasOwnProperty("parameters"))
                        object.parameters = $root.message.support.optimisation.OptimiserParameters.toObject(message.parameters, options);
                    return object;
                };

                /**
                 * Creates a plain object from this RegisterOptimisation message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RegisterOptimisation.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RegisterOptimisation to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RegisterOptimisation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RegisterOptimisation;
            })();

            optimisation.RequestParameters = (function() {

                /**
                 * Properties of a RequestParameters.
                 * @typedef message.support.optimisation.RequestParameters$Properties
                 * @type {Object}
                 * @property {string} [group] RequestParameters group.
                 * @property {number} [nSamples] RequestParameters nSamples.
                 */

                /**
                 * Constructs a new RequestParameters.
                 * @exports message.support.optimisation.RequestParameters
                 * @constructor
                 * @param {message.support.optimisation.RequestParameters$Properties=} [properties] Properties to set
                 */
                function RequestParameters(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RequestParameters group.
                 * @type {string}
                 */
                RequestParameters.prototype.group = "";

                /**
                 * RequestParameters nSamples.
                 * @type {number}
                 */
                RequestParameters.prototype.nSamples = 0;

                /**
                 * Creates a new RequestParameters instance using the specified properties.
                 * @param {message.support.optimisation.RequestParameters$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.RequestParameters} RequestParameters instance
                 */
                RequestParameters.create = function create(properties) {
                    return new RequestParameters(properties);
                };

                /**
                 * Encodes the specified RequestParameters message. Does not implicitly {@link message.support.optimisation.RequestParameters.verify|verify} messages.
                 * @param {message.support.optimisation.RequestParameters$Properties} message RequestParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RequestParameters.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.group != null && message.hasOwnProperty("group"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.group);
                    if (message.nSamples != null && message.hasOwnProperty("nSamples"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.nSamples);
                    return writer;
                };

                /**
                 * Encodes the specified RequestParameters message, length delimited. Does not implicitly {@link message.support.optimisation.RequestParameters.verify|verify} messages.
                 * @param {message.support.optimisation.RequestParameters$Properties} message RequestParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RequestParameters.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RequestParameters message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.RequestParameters} RequestParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RequestParameters.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.optimisation.RequestParameters();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.group = reader.string();
                            break;
                        case 2:
                            message.nSamples = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RequestParameters message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.RequestParameters} RequestParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RequestParameters.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RequestParameters message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RequestParameters.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.group != null && message.hasOwnProperty("group"))
                        if (!$util.isString(message.group))
                            return "group: string expected";
                    if (message.nSamples != null && message.hasOwnProperty("nSamples"))
                        if (!$util.isInteger(message.nSamples))
                            return "nSamples: integer expected";
                    return null;
                };

                /**
                 * Creates a RequestParameters message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.RequestParameters} RequestParameters
                 */
                RequestParameters.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.optimisation.RequestParameters)
                        return object;
                    var message = new $root.message.support.optimisation.RequestParameters();
                    if (object.group != null)
                        message.group = String(object.group);
                    if (object.nSamples != null)
                        message.nSamples = object.nSamples >>> 0;
                    return message;
                };

                /**
                 * Creates a RequestParameters message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.RequestParameters.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.RequestParameters} RequestParameters
                 */
                RequestParameters.from = RequestParameters.fromObject;

                /**
                 * Creates a plain object from a RequestParameters message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.RequestParameters} message RequestParameters
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RequestParameters.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.group = "";
                        object.nSamples = 0;
                    }
                    if (message.group != null && message.hasOwnProperty("group"))
                        object.group = message.group;
                    if (message.nSamples != null && message.hasOwnProperty("nSamples"))
                        object.nSamples = message.nSamples;
                    return object;
                };

                /**
                 * Creates a plain object from this RequestParameters message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RequestParameters.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RequestParameters to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RequestParameters.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RequestParameters;
            })();

            optimisation.Parameters = (function() {

                /**
                 * Properties of a Parameters.
                 * @typedef message.support.optimisation.Parameters$Properties
                 * @type {Object}
                 * @property {string} [group] Parameters group.
                 * @property {number} [generation] Parameters generation.
                 * @property {mat$Properties} [samples] Parameters samples.
                 * @property {mat$Properties} [covariance] Parameters covariance.
                 */

                /**
                 * Constructs a new Parameters.
                 * @exports message.support.optimisation.Parameters
                 * @constructor
                 * @param {message.support.optimisation.Parameters$Properties=} [properties] Properties to set
                 */
                function Parameters(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Parameters group.
                 * @type {string}
                 */
                Parameters.prototype.group = "";

                /**
                 * Parameters generation.
                 * @type {number}
                 */
                Parameters.prototype.generation = 0;

                /**
                 * Parameters samples.
                 * @type {(mat$Properties|null)}
                 */
                Parameters.prototype.samples = null;

                /**
                 * Parameters covariance.
                 * @type {(mat$Properties|null)}
                 */
                Parameters.prototype.covariance = null;

                /**
                 * Creates a new Parameters instance using the specified properties.
                 * @param {message.support.optimisation.Parameters$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.Parameters} Parameters instance
                 */
                Parameters.create = function create(properties) {
                    return new Parameters(properties);
                };

                /**
                 * Encodes the specified Parameters message. Does not implicitly {@link message.support.optimisation.Parameters.verify|verify} messages.
                 * @param {message.support.optimisation.Parameters$Properties} message Parameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Parameters.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.group != null && message.hasOwnProperty("group"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.group);
                    if (message.generation != null && message.hasOwnProperty("generation"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.generation);
                    if (message.samples != null && message.hasOwnProperty("samples"))
                        $root.mat.encode(message.samples, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.covariance != null && message.hasOwnProperty("covariance"))
                        $root.mat.encode(message.covariance, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Parameters message, length delimited. Does not implicitly {@link message.support.optimisation.Parameters.verify|verify} messages.
                 * @param {message.support.optimisation.Parameters$Properties} message Parameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Parameters.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Parameters message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.Parameters} Parameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Parameters.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.optimisation.Parameters();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.group = reader.string();
                            break;
                        case 2:
                            message.generation = reader.int32();
                            break;
                        case 3:
                            message.samples = $root.mat.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.covariance = $root.mat.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Parameters message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.Parameters} Parameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Parameters.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Parameters message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Parameters.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.group != null && message.hasOwnProperty("group"))
                        if (!$util.isString(message.group))
                            return "group: string expected";
                    if (message.generation != null && message.hasOwnProperty("generation"))
                        if (!$util.isInteger(message.generation))
                            return "generation: integer expected";
                    if (message.samples != null && message.hasOwnProperty("samples")) {
                        var error = $root.mat.verify(message.samples);
                        if (error)
                            return "samples." + error;
                    }
                    if (message.covariance != null && message.hasOwnProperty("covariance")) {
                        var error = $root.mat.verify(message.covariance);
                        if (error)
                            return "covariance." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Parameters message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.Parameters} Parameters
                 */
                Parameters.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.optimisation.Parameters)
                        return object;
                    var message = new $root.message.support.optimisation.Parameters();
                    if (object.group != null)
                        message.group = String(object.group);
                    if (object.generation != null)
                        message.generation = object.generation | 0;
                    if (object.samples != null) {
                        if (typeof object.samples !== "object")
                            throw TypeError(".message.support.optimisation.Parameters.samples: object expected");
                        message.samples = $root.mat.fromObject(object.samples);
                    }
                    if (object.covariance != null) {
                        if (typeof object.covariance !== "object")
                            throw TypeError(".message.support.optimisation.Parameters.covariance: object expected");
                        message.covariance = $root.mat.fromObject(object.covariance);
                    }
                    return message;
                };

                /**
                 * Creates a Parameters message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.Parameters.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.Parameters} Parameters
                 */
                Parameters.from = Parameters.fromObject;

                /**
                 * Creates a plain object from a Parameters message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.Parameters} message Parameters
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Parameters.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.group = "";
                        object.generation = 0;
                        object.samples = null;
                        object.covariance = null;
                    }
                    if (message.group != null && message.hasOwnProperty("group"))
                        object.group = message.group;
                    if (message.generation != null && message.hasOwnProperty("generation"))
                        object.generation = message.generation;
                    if (message.samples != null && message.hasOwnProperty("samples"))
                        object.samples = $root.mat.toObject(message.samples, options);
                    if (message.covariance != null && message.hasOwnProperty("covariance"))
                        object.covariance = $root.mat.toObject(message.covariance, options);
                    return object;
                };

                /**
                 * Creates a plain object from this Parameters message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Parameters.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Parameters to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Parameters.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Parameters;
            })();

            optimisation.OptimiserEstimate = (function() {

                /**
                 * Properties of an OptimiserEstimate.
                 * @typedef message.support.optimisation.OptimiserEstimate$Properties
                 * @type {Object}
                 * @property {number} [generation] OptimiserEstimate generation.
                 * @property {vec$Properties} [estimate] OptimiserEstimate estimate.
                 * @property {mat$Properties} [covariance] OptimiserEstimate covariance.
                 */

                /**
                 * Constructs a new OptimiserEstimate.
                 * @exports message.support.optimisation.OptimiserEstimate
                 * @constructor
                 * @param {message.support.optimisation.OptimiserEstimate$Properties=} [properties] Properties to set
                 */
                function OptimiserEstimate(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * OptimiserEstimate generation.
                 * @type {number}
                 */
                OptimiserEstimate.prototype.generation = 0;

                /**
                 * OptimiserEstimate estimate.
                 * @type {(vec$Properties|null)}
                 */
                OptimiserEstimate.prototype.estimate = null;

                /**
                 * OptimiserEstimate covariance.
                 * @type {(mat$Properties|null)}
                 */
                OptimiserEstimate.prototype.covariance = null;

                /**
                 * Creates a new OptimiserEstimate instance using the specified properties.
                 * @param {message.support.optimisation.OptimiserEstimate$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.OptimiserEstimate} OptimiserEstimate instance
                 */
                OptimiserEstimate.create = function create(properties) {
                    return new OptimiserEstimate(properties);
                };

                /**
                 * Encodes the specified OptimiserEstimate message. Does not implicitly {@link message.support.optimisation.OptimiserEstimate.verify|verify} messages.
                 * @param {message.support.optimisation.OptimiserEstimate$Properties} message OptimiserEstimate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OptimiserEstimate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.generation != null && message.hasOwnProperty("generation"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.generation);
                    if (message.estimate != null && message.hasOwnProperty("estimate"))
                        $root.vec.encode(message.estimate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.covariance != null && message.hasOwnProperty("covariance"))
                        $root.mat.encode(message.covariance, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified OptimiserEstimate message, length delimited. Does not implicitly {@link message.support.optimisation.OptimiserEstimate.verify|verify} messages.
                 * @param {message.support.optimisation.OptimiserEstimate$Properties} message OptimiserEstimate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OptimiserEstimate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an OptimiserEstimate message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.OptimiserEstimate} OptimiserEstimate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OptimiserEstimate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.optimisation.OptimiserEstimate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.generation = reader.int32();
                            break;
                        case 2:
                            message.estimate = $root.vec.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.covariance = $root.mat.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an OptimiserEstimate message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.OptimiserEstimate} OptimiserEstimate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OptimiserEstimate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an OptimiserEstimate message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                OptimiserEstimate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.generation != null && message.hasOwnProperty("generation"))
                        if (!$util.isInteger(message.generation))
                            return "generation: integer expected";
                    if (message.estimate != null && message.hasOwnProperty("estimate")) {
                        var error = $root.vec.verify(message.estimate);
                        if (error)
                            return "estimate." + error;
                    }
                    if (message.covariance != null && message.hasOwnProperty("covariance")) {
                        var error = $root.mat.verify(message.covariance);
                        if (error)
                            return "covariance." + error;
                    }
                    return null;
                };

                /**
                 * Creates an OptimiserEstimate message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.OptimiserEstimate} OptimiserEstimate
                 */
                OptimiserEstimate.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.optimisation.OptimiserEstimate)
                        return object;
                    var message = new $root.message.support.optimisation.OptimiserEstimate();
                    if (object.generation != null)
                        message.generation = object.generation | 0;
                    if (object.estimate != null) {
                        if (typeof object.estimate !== "object")
                            throw TypeError(".message.support.optimisation.OptimiserEstimate.estimate: object expected");
                        message.estimate = $root.vec.fromObject(object.estimate);
                    }
                    if (object.covariance != null) {
                        if (typeof object.covariance !== "object")
                            throw TypeError(".message.support.optimisation.OptimiserEstimate.covariance: object expected");
                        message.covariance = $root.mat.fromObject(object.covariance);
                    }
                    return message;
                };

                /**
                 * Creates an OptimiserEstimate message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.OptimiserEstimate.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.OptimiserEstimate} OptimiserEstimate
                 */
                OptimiserEstimate.from = OptimiserEstimate.fromObject;

                /**
                 * Creates a plain object from an OptimiserEstimate message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.OptimiserEstimate} message OptimiserEstimate
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OptimiserEstimate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.generation = 0;
                        object.estimate = null;
                        object.covariance = null;
                    }
                    if (message.generation != null && message.hasOwnProperty("generation"))
                        object.generation = message.generation;
                    if (message.estimate != null && message.hasOwnProperty("estimate"))
                        object.estimate = $root.vec.toObject(message.estimate, options);
                    if (message.covariance != null && message.hasOwnProperty("covariance"))
                        object.covariance = $root.mat.toObject(message.covariance, options);
                    return object;
                };

                /**
                 * Creates a plain object from this OptimiserEstimate message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OptimiserEstimate.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this OptimiserEstimate to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                OptimiserEstimate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return OptimiserEstimate;
            })();

            optimisation.OptimiserParameters = (function() {

                /**
                 * Properties of an OptimiserParameters.
                 * @typedef message.support.optimisation.OptimiserParameters$Properties
                 * @type {Object}
                 * @property {message.support.optimisation.OptimiserEstimate$Properties} [initial] OptimiserParameters initial.
                 * @property {vec$Properties} [upperBound] OptimiserParameters upperBound.
                 * @property {vec$Properties} [lowerBound] OptimiserParameters lowerBound.
                 * @property {number} [batchSize] OptimiserParameters batchSize.
                 */

                /**
                 * Constructs a new OptimiserParameters.
                 * @exports message.support.optimisation.OptimiserParameters
                 * @constructor
                 * @param {message.support.optimisation.OptimiserParameters$Properties=} [properties] Properties to set
                 */
                function OptimiserParameters(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * OptimiserParameters initial.
                 * @type {(message.support.optimisation.OptimiserEstimate$Properties|null)}
                 */
                OptimiserParameters.prototype.initial = null;

                /**
                 * OptimiserParameters upperBound.
                 * @type {(vec$Properties|null)}
                 */
                OptimiserParameters.prototype.upperBound = null;

                /**
                 * OptimiserParameters lowerBound.
                 * @type {(vec$Properties|null)}
                 */
                OptimiserParameters.prototype.lowerBound = null;

                /**
                 * OptimiserParameters batchSize.
                 * @type {number}
                 */
                OptimiserParameters.prototype.batchSize = 0;

                /**
                 * Creates a new OptimiserParameters instance using the specified properties.
                 * @param {message.support.optimisation.OptimiserParameters$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.OptimiserParameters} OptimiserParameters instance
                 */
                OptimiserParameters.create = function create(properties) {
                    return new OptimiserParameters(properties);
                };

                /**
                 * Encodes the specified OptimiserParameters message. Does not implicitly {@link message.support.optimisation.OptimiserParameters.verify|verify} messages.
                 * @param {message.support.optimisation.OptimiserParameters$Properties} message OptimiserParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OptimiserParameters.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.initial != null && message.hasOwnProperty("initial"))
                        $root.message.support.optimisation.OptimiserEstimate.encode(message.initial, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.upperBound != null && message.hasOwnProperty("upperBound"))
                        $root.vec.encode(message.upperBound, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.lowerBound != null && message.hasOwnProperty("lowerBound"))
                        $root.vec.encode(message.lowerBound, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.batchSize != null && message.hasOwnProperty("batchSize"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.batchSize);
                    return writer;
                };

                /**
                 * Encodes the specified OptimiserParameters message, length delimited. Does not implicitly {@link message.support.optimisation.OptimiserParameters.verify|verify} messages.
                 * @param {message.support.optimisation.OptimiserParameters$Properties} message OptimiserParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OptimiserParameters.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an OptimiserParameters message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.OptimiserParameters} OptimiserParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OptimiserParameters.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.optimisation.OptimiserParameters();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.initial = $root.message.support.optimisation.OptimiserEstimate.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.upperBound = $root.vec.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.lowerBound = $root.vec.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.batchSize = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an OptimiserParameters message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.OptimiserParameters} OptimiserParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OptimiserParameters.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an OptimiserParameters message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                OptimiserParameters.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.initial != null && message.hasOwnProperty("initial")) {
                        var error = $root.message.support.optimisation.OptimiserEstimate.verify(message.initial);
                        if (error)
                            return "initial." + error;
                    }
                    if (message.upperBound != null && message.hasOwnProperty("upperBound")) {
                        var error = $root.vec.verify(message.upperBound);
                        if (error)
                            return "upperBound." + error;
                    }
                    if (message.lowerBound != null && message.hasOwnProperty("lowerBound")) {
                        var error = $root.vec.verify(message.lowerBound);
                        if (error)
                            return "lowerBound." + error;
                    }
                    if (message.batchSize != null && message.hasOwnProperty("batchSize"))
                        if (!$util.isInteger(message.batchSize))
                            return "batchSize: integer expected";
                    return null;
                };

                /**
                 * Creates an OptimiserParameters message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.OptimiserParameters} OptimiserParameters
                 */
                OptimiserParameters.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.optimisation.OptimiserParameters)
                        return object;
                    var message = new $root.message.support.optimisation.OptimiserParameters();
                    if (object.initial != null) {
                        if (typeof object.initial !== "object")
                            throw TypeError(".message.support.optimisation.OptimiserParameters.initial: object expected");
                        message.initial = $root.message.support.optimisation.OptimiserEstimate.fromObject(object.initial);
                    }
                    if (object.upperBound != null) {
                        if (typeof object.upperBound !== "object")
                            throw TypeError(".message.support.optimisation.OptimiserParameters.upperBound: object expected");
                        message.upperBound = $root.vec.fromObject(object.upperBound);
                    }
                    if (object.lowerBound != null) {
                        if (typeof object.lowerBound !== "object")
                            throw TypeError(".message.support.optimisation.OptimiserParameters.lowerBound: object expected");
                        message.lowerBound = $root.vec.fromObject(object.lowerBound);
                    }
                    if (object.batchSize != null)
                        message.batchSize = object.batchSize >>> 0;
                    return message;
                };

                /**
                 * Creates an OptimiserParameters message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.OptimiserParameters.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.OptimiserParameters} OptimiserParameters
                 */
                OptimiserParameters.from = OptimiserParameters.fromObject;

                /**
                 * Creates a plain object from an OptimiserParameters message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.OptimiserParameters} message OptimiserParameters
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OptimiserParameters.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.initial = null;
                        object.upperBound = null;
                        object.lowerBound = null;
                        object.batchSize = 0;
                    }
                    if (message.initial != null && message.hasOwnProperty("initial"))
                        object.initial = $root.message.support.optimisation.OptimiserEstimate.toObject(message.initial, options);
                    if (message.upperBound != null && message.hasOwnProperty("upperBound"))
                        object.upperBound = $root.vec.toObject(message.upperBound, options);
                    if (message.lowerBound != null && message.hasOwnProperty("lowerBound"))
                        object.lowerBound = $root.vec.toObject(message.lowerBound, options);
                    if (message.batchSize != null && message.hasOwnProperty("batchSize"))
                        object.batchSize = message.batchSize;
                    return object;
                };

                /**
                 * Creates a plain object from this OptimiserParameters message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OptimiserParameters.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this OptimiserParameters to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                OptimiserParameters.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return OptimiserParameters;
            })();

            optimisation.Episode = (function() {

                /**
                 * Properties of an Episode.
                 * @typedef message.support.optimisation.Episode$Properties
                 * @type {Object}
                 * @property {string} [group] Episode group.
                 * @property {number} [generation] Episode generation.
                 * @property {vec$Properties} [values] Episode values.
                 * @property {mat$Properties} [covariance] Episode covariance.
                 * @property {Array.<message.support.optimisation.Episode.Fitness$Properties>} [fitness] Episode fitness.
                 */

                /**
                 * Constructs a new Episode.
                 * @exports message.support.optimisation.Episode
                 * @constructor
                 * @param {message.support.optimisation.Episode$Properties=} [properties] Properties to set
                 */
                function Episode(properties) {
                    this.fitness = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Episode group.
                 * @type {string}
                 */
                Episode.prototype.group = "";

                /**
                 * Episode generation.
                 * @type {number}
                 */
                Episode.prototype.generation = 0;

                /**
                 * Episode values.
                 * @type {(vec$Properties|null)}
                 */
                Episode.prototype.values = null;

                /**
                 * Episode covariance.
                 * @type {(mat$Properties|null)}
                 */
                Episode.prototype.covariance = null;

                /**
                 * Episode fitness.
                 * @type {Array.<message.support.optimisation.Episode.Fitness$Properties>}
                 */
                Episode.prototype.fitness = $util.emptyArray;

                /**
                 * Creates a new Episode instance using the specified properties.
                 * @param {message.support.optimisation.Episode$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.Episode} Episode instance
                 */
                Episode.create = function create(properties) {
                    return new Episode(properties);
                };

                /**
                 * Encodes the specified Episode message. Does not implicitly {@link message.support.optimisation.Episode.verify|verify} messages.
                 * @param {message.support.optimisation.Episode$Properties} message Episode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Episode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.group != null && message.hasOwnProperty("group"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.group);
                    if (message.generation != null && message.hasOwnProperty("generation"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.generation);
                    if (message.values != null && message.hasOwnProperty("values"))
                        $root.vec.encode(message.values, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.covariance != null && message.hasOwnProperty("covariance"))
                        $root.mat.encode(message.covariance, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.fitness != null && message.fitness.length)
                        for (var i = 0; i < message.fitness.length; ++i)
                            $root.message.support.optimisation.Episode.Fitness.encode(message.fitness[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Episode message, length delimited. Does not implicitly {@link message.support.optimisation.Episode.verify|verify} messages.
                 * @param {message.support.optimisation.Episode$Properties} message Episode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Episode.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Episode message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.Episode} Episode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Episode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.optimisation.Episode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.group = reader.string();
                            break;
                        case 2:
                            message.generation = reader.int32();
                            break;
                        case 3:
                            message.values = $root.vec.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.covariance = $root.mat.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.fitness && message.fitness.length))
                                message.fitness = [];
                            message.fitness.push($root.message.support.optimisation.Episode.Fitness.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Episode message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.Episode} Episode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Episode.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Episode message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Episode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.group != null && message.hasOwnProperty("group"))
                        if (!$util.isString(message.group))
                            return "group: string expected";
                    if (message.generation != null && message.hasOwnProperty("generation"))
                        if (!$util.isInteger(message.generation))
                            return "generation: integer expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        var error = $root.vec.verify(message.values);
                        if (error)
                            return "values." + error;
                    }
                    if (message.covariance != null && message.hasOwnProperty("covariance")) {
                        var error = $root.mat.verify(message.covariance);
                        if (error)
                            return "covariance." + error;
                    }
                    if (message.fitness != null && message.hasOwnProperty("fitness")) {
                        if (!Array.isArray(message.fitness))
                            return "fitness: array expected";
                        for (var i = 0; i < message.fitness.length; ++i) {
                            var error = $root.message.support.optimisation.Episode.Fitness.verify(message.fitness[i]);
                            if (error)
                                return "fitness." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Episode message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.Episode} Episode
                 */
                Episode.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.optimisation.Episode)
                        return object;
                    var message = new $root.message.support.optimisation.Episode();
                    if (object.group != null)
                        message.group = String(object.group);
                    if (object.generation != null)
                        message.generation = object.generation | 0;
                    if (object.values != null) {
                        if (typeof object.values !== "object")
                            throw TypeError(".message.support.optimisation.Episode.values: object expected");
                        message.values = $root.vec.fromObject(object.values);
                    }
                    if (object.covariance != null) {
                        if (typeof object.covariance !== "object")
                            throw TypeError(".message.support.optimisation.Episode.covariance: object expected");
                        message.covariance = $root.mat.fromObject(object.covariance);
                    }
                    if (object.fitness) {
                        if (!Array.isArray(object.fitness))
                            throw TypeError(".message.support.optimisation.Episode.fitness: array expected");
                        message.fitness = [];
                        for (var i = 0; i < object.fitness.length; ++i) {
                            if (typeof object.fitness[i] !== "object")
                                throw TypeError(".message.support.optimisation.Episode.fitness: object expected");
                            message.fitness[i] = $root.message.support.optimisation.Episode.Fitness.fromObject(object.fitness[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates an Episode message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.Episode.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.Episode} Episode
                 */
                Episode.from = Episode.fromObject;

                /**
                 * Creates a plain object from an Episode message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.Episode} message Episode
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Episode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.fitness = [];
                    if (options.defaults) {
                        object.group = "";
                        object.generation = 0;
                        object.values = null;
                        object.covariance = null;
                    }
                    if (message.group != null && message.hasOwnProperty("group"))
                        object.group = message.group;
                    if (message.generation != null && message.hasOwnProperty("generation"))
                        object.generation = message.generation;
                    if (message.values != null && message.hasOwnProperty("values"))
                        object.values = $root.vec.toObject(message.values, options);
                    if (message.covariance != null && message.hasOwnProperty("covariance"))
                        object.covariance = $root.mat.toObject(message.covariance, options);
                    if (message.fitness && message.fitness.length) {
                        object.fitness = [];
                        for (var j = 0; j < message.fitness.length; ++j)
                            object.fitness[j] = $root.message.support.optimisation.Episode.Fitness.toObject(message.fitness[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this Episode message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Episode.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Episode to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Episode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Episode.Fitness = (function() {

                    /**
                     * Properties of a Fitness.
                     * @typedef message.support.optimisation.Episode.Fitness$Properties
                     * @type {Object}
                     * @property {number} [fitness] Fitness fitness.
                     * @property {number} [weight] Fitness weight.
                     */

                    /**
                     * Constructs a new Fitness.
                     * @exports message.support.optimisation.Episode.Fitness
                     * @constructor
                     * @param {message.support.optimisation.Episode.Fitness$Properties=} [properties] Properties to set
                     */
                    function Fitness(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Fitness fitness.
                     * @type {number}
                     */
                    Fitness.prototype.fitness = 0;

                    /**
                     * Fitness weight.
                     * @type {number}
                     */
                    Fitness.prototype.weight = 0;

                    /**
                     * Creates a new Fitness instance using the specified properties.
                     * @param {message.support.optimisation.Episode.Fitness$Properties=} [properties] Properties to set
                     * @returns {message.support.optimisation.Episode.Fitness} Fitness instance
                     */
                    Fitness.create = function create(properties) {
                        return new Fitness(properties);
                    };

                    /**
                     * Encodes the specified Fitness message. Does not implicitly {@link message.support.optimisation.Episode.Fitness.verify|verify} messages.
                     * @param {message.support.optimisation.Episode.Fitness$Properties} message Fitness message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Fitness.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.fitness != null && message.hasOwnProperty("fitness"))
                            writer.uint32(/* id 1, wireType 1 =*/9).double(message.fitness);
                        if (message.weight != null && message.hasOwnProperty("weight"))
                            writer.uint32(/* id 2, wireType 1 =*/17).double(message.weight);
                        return writer;
                    };

                    /**
                     * Encodes the specified Fitness message, length delimited. Does not implicitly {@link message.support.optimisation.Episode.Fitness.verify|verify} messages.
                     * @param {message.support.optimisation.Episode.Fitness$Properties} message Fitness message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Fitness.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Fitness message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.support.optimisation.Episode.Fitness} Fitness
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Fitness.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.optimisation.Episode.Fitness();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.fitness = reader.double();
                                break;
                            case 2:
                                message.weight = reader.double();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Fitness message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.support.optimisation.Episode.Fitness} Fitness
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Fitness.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Fitness message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Fitness.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fitness != null && message.hasOwnProperty("fitness"))
                            if (typeof message.fitness !== "number")
                                return "fitness: number expected";
                        if (message.weight != null && message.hasOwnProperty("weight"))
                            if (typeof message.weight !== "number")
                                return "weight: number expected";
                        return null;
                    };

                    /**
                     * Creates a Fitness message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.support.optimisation.Episode.Fitness} Fitness
                     */
                    Fitness.fromObject = function fromObject(object) {
                        if (object instanceof $root.message.support.optimisation.Episode.Fitness)
                            return object;
                        var message = new $root.message.support.optimisation.Episode.Fitness();
                        if (object.fitness != null)
                            message.fitness = Number(object.fitness);
                        if (object.weight != null)
                            message.weight = Number(object.weight);
                        return message;
                    };

                    /**
                     * Creates a Fitness message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.support.optimisation.Episode.Fitness.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.support.optimisation.Episode.Fitness} Fitness
                     */
                    Fitness.from = Fitness.fromObject;

                    /**
                     * Creates a plain object from a Fitness message. Also converts values to other types if specified.
                     * @param {message.support.optimisation.Episode.Fitness} message Fitness
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Fitness.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.fitness = 0;
                            object.weight = 0;
                        }
                        if (message.fitness != null && message.hasOwnProperty("fitness"))
                            object.fitness = message.fitness;
                        if (message.weight != null && message.hasOwnProperty("weight"))
                            object.weight = message.weight;
                        return object;
                    };

                    /**
                     * Creates a plain object from this Fitness message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Fitness.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Fitness to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Fitness.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Fitness;
                })();

                return Episode;
            })();

            optimisation.Estimate = (function() {

                /**
                 * Properties of an Estimate.
                 * @typedef message.support.optimisation.Estimate$Properties
                 * @type {Object}
                 * @property {string} [group] Estimate group.
                 * @property {number} [generation] Estimate generation.
                 * @property {vec$Properties} [values] Estimate values.
                 * @property {mat$Properties} [covariance] Estimate covariance.
                 * @property {Array.<message.support.optimisation.Episode$Properties>} [estimateEpisode] Estimate estimateEpisode.
                 * @property {Array.<message.support.optimisation.Episode$Properties>} [episode] Estimate episode.
                 */

                /**
                 * Constructs a new Estimate.
                 * @exports message.support.optimisation.Estimate
                 * @constructor
                 * @param {message.support.optimisation.Estimate$Properties=} [properties] Properties to set
                 */
                function Estimate(properties) {
                    this.estimateEpisode = [];
                    this.episode = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Estimate group.
                 * @type {string}
                 */
                Estimate.prototype.group = "";

                /**
                 * Estimate generation.
                 * @type {number}
                 */
                Estimate.prototype.generation = 0;

                /**
                 * Estimate values.
                 * @type {(vec$Properties|null)}
                 */
                Estimate.prototype.values = null;

                /**
                 * Estimate covariance.
                 * @type {(mat$Properties|null)}
                 */
                Estimate.prototype.covariance = null;

                /**
                 * Estimate estimateEpisode.
                 * @type {Array.<message.support.optimisation.Episode$Properties>}
                 */
                Estimate.prototype.estimateEpisode = $util.emptyArray;

                /**
                 * Estimate episode.
                 * @type {Array.<message.support.optimisation.Episode$Properties>}
                 */
                Estimate.prototype.episode = $util.emptyArray;

                /**
                 * Creates a new Estimate instance using the specified properties.
                 * @param {message.support.optimisation.Estimate$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.Estimate} Estimate instance
                 */
                Estimate.create = function create(properties) {
                    return new Estimate(properties);
                };

                /**
                 * Encodes the specified Estimate message. Does not implicitly {@link message.support.optimisation.Estimate.verify|verify} messages.
                 * @param {message.support.optimisation.Estimate$Properties} message Estimate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Estimate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.group != null && message.hasOwnProperty("group"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.group);
                    if (message.generation != null && message.hasOwnProperty("generation"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.generation);
                    if (message.values != null && message.hasOwnProperty("values"))
                        $root.vec.encode(message.values, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.covariance != null && message.hasOwnProperty("covariance"))
                        $root.mat.encode(message.covariance, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.estimateEpisode != null && message.estimateEpisode.length)
                        for (var i = 0; i < message.estimateEpisode.length; ++i)
                            $root.message.support.optimisation.Episode.encode(message.estimateEpisode[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.episode != null && message.episode.length)
                        for (var i = 0; i < message.episode.length; ++i)
                            $root.message.support.optimisation.Episode.encode(message.episode[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Estimate message, length delimited. Does not implicitly {@link message.support.optimisation.Estimate.verify|verify} messages.
                 * @param {message.support.optimisation.Estimate$Properties} message Estimate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Estimate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Estimate message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.Estimate} Estimate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Estimate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.optimisation.Estimate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.group = reader.string();
                            break;
                        case 2:
                            message.generation = reader.int32();
                            break;
                        case 3:
                            message.values = $root.vec.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.covariance = $root.mat.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.estimateEpisode && message.estimateEpisode.length))
                                message.estimateEpisode = [];
                            message.estimateEpisode.push($root.message.support.optimisation.Episode.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.episode && message.episode.length))
                                message.episode = [];
                            message.episode.push($root.message.support.optimisation.Episode.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Estimate message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.Estimate} Estimate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Estimate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Estimate message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Estimate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.group != null && message.hasOwnProperty("group"))
                        if (!$util.isString(message.group))
                            return "group: string expected";
                    if (message.generation != null && message.hasOwnProperty("generation"))
                        if (!$util.isInteger(message.generation))
                            return "generation: integer expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        var error = $root.vec.verify(message.values);
                        if (error)
                            return "values." + error;
                    }
                    if (message.covariance != null && message.hasOwnProperty("covariance")) {
                        var error = $root.mat.verify(message.covariance);
                        if (error)
                            return "covariance." + error;
                    }
                    if (message.estimateEpisode != null && message.hasOwnProperty("estimateEpisode")) {
                        if (!Array.isArray(message.estimateEpisode))
                            return "estimateEpisode: array expected";
                        for (var i = 0; i < message.estimateEpisode.length; ++i) {
                            var error = $root.message.support.optimisation.Episode.verify(message.estimateEpisode[i]);
                            if (error)
                                return "estimateEpisode." + error;
                        }
                    }
                    if (message.episode != null && message.hasOwnProperty("episode")) {
                        if (!Array.isArray(message.episode))
                            return "episode: array expected";
                        for (var i = 0; i < message.episode.length; ++i) {
                            var error = $root.message.support.optimisation.Episode.verify(message.episode[i]);
                            if (error)
                                return "episode." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Estimate message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.Estimate} Estimate
                 */
                Estimate.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.support.optimisation.Estimate)
                        return object;
                    var message = new $root.message.support.optimisation.Estimate();
                    if (object.group != null)
                        message.group = String(object.group);
                    if (object.generation != null)
                        message.generation = object.generation | 0;
                    if (object.values != null) {
                        if (typeof object.values !== "object")
                            throw TypeError(".message.support.optimisation.Estimate.values: object expected");
                        message.values = $root.vec.fromObject(object.values);
                    }
                    if (object.covariance != null) {
                        if (typeof object.covariance !== "object")
                            throw TypeError(".message.support.optimisation.Estimate.covariance: object expected");
                        message.covariance = $root.mat.fromObject(object.covariance);
                    }
                    if (object.estimateEpisode) {
                        if (!Array.isArray(object.estimateEpisode))
                            throw TypeError(".message.support.optimisation.Estimate.estimateEpisode: array expected");
                        message.estimateEpisode = [];
                        for (var i = 0; i < object.estimateEpisode.length; ++i) {
                            if (typeof object.estimateEpisode[i] !== "object")
                                throw TypeError(".message.support.optimisation.Estimate.estimateEpisode: object expected");
                            message.estimateEpisode[i] = $root.message.support.optimisation.Episode.fromObject(object.estimateEpisode[i]);
                        }
                    }
                    if (object.episode) {
                        if (!Array.isArray(object.episode))
                            throw TypeError(".message.support.optimisation.Estimate.episode: array expected");
                        message.episode = [];
                        for (var i = 0; i < object.episode.length; ++i) {
                            if (typeof object.episode[i] !== "object")
                                throw TypeError(".message.support.optimisation.Estimate.episode: object expected");
                            message.episode[i] = $root.message.support.optimisation.Episode.fromObject(object.episode[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates an Estimate message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.Estimate.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.Estimate} Estimate
                 */
                Estimate.from = Estimate.fromObject;

                /**
                 * Creates a plain object from an Estimate message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.Estimate} message Estimate
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Estimate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.estimateEpisode = [];
                        object.episode = [];
                    }
                    if (options.defaults) {
                        object.group = "";
                        object.generation = 0;
                        object.values = null;
                        object.covariance = null;
                    }
                    if (message.group != null && message.hasOwnProperty("group"))
                        object.group = message.group;
                    if (message.generation != null && message.hasOwnProperty("generation"))
                        object.generation = message.generation;
                    if (message.values != null && message.hasOwnProperty("values"))
                        object.values = $root.vec.toObject(message.values, options);
                    if (message.covariance != null && message.hasOwnProperty("covariance"))
                        object.covariance = $root.mat.toObject(message.covariance, options);
                    if (message.estimateEpisode && message.estimateEpisode.length) {
                        object.estimateEpisode = [];
                        for (var j = 0; j < message.estimateEpisode.length; ++j)
                            object.estimateEpisode[j] = $root.message.support.optimisation.Episode.toObject(message.estimateEpisode[j], options);
                    }
                    if (message.episode && message.episode.length) {
                        object.episode = [];
                        for (var j = 0; j < message.episode.length; ++j)
                            object.episode[j] = $root.message.support.optimisation.Episode.toObject(message.episode[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this Estimate message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Estimate.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Estimate to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Estimate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Estimate;
            })();

            return optimisation;
        })();

        support.SaveConfiguration = (function() {

            /**
             * Properties of a SaveConfiguration.
             * @typedef message.support.SaveConfiguration$Properties
             * @type {Object}
             * @property {string} [path] SaveConfiguration path.
             * @property {string} [config] SaveConfiguration config.
             */

            /**
             * Constructs a new SaveConfiguration.
             * @exports message.support.SaveConfiguration
             * @constructor
             * @param {message.support.SaveConfiguration$Properties=} [properties] Properties to set
             */
            function SaveConfiguration(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SaveConfiguration path.
             * @type {string}
             */
            SaveConfiguration.prototype.path = "";

            /**
             * SaveConfiguration config.
             * @type {string}
             */
            SaveConfiguration.prototype.config = "";

            /**
             * Creates a new SaveConfiguration instance using the specified properties.
             * @param {message.support.SaveConfiguration$Properties=} [properties] Properties to set
             * @returns {message.support.SaveConfiguration} SaveConfiguration instance
             */
            SaveConfiguration.create = function create(properties) {
                return new SaveConfiguration(properties);
            };

            /**
             * Encodes the specified SaveConfiguration message. Does not implicitly {@link message.support.SaveConfiguration.verify|verify} messages.
             * @param {message.support.SaveConfiguration$Properties} message SaveConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveConfiguration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.config != null && message.hasOwnProperty("config"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.config);
                return writer;
            };

            /**
             * Encodes the specified SaveConfiguration message, length delimited. Does not implicitly {@link message.support.SaveConfiguration.verify|verify} messages.
             * @param {message.support.SaveConfiguration$Properties} message SaveConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SaveConfiguration message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.support.SaveConfiguration} SaveConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveConfiguration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.SaveConfiguration();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.config = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SaveConfiguration message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.support.SaveConfiguration} SaveConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveConfiguration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SaveConfiguration message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            SaveConfiguration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.config != null && message.hasOwnProperty("config"))
                    if (!$util.isString(message.config))
                        return "config: string expected";
                return null;
            };

            /**
             * Creates a SaveConfiguration message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.SaveConfiguration} SaveConfiguration
             */
            SaveConfiguration.fromObject = function fromObject(object) {
                if (object instanceof $root.message.support.SaveConfiguration)
                    return object;
                var message = new $root.message.support.SaveConfiguration();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.config != null)
                    message.config = String(object.config);
                return message;
            };

            /**
             * Creates a SaveConfiguration message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.support.SaveConfiguration.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.SaveConfiguration} SaveConfiguration
             */
            SaveConfiguration.from = SaveConfiguration.fromObject;

            /**
             * Creates a plain object from a SaveConfiguration message. Also converts values to other types if specified.
             * @param {message.support.SaveConfiguration} message SaveConfiguration
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveConfiguration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.config = "";
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.config != null && message.hasOwnProperty("config"))
                    object.config = message.config;
                return object;
            };

            /**
             * Creates a plain object from this SaveConfiguration message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveConfiguration.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this SaveConfiguration to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            SaveConfiguration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SaveConfiguration;
        })();

        support.ServoHealthTestData = (function() {

            /**
             * Properties of a ServoHealthTestData.
             * @typedef message.support.ServoHealthTestData$Properties
             * @type {Object}
             * @property {message.support.ServoHealthTestData.State} [state] ServoHealthTestData state.
             * @property {message.platform.darwin.DarwinSensors$Properties} [sensors] ServoHealthTestData sensors.
             */

            /**
             * Constructs a new ServoHealthTestData.
             * @exports message.support.ServoHealthTestData
             * @constructor
             * @param {message.support.ServoHealthTestData$Properties=} [properties] Properties to set
             */
            function ServoHealthTestData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServoHealthTestData state.
             * @type {message.support.ServoHealthTestData.State}
             */
            ServoHealthTestData.prototype.state = 0;

            /**
             * ServoHealthTestData sensors.
             * @type {(message.platform.darwin.DarwinSensors$Properties|null)}
             */
            ServoHealthTestData.prototype.sensors = null;

            /**
             * Creates a new ServoHealthTestData instance using the specified properties.
             * @param {message.support.ServoHealthTestData$Properties=} [properties] Properties to set
             * @returns {message.support.ServoHealthTestData} ServoHealthTestData instance
             */
            ServoHealthTestData.create = function create(properties) {
                return new ServoHealthTestData(properties);
            };

            /**
             * Encodes the specified ServoHealthTestData message. Does not implicitly {@link message.support.ServoHealthTestData.verify|verify} messages.
             * @param {message.support.ServoHealthTestData$Properties} message ServoHealthTestData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoHealthTestData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.state != null && message.hasOwnProperty("state"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.state);
                if (message.sensors != null && message.hasOwnProperty("sensors"))
                    $root.message.platform.darwin.DarwinSensors.encode(message.sensors, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServoHealthTestData message, length delimited. Does not implicitly {@link message.support.ServoHealthTestData.verify|verify} messages.
             * @param {message.support.ServoHealthTestData$Properties} message ServoHealthTestData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoHealthTestData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServoHealthTestData message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.support.ServoHealthTestData} ServoHealthTestData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoHealthTestData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.support.ServoHealthTestData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.state = reader.uint32();
                        break;
                    case 2:
                        message.sensors = $root.message.platform.darwin.DarwinSensors.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServoHealthTestData message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.support.ServoHealthTestData} ServoHealthTestData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoHealthTestData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServoHealthTestData message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ServoHealthTestData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                        break;
                    }
                if (message.sensors != null && message.hasOwnProperty("sensors")) {
                    var error = $root.message.platform.darwin.DarwinSensors.verify(message.sensors);
                    if (error)
                        return "sensors." + error;
                }
                return null;
            };

            /**
             * Creates a ServoHealthTestData message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.ServoHealthTestData} ServoHealthTestData
             */
            ServoHealthTestData.fromObject = function fromObject(object) {
                if (object instanceof $root.message.support.ServoHealthTestData)
                    return object;
                var message = new $root.message.support.ServoHealthTestData();
                switch (object.state) {
                case "INITIALISE":
                case 0:
                    message.state = 0;
                    break;
                case "MOVE_1":
                case 1:
                    message.state = 1;
                    break;
                case "ELBOW":
                case 2:
                    message.state = 2;
                    break;
                case "MOVE_2":
                case 3:
                    message.state = 3;
                    break;
                case "SHOULDER_PITCH":
                case 4:
                    message.state = 4;
                    break;
                case "SHOULDER_MOVE_1":
                case 5:
                    message.state = 5;
                    break;
                case "SHOULDER_ROLL":
                case 6:
                    message.state = 6;
                    break;
                case "MOVE_3":
                case 7:
                    message.state = 7;
                    break;
                case "HEAD_PITCH":
                case 8:
                    message.state = 8;
                    break;
                case "MOVE_4":
                case 9:
                    message.state = 9;
                    break;
                case "HEAD_YAW":
                case 10:
                    message.state = 10;
                    break;
                case "LAYDOWN":
                case 11:
                    message.state = 11;
                    break;
                case "HIP_ROLL":
                case 12:
                    message.state = 12;
                    break;
                case "HIP_MOVE_1":
                case 13:
                    message.state = 13;
                    break;
                case "HIP_YAW":
                case 14:
                    message.state = 14;
                    break;
                case "HIP_MOVE_2":
                case 15:
                    message.state = 15;
                    break;
                case "ANKLE_PITCH":
                case 16:
                    message.state = 16;
                    break;
                case "ANKLE_MOVE":
                case 17:
                    message.state = 17;
                    break;
                case "ANKLE_ROLL":
                case 18:
                    message.state = 18;
                    break;
                case "KNEE_MOVE":
                case 19:
                    message.state = 19;
                    break;
                case "KNEE":
                case 20:
                    message.state = 20;
                    break;
                case "KNEE_MOVE_2":
                case 21:
                    message.state = 21;
                    break;
                case "HIP_PITCH":
                case 22:
                    message.state = 22;
                    break;
                case "LAYDOWN_2":
                case 23:
                    message.state = 23;
                    break;
                case "FINISHED":
                case 24:
                    message.state = 24;
                    break;
                }
                if (object.sensors != null) {
                    if (typeof object.sensors !== "object")
                        throw TypeError(".message.support.ServoHealthTestData.sensors: object expected");
                    message.sensors = $root.message.platform.darwin.DarwinSensors.fromObject(object.sensors);
                }
                return message;
            };

            /**
             * Creates a ServoHealthTestData message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.support.ServoHealthTestData.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.ServoHealthTestData} ServoHealthTestData
             */
            ServoHealthTestData.from = ServoHealthTestData.fromObject;

            /**
             * Creates a plain object from a ServoHealthTestData message. Also converts values to other types if specified.
             * @param {message.support.ServoHealthTestData} message ServoHealthTestData
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServoHealthTestData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.state = options.enums === String ? "INITIALISE" : 0;
                    object.sensors = null;
                }
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.message.support.ServoHealthTestData.State[message.state] : message.state;
                if (message.sensors != null && message.hasOwnProperty("sensors"))
                    object.sensors = $root.message.platform.darwin.DarwinSensors.toObject(message.sensors, options);
                return object;
            };

            /**
             * Creates a plain object from this ServoHealthTestData message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServoHealthTestData.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ServoHealthTestData to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ServoHealthTestData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * State enum.
             * @name State
             * @memberof message.support.ServoHealthTestData
             * @enum {number}
             * @property {number} INITIALISE=0 INITIALISE value
             * @property {number} MOVE_1=1 MOVE_1 value
             * @property {number} ELBOW=2 ELBOW value
             * @property {number} MOVE_2=3 MOVE_2 value
             * @property {number} SHOULDER_PITCH=4 SHOULDER_PITCH value
             * @property {number} SHOULDER_MOVE_1=5 SHOULDER_MOVE_1 value
             * @property {number} SHOULDER_ROLL=6 SHOULDER_ROLL value
             * @property {number} MOVE_3=7 MOVE_3 value
             * @property {number} HEAD_PITCH=8 HEAD_PITCH value
             * @property {number} MOVE_4=9 MOVE_4 value
             * @property {number} HEAD_YAW=10 HEAD_YAW value
             * @property {number} LAYDOWN=11 LAYDOWN value
             * @property {number} HIP_ROLL=12 HIP_ROLL value
             * @property {number} HIP_MOVE_1=13 HIP_MOVE_1 value
             * @property {number} HIP_YAW=14 HIP_YAW value
             * @property {number} HIP_MOVE_2=15 HIP_MOVE_2 value
             * @property {number} ANKLE_PITCH=16 ANKLE_PITCH value
             * @property {number} ANKLE_MOVE=17 ANKLE_MOVE value
             * @property {number} ANKLE_ROLL=18 ANKLE_ROLL value
             * @property {number} KNEE_MOVE=19 KNEE_MOVE value
             * @property {number} KNEE=20 KNEE value
             * @property {number} KNEE_MOVE_2=21 KNEE_MOVE_2 value
             * @property {number} HIP_PITCH=22 HIP_PITCH value
             * @property {number} LAYDOWN_2=23 LAYDOWN_2 value
             * @property {number} FINISHED=24 FINISHED value
             */
            ServoHealthTestData.State = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "INITIALISE"] = 0;
                values[valuesById[1] = "MOVE_1"] = 1;
                values[valuesById[2] = "ELBOW"] = 2;
                values[valuesById[3] = "MOVE_2"] = 3;
                values[valuesById[4] = "SHOULDER_PITCH"] = 4;
                values[valuesById[5] = "SHOULDER_MOVE_1"] = 5;
                values[valuesById[6] = "SHOULDER_ROLL"] = 6;
                values[valuesById[7] = "MOVE_3"] = 7;
                values[valuesById[8] = "HEAD_PITCH"] = 8;
                values[valuesById[9] = "MOVE_4"] = 9;
                values[valuesById[10] = "HEAD_YAW"] = 10;
                values[valuesById[11] = "LAYDOWN"] = 11;
                values[valuesById[12] = "HIP_ROLL"] = 12;
                values[valuesById[13] = "HIP_MOVE_1"] = 13;
                values[valuesById[14] = "HIP_YAW"] = 14;
                values[valuesById[15] = "HIP_MOVE_2"] = 15;
                values[valuesById[16] = "ANKLE_PITCH"] = 16;
                values[valuesById[17] = "ANKLE_MOVE"] = 17;
                values[valuesById[18] = "ANKLE_ROLL"] = 18;
                values[valuesById[19] = "KNEE_MOVE"] = 19;
                values[valuesById[20] = "KNEE"] = 20;
                values[valuesById[21] = "KNEE_MOVE_2"] = 21;
                values[valuesById[22] = "HIP_PITCH"] = 22;
                values[valuesById[23] = "LAYDOWN_2"] = 23;
                values[valuesById[24] = "FINISHED"] = 24;
                return values;
            })();

            return ServoHealthTestData;
        })();

        return support;
    })();

    message.vision = (function() {

        /**
         * Namespace vision.
         * @exports message.vision
         * @namespace
         */
        var vision = {};

        vision.ClassifiedImage = (function() {

            /**
             * Properties of a ClassifiedImage.
             * @typedef message.vision.ClassifiedImage$Properties
             * @type {Object}
             * @property {message.input.Sensors$Properties} [sensors] ClassifiedImage sensors.
             * @property {message.input.Image$Properties} [image] ClassifiedImage image.
             * @property {uvec2$Properties} [dimensions] ClassifiedImage dimensions.
             * @property {Array.<message.vision.ClassifiedImage.SeedPoints$Properties>} [ballSeedPoints] ClassifiedImage ballSeedPoints.
             * @property {Array.<ivec2$Properties>} [ballPoints] ClassifiedImage ballPoints.
             * @property {message.vision.Line$Properties} [horizon] ClassifiedImage horizon.
             * @property {Array.<ivec2$Properties>} [visualHorizon] ClassifiedImage visualHorizon.
             * @property {Array.<message.vision.ClassifiedImage.Segment$Properties>} [horizontalSegments] ClassifiedImage horizontalSegments.
             * @property {Array.<message.vision.ClassifiedImage.Segment$Properties>} [verticalSegments] ClassifiedImage verticalSegments.
             */

            /**
             * Constructs a new ClassifiedImage.
             * @exports message.vision.ClassifiedImage
             * @constructor
             * @param {message.vision.ClassifiedImage$Properties=} [properties] Properties to set
             */
            function ClassifiedImage(properties) {
                this.ballSeedPoints = [];
                this.ballPoints = [];
                this.visualHorizon = [];
                this.horizontalSegments = [];
                this.verticalSegments = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ClassifiedImage sensors.
             * @type {(message.input.Sensors$Properties|null)}
             */
            ClassifiedImage.prototype.sensors = null;

            /**
             * ClassifiedImage image.
             * @type {(message.input.Image$Properties|null)}
             */
            ClassifiedImage.prototype.image = null;

            /**
             * ClassifiedImage dimensions.
             * @type {(uvec2$Properties|null)}
             */
            ClassifiedImage.prototype.dimensions = null;

            /**
             * ClassifiedImage ballSeedPoints.
             * @type {Array.<message.vision.ClassifiedImage.SeedPoints$Properties>}
             */
            ClassifiedImage.prototype.ballSeedPoints = $util.emptyArray;

            /**
             * ClassifiedImage ballPoints.
             * @type {Array.<ivec2$Properties>}
             */
            ClassifiedImage.prototype.ballPoints = $util.emptyArray;

            /**
             * ClassifiedImage horizon.
             * @type {(message.vision.Line$Properties|null)}
             */
            ClassifiedImage.prototype.horizon = null;

            /**
             * ClassifiedImage visualHorizon.
             * @type {Array.<ivec2$Properties>}
             */
            ClassifiedImage.prototype.visualHorizon = $util.emptyArray;

            /**
             * ClassifiedImage horizontalSegments.
             * @type {Array.<message.vision.ClassifiedImage.Segment$Properties>}
             */
            ClassifiedImage.prototype.horizontalSegments = $util.emptyArray;

            /**
             * ClassifiedImage verticalSegments.
             * @type {Array.<message.vision.ClassifiedImage.Segment$Properties>}
             */
            ClassifiedImage.prototype.verticalSegments = $util.emptyArray;

            /**
             * Creates a new ClassifiedImage instance using the specified properties.
             * @param {message.vision.ClassifiedImage$Properties=} [properties] Properties to set
             * @returns {message.vision.ClassifiedImage} ClassifiedImage instance
             */
            ClassifiedImage.create = function create(properties) {
                return new ClassifiedImage(properties);
            };

            /**
             * Encodes the specified ClassifiedImage message. Does not implicitly {@link message.vision.ClassifiedImage.verify|verify} messages.
             * @param {message.vision.ClassifiedImage$Properties} message ClassifiedImage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClassifiedImage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sensors != null && message.hasOwnProperty("sensors"))
                    $root.message.input.Sensors.encode(message.sensors, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.image != null && message.hasOwnProperty("image"))
                    $root.message.input.Image.encode(message.image, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.dimensions != null && message.hasOwnProperty("dimensions"))
                    $root.uvec2.encode(message.dimensions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.ballSeedPoints != null && message.ballSeedPoints.length)
                    for (var i = 0; i < message.ballSeedPoints.length; ++i)
                        $root.message.vision.ClassifiedImage.SeedPoints.encode(message.ballSeedPoints[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.ballPoints != null && message.ballPoints.length)
                    for (var i = 0; i < message.ballPoints.length; ++i)
                        $root.ivec2.encode(message.ballPoints[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.horizon != null && message.hasOwnProperty("horizon"))
                    $root.message.vision.Line.encode(message.horizon, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.visualHorizon != null && message.visualHorizon.length)
                    for (var i = 0; i < message.visualHorizon.length; ++i)
                        $root.ivec2.encode(message.visualHorizon[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.horizontalSegments != null && message.horizontalSegments.length)
                    for (var i = 0; i < message.horizontalSegments.length; ++i)
                        $root.message.vision.ClassifiedImage.Segment.encode(message.horizontalSegments[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.verticalSegments != null && message.verticalSegments.length)
                    for (var i = 0; i < message.verticalSegments.length; ++i)
                        $root.message.vision.ClassifiedImage.Segment.encode(message.verticalSegments[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ClassifiedImage message, length delimited. Does not implicitly {@link message.vision.ClassifiedImage.verify|verify} messages.
             * @param {message.vision.ClassifiedImage$Properties} message ClassifiedImage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClassifiedImage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClassifiedImage message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.ClassifiedImage} ClassifiedImage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClassifiedImage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.ClassifiedImage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sensors = $root.message.input.Sensors.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.image = $root.message.input.Image.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.dimensions = $root.uvec2.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.ballSeedPoints && message.ballSeedPoints.length))
                            message.ballSeedPoints = [];
                        message.ballSeedPoints.push($root.message.vision.ClassifiedImage.SeedPoints.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.ballPoints && message.ballPoints.length))
                            message.ballPoints = [];
                        message.ballPoints.push($root.ivec2.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.horizon = $root.message.vision.Line.decode(reader, reader.uint32());
                        break;
                    case 7:
                        if (!(message.visualHorizon && message.visualHorizon.length))
                            message.visualHorizon = [];
                        message.visualHorizon.push($root.ivec2.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.horizontalSegments && message.horizontalSegments.length))
                            message.horizontalSegments = [];
                        message.horizontalSegments.push($root.message.vision.ClassifiedImage.Segment.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        if (!(message.verticalSegments && message.verticalSegments.length))
                            message.verticalSegments = [];
                        message.verticalSegments.push($root.message.vision.ClassifiedImage.Segment.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClassifiedImage message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.ClassifiedImage} ClassifiedImage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClassifiedImage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClassifiedImage message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ClassifiedImage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sensors != null && message.hasOwnProperty("sensors")) {
                    var error = $root.message.input.Sensors.verify(message.sensors);
                    if (error)
                        return "sensors." + error;
                }
                if (message.image != null && message.hasOwnProperty("image")) {
                    var error = $root.message.input.Image.verify(message.image);
                    if (error)
                        return "image." + error;
                }
                if (message.dimensions != null && message.hasOwnProperty("dimensions")) {
                    var error = $root.uvec2.verify(message.dimensions);
                    if (error)
                        return "dimensions." + error;
                }
                if (message.ballSeedPoints != null && message.hasOwnProperty("ballSeedPoints")) {
                    if (!Array.isArray(message.ballSeedPoints))
                        return "ballSeedPoints: array expected";
                    for (var i = 0; i < message.ballSeedPoints.length; ++i) {
                        var error = $root.message.vision.ClassifiedImage.SeedPoints.verify(message.ballSeedPoints[i]);
                        if (error)
                            return "ballSeedPoints." + error;
                    }
                }
                if (message.ballPoints != null && message.hasOwnProperty("ballPoints")) {
                    if (!Array.isArray(message.ballPoints))
                        return "ballPoints: array expected";
                    for (var i = 0; i < message.ballPoints.length; ++i) {
                        var error = $root.ivec2.verify(message.ballPoints[i]);
                        if (error)
                            return "ballPoints." + error;
                    }
                }
                if (message.horizon != null && message.hasOwnProperty("horizon")) {
                    var error = $root.message.vision.Line.verify(message.horizon);
                    if (error)
                        return "horizon." + error;
                }
                if (message.visualHorizon != null && message.hasOwnProperty("visualHorizon")) {
                    if (!Array.isArray(message.visualHorizon))
                        return "visualHorizon: array expected";
                    for (var i = 0; i < message.visualHorizon.length; ++i) {
                        var error = $root.ivec2.verify(message.visualHorizon[i]);
                        if (error)
                            return "visualHorizon." + error;
                    }
                }
                if (message.horizontalSegments != null && message.hasOwnProperty("horizontalSegments")) {
                    if (!Array.isArray(message.horizontalSegments))
                        return "horizontalSegments: array expected";
                    for (var i = 0; i < message.horizontalSegments.length; ++i) {
                        var error = $root.message.vision.ClassifiedImage.Segment.verify(message.horizontalSegments[i]);
                        if (error)
                            return "horizontalSegments." + error;
                    }
                }
                if (message.verticalSegments != null && message.hasOwnProperty("verticalSegments")) {
                    if (!Array.isArray(message.verticalSegments))
                        return "verticalSegments: array expected";
                    for (var i = 0; i < message.verticalSegments.length; ++i) {
                        var error = $root.message.vision.ClassifiedImage.Segment.verify(message.verticalSegments[i]);
                        if (error)
                            return "verticalSegments." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ClassifiedImage message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.ClassifiedImage} ClassifiedImage
             */
            ClassifiedImage.fromObject = function fromObject(object) {
                if (object instanceof $root.message.vision.ClassifiedImage)
                    return object;
                var message = new $root.message.vision.ClassifiedImage();
                if (object.sensors != null) {
                    if (typeof object.sensors !== "object")
                        throw TypeError(".message.vision.ClassifiedImage.sensors: object expected");
                    message.sensors = $root.message.input.Sensors.fromObject(object.sensors);
                }
                if (object.image != null) {
                    if (typeof object.image !== "object")
                        throw TypeError(".message.vision.ClassifiedImage.image: object expected");
                    message.image = $root.message.input.Image.fromObject(object.image);
                }
                if (object.dimensions != null) {
                    if (typeof object.dimensions !== "object")
                        throw TypeError(".message.vision.ClassifiedImage.dimensions: object expected");
                    message.dimensions = $root.uvec2.fromObject(object.dimensions);
                }
                if (object.ballSeedPoints) {
                    if (!Array.isArray(object.ballSeedPoints))
                        throw TypeError(".message.vision.ClassifiedImage.ballSeedPoints: array expected");
                    message.ballSeedPoints = [];
                    for (var i = 0; i < object.ballSeedPoints.length; ++i) {
                        if (typeof object.ballSeedPoints[i] !== "object")
                            throw TypeError(".message.vision.ClassifiedImage.ballSeedPoints: object expected");
                        message.ballSeedPoints[i] = $root.message.vision.ClassifiedImage.SeedPoints.fromObject(object.ballSeedPoints[i]);
                    }
                }
                if (object.ballPoints) {
                    if (!Array.isArray(object.ballPoints))
                        throw TypeError(".message.vision.ClassifiedImage.ballPoints: array expected");
                    message.ballPoints = [];
                    for (var i = 0; i < object.ballPoints.length; ++i) {
                        if (typeof object.ballPoints[i] !== "object")
                            throw TypeError(".message.vision.ClassifiedImage.ballPoints: object expected");
                        message.ballPoints[i] = $root.ivec2.fromObject(object.ballPoints[i]);
                    }
                }
                if (object.horizon != null) {
                    if (typeof object.horizon !== "object")
                        throw TypeError(".message.vision.ClassifiedImage.horizon: object expected");
                    message.horizon = $root.message.vision.Line.fromObject(object.horizon);
                }
                if (object.visualHorizon) {
                    if (!Array.isArray(object.visualHorizon))
                        throw TypeError(".message.vision.ClassifiedImage.visualHorizon: array expected");
                    message.visualHorizon = [];
                    for (var i = 0; i < object.visualHorizon.length; ++i) {
                        if (typeof object.visualHorizon[i] !== "object")
                            throw TypeError(".message.vision.ClassifiedImage.visualHorizon: object expected");
                        message.visualHorizon[i] = $root.ivec2.fromObject(object.visualHorizon[i]);
                    }
                }
                if (object.horizontalSegments) {
                    if (!Array.isArray(object.horizontalSegments))
                        throw TypeError(".message.vision.ClassifiedImage.horizontalSegments: array expected");
                    message.horizontalSegments = [];
                    for (var i = 0; i < object.horizontalSegments.length; ++i) {
                        if (typeof object.horizontalSegments[i] !== "object")
                            throw TypeError(".message.vision.ClassifiedImage.horizontalSegments: object expected");
                        message.horizontalSegments[i] = $root.message.vision.ClassifiedImage.Segment.fromObject(object.horizontalSegments[i]);
                    }
                }
                if (object.verticalSegments) {
                    if (!Array.isArray(object.verticalSegments))
                        throw TypeError(".message.vision.ClassifiedImage.verticalSegments: array expected");
                    message.verticalSegments = [];
                    for (var i = 0; i < object.verticalSegments.length; ++i) {
                        if (typeof object.verticalSegments[i] !== "object")
                            throw TypeError(".message.vision.ClassifiedImage.verticalSegments: object expected");
                        message.verticalSegments[i] = $root.message.vision.ClassifiedImage.Segment.fromObject(object.verticalSegments[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a ClassifiedImage message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.ClassifiedImage.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.ClassifiedImage} ClassifiedImage
             */
            ClassifiedImage.from = ClassifiedImage.fromObject;

            /**
             * Creates a plain object from a ClassifiedImage message. Also converts values to other types if specified.
             * @param {message.vision.ClassifiedImage} message ClassifiedImage
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClassifiedImage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.ballSeedPoints = [];
                    object.ballPoints = [];
                    object.visualHorizon = [];
                    object.horizontalSegments = [];
                    object.verticalSegments = [];
                }
                if (options.defaults) {
                    object.sensors = null;
                    object.image = null;
                    object.dimensions = null;
                    object.horizon = null;
                }
                if (message.sensors != null && message.hasOwnProperty("sensors"))
                    object.sensors = $root.message.input.Sensors.toObject(message.sensors, options);
                if (message.image != null && message.hasOwnProperty("image"))
                    object.image = $root.message.input.Image.toObject(message.image, options);
                if (message.dimensions != null && message.hasOwnProperty("dimensions"))
                    object.dimensions = $root.uvec2.toObject(message.dimensions, options);
                if (message.ballSeedPoints && message.ballSeedPoints.length) {
                    object.ballSeedPoints = [];
                    for (var j = 0; j < message.ballSeedPoints.length; ++j)
                        object.ballSeedPoints[j] = $root.message.vision.ClassifiedImage.SeedPoints.toObject(message.ballSeedPoints[j], options);
                }
                if (message.ballPoints && message.ballPoints.length) {
                    object.ballPoints = [];
                    for (var j = 0; j < message.ballPoints.length; ++j)
                        object.ballPoints[j] = $root.ivec2.toObject(message.ballPoints[j], options);
                }
                if (message.horizon != null && message.hasOwnProperty("horizon"))
                    object.horizon = $root.message.vision.Line.toObject(message.horizon, options);
                if (message.visualHorizon && message.visualHorizon.length) {
                    object.visualHorizon = [];
                    for (var j = 0; j < message.visualHorizon.length; ++j)
                        object.visualHorizon[j] = $root.ivec2.toObject(message.visualHorizon[j], options);
                }
                if (message.horizontalSegments && message.horizontalSegments.length) {
                    object.horizontalSegments = [];
                    for (var j = 0; j < message.horizontalSegments.length; ++j)
                        object.horizontalSegments[j] = $root.message.vision.ClassifiedImage.Segment.toObject(message.horizontalSegments[j], options);
                }
                if (message.verticalSegments && message.verticalSegments.length) {
                    object.verticalSegments = [];
                    for (var j = 0; j < message.verticalSegments.length; ++j)
                        object.verticalSegments[j] = $root.message.vision.ClassifiedImage.Segment.toObject(message.verticalSegments[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this ClassifiedImage message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClassifiedImage.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ClassifiedImage to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ClassifiedImage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * SegmentClass enum.
             * @name SegmentClass
             * @memberof message.vision.ClassifiedImage
             * @enum {number}
             * @property {number} UNKNOWN_CLASS=0 UNKNOWN_CLASS value
             * @property {number} FIELD=1 FIELD value
             * @property {number} BALL=2 BALL value
             * @property {number} GOAL=3 GOAL value
             * @property {number} LINE=4 LINE value
             * @property {number} CYAN_TEAM=5 CYAN_TEAM value
             * @property {number} MAGENTA_TEAM=6 MAGENTA_TEAM value
             */
            ClassifiedImage.SegmentClass = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN_CLASS"] = 0;
                values[valuesById[1] = "FIELD"] = 1;
                values[valuesById[2] = "BALL"] = 2;
                values[valuesById[3] = "GOAL"] = 3;
                values[valuesById[4] = "LINE"] = 4;
                values[valuesById[5] = "CYAN_TEAM"] = 5;
                values[valuesById[6] = "MAGENTA_TEAM"] = 6;
                return values;
            })();

            ClassifiedImage.Segment = (function() {

                /**
                 * Properties of a Segment.
                 * @typedef message.vision.ClassifiedImage.Segment$Properties
                 * @type {Object}
                 * @property {message.vision.ClassifiedImage.SegmentClass} [segmentClass] Segment segmentClass.
                 * @property {number} [length] Segment length.
                 * @property {number} [subsample] Segment subsample.
                 * @property {ivec2$Properties} [start] Segment start.
                 * @property {ivec2$Properties} [end] Segment end.
                 * @property {ivec2$Properties} [midpoint] Segment midpoint.
                 * @property {number} [previous] Segment previous.
                 * @property {number} [next] Segment next.
                 */

                /**
                 * Constructs a new Segment.
                 * @exports message.vision.ClassifiedImage.Segment
                 * @constructor
                 * @param {message.vision.ClassifiedImage.Segment$Properties=} [properties] Properties to set
                 */
                function Segment(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Segment segmentClass.
                 * @type {message.vision.ClassifiedImage.SegmentClass}
                 */
                Segment.prototype.segmentClass = 0;

                /**
                 * Segment length.
                 * @type {number}
                 */
                Segment.prototype.length = 0;

                /**
                 * Segment subsample.
                 * @type {number}
                 */
                Segment.prototype.subsample = 0;

                /**
                 * Segment start.
                 * @type {(ivec2$Properties|null)}
                 */
                Segment.prototype.start = null;

                /**
                 * Segment end.
                 * @type {(ivec2$Properties|null)}
                 */
                Segment.prototype.end = null;

                /**
                 * Segment midpoint.
                 * @type {(ivec2$Properties|null)}
                 */
                Segment.prototype.midpoint = null;

                /**
                 * Segment previous.
                 * @type {number}
                 */
                Segment.prototype.previous = 0;

                /**
                 * Segment next.
                 * @type {number}
                 */
                Segment.prototype.next = 0;

                /**
                 * Creates a new Segment instance using the specified properties.
                 * @param {message.vision.ClassifiedImage.Segment$Properties=} [properties] Properties to set
                 * @returns {message.vision.ClassifiedImage.Segment} Segment instance
                 */
                Segment.create = function create(properties) {
                    return new Segment(properties);
                };

                /**
                 * Encodes the specified Segment message. Does not implicitly {@link message.vision.ClassifiedImage.Segment.verify|verify} messages.
                 * @param {message.vision.ClassifiedImage.Segment$Properties} message Segment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Segment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.segmentClass != null && message.hasOwnProperty("segmentClass"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.segmentClass);
                    if (message.length != null && message.hasOwnProperty("length"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.length);
                    if (message.subsample != null && message.hasOwnProperty("subsample"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.subsample);
                    if (message.start != null && message.hasOwnProperty("start"))
                        $root.ivec2.encode(message.start, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.end != null && message.hasOwnProperty("end"))
                        $root.ivec2.encode(message.end, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.midpoint != null && message.hasOwnProperty("midpoint"))
                        $root.ivec2.encode(message.midpoint, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.previous != null && message.hasOwnProperty("previous"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.previous);
                    if (message.next != null && message.hasOwnProperty("next"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.next);
                    return writer;
                };

                /**
                 * Encodes the specified Segment message, length delimited. Does not implicitly {@link message.vision.ClassifiedImage.Segment.verify|verify} messages.
                 * @param {message.vision.ClassifiedImage.Segment$Properties} message Segment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Segment.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Segment message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.vision.ClassifiedImage.Segment} Segment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Segment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.ClassifiedImage.Segment();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.segmentClass = reader.uint32();
                            break;
                        case 2:
                            message.length = reader.uint32();
                            break;
                        case 3:
                            message.subsample = reader.uint32();
                            break;
                        case 4:
                            message.start = $root.ivec2.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.end = $root.ivec2.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.midpoint = $root.ivec2.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.previous = reader.int32();
                            break;
                        case 8:
                            message.next = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Segment message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.vision.ClassifiedImage.Segment} Segment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Segment.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Segment message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Segment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.segmentClass != null && message.hasOwnProperty("segmentClass"))
                        switch (message.segmentClass) {
                        default:
                            return "segmentClass: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.length != null && message.hasOwnProperty("length"))
                        if (!$util.isInteger(message.length))
                            return "length: integer expected";
                    if (message.subsample != null && message.hasOwnProperty("subsample"))
                        if (!$util.isInteger(message.subsample))
                            return "subsample: integer expected";
                    if (message.start != null && message.hasOwnProperty("start")) {
                        var error = $root.ivec2.verify(message.start);
                        if (error)
                            return "start." + error;
                    }
                    if (message.end != null && message.hasOwnProperty("end")) {
                        var error = $root.ivec2.verify(message.end);
                        if (error)
                            return "end." + error;
                    }
                    if (message.midpoint != null && message.hasOwnProperty("midpoint")) {
                        var error = $root.ivec2.verify(message.midpoint);
                        if (error)
                            return "midpoint." + error;
                    }
                    if (message.previous != null && message.hasOwnProperty("previous"))
                        if (!$util.isInteger(message.previous))
                            return "previous: integer expected";
                    if (message.next != null && message.hasOwnProperty("next"))
                        if (!$util.isInteger(message.next))
                            return "next: integer expected";
                    return null;
                };

                /**
                 * Creates a Segment message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.ClassifiedImage.Segment} Segment
                 */
                Segment.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.vision.ClassifiedImage.Segment)
                        return object;
                    var message = new $root.message.vision.ClassifiedImage.Segment();
                    switch (object.segmentClass) {
                    case "UNKNOWN_CLASS":
                    case 0:
                        message.segmentClass = 0;
                        break;
                    case "FIELD":
                    case 1:
                        message.segmentClass = 1;
                        break;
                    case "BALL":
                    case 2:
                        message.segmentClass = 2;
                        break;
                    case "GOAL":
                    case 3:
                        message.segmentClass = 3;
                        break;
                    case "LINE":
                    case 4:
                        message.segmentClass = 4;
                        break;
                    case "CYAN_TEAM":
                    case 5:
                        message.segmentClass = 5;
                        break;
                    case "MAGENTA_TEAM":
                    case 6:
                        message.segmentClass = 6;
                        break;
                    }
                    if (object.length != null)
                        message.length = object.length >>> 0;
                    if (object.subsample != null)
                        message.subsample = object.subsample >>> 0;
                    if (object.start != null) {
                        if (typeof object.start !== "object")
                            throw TypeError(".message.vision.ClassifiedImage.Segment.start: object expected");
                        message.start = $root.ivec2.fromObject(object.start);
                    }
                    if (object.end != null) {
                        if (typeof object.end !== "object")
                            throw TypeError(".message.vision.ClassifiedImage.Segment.end: object expected");
                        message.end = $root.ivec2.fromObject(object.end);
                    }
                    if (object.midpoint != null) {
                        if (typeof object.midpoint !== "object")
                            throw TypeError(".message.vision.ClassifiedImage.Segment.midpoint: object expected");
                        message.midpoint = $root.ivec2.fromObject(object.midpoint);
                    }
                    if (object.previous != null)
                        message.previous = object.previous | 0;
                    if (object.next != null)
                        message.next = object.next | 0;
                    return message;
                };

                /**
                 * Creates a Segment message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.vision.ClassifiedImage.Segment.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.ClassifiedImage.Segment} Segment
                 */
                Segment.from = Segment.fromObject;

                /**
                 * Creates a plain object from a Segment message. Also converts values to other types if specified.
                 * @param {message.vision.ClassifiedImage.Segment} message Segment
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Segment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.segmentClass = options.enums === String ? "UNKNOWN_CLASS" : 0;
                        object.length = 0;
                        object.subsample = 0;
                        object.start = null;
                        object.end = null;
                        object.midpoint = null;
                        object.previous = 0;
                        object.next = 0;
                    }
                    if (message.segmentClass != null && message.hasOwnProperty("segmentClass"))
                        object.segmentClass = options.enums === String ? $root.message.vision.ClassifiedImage.SegmentClass[message.segmentClass] : message.segmentClass;
                    if (message.length != null && message.hasOwnProperty("length"))
                        object.length = message.length;
                    if (message.subsample != null && message.hasOwnProperty("subsample"))
                        object.subsample = message.subsample;
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = $root.ivec2.toObject(message.start, options);
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = $root.ivec2.toObject(message.end, options);
                    if (message.midpoint != null && message.hasOwnProperty("midpoint"))
                        object.midpoint = $root.ivec2.toObject(message.midpoint, options);
                    if (message.previous != null && message.hasOwnProperty("previous"))
                        object.previous = message.previous;
                    if (message.next != null && message.hasOwnProperty("next"))
                        object.next = message.next;
                    return object;
                };

                /**
                 * Creates a plain object from this Segment message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Segment.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Segment to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Segment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Segment;
            })();

            ClassifiedImage.SeedPoints = (function() {

                /**
                 * Properties of a SeedPoints.
                 * @typedef message.vision.ClassifiedImage.SeedPoints$Properties
                 * @type {Object}
                 * @property {Array.<ivec2$Properties>} [points] SeedPoints points.
                 */

                /**
                 * Constructs a new SeedPoints.
                 * @exports message.vision.ClassifiedImage.SeedPoints
                 * @constructor
                 * @param {message.vision.ClassifiedImage.SeedPoints$Properties=} [properties] Properties to set
                 */
                function SeedPoints(properties) {
                    this.points = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SeedPoints points.
                 * @type {Array.<ivec2$Properties>}
                 */
                SeedPoints.prototype.points = $util.emptyArray;

                /**
                 * Creates a new SeedPoints instance using the specified properties.
                 * @param {message.vision.ClassifiedImage.SeedPoints$Properties=} [properties] Properties to set
                 * @returns {message.vision.ClassifiedImage.SeedPoints} SeedPoints instance
                 */
                SeedPoints.create = function create(properties) {
                    return new SeedPoints(properties);
                };

                /**
                 * Encodes the specified SeedPoints message. Does not implicitly {@link message.vision.ClassifiedImage.SeedPoints.verify|verify} messages.
                 * @param {message.vision.ClassifiedImage.SeedPoints$Properties} message SeedPoints message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SeedPoints.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.points != null && message.points.length)
                        for (var i = 0; i < message.points.length; ++i)
                            $root.ivec2.encode(message.points[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SeedPoints message, length delimited. Does not implicitly {@link message.vision.ClassifiedImage.SeedPoints.verify|verify} messages.
                 * @param {message.vision.ClassifiedImage.SeedPoints$Properties} message SeedPoints message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SeedPoints.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SeedPoints message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.vision.ClassifiedImage.SeedPoints} SeedPoints
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SeedPoints.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.ClassifiedImage.SeedPoints();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.points && message.points.length))
                                message.points = [];
                            message.points.push($root.ivec2.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SeedPoints message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.vision.ClassifiedImage.SeedPoints} SeedPoints
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SeedPoints.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SeedPoints message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                SeedPoints.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.points != null && message.hasOwnProperty("points")) {
                        if (!Array.isArray(message.points))
                            return "points: array expected";
                        for (var i = 0; i < message.points.length; ++i) {
                            var error = $root.ivec2.verify(message.points[i]);
                            if (error)
                                return "points." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SeedPoints message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.ClassifiedImage.SeedPoints} SeedPoints
                 */
                SeedPoints.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.vision.ClassifiedImage.SeedPoints)
                        return object;
                    var message = new $root.message.vision.ClassifiedImage.SeedPoints();
                    if (object.points) {
                        if (!Array.isArray(object.points))
                            throw TypeError(".message.vision.ClassifiedImage.SeedPoints.points: array expected");
                        message.points = [];
                        for (var i = 0; i < object.points.length; ++i) {
                            if (typeof object.points[i] !== "object")
                                throw TypeError(".message.vision.ClassifiedImage.SeedPoints.points: object expected");
                            message.points[i] = $root.ivec2.fromObject(object.points[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a SeedPoints message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.vision.ClassifiedImage.SeedPoints.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.ClassifiedImage.SeedPoints} SeedPoints
                 */
                SeedPoints.from = SeedPoints.fromObject;

                /**
                 * Creates a plain object from a SeedPoints message. Also converts values to other types if specified.
                 * @param {message.vision.ClassifiedImage.SeedPoints} message SeedPoints
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SeedPoints.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.points = [];
                    if (message.points && message.points.length) {
                        object.points = [];
                        for (var j = 0; j < message.points.length; ++j)
                            object.points[j] = $root.ivec2.toObject(message.points[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this SeedPoints message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SeedPoints.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this SeedPoints to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                SeedPoints.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SeedPoints;
            })();

            return ClassifiedImage;
        })();

        vision.LookUpTable = (function() {

            /**
             * Properties of a LookUpTable.
             * @typedef message.vision.LookUpTable$Properties
             * @type {Object}
             * @property {Uint8Array} [table] LookUpTable table.
             * @property {number} [bitsY] LookUpTable bitsY.
             * @property {number} [bitsCb] LookUpTable bitsCb.
             * @property {number} [bitsCr] LookUpTable bitsCr.
             */

            /**
             * Constructs a new LookUpTable.
             * @exports message.vision.LookUpTable
             * @constructor
             * @param {message.vision.LookUpTable$Properties=} [properties] Properties to set
             */
            function LookUpTable(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LookUpTable table.
             * @type {Uint8Array}
             */
            LookUpTable.prototype.table = $util.newBuffer([]);

            /**
             * LookUpTable bitsY.
             * @type {number}
             */
            LookUpTable.prototype.bitsY = 0;

            /**
             * LookUpTable bitsCb.
             * @type {number}
             */
            LookUpTable.prototype.bitsCb = 0;

            /**
             * LookUpTable bitsCr.
             * @type {number}
             */
            LookUpTable.prototype.bitsCr = 0;

            /**
             * Creates a new LookUpTable instance using the specified properties.
             * @param {message.vision.LookUpTable$Properties=} [properties] Properties to set
             * @returns {message.vision.LookUpTable} LookUpTable instance
             */
            LookUpTable.create = function create(properties) {
                return new LookUpTable(properties);
            };

            /**
             * Encodes the specified LookUpTable message. Does not implicitly {@link message.vision.LookUpTable.verify|verify} messages.
             * @param {message.vision.LookUpTable$Properties} message LookUpTable message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LookUpTable.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.table != null && message.hasOwnProperty("table"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.table);
                if (message.bitsY != null && message.hasOwnProperty("bitsY"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.bitsY);
                if (message.bitsCb != null && message.hasOwnProperty("bitsCb"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.bitsCb);
                if (message.bitsCr != null && message.hasOwnProperty("bitsCr"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.bitsCr);
                return writer;
            };

            /**
             * Encodes the specified LookUpTable message, length delimited. Does not implicitly {@link message.vision.LookUpTable.verify|verify} messages.
             * @param {message.vision.LookUpTable$Properties} message LookUpTable message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LookUpTable.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LookUpTable message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.LookUpTable} LookUpTable
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LookUpTable.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.LookUpTable();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.table = reader.bytes();
                        break;
                    case 2:
                        message.bitsY = reader.uint32();
                        break;
                    case 3:
                        message.bitsCb = reader.uint32();
                        break;
                    case 4:
                        message.bitsCr = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LookUpTable message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.LookUpTable} LookUpTable
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LookUpTable.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LookUpTable message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            LookUpTable.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.table != null && message.hasOwnProperty("table"))
                    if (!(message.table && typeof message.table.length === "number" || $util.isString(message.table)))
                        return "table: buffer expected";
                if (message.bitsY != null && message.hasOwnProperty("bitsY"))
                    if (!$util.isInteger(message.bitsY))
                        return "bitsY: integer expected";
                if (message.bitsCb != null && message.hasOwnProperty("bitsCb"))
                    if (!$util.isInteger(message.bitsCb))
                        return "bitsCb: integer expected";
                if (message.bitsCr != null && message.hasOwnProperty("bitsCr"))
                    if (!$util.isInteger(message.bitsCr))
                        return "bitsCr: integer expected";
                return null;
            };

            /**
             * Creates a LookUpTable message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.LookUpTable} LookUpTable
             */
            LookUpTable.fromObject = function fromObject(object) {
                if (object instanceof $root.message.vision.LookUpTable)
                    return object;
                var message = new $root.message.vision.LookUpTable();
                if (object.table != null)
                    if (typeof object.table === "string")
                        $util.base64.decode(object.table, message.table = $util.newBuffer($util.base64.length(object.table)), 0);
                    else if (object.table.length)
                        message.table = object.table;
                if (object.bitsY != null)
                    message.bitsY = object.bitsY >>> 0;
                if (object.bitsCb != null)
                    message.bitsCb = object.bitsCb >>> 0;
                if (object.bitsCr != null)
                    message.bitsCr = object.bitsCr >>> 0;
                return message;
            };

            /**
             * Creates a LookUpTable message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.LookUpTable.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.LookUpTable} LookUpTable
             */
            LookUpTable.from = LookUpTable.fromObject;

            /**
             * Creates a plain object from a LookUpTable message. Also converts values to other types if specified.
             * @param {message.vision.LookUpTable} message LookUpTable
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LookUpTable.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.table = options.bytes === String ? "" : [];
                    object.bitsY = 0;
                    object.bitsCb = 0;
                    object.bitsCr = 0;
                }
                if (message.table != null && message.hasOwnProperty("table"))
                    object.table = options.bytes === String ? $util.base64.encode(message.table, 0, message.table.length) : options.bytes === Array ? Array.prototype.slice.call(message.table) : message.table;
                if (message.bitsY != null && message.hasOwnProperty("bitsY"))
                    object.bitsY = message.bitsY;
                if (message.bitsCb != null && message.hasOwnProperty("bitsCb"))
                    object.bitsCb = message.bitsCb;
                if (message.bitsCr != null && message.hasOwnProperty("bitsCr"))
                    object.bitsCr = message.bitsCr;
                return object;
            };

            /**
             * Creates a plain object from this LookUpTable message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LookUpTable.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this LookUpTable to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            LookUpTable.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return LookUpTable;
        })();

        vision.SaveLookUpTable = (function() {

            /**
             * Properties of a SaveLookUpTable.
             * @typedef message.vision.SaveLookUpTable$Properties
             * @type {Object}
             */

            /**
             * Constructs a new SaveLookUpTable.
             * @exports message.vision.SaveLookUpTable
             * @constructor
             * @param {message.vision.SaveLookUpTable$Properties=} [properties] Properties to set
             */
            function SaveLookUpTable(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SaveLookUpTable instance using the specified properties.
             * @param {message.vision.SaveLookUpTable$Properties=} [properties] Properties to set
             * @returns {message.vision.SaveLookUpTable} SaveLookUpTable instance
             */
            SaveLookUpTable.create = function create(properties) {
                return new SaveLookUpTable(properties);
            };

            /**
             * Encodes the specified SaveLookUpTable message. Does not implicitly {@link message.vision.SaveLookUpTable.verify|verify} messages.
             * @param {message.vision.SaveLookUpTable$Properties} message SaveLookUpTable message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveLookUpTable.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SaveLookUpTable message, length delimited. Does not implicitly {@link message.vision.SaveLookUpTable.verify|verify} messages.
             * @param {message.vision.SaveLookUpTable$Properties} message SaveLookUpTable message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveLookUpTable.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SaveLookUpTable message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.SaveLookUpTable} SaveLookUpTable
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveLookUpTable.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.SaveLookUpTable();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SaveLookUpTable message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.SaveLookUpTable} SaveLookUpTable
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveLookUpTable.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SaveLookUpTable message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            SaveLookUpTable.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SaveLookUpTable message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.SaveLookUpTable} SaveLookUpTable
             */
            SaveLookUpTable.fromObject = function fromObject(object) {
                if (object instanceof $root.message.vision.SaveLookUpTable)
                    return object;
                return new $root.message.vision.SaveLookUpTable();
            };

            /**
             * Creates a SaveLookUpTable message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.SaveLookUpTable.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.SaveLookUpTable} SaveLookUpTable
             */
            SaveLookUpTable.from = SaveLookUpTable.fromObject;

            /**
             * Creates a plain object from a SaveLookUpTable message. Also converts values to other types if specified.
             * @param {message.vision.SaveLookUpTable} message SaveLookUpTable
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveLookUpTable.toObject = function toObject() {
                return {};
            };

            /**
             * Creates a plain object from this SaveLookUpTable message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveLookUpTable.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this SaveLookUpTable to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            SaveLookUpTable.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SaveLookUpTable;
        })();

        vision.LookUpTableDiff = (function() {

            /**
             * Properties of a LookUpTableDiff.
             * @typedef message.vision.LookUpTableDiff$Properties
             * @type {Object}
             * @property {Array.<message.vision.LookUpTableDiff.Diff$Properties>} [diff] LookUpTableDiff diff.
             */

            /**
             * Constructs a new LookUpTableDiff.
             * @exports message.vision.LookUpTableDiff
             * @constructor
             * @param {message.vision.LookUpTableDiff$Properties=} [properties] Properties to set
             */
            function LookUpTableDiff(properties) {
                this.diff = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LookUpTableDiff diff.
             * @type {Array.<message.vision.LookUpTableDiff.Diff$Properties>}
             */
            LookUpTableDiff.prototype.diff = $util.emptyArray;

            /**
             * Creates a new LookUpTableDiff instance using the specified properties.
             * @param {message.vision.LookUpTableDiff$Properties=} [properties] Properties to set
             * @returns {message.vision.LookUpTableDiff} LookUpTableDiff instance
             */
            LookUpTableDiff.create = function create(properties) {
                return new LookUpTableDiff(properties);
            };

            /**
             * Encodes the specified LookUpTableDiff message. Does not implicitly {@link message.vision.LookUpTableDiff.verify|verify} messages.
             * @param {message.vision.LookUpTableDiff$Properties} message LookUpTableDiff message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LookUpTableDiff.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.diff != null && message.diff.length)
                    for (var i = 0; i < message.diff.length; ++i)
                        $root.message.vision.LookUpTableDiff.Diff.encode(message.diff[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LookUpTableDiff message, length delimited. Does not implicitly {@link message.vision.LookUpTableDiff.verify|verify} messages.
             * @param {message.vision.LookUpTableDiff$Properties} message LookUpTableDiff message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LookUpTableDiff.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LookUpTableDiff message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.LookUpTableDiff} LookUpTableDiff
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LookUpTableDiff.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.LookUpTableDiff();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.diff && message.diff.length))
                            message.diff = [];
                        message.diff.push($root.message.vision.LookUpTableDiff.Diff.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LookUpTableDiff message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.LookUpTableDiff} LookUpTableDiff
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LookUpTableDiff.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LookUpTableDiff message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            LookUpTableDiff.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.diff != null && message.hasOwnProperty("diff")) {
                    if (!Array.isArray(message.diff))
                        return "diff: array expected";
                    for (var i = 0; i < message.diff.length; ++i) {
                        var error = $root.message.vision.LookUpTableDiff.Diff.verify(message.diff[i]);
                        if (error)
                            return "diff." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a LookUpTableDiff message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.LookUpTableDiff} LookUpTableDiff
             */
            LookUpTableDiff.fromObject = function fromObject(object) {
                if (object instanceof $root.message.vision.LookUpTableDiff)
                    return object;
                var message = new $root.message.vision.LookUpTableDiff();
                if (object.diff) {
                    if (!Array.isArray(object.diff))
                        throw TypeError(".message.vision.LookUpTableDiff.diff: array expected");
                    message.diff = [];
                    for (var i = 0; i < object.diff.length; ++i) {
                        if (typeof object.diff[i] !== "object")
                            throw TypeError(".message.vision.LookUpTableDiff.diff: object expected");
                        message.diff[i] = $root.message.vision.LookUpTableDiff.Diff.fromObject(object.diff[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a LookUpTableDiff message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.LookUpTableDiff.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.LookUpTableDiff} LookUpTableDiff
             */
            LookUpTableDiff.from = LookUpTableDiff.fromObject;

            /**
             * Creates a plain object from a LookUpTableDiff message. Also converts values to other types if specified.
             * @param {message.vision.LookUpTableDiff} message LookUpTableDiff
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LookUpTableDiff.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.diff = [];
                if (message.diff && message.diff.length) {
                    object.diff = [];
                    for (var j = 0; j < message.diff.length; ++j)
                        object.diff[j] = $root.message.vision.LookUpTableDiff.Diff.toObject(message.diff[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this LookUpTableDiff message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LookUpTableDiff.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this LookUpTableDiff to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            LookUpTableDiff.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            LookUpTableDiff.Diff = (function() {

                /**
                 * Properties of a Diff.
                 * @typedef message.vision.LookUpTableDiff.Diff$Properties
                 * @type {Object}
                 * @property {number} [lutIndex] Diff lutIndex.
                 * @property {number} [classification] Diff classification.
                 */

                /**
                 * Constructs a new Diff.
                 * @exports message.vision.LookUpTableDiff.Diff
                 * @constructor
                 * @param {message.vision.LookUpTableDiff.Diff$Properties=} [properties] Properties to set
                 */
                function Diff(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Diff lutIndex.
                 * @type {number}
                 */
                Diff.prototype.lutIndex = 0;

                /**
                 * Diff classification.
                 * @type {number}
                 */
                Diff.prototype.classification = 0;

                /**
                 * Creates a new Diff instance using the specified properties.
                 * @param {message.vision.LookUpTableDiff.Diff$Properties=} [properties] Properties to set
                 * @returns {message.vision.LookUpTableDiff.Diff} Diff instance
                 */
                Diff.create = function create(properties) {
                    return new Diff(properties);
                };

                /**
                 * Encodes the specified Diff message. Does not implicitly {@link message.vision.LookUpTableDiff.Diff.verify|verify} messages.
                 * @param {message.vision.LookUpTableDiff.Diff$Properties} message Diff message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Diff.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.lutIndex != null && message.hasOwnProperty("lutIndex"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.lutIndex);
                    if (message.classification != null && message.hasOwnProperty("classification"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.classification);
                    return writer;
                };

                /**
                 * Encodes the specified Diff message, length delimited. Does not implicitly {@link message.vision.LookUpTableDiff.Diff.verify|verify} messages.
                 * @param {message.vision.LookUpTableDiff.Diff$Properties} message Diff message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Diff.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Diff message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.vision.LookUpTableDiff.Diff} Diff
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Diff.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.LookUpTableDiff.Diff();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.lutIndex = reader.uint32();
                            break;
                        case 2:
                            message.classification = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Diff message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.vision.LookUpTableDiff.Diff} Diff
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Diff.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Diff message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Diff.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.lutIndex != null && message.hasOwnProperty("lutIndex"))
                        if (!$util.isInteger(message.lutIndex))
                            return "lutIndex: integer expected";
                    if (message.classification != null && message.hasOwnProperty("classification"))
                        if (!$util.isInteger(message.classification))
                            return "classification: integer expected";
                    return null;
                };

                /**
                 * Creates a Diff message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.LookUpTableDiff.Diff} Diff
                 */
                Diff.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.vision.LookUpTableDiff.Diff)
                        return object;
                    var message = new $root.message.vision.LookUpTableDiff.Diff();
                    if (object.lutIndex != null)
                        message.lutIndex = object.lutIndex >>> 0;
                    if (object.classification != null)
                        message.classification = object.classification >>> 0;
                    return message;
                };

                /**
                 * Creates a Diff message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.vision.LookUpTableDiff.Diff.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.LookUpTableDiff.Diff} Diff
                 */
                Diff.from = Diff.fromObject;

                /**
                 * Creates a plain object from a Diff message. Also converts values to other types if specified.
                 * @param {message.vision.LookUpTableDiff.Diff} message Diff
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Diff.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.lutIndex = 0;
                        object.classification = 0;
                    }
                    if (message.lutIndex != null && message.hasOwnProperty("lutIndex"))
                        object.lutIndex = message.lutIndex;
                    if (message.classification != null && message.hasOwnProperty("classification"))
                        object.classification = message.classification;
                    return object;
                };

                /**
                 * Creates a plain object from this Diff message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Diff.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Diff to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Diff.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Diff;
            })();

            return LookUpTableDiff;
        })();

        vision.VisionObject = (function() {

            /**
             * Properties of a VisionObject.
             * @typedef message.vision.VisionObject$Properties
             * @type {Object}
             * @property {google.protobuf.Timestamp$Properties} [timestamp] VisionObject timestamp.
             * @property {vec2$Properties} [screenAngular] VisionObject screenAngular.
             * @property {vec2$Properties} [angularSize] VisionObject angularSize.
             * @property {message.input.Sensors$Properties} [sensors] VisionObject sensors.
             * @property {message.vision.ClassifiedImage$Properties} [classifiedImage] VisionObject classifiedImage.
             * @property {number} [cameraId] VisionObject cameraId.
             */

            /**
             * Constructs a new VisionObject.
             * @exports message.vision.VisionObject
             * @constructor
             * @param {message.vision.VisionObject$Properties=} [properties] Properties to set
             */
            function VisionObject(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VisionObject timestamp.
             * @type {(google.protobuf.Timestamp$Properties|null)}
             */
            VisionObject.prototype.timestamp = null;

            /**
             * VisionObject screenAngular.
             * @type {(vec2$Properties|null)}
             */
            VisionObject.prototype.screenAngular = null;

            /**
             * VisionObject angularSize.
             * @type {(vec2$Properties|null)}
             */
            VisionObject.prototype.angularSize = null;

            /**
             * VisionObject sensors.
             * @type {(message.input.Sensors$Properties|null)}
             */
            VisionObject.prototype.sensors = null;

            /**
             * VisionObject classifiedImage.
             * @type {(message.vision.ClassifiedImage$Properties|null)}
             */
            VisionObject.prototype.classifiedImage = null;

            /**
             * VisionObject cameraId.
             * @type {number}
             */
            VisionObject.prototype.cameraId = 0;

            /**
             * Creates a new VisionObject instance using the specified properties.
             * @param {message.vision.VisionObject$Properties=} [properties] Properties to set
             * @returns {message.vision.VisionObject} VisionObject instance
             */
            VisionObject.create = function create(properties) {
                return new VisionObject(properties);
            };

            /**
             * Encodes the specified VisionObject message. Does not implicitly {@link message.vision.VisionObject.verify|verify} messages.
             * @param {message.vision.VisionObject$Properties} message VisionObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VisionObject.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.screenAngular != null && message.hasOwnProperty("screenAngular"))
                    $root.vec2.encode(message.screenAngular, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.angularSize != null && message.hasOwnProperty("angularSize"))
                    $root.vec2.encode(message.angularSize, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.sensors != null && message.hasOwnProperty("sensors"))
                    $root.message.input.Sensors.encode(message.sensors, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.classifiedImage != null && message.hasOwnProperty("classifiedImage"))
                    $root.message.vision.ClassifiedImage.encode(message.classifiedImage, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.cameraId != null && message.hasOwnProperty("cameraId"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.cameraId);
                return writer;
            };

            /**
             * Encodes the specified VisionObject message, length delimited. Does not implicitly {@link message.vision.VisionObject.verify|verify} messages.
             * @param {message.vision.VisionObject$Properties} message VisionObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VisionObject.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VisionObject message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.VisionObject} VisionObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VisionObject.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.VisionObject();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.screenAngular = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.angularSize = $root.vec2.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.sensors = $root.message.input.Sensors.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.classifiedImage = $root.message.vision.ClassifiedImage.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.cameraId = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VisionObject message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.VisionObject} VisionObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VisionObject.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VisionObject message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            VisionObject.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.screenAngular != null && message.hasOwnProperty("screenAngular")) {
                    var error = $root.vec2.verify(message.screenAngular);
                    if (error)
                        return "screenAngular." + error;
                }
                if (message.angularSize != null && message.hasOwnProperty("angularSize")) {
                    var error = $root.vec2.verify(message.angularSize);
                    if (error)
                        return "angularSize." + error;
                }
                if (message.sensors != null && message.hasOwnProperty("sensors")) {
                    var error = $root.message.input.Sensors.verify(message.sensors);
                    if (error)
                        return "sensors." + error;
                }
                if (message.classifiedImage != null && message.hasOwnProperty("classifiedImage")) {
                    var error = $root.message.vision.ClassifiedImage.verify(message.classifiedImage);
                    if (error)
                        return "classifiedImage." + error;
                }
                if (message.cameraId != null && message.hasOwnProperty("cameraId"))
                    if (!$util.isInteger(message.cameraId))
                        return "cameraId: integer expected";
                return null;
            };

            /**
             * Creates a VisionObject message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.VisionObject} VisionObject
             */
            VisionObject.fromObject = function fromObject(object) {
                if (object instanceof $root.message.vision.VisionObject)
                    return object;
                var message = new $root.message.vision.VisionObject();
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".message.vision.VisionObject.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                if (object.screenAngular != null) {
                    if (typeof object.screenAngular !== "object")
                        throw TypeError(".message.vision.VisionObject.screenAngular: object expected");
                    message.screenAngular = $root.vec2.fromObject(object.screenAngular);
                }
                if (object.angularSize != null) {
                    if (typeof object.angularSize !== "object")
                        throw TypeError(".message.vision.VisionObject.angularSize: object expected");
                    message.angularSize = $root.vec2.fromObject(object.angularSize);
                }
                if (object.sensors != null) {
                    if (typeof object.sensors !== "object")
                        throw TypeError(".message.vision.VisionObject.sensors: object expected");
                    message.sensors = $root.message.input.Sensors.fromObject(object.sensors);
                }
                if (object.classifiedImage != null) {
                    if (typeof object.classifiedImage !== "object")
                        throw TypeError(".message.vision.VisionObject.classifiedImage: object expected");
                    message.classifiedImage = $root.message.vision.ClassifiedImage.fromObject(object.classifiedImage);
                }
                if (object.cameraId != null)
                    message.cameraId = object.cameraId >>> 0;
                return message;
            };

            /**
             * Creates a VisionObject message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.VisionObject.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.VisionObject} VisionObject
             */
            VisionObject.from = VisionObject.fromObject;

            /**
             * Creates a plain object from a VisionObject message. Also converts values to other types if specified.
             * @param {message.vision.VisionObject} message VisionObject
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VisionObject.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.timestamp = null;
                    object.screenAngular = null;
                    object.angularSize = null;
                    object.sensors = null;
                    object.classifiedImage = null;
                    object.cameraId = 0;
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                if (message.screenAngular != null && message.hasOwnProperty("screenAngular"))
                    object.screenAngular = $root.vec2.toObject(message.screenAngular, options);
                if (message.angularSize != null && message.hasOwnProperty("angularSize"))
                    object.angularSize = $root.vec2.toObject(message.angularSize, options);
                if (message.sensors != null && message.hasOwnProperty("sensors"))
                    object.sensors = $root.message.input.Sensors.toObject(message.sensors, options);
                if (message.classifiedImage != null && message.hasOwnProperty("classifiedImage"))
                    object.classifiedImage = $root.message.vision.ClassifiedImage.toObject(message.classifiedImage, options);
                if (message.cameraId != null && message.hasOwnProperty("cameraId"))
                    object.cameraId = message.cameraId;
                return object;
            };

            /**
             * Creates a plain object from this VisionObject message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VisionObject.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this VisionObject to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            VisionObject.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return VisionObject;
        })();

        vision.Ball = (function() {

            /**
             * Properties of a Ball.
             * @typedef message.vision.Ball$Properties
             * @type {Object}
             * @property {message.vision.VisionObject$Properties} [visObject] Ball visObject.
             * @property {Array.<message.vision.Ball.Measurement$Properties>} [measurements] Ball measurements.
             * @property {Array.<vec3$Properties>} [edgePoints] Ball edgePoints.
             * @property {message.Circle$Properties} [circle] Ball circle.
             */

            /**
             * Constructs a new Ball.
             * @exports message.vision.Ball
             * @constructor
             * @param {message.vision.Ball$Properties=} [properties] Properties to set
             */
            function Ball(properties) {
                this.measurements = [];
                this.edgePoints = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Ball visObject.
             * @type {(message.vision.VisionObject$Properties|null)}
             */
            Ball.prototype.visObject = null;

            /**
             * Ball measurements.
             * @type {Array.<message.vision.Ball.Measurement$Properties>}
             */
            Ball.prototype.measurements = $util.emptyArray;

            /**
             * Ball edgePoints.
             * @type {Array.<vec3$Properties>}
             */
            Ball.prototype.edgePoints = $util.emptyArray;

            /**
             * Ball circle.
             * @type {(message.Circle$Properties|null)}
             */
            Ball.prototype.circle = null;

            /**
             * Creates a new Ball instance using the specified properties.
             * @param {message.vision.Ball$Properties=} [properties] Properties to set
             * @returns {message.vision.Ball} Ball instance
             */
            Ball.create = function create(properties) {
                return new Ball(properties);
            };

            /**
             * Encodes the specified Ball message. Does not implicitly {@link message.vision.Ball.verify|verify} messages.
             * @param {message.vision.Ball$Properties} message Ball message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ball.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.visObject != null && message.hasOwnProperty("visObject"))
                    $root.message.vision.VisionObject.encode(message.visObject, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.measurements != null && message.measurements.length)
                    for (var i = 0; i < message.measurements.length; ++i)
                        $root.message.vision.Ball.Measurement.encode(message.measurements[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.edgePoints != null && message.edgePoints.length)
                    for (var i = 0; i < message.edgePoints.length; ++i)
                        $root.vec3.encode(message.edgePoints[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.circle != null && message.hasOwnProperty("circle"))
                    $root.message.Circle.encode(message.circle, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Ball message, length delimited. Does not implicitly {@link message.vision.Ball.verify|verify} messages.
             * @param {message.vision.Ball$Properties} message Ball message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ball.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Ball message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Ball} Ball
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ball.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Ball();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.visObject = $root.message.vision.VisionObject.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.measurements && message.measurements.length))
                            message.measurements = [];
                        message.measurements.push($root.message.vision.Ball.Measurement.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.edgePoints && message.edgePoints.length))
                            message.edgePoints = [];
                        message.edgePoints.push($root.vec3.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.circle = $root.message.Circle.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Ball message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.Ball} Ball
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ball.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Ball message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Ball.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.visObject != null && message.hasOwnProperty("visObject")) {
                    var error = $root.message.vision.VisionObject.verify(message.visObject);
                    if (error)
                        return "visObject." + error;
                }
                if (message.measurements != null && message.hasOwnProperty("measurements")) {
                    if (!Array.isArray(message.measurements))
                        return "measurements: array expected";
                    for (var i = 0; i < message.measurements.length; ++i) {
                        var error = $root.message.vision.Ball.Measurement.verify(message.measurements[i]);
                        if (error)
                            return "measurements." + error;
                    }
                }
                if (message.edgePoints != null && message.hasOwnProperty("edgePoints")) {
                    if (!Array.isArray(message.edgePoints))
                        return "edgePoints: array expected";
                    for (var i = 0; i < message.edgePoints.length; ++i) {
                        var error = $root.vec3.verify(message.edgePoints[i]);
                        if (error)
                            return "edgePoints." + error;
                    }
                }
                if (message.circle != null && message.hasOwnProperty("circle")) {
                    var error = $root.message.Circle.verify(message.circle);
                    if (error)
                        return "circle." + error;
                }
                return null;
            };

            /**
             * Creates a Ball message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Ball} Ball
             */
            Ball.fromObject = function fromObject(object) {
                if (object instanceof $root.message.vision.Ball)
                    return object;
                var message = new $root.message.vision.Ball();
                if (object.visObject != null) {
                    if (typeof object.visObject !== "object")
                        throw TypeError(".message.vision.Ball.visObject: object expected");
                    message.visObject = $root.message.vision.VisionObject.fromObject(object.visObject);
                }
                if (object.measurements) {
                    if (!Array.isArray(object.measurements))
                        throw TypeError(".message.vision.Ball.measurements: array expected");
                    message.measurements = [];
                    for (var i = 0; i < object.measurements.length; ++i) {
                        if (typeof object.measurements[i] !== "object")
                            throw TypeError(".message.vision.Ball.measurements: object expected");
                        message.measurements[i] = $root.message.vision.Ball.Measurement.fromObject(object.measurements[i]);
                    }
                }
                if (object.edgePoints) {
                    if (!Array.isArray(object.edgePoints))
                        throw TypeError(".message.vision.Ball.edgePoints: array expected");
                    message.edgePoints = [];
                    for (var i = 0; i < object.edgePoints.length; ++i) {
                        if (typeof object.edgePoints[i] !== "object")
                            throw TypeError(".message.vision.Ball.edgePoints: object expected");
                        message.edgePoints[i] = $root.vec3.fromObject(object.edgePoints[i]);
                    }
                }
                if (object.circle != null) {
                    if (typeof object.circle !== "object")
                        throw TypeError(".message.vision.Ball.circle: object expected");
                    message.circle = $root.message.Circle.fromObject(object.circle);
                }
                return message;
            };

            /**
             * Creates a Ball message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.Ball.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Ball} Ball
             */
            Ball.from = Ball.fromObject;

            /**
             * Creates a plain object from a Ball message. Also converts values to other types if specified.
             * @param {message.vision.Ball} message Ball
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Ball.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.measurements = [];
                    object.edgePoints = [];
                }
                if (options.defaults) {
                    object.visObject = null;
                    object.circle = null;
                }
                if (message.visObject != null && message.hasOwnProperty("visObject"))
                    object.visObject = $root.message.vision.VisionObject.toObject(message.visObject, options);
                if (message.measurements && message.measurements.length) {
                    object.measurements = [];
                    for (var j = 0; j < message.measurements.length; ++j)
                        object.measurements[j] = $root.message.vision.Ball.Measurement.toObject(message.measurements[j], options);
                }
                if (message.edgePoints && message.edgePoints.length) {
                    object.edgePoints = [];
                    for (var j = 0; j < message.edgePoints.length; ++j)
                        object.edgePoints[j] = $root.vec3.toObject(message.edgePoints[j], options);
                }
                if (message.circle != null && message.hasOwnProperty("circle"))
                    object.circle = $root.message.Circle.toObject(message.circle, options);
                return object;
            };

            /**
             * Creates a plain object from this Ball message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Ball.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Ball to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Ball.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * MeasurementType enum.
             * @name MeasurementType
             * @memberof message.vision.Ball
             * @enum {number}
             * @property {number} REPROJECTION=0 REPROJECTION value
             * @property {number} WIDTH_BASED=1 WIDTH_BASED value
             */
            Ball.MeasurementType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "REPROJECTION"] = 0;
                values[valuesById[1] = "WIDTH_BASED"] = 1;
                return values;
            })();

            Ball.Measurement = (function() {

                /**
                 * Properties of a Measurement.
                 * @typedef message.vision.Ball.Measurement$Properties
                 * @type {Object}
                 * @property {message.vision.Ball.MeasurementType} [type] Measurement type.
                 * @property {vec3$Properties} [rBCc] Measurement rBCc.
                 * @property {mat33$Properties} [covariance] Measurement covariance.
                 */

                /**
                 * Constructs a new Measurement.
                 * @exports message.vision.Ball.Measurement
                 * @constructor
                 * @param {message.vision.Ball.Measurement$Properties=} [properties] Properties to set
                 */
                function Measurement(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Measurement type.
                 * @type {message.vision.Ball.MeasurementType}
                 */
                Measurement.prototype.type = 0;

                /**
                 * Measurement rBCc.
                 * @type {(vec3$Properties|null)}
                 */
                Measurement.prototype.rBCc = null;

                /**
                 * Measurement covariance.
                 * @type {(mat33$Properties|null)}
                 */
                Measurement.prototype.covariance = null;

                /**
                 * Creates a new Measurement instance using the specified properties.
                 * @param {message.vision.Ball.Measurement$Properties=} [properties] Properties to set
                 * @returns {message.vision.Ball.Measurement} Measurement instance
                 */
                Measurement.create = function create(properties) {
                    return new Measurement(properties);
                };

                /**
                 * Encodes the specified Measurement message. Does not implicitly {@link message.vision.Ball.Measurement.verify|verify} messages.
                 * @param {message.vision.Ball.Measurement$Properties} message Measurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Measurement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
                    if (message.rBCc != null && message.hasOwnProperty("rBCc"))
                        $root.vec3.encode(message.rBCc, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.covariance != null && message.hasOwnProperty("covariance"))
                        $root.mat33.encode(message.covariance, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Measurement message, length delimited. Does not implicitly {@link message.vision.Ball.Measurement.verify|verify} messages.
                 * @param {message.vision.Ball.Measurement$Properties} message Measurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Measurement.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Measurement message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.vision.Ball.Measurement} Measurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Measurement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Ball.Measurement();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.uint32();
                            break;
                        case 2:
                            message.rBCc = $root.vec3.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.covariance = $root.mat33.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Measurement message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.vision.Ball.Measurement} Measurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Measurement.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Measurement message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Measurement.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.rBCc != null && message.hasOwnProperty("rBCc")) {
                        var error = $root.vec3.verify(message.rBCc);
                        if (error)
                            return "rBCc." + error;
                    }
                    if (message.covariance != null && message.hasOwnProperty("covariance")) {
                        var error = $root.mat33.verify(message.covariance);
                        if (error)
                            return "covariance." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Measurement message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.Ball.Measurement} Measurement
                 */
                Measurement.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.vision.Ball.Measurement)
                        return object;
                    var message = new $root.message.vision.Ball.Measurement();
                    switch (object.type) {
                    case "REPROJECTION":
                    case 0:
                        message.type = 0;
                        break;
                    case "WIDTH_BASED":
                    case 1:
                        message.type = 1;
                        break;
                    }
                    if (object.rBCc != null) {
                        if (typeof object.rBCc !== "object")
                            throw TypeError(".message.vision.Ball.Measurement.rBCc: object expected");
                        message.rBCc = $root.vec3.fromObject(object.rBCc);
                    }
                    if (object.covariance != null) {
                        if (typeof object.covariance !== "object")
                            throw TypeError(".message.vision.Ball.Measurement.covariance: object expected");
                        message.covariance = $root.mat33.fromObject(object.covariance);
                    }
                    return message;
                };

                /**
                 * Creates a Measurement message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.vision.Ball.Measurement.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.Ball.Measurement} Measurement
                 */
                Measurement.from = Measurement.fromObject;

                /**
                 * Creates a plain object from a Measurement message. Also converts values to other types if specified.
                 * @param {message.vision.Ball.Measurement} message Measurement
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Measurement.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "REPROJECTION" : 0;
                        object.rBCc = null;
                        object.covariance = null;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.message.vision.Ball.MeasurementType[message.type] : message.type;
                    if (message.rBCc != null && message.hasOwnProperty("rBCc"))
                        object.rBCc = $root.vec3.toObject(message.rBCc, options);
                    if (message.covariance != null && message.hasOwnProperty("covariance"))
                        object.covariance = $root.mat33.toObject(message.covariance, options);
                    return object;
                };

                /**
                 * Creates a plain object from this Measurement message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Measurement.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Measurement to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Measurement.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Measurement;
            })();

            return Ball;
        })();

        vision.Goal = (function() {

            /**
             * Properties of a Goal.
             * @typedef message.vision.Goal$Properties
             * @type {Object}
             * @property {message.vision.VisionObject$Properties} [visObject] Goal visObject.
             * @property {message.vision.Goal.Side} [side] Goal side.
             * @property {message.vision.Goal.Team} [team] Goal team.
             * @property {message.Quad$Properties} [quad] Goal quad.
             * @property {Array.<message.vision.Goal.Measurement$Properties>} [measurement] Goal measurement.
             */

            /**
             * Constructs a new Goal.
             * @exports message.vision.Goal
             * @constructor
             * @param {message.vision.Goal$Properties=} [properties] Properties to set
             */
            function Goal(properties) {
                this.measurement = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Goal visObject.
             * @type {(message.vision.VisionObject$Properties|null)}
             */
            Goal.prototype.visObject = null;

            /**
             * Goal side.
             * @type {message.vision.Goal.Side}
             */
            Goal.prototype.side = 0;

            /**
             * Goal team.
             * @type {message.vision.Goal.Team}
             */
            Goal.prototype.team = 0;

            /**
             * Goal quad.
             * @type {(message.Quad$Properties|null)}
             */
            Goal.prototype.quad = null;

            /**
             * Goal measurement.
             * @type {Array.<message.vision.Goal.Measurement$Properties>}
             */
            Goal.prototype.measurement = $util.emptyArray;

            /**
             * Creates a new Goal instance using the specified properties.
             * @param {message.vision.Goal$Properties=} [properties] Properties to set
             * @returns {message.vision.Goal} Goal instance
             */
            Goal.create = function create(properties) {
                return new Goal(properties);
            };

            /**
             * Encodes the specified Goal message. Does not implicitly {@link message.vision.Goal.verify|verify} messages.
             * @param {message.vision.Goal$Properties} message Goal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Goal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.visObject != null && message.hasOwnProperty("visObject"))
                    $root.message.vision.VisionObject.encode(message.visObject, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.side != null && message.hasOwnProperty("side"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.side);
                if (message.team != null && message.hasOwnProperty("team"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.team);
                if (message.quad != null && message.hasOwnProperty("quad"))
                    $root.message.Quad.encode(message.quad, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.measurement != null && message.measurement.length)
                    for (var i = 0; i < message.measurement.length; ++i)
                        $root.message.vision.Goal.Measurement.encode(message.measurement[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Goal message, length delimited. Does not implicitly {@link message.vision.Goal.verify|verify} messages.
             * @param {message.vision.Goal$Properties} message Goal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Goal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Goal message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Goal} Goal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Goal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Goal();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.visObject = $root.message.vision.VisionObject.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.side = reader.uint32();
                        break;
                    case 3:
                        message.team = reader.uint32();
                        break;
                    case 4:
                        message.quad = $root.message.Quad.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.measurement && message.measurement.length))
                            message.measurement = [];
                        message.measurement.push($root.message.vision.Goal.Measurement.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Goal message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.Goal} Goal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Goal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Goal message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Goal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.visObject != null && message.hasOwnProperty("visObject")) {
                    var error = $root.message.vision.VisionObject.verify(message.visObject);
                    if (error)
                        return "visObject." + error;
                }
                if (message.side != null && message.hasOwnProperty("side"))
                    switch (message.side) {
                    default:
                        return "side: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.team != null && message.hasOwnProperty("team"))
                    switch (message.team) {
                    default:
                        return "team: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.quad != null && message.hasOwnProperty("quad")) {
                    var error = $root.message.Quad.verify(message.quad);
                    if (error)
                        return "quad." + error;
                }
                if (message.measurement != null && message.hasOwnProperty("measurement")) {
                    if (!Array.isArray(message.measurement))
                        return "measurement: array expected";
                    for (var i = 0; i < message.measurement.length; ++i) {
                        var error = $root.message.vision.Goal.Measurement.verify(message.measurement[i]);
                        if (error)
                            return "measurement." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Goal message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Goal} Goal
             */
            Goal.fromObject = function fromObject(object) {
                if (object instanceof $root.message.vision.Goal)
                    return object;
                var message = new $root.message.vision.Goal();
                if (object.visObject != null) {
                    if (typeof object.visObject !== "object")
                        throw TypeError(".message.vision.Goal.visObject: object expected");
                    message.visObject = $root.message.vision.VisionObject.fromObject(object.visObject);
                }
                switch (object.side) {
                case "UNKNOWN_SIDE":
                case 0:
                    message.side = 0;
                    break;
                case "LEFT":
                case 1:
                    message.side = 1;
                    break;
                case "RIGHT":
                case 2:
                    message.side = 2;
                    break;
                }
                switch (object.team) {
                case "UNKNOWN_TEAM":
                case 0:
                    message.team = 0;
                    break;
                case "OWN":
                case 1:
                    message.team = 1;
                    break;
                case "OPPONENT":
                case 2:
                    message.team = 2;
                    break;
                }
                if (object.quad != null) {
                    if (typeof object.quad !== "object")
                        throw TypeError(".message.vision.Goal.quad: object expected");
                    message.quad = $root.message.Quad.fromObject(object.quad);
                }
                if (object.measurement) {
                    if (!Array.isArray(object.measurement))
                        throw TypeError(".message.vision.Goal.measurement: array expected");
                    message.measurement = [];
                    for (var i = 0; i < object.measurement.length; ++i) {
                        if (typeof object.measurement[i] !== "object")
                            throw TypeError(".message.vision.Goal.measurement: object expected");
                        message.measurement[i] = $root.message.vision.Goal.Measurement.fromObject(object.measurement[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a Goal message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.Goal.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Goal} Goal
             */
            Goal.from = Goal.fromObject;

            /**
             * Creates a plain object from a Goal message. Also converts values to other types if specified.
             * @param {message.vision.Goal} message Goal
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Goal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.measurement = [];
                if (options.defaults) {
                    object.visObject = null;
                    object.side = options.enums === String ? "UNKNOWN_SIDE" : 0;
                    object.team = options.enums === String ? "UNKNOWN_TEAM" : 0;
                    object.quad = null;
                }
                if (message.visObject != null && message.hasOwnProperty("visObject"))
                    object.visObject = $root.message.vision.VisionObject.toObject(message.visObject, options);
                if (message.side != null && message.hasOwnProperty("side"))
                    object.side = options.enums === String ? $root.message.vision.Goal.Side[message.side] : message.side;
                if (message.team != null && message.hasOwnProperty("team"))
                    object.team = options.enums === String ? $root.message.vision.Goal.Team[message.team] : message.team;
                if (message.quad != null && message.hasOwnProperty("quad"))
                    object.quad = $root.message.Quad.toObject(message.quad, options);
                if (message.measurement && message.measurement.length) {
                    object.measurement = [];
                    for (var j = 0; j < message.measurement.length; ++j)
                        object.measurement[j] = $root.message.vision.Goal.Measurement.toObject(message.measurement[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this Goal message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Goal.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Goal to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Goal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Side enum.
             * @name Side
             * @memberof message.vision.Goal
             * @enum {number}
             * @property {number} UNKNOWN_SIDE=0 UNKNOWN_SIDE value
             * @property {number} LEFT=1 LEFT value
             * @property {number} RIGHT=2 RIGHT value
             */
            Goal.Side = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN_SIDE"] = 0;
                values[valuesById[1] = "LEFT"] = 1;
                values[valuesById[2] = "RIGHT"] = 2;
                return values;
            })();

            /**
             * Team enum.
             * @name Team
             * @memberof message.vision.Goal
             * @enum {number}
             * @property {number} UNKNOWN_TEAM=0 UNKNOWN_TEAM value
             * @property {number} OWN=1 OWN value
             * @property {number} OPPONENT=2 OPPONENT value
             */
            Goal.Team = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN_TEAM"] = 0;
                values[valuesById[1] = "OWN"] = 1;
                values[valuesById[2] = "OPPONENT"] = 2;
                return values;
            })();

            /**
             * MeasurementType enum.
             * @name MeasurementType
             * @memberof message.vision.Goal
             * @enum {number}
             * @property {number} UNKNOWN_MEASUREMENT=0 UNKNOWN_MEASUREMENT value
             * @property {number} LEFT_NORMAL=1 LEFT_NORMAL value
             * @property {number} RIGHT_NORMAL=2 RIGHT_NORMAL value
             * @property {number} TOP_NORMAL=3 TOP_NORMAL value
             * @property {number} BASE_NORMAL=4 BASE_NORMAL value
             * @property {number} CENTRE=5 CENTRE value
             */
            Goal.MeasurementType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN_MEASUREMENT"] = 0;
                values[valuesById[1] = "LEFT_NORMAL"] = 1;
                values[valuesById[2] = "RIGHT_NORMAL"] = 2;
                values[valuesById[3] = "TOP_NORMAL"] = 3;
                values[valuesById[4] = "BASE_NORMAL"] = 4;
                values[valuesById[5] = "CENTRE"] = 5;
                return values;
            })();

            Goal.Measurement = (function() {

                /**
                 * Properties of a Measurement.
                 * @typedef message.vision.Goal.Measurement$Properties
                 * @type {Object}
                 * @property {message.vision.Goal.MeasurementType} [type] Measurement type.
                 * @property {vec3$Properties} [position] Measurement position.
                 * @property {mat33$Properties} [covariance] Measurement covariance.
                 * @property {vec2$Properties} [normalAngles] Measurement normalAngles.
                 * @property {mat22$Properties} [normAngCov] Measurement normAngCov.
                 */

                /**
                 * Constructs a new Measurement.
                 * @exports message.vision.Goal.Measurement
                 * @constructor
                 * @param {message.vision.Goal.Measurement$Properties=} [properties] Properties to set
                 */
                function Measurement(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Measurement type.
                 * @type {message.vision.Goal.MeasurementType}
                 */
                Measurement.prototype.type = 0;

                /**
                 * Measurement position.
                 * @type {(vec3$Properties|null)}
                 */
                Measurement.prototype.position = null;

                /**
                 * Measurement covariance.
                 * @type {(mat33$Properties|null)}
                 */
                Measurement.prototype.covariance = null;

                /**
                 * Measurement normalAngles.
                 * @type {(vec2$Properties|null)}
                 */
                Measurement.prototype.normalAngles = null;

                /**
                 * Measurement normAngCov.
                 * @type {(mat22$Properties|null)}
                 */
                Measurement.prototype.normAngCov = null;

                /**
                 * Creates a new Measurement instance using the specified properties.
                 * @param {message.vision.Goal.Measurement$Properties=} [properties] Properties to set
                 * @returns {message.vision.Goal.Measurement} Measurement instance
                 */
                Measurement.create = function create(properties) {
                    return new Measurement(properties);
                };

                /**
                 * Encodes the specified Measurement message. Does not implicitly {@link message.vision.Goal.Measurement.verify|verify} messages.
                 * @param {message.vision.Goal.Measurement$Properties} message Measurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Measurement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
                    if (message.position != null && message.hasOwnProperty("position"))
                        $root.vec3.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.covariance != null && message.hasOwnProperty("covariance"))
                        $root.mat33.encode(message.covariance, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.normalAngles != null && message.hasOwnProperty("normalAngles"))
                        $root.vec2.encode(message.normalAngles, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.normAngCov != null && message.hasOwnProperty("normAngCov"))
                        $root.mat22.encode(message.normAngCov, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Measurement message, length delimited. Does not implicitly {@link message.vision.Goal.Measurement.verify|verify} messages.
                 * @param {message.vision.Goal.Measurement$Properties} message Measurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Measurement.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Measurement message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.vision.Goal.Measurement} Measurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Measurement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Goal.Measurement();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.uint32();
                            break;
                        case 2:
                            message.position = $root.vec3.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.covariance = $root.mat33.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.normalAngles = $root.vec2.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.normAngCov = $root.mat22.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Measurement message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.vision.Goal.Measurement} Measurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Measurement.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Measurement message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Measurement.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.position != null && message.hasOwnProperty("position")) {
                        var error = $root.vec3.verify(message.position);
                        if (error)
                            return "position." + error;
                    }
                    if (message.covariance != null && message.hasOwnProperty("covariance")) {
                        var error = $root.mat33.verify(message.covariance);
                        if (error)
                            return "covariance." + error;
                    }
                    if (message.normalAngles != null && message.hasOwnProperty("normalAngles")) {
                        var error = $root.vec2.verify(message.normalAngles);
                        if (error)
                            return "normalAngles." + error;
                    }
                    if (message.normAngCov != null && message.hasOwnProperty("normAngCov")) {
                        var error = $root.mat22.verify(message.normAngCov);
                        if (error)
                            return "normAngCov." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Measurement message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.Goal.Measurement} Measurement
                 */
                Measurement.fromObject = function fromObject(object) {
                    if (object instanceof $root.message.vision.Goal.Measurement)
                        return object;
                    var message = new $root.message.vision.Goal.Measurement();
                    switch (object.type) {
                    case "UNKNOWN_MEASUREMENT":
                    case 0:
                        message.type = 0;
                        break;
                    case "LEFT_NORMAL":
                    case 1:
                        message.type = 1;
                        break;
                    case "RIGHT_NORMAL":
                    case 2:
                        message.type = 2;
                        break;
                    case "TOP_NORMAL":
                    case 3:
                        message.type = 3;
                        break;
                    case "BASE_NORMAL":
                    case 4:
                        message.type = 4;
                        break;
                    case "CENTRE":
                    case 5:
                        message.type = 5;
                        break;
                    }
                    if (object.position != null) {
                        if (typeof object.position !== "object")
                            throw TypeError(".message.vision.Goal.Measurement.position: object expected");
                        message.position = $root.vec3.fromObject(object.position);
                    }
                    if (object.covariance != null) {
                        if (typeof object.covariance !== "object")
                            throw TypeError(".message.vision.Goal.Measurement.covariance: object expected");
                        message.covariance = $root.mat33.fromObject(object.covariance);
                    }
                    if (object.normalAngles != null) {
                        if (typeof object.normalAngles !== "object")
                            throw TypeError(".message.vision.Goal.Measurement.normalAngles: object expected");
                        message.normalAngles = $root.vec2.fromObject(object.normalAngles);
                    }
                    if (object.normAngCov != null) {
                        if (typeof object.normAngCov !== "object")
                            throw TypeError(".message.vision.Goal.Measurement.normAngCov: object expected");
                        message.normAngCov = $root.mat22.fromObject(object.normAngCov);
                    }
                    return message;
                };

                /**
                 * Creates a Measurement message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.vision.Goal.Measurement.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.Goal.Measurement} Measurement
                 */
                Measurement.from = Measurement.fromObject;

                /**
                 * Creates a plain object from a Measurement message. Also converts values to other types if specified.
                 * @param {message.vision.Goal.Measurement} message Measurement
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Measurement.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "UNKNOWN_MEASUREMENT" : 0;
                        object.position = null;
                        object.covariance = null;
                        object.normalAngles = null;
                        object.normAngCov = null;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.message.vision.Goal.MeasurementType[message.type] : message.type;
                    if (message.position != null && message.hasOwnProperty("position"))
                        object.position = $root.vec3.toObject(message.position, options);
                    if (message.covariance != null && message.hasOwnProperty("covariance"))
                        object.covariance = $root.mat33.toObject(message.covariance, options);
                    if (message.normalAngles != null && message.hasOwnProperty("normalAngles"))
                        object.normalAngles = $root.vec2.toObject(message.normalAngles, options);
                    if (message.normAngCov != null && message.hasOwnProperty("normAngCov"))
                        object.normAngCov = $root.mat22.toObject(message.normAngCov, options);
                    return object;
                };

                /**
                 * Creates a plain object from this Measurement message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Measurement.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Measurement to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Measurement.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Measurement;
            })();

            return Goal;
        })();

        vision.Obstacle = (function() {

            /**
             * Properties of an Obstacle.
             * @typedef message.vision.Obstacle$Properties
             * @type {Object}
             * @property {message.vision.VisionObject$Properties} [visObject] Obstacle visObject.
             * @property {message.Polygon$Properties} [shape] Obstacle shape.
             * @property {message.vision.Obstacle.Team} [team] Obstacle team.
             */

            /**
             * Constructs a new Obstacle.
             * @exports message.vision.Obstacle
             * @constructor
             * @param {message.vision.Obstacle$Properties=} [properties] Properties to set
             */
            function Obstacle(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Obstacle visObject.
             * @type {(message.vision.VisionObject$Properties|null)}
             */
            Obstacle.prototype.visObject = null;

            /**
             * Obstacle shape.
             * @type {(message.Polygon$Properties|null)}
             */
            Obstacle.prototype.shape = null;

            /**
             * Obstacle team.
             * @type {message.vision.Obstacle.Team}
             */
            Obstacle.prototype.team = 0;

            /**
             * Creates a new Obstacle instance using the specified properties.
             * @param {message.vision.Obstacle$Properties=} [properties] Properties to set
             * @returns {message.vision.Obstacle} Obstacle instance
             */
            Obstacle.create = function create(properties) {
                return new Obstacle(properties);
            };

            /**
             * Encodes the specified Obstacle message. Does not implicitly {@link message.vision.Obstacle.verify|verify} messages.
             * @param {message.vision.Obstacle$Properties} message Obstacle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Obstacle.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.visObject != null && message.hasOwnProperty("visObject"))
                    $root.message.vision.VisionObject.encode(message.visObject, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.shape != null && message.hasOwnProperty("shape"))
                    $root.message.Polygon.encode(message.shape, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.team != null && message.hasOwnProperty("team"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.team);
                return writer;
            };

            /**
             * Encodes the specified Obstacle message, length delimited. Does not implicitly {@link message.vision.Obstacle.verify|verify} messages.
             * @param {message.vision.Obstacle$Properties} message Obstacle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Obstacle.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Obstacle message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Obstacle} Obstacle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Obstacle.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Obstacle();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.visObject = $root.message.vision.VisionObject.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.shape = $root.message.Polygon.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.team = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Obstacle message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.Obstacle} Obstacle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Obstacle.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Obstacle message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Obstacle.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.visObject != null && message.hasOwnProperty("visObject")) {
                    var error = $root.message.vision.VisionObject.verify(message.visObject);
                    if (error)
                        return "visObject." + error;
                }
                if (message.shape != null && message.hasOwnProperty("shape")) {
                    var error = $root.message.Polygon.verify(message.shape);
                    if (error)
                        return "shape." + error;
                }
                if (message.team != null && message.hasOwnProperty("team"))
                    switch (message.team) {
                    default:
                        return "team: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates an Obstacle message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Obstacle} Obstacle
             */
            Obstacle.fromObject = function fromObject(object) {
                if (object instanceof $root.message.vision.Obstacle)
                    return object;
                var message = new $root.message.vision.Obstacle();
                if (object.visObject != null) {
                    if (typeof object.visObject !== "object")
                        throw TypeError(".message.vision.Obstacle.visObject: object expected");
                    message.visObject = $root.message.vision.VisionObject.fromObject(object.visObject);
                }
                if (object.shape != null) {
                    if (typeof object.shape !== "object")
                        throw TypeError(".message.vision.Obstacle.shape: object expected");
                    message.shape = $root.message.Polygon.fromObject(object.shape);
                }
                switch (object.team) {
                case "UNKNOWN_TEAM":
                case 0:
                    message.team = 0;
                    break;
                case "MAGENTA":
                case 1:
                    message.team = 1;
                    break;
                case "CYAN":
                case 2:
                    message.team = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates an Obstacle message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.Obstacle.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Obstacle} Obstacle
             */
            Obstacle.from = Obstacle.fromObject;

            /**
             * Creates a plain object from an Obstacle message. Also converts values to other types if specified.
             * @param {message.vision.Obstacle} message Obstacle
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Obstacle.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.visObject = null;
                    object.shape = null;
                    object.team = options.enums === String ? "UNKNOWN_TEAM" : 0;
                }
                if (message.visObject != null && message.hasOwnProperty("visObject"))
                    object.visObject = $root.message.vision.VisionObject.toObject(message.visObject, options);
                if (message.shape != null && message.hasOwnProperty("shape"))
                    object.shape = $root.message.Polygon.toObject(message.shape, options);
                if (message.team != null && message.hasOwnProperty("team"))
                    object.team = options.enums === String ? $root.message.vision.Obstacle.Team[message.team] : message.team;
                return object;
            };

            /**
             * Creates a plain object from this Obstacle message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Obstacle.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Obstacle to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Obstacle.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Team enum.
             * @name Team
             * @memberof message.vision.Obstacle
             * @enum {number}
             * @property {number} UNKNOWN_TEAM=0 UNKNOWN_TEAM value
             * @property {number} MAGENTA=1 MAGENTA value
             * @property {number} CYAN=2 CYAN value
             */
            Obstacle.Team = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN_TEAM"] = 0;
                values[valuesById[1] = "MAGENTA"] = 1;
                values[valuesById[2] = "CYAN"] = 2;
                return values;
            })();

            return Obstacle;
        })();

        vision.Line = (function() {

            /**
             * Properties of a Line.
             * @typedef message.vision.Line$Properties
             * @type {Object}
             * @property {message.vision.VisionObject$Properties} [visObject] Line visObject.
             * @property {ivec2$Properties} [start] Line start.
             * @property {ivec2$Properties} [end] Line end.
             * @property {vec4$Properties} [colour] Line colour.
             */

            /**
             * Constructs a new Line.
             * @exports message.vision.Line
             * @constructor
             * @param {message.vision.Line$Properties=} [properties] Properties to set
             */
            function Line(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Line visObject.
             * @type {(message.vision.VisionObject$Properties|null)}
             */
            Line.prototype.visObject = null;

            /**
             * Line start.
             * @type {(ivec2$Properties|null)}
             */
            Line.prototype.start = null;

            /**
             * Line end.
             * @type {(ivec2$Properties|null)}
             */
            Line.prototype.end = null;

            /**
             * Line colour.
             * @type {(vec4$Properties|null)}
             */
            Line.prototype.colour = null;

            /**
             * Creates a new Line instance using the specified properties.
             * @param {message.vision.Line$Properties=} [properties] Properties to set
             * @returns {message.vision.Line} Line instance
             */
            Line.create = function create(properties) {
                return new Line(properties);
            };

            /**
             * Encodes the specified Line message. Does not implicitly {@link message.vision.Line.verify|verify} messages.
             * @param {message.vision.Line$Properties} message Line message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Line.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.visObject != null && message.hasOwnProperty("visObject"))
                    $root.message.vision.VisionObject.encode(message.visObject, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.start != null && message.hasOwnProperty("start"))
                    $root.ivec2.encode(message.start, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.end != null && message.hasOwnProperty("end"))
                    $root.ivec2.encode(message.end, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.colour != null && message.hasOwnProperty("colour"))
                    $root.vec4.encode(message.colour, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Line message, length delimited. Does not implicitly {@link message.vision.Line.verify|verify} messages.
             * @param {message.vision.Line$Properties} message Line message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Line.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Line message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Line} Line
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Line.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.Line();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.visObject = $root.message.vision.VisionObject.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.start = $root.ivec2.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.end = $root.ivec2.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.colour = $root.vec4.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Line message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.Line} Line
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Line.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Line message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Line.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.visObject != null && message.hasOwnProperty("visObject")) {
                    var error = $root.message.vision.VisionObject.verify(message.visObject);
                    if (error)
                        return "visObject." + error;
                }
                if (message.start != null && message.hasOwnProperty("start")) {
                    var error = $root.ivec2.verify(message.start);
                    if (error)
                        return "start." + error;
                }
                if (message.end != null && message.hasOwnProperty("end")) {
                    var error = $root.ivec2.verify(message.end);
                    if (error)
                        return "end." + error;
                }
                if (message.colour != null && message.hasOwnProperty("colour")) {
                    var error = $root.vec4.verify(message.colour);
                    if (error)
                        return "colour." + error;
                }
                return null;
            };

            /**
             * Creates a Line message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Line} Line
             */
            Line.fromObject = function fromObject(object) {
                if (object instanceof $root.message.vision.Line)
                    return object;
                var message = new $root.message.vision.Line();
                if (object.visObject != null) {
                    if (typeof object.visObject !== "object")
                        throw TypeError(".message.vision.Line.visObject: object expected");
                    message.visObject = $root.message.vision.VisionObject.fromObject(object.visObject);
                }
                if (object.start != null) {
                    if (typeof object.start !== "object")
                        throw TypeError(".message.vision.Line.start: object expected");
                    message.start = $root.ivec2.fromObject(object.start);
                }
                if (object.end != null) {
                    if (typeof object.end !== "object")
                        throw TypeError(".message.vision.Line.end: object expected");
                    message.end = $root.ivec2.fromObject(object.end);
                }
                if (object.colour != null) {
                    if (typeof object.colour !== "object")
                        throw TypeError(".message.vision.Line.colour: object expected");
                    message.colour = $root.vec4.fromObject(object.colour);
                }
                return message;
            };

            /**
             * Creates a Line message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.Line.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Line} Line
             */
            Line.from = Line.fromObject;

            /**
             * Creates a plain object from a Line message. Also converts values to other types if specified.
             * @param {message.vision.Line} message Line
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Line.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.visObject = null;
                    object.start = null;
                    object.end = null;
                    object.colour = null;
                }
                if (message.visObject != null && message.hasOwnProperty("visObject"))
                    object.visObject = $root.message.vision.VisionObject.toObject(message.visObject, options);
                if (message.start != null && message.hasOwnProperty("start"))
                    object.start = $root.ivec2.toObject(message.start, options);
                if (message.end != null && message.hasOwnProperty("end"))
                    object.end = $root.ivec2.toObject(message.end, options);
                if (message.colour != null && message.hasOwnProperty("colour"))
                    object.colour = $root.vec4.toObject(message.colour, options);
                return object;
            };

            /**
             * Creates a plain object from this Line message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Line.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Line to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Line.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Line;
        })();

        vision.NUsightBalls = (function() {

            /**
             * Properties of a NUsightBalls.
             * @typedef message.vision.NUsightBalls$Properties
             * @type {Object}
             * @property {Array.<message.vision.Ball$Properties>} [balls] NUsightBalls balls.
             */

            /**
             * Constructs a new NUsightBalls.
             * @exports message.vision.NUsightBalls
             * @constructor
             * @param {message.vision.NUsightBalls$Properties=} [properties] Properties to set
             */
            function NUsightBalls(properties) {
                this.balls = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NUsightBalls balls.
             * @type {Array.<message.vision.Ball$Properties>}
             */
            NUsightBalls.prototype.balls = $util.emptyArray;

            /**
             * Creates a new NUsightBalls instance using the specified properties.
             * @param {message.vision.NUsightBalls$Properties=} [properties] Properties to set
             * @returns {message.vision.NUsightBalls} NUsightBalls instance
             */
            NUsightBalls.create = function create(properties) {
                return new NUsightBalls(properties);
            };

            /**
             * Encodes the specified NUsightBalls message. Does not implicitly {@link message.vision.NUsightBalls.verify|verify} messages.
             * @param {message.vision.NUsightBalls$Properties} message NUsightBalls message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NUsightBalls.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.balls != null && message.balls.length)
                    for (var i = 0; i < message.balls.length; ++i)
                        $root.message.vision.Ball.encode(message.balls[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NUsightBalls message, length delimited. Does not implicitly {@link message.vision.NUsightBalls.verify|verify} messages.
             * @param {message.vision.NUsightBalls$Properties} message NUsightBalls message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NUsightBalls.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NUsightBalls message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.NUsightBalls} NUsightBalls
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NUsightBalls.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.NUsightBalls();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.balls && message.balls.length))
                            message.balls = [];
                        message.balls.push($root.message.vision.Ball.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NUsightBalls message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.NUsightBalls} NUsightBalls
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NUsightBalls.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NUsightBalls message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            NUsightBalls.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.balls != null && message.hasOwnProperty("balls")) {
                    if (!Array.isArray(message.balls))
                        return "balls: array expected";
                    for (var i = 0; i < message.balls.length; ++i) {
                        var error = $root.message.vision.Ball.verify(message.balls[i]);
                        if (error)
                            return "balls." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a NUsightBalls message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightBalls} NUsightBalls
             */
            NUsightBalls.fromObject = function fromObject(object) {
                if (object instanceof $root.message.vision.NUsightBalls)
                    return object;
                var message = new $root.message.vision.NUsightBalls();
                if (object.balls) {
                    if (!Array.isArray(object.balls))
                        throw TypeError(".message.vision.NUsightBalls.balls: array expected");
                    message.balls = [];
                    for (var i = 0; i < object.balls.length; ++i) {
                        if (typeof object.balls[i] !== "object")
                            throw TypeError(".message.vision.NUsightBalls.balls: object expected");
                        message.balls[i] = $root.message.vision.Ball.fromObject(object.balls[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a NUsightBalls message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.NUsightBalls.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightBalls} NUsightBalls
             */
            NUsightBalls.from = NUsightBalls.fromObject;

            /**
             * Creates a plain object from a NUsightBalls message. Also converts values to other types if specified.
             * @param {message.vision.NUsightBalls} message NUsightBalls
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NUsightBalls.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.balls = [];
                if (message.balls && message.balls.length) {
                    object.balls = [];
                    for (var j = 0; j < message.balls.length; ++j)
                        object.balls[j] = $root.message.vision.Ball.toObject(message.balls[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this NUsightBalls message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NUsightBalls.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this NUsightBalls to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            NUsightBalls.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NUsightBalls;
        })();

        vision.NUsightGoals = (function() {

            /**
             * Properties of a NUsightGoals.
             * @typedef message.vision.NUsightGoals$Properties
             * @type {Object}
             * @property {Array.<message.vision.Goal$Properties>} [goals] NUsightGoals goals.
             */

            /**
             * Constructs a new NUsightGoals.
             * @exports message.vision.NUsightGoals
             * @constructor
             * @param {message.vision.NUsightGoals$Properties=} [properties] Properties to set
             */
            function NUsightGoals(properties) {
                this.goals = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NUsightGoals goals.
             * @type {Array.<message.vision.Goal$Properties>}
             */
            NUsightGoals.prototype.goals = $util.emptyArray;

            /**
             * Creates a new NUsightGoals instance using the specified properties.
             * @param {message.vision.NUsightGoals$Properties=} [properties] Properties to set
             * @returns {message.vision.NUsightGoals} NUsightGoals instance
             */
            NUsightGoals.create = function create(properties) {
                return new NUsightGoals(properties);
            };

            /**
             * Encodes the specified NUsightGoals message. Does not implicitly {@link message.vision.NUsightGoals.verify|verify} messages.
             * @param {message.vision.NUsightGoals$Properties} message NUsightGoals message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NUsightGoals.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.goals != null && message.goals.length)
                    for (var i = 0; i < message.goals.length; ++i)
                        $root.message.vision.Goal.encode(message.goals[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NUsightGoals message, length delimited. Does not implicitly {@link message.vision.NUsightGoals.verify|verify} messages.
             * @param {message.vision.NUsightGoals$Properties} message NUsightGoals message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NUsightGoals.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NUsightGoals message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.NUsightGoals} NUsightGoals
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NUsightGoals.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.NUsightGoals();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.goals && message.goals.length))
                            message.goals = [];
                        message.goals.push($root.message.vision.Goal.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NUsightGoals message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.NUsightGoals} NUsightGoals
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NUsightGoals.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NUsightGoals message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            NUsightGoals.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.goals != null && message.hasOwnProperty("goals")) {
                    if (!Array.isArray(message.goals))
                        return "goals: array expected";
                    for (var i = 0; i < message.goals.length; ++i) {
                        var error = $root.message.vision.Goal.verify(message.goals[i]);
                        if (error)
                            return "goals." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a NUsightGoals message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightGoals} NUsightGoals
             */
            NUsightGoals.fromObject = function fromObject(object) {
                if (object instanceof $root.message.vision.NUsightGoals)
                    return object;
                var message = new $root.message.vision.NUsightGoals();
                if (object.goals) {
                    if (!Array.isArray(object.goals))
                        throw TypeError(".message.vision.NUsightGoals.goals: array expected");
                    message.goals = [];
                    for (var i = 0; i < object.goals.length; ++i) {
                        if (typeof object.goals[i] !== "object")
                            throw TypeError(".message.vision.NUsightGoals.goals: object expected");
                        message.goals[i] = $root.message.vision.Goal.fromObject(object.goals[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a NUsightGoals message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.NUsightGoals.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightGoals} NUsightGoals
             */
            NUsightGoals.from = NUsightGoals.fromObject;

            /**
             * Creates a plain object from a NUsightGoals message. Also converts values to other types if specified.
             * @param {message.vision.NUsightGoals} message NUsightGoals
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NUsightGoals.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.goals = [];
                if (message.goals && message.goals.length) {
                    object.goals = [];
                    for (var j = 0; j < message.goals.length; ++j)
                        object.goals[j] = $root.message.vision.Goal.toObject(message.goals[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this NUsightGoals message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NUsightGoals.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this NUsightGoals to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            NUsightGoals.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NUsightGoals;
        })();

        vision.NUsightObstacles = (function() {

            /**
             * Properties of a NUsightObstacles.
             * @typedef message.vision.NUsightObstacles$Properties
             * @type {Object}
             * @property {Array.<message.vision.Obstacle$Properties>} [obstacles] NUsightObstacles obstacles.
             */

            /**
             * Constructs a new NUsightObstacles.
             * @exports message.vision.NUsightObstacles
             * @constructor
             * @param {message.vision.NUsightObstacles$Properties=} [properties] Properties to set
             */
            function NUsightObstacles(properties) {
                this.obstacles = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NUsightObstacles obstacles.
             * @type {Array.<message.vision.Obstacle$Properties>}
             */
            NUsightObstacles.prototype.obstacles = $util.emptyArray;

            /**
             * Creates a new NUsightObstacles instance using the specified properties.
             * @param {message.vision.NUsightObstacles$Properties=} [properties] Properties to set
             * @returns {message.vision.NUsightObstacles} NUsightObstacles instance
             */
            NUsightObstacles.create = function create(properties) {
                return new NUsightObstacles(properties);
            };

            /**
             * Encodes the specified NUsightObstacles message. Does not implicitly {@link message.vision.NUsightObstacles.verify|verify} messages.
             * @param {message.vision.NUsightObstacles$Properties} message NUsightObstacles message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NUsightObstacles.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.obstacles != null && message.obstacles.length)
                    for (var i = 0; i < message.obstacles.length; ++i)
                        $root.message.vision.Obstacle.encode(message.obstacles[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NUsightObstacles message, length delimited. Does not implicitly {@link message.vision.NUsightObstacles.verify|verify} messages.
             * @param {message.vision.NUsightObstacles$Properties} message NUsightObstacles message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NUsightObstacles.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NUsightObstacles message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.NUsightObstacles} NUsightObstacles
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NUsightObstacles.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.NUsightObstacles();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.obstacles && message.obstacles.length))
                            message.obstacles = [];
                        message.obstacles.push($root.message.vision.Obstacle.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NUsightObstacles message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.NUsightObstacles} NUsightObstacles
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NUsightObstacles.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NUsightObstacles message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            NUsightObstacles.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.obstacles != null && message.hasOwnProperty("obstacles")) {
                    if (!Array.isArray(message.obstacles))
                        return "obstacles: array expected";
                    for (var i = 0; i < message.obstacles.length; ++i) {
                        var error = $root.message.vision.Obstacle.verify(message.obstacles[i]);
                        if (error)
                            return "obstacles." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a NUsightObstacles message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightObstacles} NUsightObstacles
             */
            NUsightObstacles.fromObject = function fromObject(object) {
                if (object instanceof $root.message.vision.NUsightObstacles)
                    return object;
                var message = new $root.message.vision.NUsightObstacles();
                if (object.obstacles) {
                    if (!Array.isArray(object.obstacles))
                        throw TypeError(".message.vision.NUsightObstacles.obstacles: array expected");
                    message.obstacles = [];
                    for (var i = 0; i < object.obstacles.length; ++i) {
                        if (typeof object.obstacles[i] !== "object")
                            throw TypeError(".message.vision.NUsightObstacles.obstacles: object expected");
                        message.obstacles[i] = $root.message.vision.Obstacle.fromObject(object.obstacles[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a NUsightObstacles message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.NUsightObstacles.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightObstacles} NUsightObstacles
             */
            NUsightObstacles.from = NUsightObstacles.fromObject;

            /**
             * Creates a plain object from a NUsightObstacles message. Also converts values to other types if specified.
             * @param {message.vision.NUsightObstacles} message NUsightObstacles
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NUsightObstacles.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.obstacles = [];
                if (message.obstacles && message.obstacles.length) {
                    object.obstacles = [];
                    for (var j = 0; j < message.obstacles.length; ++j)
                        object.obstacles[j] = $root.message.vision.Obstacle.toObject(message.obstacles[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this NUsightObstacles message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NUsightObstacles.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this NUsightObstacles to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            NUsightObstacles.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NUsightObstacles;
        })();

        vision.NUsightLines = (function() {

            /**
             * Properties of a NUsightLines.
             * @typedef message.vision.NUsightLines$Properties
             * @type {Object}
             * @property {Array.<message.vision.Line$Properties>} [lines] NUsightLines lines.
             */

            /**
             * Constructs a new NUsightLines.
             * @exports message.vision.NUsightLines
             * @constructor
             * @param {message.vision.NUsightLines$Properties=} [properties] Properties to set
             */
            function NUsightLines(properties) {
                this.lines = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NUsightLines lines.
             * @type {Array.<message.vision.Line$Properties>}
             */
            NUsightLines.prototype.lines = $util.emptyArray;

            /**
             * Creates a new NUsightLines instance using the specified properties.
             * @param {message.vision.NUsightLines$Properties=} [properties] Properties to set
             * @returns {message.vision.NUsightLines} NUsightLines instance
             */
            NUsightLines.create = function create(properties) {
                return new NUsightLines(properties);
            };

            /**
             * Encodes the specified NUsightLines message. Does not implicitly {@link message.vision.NUsightLines.verify|verify} messages.
             * @param {message.vision.NUsightLines$Properties} message NUsightLines message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NUsightLines.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lines != null && message.lines.length)
                    for (var i = 0; i < message.lines.length; ++i)
                        $root.message.vision.Line.encode(message.lines[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NUsightLines message, length delimited. Does not implicitly {@link message.vision.NUsightLines.verify|verify} messages.
             * @param {message.vision.NUsightLines$Properties} message NUsightLines message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NUsightLines.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NUsightLines message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.NUsightLines} NUsightLines
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NUsightLines.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.message.vision.NUsightLines();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.lines && message.lines.length))
                            message.lines = [];
                        message.lines.push($root.message.vision.Line.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NUsightLines message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.NUsightLines} NUsightLines
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NUsightLines.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NUsightLines message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            NUsightLines.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lines != null && message.hasOwnProperty("lines")) {
                    if (!Array.isArray(message.lines))
                        return "lines: array expected";
                    for (var i = 0; i < message.lines.length; ++i) {
                        var error = $root.message.vision.Line.verify(message.lines[i]);
                        if (error)
                            return "lines." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a NUsightLines message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightLines} NUsightLines
             */
            NUsightLines.fromObject = function fromObject(object) {
                if (object instanceof $root.message.vision.NUsightLines)
                    return object;
                var message = new $root.message.vision.NUsightLines();
                if (object.lines) {
                    if (!Array.isArray(object.lines))
                        throw TypeError(".message.vision.NUsightLines.lines: array expected");
                    message.lines = [];
                    for (var i = 0; i < object.lines.length; ++i) {
                        if (typeof object.lines[i] !== "object")
                            throw TypeError(".message.vision.NUsightLines.lines: object expected");
                        message.lines[i] = $root.message.vision.Line.fromObject(object.lines[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a NUsightLines message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.NUsightLines.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightLines} NUsightLines
             */
            NUsightLines.from = NUsightLines.fromObject;

            /**
             * Creates a plain object from a NUsightLines message. Also converts values to other types if specified.
             * @param {message.vision.NUsightLines} message NUsightLines
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NUsightLines.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.lines = [];
                if (message.lines && message.lines.length) {
                    object.lines = [];
                    for (var j = 0; j < message.lines.length; ++j)
                        object.lines[j] = $root.message.vision.Line.toObject(message.lines[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this NUsightLines message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NUsightLines.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this NUsightLines to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            NUsightLines.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NUsightLines;
        })();

        return vision;
    })();

    return message;
})();

/**
 * PointerType enum.
 * @exports PointerType
 * @enum {number}
 * @property {number} NONE=0 NONE value
 * @property {number} RAW=1 RAW value
 * @property {number} SHARED=2 SHARED value
 * @property {number} UNIQUE=3 UNIQUE value
 */
$root.PointerType = (function() {
    var valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "NONE"] = 0;
    values[valuesById[1] = "RAW"] = 1;
    values[valuesById[2] = "SHARED"] = 2;
    values[valuesById[3] = "UNIQUE"] = 3;
    return values;
})();

module.exports = $root;
