import * as $protobuf from "protobufjs";

type mat$Properties = {
    rows?: number;
    cols?: number;
    v?: number[];
};

/**
 * Constructs a new mat.
 * @exports mat
 * @constructor
 * @param {mat$Properties=} [properties] Properties to set
 */
export class mat {

    /**
     * Constructs a new mat.
     * @exports mat
     * @constructor
     * @param {mat$Properties=} [properties] Properties to set
     */
    constructor(properties?: mat$Properties);

    /**
     * mat rows.
     * @type {number}
     */
    public rows: number;

    /**
     * mat cols.
     * @type {number}
     */
    public cols: number;

    /**
     * mat v.
     * @type {Array.<number>}
     */
    public v: number[];

    /**
     * Creates a new mat instance using the specified properties.
     * @param {mat$Properties=} [properties] Properties to set
     * @returns {mat} mat instance
     */
    public static create(properties?: mat$Properties): mat;

    /**
     * Encodes the specified mat message. Does not implicitly {@link mat.verify|verify} messages.
     * @param {mat$Properties} message mat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: mat$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified mat message, length delimited. Does not implicitly {@link mat.verify|verify} messages.
     * @param {mat$Properties} message mat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: mat$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a mat message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat} mat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): mat;

    /**
     * Decodes a mat message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {mat} mat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): mat;

    /**
     * Verifies a mat message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a mat message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {mat} mat
     */
    public static fromObject(object: { [k: string]: any }): mat;

    /**
     * Creates a mat message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link mat.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {mat} mat
     */
    public static from(object: { [k: string]: any }): mat;

    /**
     * Creates a plain object from a mat message. Also converts values to other types if specified.
     * @param {mat} message mat
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: mat, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this mat message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this mat to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type fmat$Properties = {
    rows?: number;
    cols?: number;
    v?: number[];
};

/**
 * Constructs a new fmat.
 * @exports fmat
 * @constructor
 * @param {fmat$Properties=} [properties] Properties to set
 */
export class fmat {

    /**
     * Constructs a new fmat.
     * @exports fmat
     * @constructor
     * @param {fmat$Properties=} [properties] Properties to set
     */
    constructor(properties?: fmat$Properties);

    /**
     * fmat rows.
     * @type {number}
     */
    public rows: number;

    /**
     * fmat cols.
     * @type {number}
     */
    public cols: number;

    /**
     * fmat v.
     * @type {Array.<number>}
     */
    public v: number[];

    /**
     * Creates a new fmat instance using the specified properties.
     * @param {fmat$Properties=} [properties] Properties to set
     * @returns {fmat} fmat instance
     */
    public static create(properties?: fmat$Properties): fmat;

    /**
     * Encodes the specified fmat message. Does not implicitly {@link fmat.verify|verify} messages.
     * @param {fmat$Properties} message fmat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: fmat$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified fmat message, length delimited. Does not implicitly {@link fmat.verify|verify} messages.
     * @param {fmat$Properties} message fmat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: fmat$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a fmat message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat} fmat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): fmat;

    /**
     * Decodes a fmat message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fmat} fmat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): fmat;

    /**
     * Verifies a fmat message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a fmat message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat} fmat
     */
    public static fromObject(object: { [k: string]: any }): fmat;

    /**
     * Creates a fmat message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fmat.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat} fmat
     */
    public static from(object: { [k: string]: any }): fmat;

    /**
     * Creates a plain object from a fmat message. Also converts values to other types if specified.
     * @param {fmat} message fmat
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: fmat, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this fmat message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this fmat to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type imat$Properties = {
    rows?: number;
    cols?: number;
    v?: number[];
};

/**
 * Constructs a new imat.
 * @exports imat
 * @constructor
 * @param {imat$Properties=} [properties] Properties to set
 */
export class imat {

    /**
     * Constructs a new imat.
     * @exports imat
     * @constructor
     * @param {imat$Properties=} [properties] Properties to set
     */
    constructor(properties?: imat$Properties);

    /**
     * imat rows.
     * @type {number}
     */
    public rows: number;

    /**
     * imat cols.
     * @type {number}
     */
    public cols: number;

    /**
     * imat v.
     * @type {Array.<number>}
     */
    public v: number[];

    /**
     * Creates a new imat instance using the specified properties.
     * @param {imat$Properties=} [properties] Properties to set
     * @returns {imat} imat instance
     */
    public static create(properties?: imat$Properties): imat;

    /**
     * Encodes the specified imat message. Does not implicitly {@link imat.verify|verify} messages.
     * @param {imat$Properties} message imat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: imat$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified imat message, length delimited. Does not implicitly {@link imat.verify|verify} messages.
     * @param {imat$Properties} message imat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: imat$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an imat message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat} imat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): imat;

    /**
     * Decodes an imat message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {imat} imat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): imat;

    /**
     * Verifies an imat message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an imat message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {imat} imat
     */
    public static fromObject(object: { [k: string]: any }): imat;

    /**
     * Creates an imat message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link imat.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {imat} imat
     */
    public static from(object: { [k: string]: any }): imat;

    /**
     * Creates a plain object from an imat message. Also converts values to other types if specified.
     * @param {imat} message imat
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: imat, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this imat message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this imat to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type umat$Properties = {
    rows?: number;
    cols?: number;
    v?: number[];
};

/**
 * Constructs a new umat.
 * @exports umat
 * @constructor
 * @param {umat$Properties=} [properties] Properties to set
 */
export class umat {

    /**
     * Constructs a new umat.
     * @exports umat
     * @constructor
     * @param {umat$Properties=} [properties] Properties to set
     */
    constructor(properties?: umat$Properties);

    /**
     * umat rows.
     * @type {number}
     */
    public rows: number;

    /**
     * umat cols.
     * @type {number}
     */
    public cols: number;

    /**
     * umat v.
     * @type {Array.<number>}
     */
    public v: number[];

    /**
     * Creates a new umat instance using the specified properties.
     * @param {umat$Properties=} [properties] Properties to set
     * @returns {umat} umat instance
     */
    public static create(properties?: umat$Properties): umat;

    /**
     * Encodes the specified umat message. Does not implicitly {@link umat.verify|verify} messages.
     * @param {umat$Properties} message umat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: umat$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified umat message, length delimited. Does not implicitly {@link umat.verify|verify} messages.
     * @param {umat$Properties} message umat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: umat$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an umat message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat} umat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): umat;

    /**
     * Decodes an umat message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {umat} umat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): umat;

    /**
     * Verifies an umat message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an umat message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {umat} umat
     */
    public static fromObject(object: { [k: string]: any }): umat;

    /**
     * Creates an umat message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link umat.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {umat} umat
     */
    public static from(object: { [k: string]: any }): umat;

    /**
     * Creates a plain object from an umat message. Also converts values to other types if specified.
     * @param {umat} message umat
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: umat, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this umat message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this umat to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type cmat$Properties = {
    rows?: number;
    cols?: number;
    v?: Uint8Array;
};

/**
 * Constructs a new cmat.
 * @exports cmat
 * @constructor
 * @param {cmat$Properties=} [properties] Properties to set
 */
export class cmat {

    /**
     * Constructs a new cmat.
     * @exports cmat
     * @constructor
     * @param {cmat$Properties=} [properties] Properties to set
     */
    constructor(properties?: cmat$Properties);

    /**
     * cmat rows.
     * @type {number}
     */
    public rows: number;

    /**
     * cmat cols.
     * @type {number}
     */
    public cols: number;

    /**
     * cmat v.
     * @type {Uint8Array}
     */
    public v: Uint8Array;

    /**
     * Creates a new cmat instance using the specified properties.
     * @param {cmat$Properties=} [properties] Properties to set
     * @returns {cmat} cmat instance
     */
    public static create(properties?: cmat$Properties): cmat;

    /**
     * Encodes the specified cmat message. Does not implicitly {@link cmat.verify|verify} messages.
     * @param {cmat$Properties} message cmat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: cmat$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified cmat message, length delimited. Does not implicitly {@link cmat.verify|verify} messages.
     * @param {cmat$Properties} message cmat message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: cmat$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a cmat message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {cmat} cmat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): cmat;

    /**
     * Decodes a cmat message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {cmat} cmat
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): cmat;

    /**
     * Verifies a cmat message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a cmat message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {cmat} cmat
     */
    public static fromObject(object: { [k: string]: any }): cmat;

    /**
     * Creates a cmat message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link cmat.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {cmat} cmat
     */
    public static from(object: { [k: string]: any }): cmat;

    /**
     * Creates a plain object from a cmat message. Also converts values to other types if specified.
     * @param {cmat} message cmat
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: cmat, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this cmat message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this cmat to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type mat22$Properties = {
    x?: vec2$Properties;
    y?: vec2$Properties;
};

/**
 * Constructs a new mat22.
 * @exports mat22
 * @constructor
 * @param {mat22$Properties=} [properties] Properties to set
 */
export class mat22 {

    /**
     * Constructs a new mat22.
     * @exports mat22
     * @constructor
     * @param {mat22$Properties=} [properties] Properties to set
     */
    constructor(properties?: mat22$Properties);

    /**
     * mat22 x.
     * @type {(vec2$Properties|null)}
     */
    public x: (vec2$Properties|null);

    /**
     * mat22 y.
     * @type {(vec2$Properties|null)}
     */
    public y: (vec2$Properties|null);

    /**
     * Creates a new mat22 instance using the specified properties.
     * @param {mat22$Properties=} [properties] Properties to set
     * @returns {mat22} mat22 instance
     */
    public static create(properties?: mat22$Properties): mat22;

    /**
     * Encodes the specified mat22 message. Does not implicitly {@link mat22.verify|verify} messages.
     * @param {mat22$Properties} message mat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: mat22$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified mat22 message, length delimited. Does not implicitly {@link mat22.verify|verify} messages.
     * @param {mat22$Properties} message mat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: mat22$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a mat22 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat22} mat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): mat22;

    /**
     * Decodes a mat22 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {mat22} mat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): mat22;

    /**
     * Verifies a mat22 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a mat22 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {mat22} mat22
     */
    public static fromObject(object: { [k: string]: any }): mat22;

    /**
     * Creates a mat22 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link mat22.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {mat22} mat22
     */
    public static from(object: { [k: string]: any }): mat22;

    /**
     * Creates a plain object from a mat22 message. Also converts values to other types if specified.
     * @param {mat22} message mat22
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: mat22, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this mat22 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this mat22 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type fmat22$Properties = {
    x?: fvec2$Properties;
    y?: fvec2$Properties;
};

/**
 * Constructs a new fmat22.
 * @exports fmat22
 * @constructor
 * @param {fmat22$Properties=} [properties] Properties to set
 */
export class fmat22 {

    /**
     * Constructs a new fmat22.
     * @exports fmat22
     * @constructor
     * @param {fmat22$Properties=} [properties] Properties to set
     */
    constructor(properties?: fmat22$Properties);

    /**
     * fmat22 x.
     * @type {(fvec2$Properties|null)}
     */
    public x: (fvec2$Properties|null);

    /**
     * fmat22 y.
     * @type {(fvec2$Properties|null)}
     */
    public y: (fvec2$Properties|null);

    /**
     * Creates a new fmat22 instance using the specified properties.
     * @param {fmat22$Properties=} [properties] Properties to set
     * @returns {fmat22} fmat22 instance
     */
    public static create(properties?: fmat22$Properties): fmat22;

    /**
     * Encodes the specified fmat22 message. Does not implicitly {@link fmat22.verify|verify} messages.
     * @param {fmat22$Properties} message fmat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: fmat22$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified fmat22 message, length delimited. Does not implicitly {@link fmat22.verify|verify} messages.
     * @param {fmat22$Properties} message fmat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: fmat22$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a fmat22 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat22} fmat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): fmat22;

    /**
     * Decodes a fmat22 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fmat22} fmat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): fmat22;

    /**
     * Verifies a fmat22 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a fmat22 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat22} fmat22
     */
    public static fromObject(object: { [k: string]: any }): fmat22;

    /**
     * Creates a fmat22 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fmat22.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat22} fmat22
     */
    public static from(object: { [k: string]: any }): fmat22;

    /**
     * Creates a plain object from a fmat22 message. Also converts values to other types if specified.
     * @param {fmat22} message fmat22
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: fmat22, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this fmat22 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this fmat22 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type imat22$Properties = {
    x?: ivec2$Properties;
    y?: ivec2$Properties;
};

/**
 * Constructs a new imat22.
 * @exports imat22
 * @constructor
 * @param {imat22$Properties=} [properties] Properties to set
 */
export class imat22 {

    /**
     * Constructs a new imat22.
     * @exports imat22
     * @constructor
     * @param {imat22$Properties=} [properties] Properties to set
     */
    constructor(properties?: imat22$Properties);

    /**
     * imat22 x.
     * @type {(ivec2$Properties|null)}
     */
    public x: (ivec2$Properties|null);

    /**
     * imat22 y.
     * @type {(ivec2$Properties|null)}
     */
    public y: (ivec2$Properties|null);

    /**
     * Creates a new imat22 instance using the specified properties.
     * @param {imat22$Properties=} [properties] Properties to set
     * @returns {imat22} imat22 instance
     */
    public static create(properties?: imat22$Properties): imat22;

    /**
     * Encodes the specified imat22 message. Does not implicitly {@link imat22.verify|verify} messages.
     * @param {imat22$Properties} message imat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: imat22$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified imat22 message, length delimited. Does not implicitly {@link imat22.verify|verify} messages.
     * @param {imat22$Properties} message imat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: imat22$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an imat22 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat22} imat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): imat22;

    /**
     * Decodes an imat22 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {imat22} imat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): imat22;

    /**
     * Verifies an imat22 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an imat22 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {imat22} imat22
     */
    public static fromObject(object: { [k: string]: any }): imat22;

    /**
     * Creates an imat22 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link imat22.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {imat22} imat22
     */
    public static from(object: { [k: string]: any }): imat22;

    /**
     * Creates a plain object from an imat22 message. Also converts values to other types if specified.
     * @param {imat22} message imat22
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: imat22, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this imat22 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this imat22 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type umat22$Properties = {
    x?: uvec2$Properties;
    y?: uvec2$Properties;
};

/**
 * Constructs a new umat22.
 * @exports umat22
 * @constructor
 * @param {umat22$Properties=} [properties] Properties to set
 */
export class umat22 {

    /**
     * Constructs a new umat22.
     * @exports umat22
     * @constructor
     * @param {umat22$Properties=} [properties] Properties to set
     */
    constructor(properties?: umat22$Properties);

    /**
     * umat22 x.
     * @type {(uvec2$Properties|null)}
     */
    public x: (uvec2$Properties|null);

    /**
     * umat22 y.
     * @type {(uvec2$Properties|null)}
     */
    public y: (uvec2$Properties|null);

    /**
     * Creates a new umat22 instance using the specified properties.
     * @param {umat22$Properties=} [properties] Properties to set
     * @returns {umat22} umat22 instance
     */
    public static create(properties?: umat22$Properties): umat22;

    /**
     * Encodes the specified umat22 message. Does not implicitly {@link umat22.verify|verify} messages.
     * @param {umat22$Properties} message umat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: umat22$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified umat22 message, length delimited. Does not implicitly {@link umat22.verify|verify} messages.
     * @param {umat22$Properties} message umat22 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: umat22$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an umat22 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat22} umat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): umat22;

    /**
     * Decodes an umat22 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {umat22} umat22
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): umat22;

    /**
     * Verifies an umat22 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an umat22 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {umat22} umat22
     */
    public static fromObject(object: { [k: string]: any }): umat22;

    /**
     * Creates an umat22 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link umat22.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {umat22} umat22
     */
    public static from(object: { [k: string]: any }): umat22;

    /**
     * Creates a plain object from an umat22 message. Also converts values to other types if specified.
     * @param {umat22} message umat22
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: umat22, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this umat22 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this umat22 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type mat33$Properties = {
    x?: vec3$Properties;
    y?: vec3$Properties;
    z?: vec3$Properties;
};

/**
 * Constructs a new mat33.
 * @exports mat33
 * @constructor
 * @param {mat33$Properties=} [properties] Properties to set
 */
export class mat33 {

    /**
     * Constructs a new mat33.
     * @exports mat33
     * @constructor
     * @param {mat33$Properties=} [properties] Properties to set
     */
    constructor(properties?: mat33$Properties);

    /**
     * mat33 x.
     * @type {(vec3$Properties|null)}
     */
    public x: (vec3$Properties|null);

    /**
     * mat33 y.
     * @type {(vec3$Properties|null)}
     */
    public y: (vec3$Properties|null);

    /**
     * mat33 z.
     * @type {(vec3$Properties|null)}
     */
    public z: (vec3$Properties|null);

    /**
     * Creates a new mat33 instance using the specified properties.
     * @param {mat33$Properties=} [properties] Properties to set
     * @returns {mat33} mat33 instance
     */
    public static create(properties?: mat33$Properties): mat33;

    /**
     * Encodes the specified mat33 message. Does not implicitly {@link mat33.verify|verify} messages.
     * @param {mat33$Properties} message mat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: mat33$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified mat33 message, length delimited. Does not implicitly {@link mat33.verify|verify} messages.
     * @param {mat33$Properties} message mat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: mat33$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a mat33 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat33} mat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): mat33;

    /**
     * Decodes a mat33 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {mat33} mat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): mat33;

    /**
     * Verifies a mat33 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a mat33 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {mat33} mat33
     */
    public static fromObject(object: { [k: string]: any }): mat33;

    /**
     * Creates a mat33 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link mat33.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {mat33} mat33
     */
    public static from(object: { [k: string]: any }): mat33;

    /**
     * Creates a plain object from a mat33 message. Also converts values to other types if specified.
     * @param {mat33} message mat33
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: mat33, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this mat33 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this mat33 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type fmat33$Properties = {
    x?: fvec3$Properties;
    y?: fvec3$Properties;
    z?: fvec3$Properties;
};

/**
 * Constructs a new fmat33.
 * @exports fmat33
 * @constructor
 * @param {fmat33$Properties=} [properties] Properties to set
 */
export class fmat33 {

    /**
     * Constructs a new fmat33.
     * @exports fmat33
     * @constructor
     * @param {fmat33$Properties=} [properties] Properties to set
     */
    constructor(properties?: fmat33$Properties);

    /**
     * fmat33 x.
     * @type {(fvec3$Properties|null)}
     */
    public x: (fvec3$Properties|null);

    /**
     * fmat33 y.
     * @type {(fvec3$Properties|null)}
     */
    public y: (fvec3$Properties|null);

    /**
     * fmat33 z.
     * @type {(fvec3$Properties|null)}
     */
    public z: (fvec3$Properties|null);

    /**
     * Creates a new fmat33 instance using the specified properties.
     * @param {fmat33$Properties=} [properties] Properties to set
     * @returns {fmat33} fmat33 instance
     */
    public static create(properties?: fmat33$Properties): fmat33;

    /**
     * Encodes the specified fmat33 message. Does not implicitly {@link fmat33.verify|verify} messages.
     * @param {fmat33$Properties} message fmat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: fmat33$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified fmat33 message, length delimited. Does not implicitly {@link fmat33.verify|verify} messages.
     * @param {fmat33$Properties} message fmat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: fmat33$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a fmat33 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat33} fmat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): fmat33;

    /**
     * Decodes a fmat33 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fmat33} fmat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): fmat33;

    /**
     * Verifies a fmat33 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a fmat33 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat33} fmat33
     */
    public static fromObject(object: { [k: string]: any }): fmat33;

    /**
     * Creates a fmat33 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fmat33.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat33} fmat33
     */
    public static from(object: { [k: string]: any }): fmat33;

    /**
     * Creates a plain object from a fmat33 message. Also converts values to other types if specified.
     * @param {fmat33} message fmat33
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: fmat33, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this fmat33 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this fmat33 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type imat33$Properties = {
    x?: ivec3$Properties;
    y?: ivec3$Properties;
    z?: ivec3$Properties;
};

/**
 * Constructs a new imat33.
 * @exports imat33
 * @constructor
 * @param {imat33$Properties=} [properties] Properties to set
 */
export class imat33 {

    /**
     * Constructs a new imat33.
     * @exports imat33
     * @constructor
     * @param {imat33$Properties=} [properties] Properties to set
     */
    constructor(properties?: imat33$Properties);

    /**
     * imat33 x.
     * @type {(ivec3$Properties|null)}
     */
    public x: (ivec3$Properties|null);

    /**
     * imat33 y.
     * @type {(ivec3$Properties|null)}
     */
    public y: (ivec3$Properties|null);

    /**
     * imat33 z.
     * @type {(ivec3$Properties|null)}
     */
    public z: (ivec3$Properties|null);

    /**
     * Creates a new imat33 instance using the specified properties.
     * @param {imat33$Properties=} [properties] Properties to set
     * @returns {imat33} imat33 instance
     */
    public static create(properties?: imat33$Properties): imat33;

    /**
     * Encodes the specified imat33 message. Does not implicitly {@link imat33.verify|verify} messages.
     * @param {imat33$Properties} message imat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: imat33$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified imat33 message, length delimited. Does not implicitly {@link imat33.verify|verify} messages.
     * @param {imat33$Properties} message imat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: imat33$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an imat33 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat33} imat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): imat33;

    /**
     * Decodes an imat33 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {imat33} imat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): imat33;

    /**
     * Verifies an imat33 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an imat33 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {imat33} imat33
     */
    public static fromObject(object: { [k: string]: any }): imat33;

    /**
     * Creates an imat33 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link imat33.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {imat33} imat33
     */
    public static from(object: { [k: string]: any }): imat33;

    /**
     * Creates a plain object from an imat33 message. Also converts values to other types if specified.
     * @param {imat33} message imat33
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: imat33, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this imat33 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this imat33 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type umat33$Properties = {
    x?: uvec3$Properties;
    y?: uvec3$Properties;
    z?: uvec3$Properties;
};

/**
 * Constructs a new umat33.
 * @exports umat33
 * @constructor
 * @param {umat33$Properties=} [properties] Properties to set
 */
export class umat33 {

    /**
     * Constructs a new umat33.
     * @exports umat33
     * @constructor
     * @param {umat33$Properties=} [properties] Properties to set
     */
    constructor(properties?: umat33$Properties);

    /**
     * umat33 x.
     * @type {(uvec3$Properties|null)}
     */
    public x: (uvec3$Properties|null);

    /**
     * umat33 y.
     * @type {(uvec3$Properties|null)}
     */
    public y: (uvec3$Properties|null);

    /**
     * umat33 z.
     * @type {(uvec3$Properties|null)}
     */
    public z: (uvec3$Properties|null);

    /**
     * Creates a new umat33 instance using the specified properties.
     * @param {umat33$Properties=} [properties] Properties to set
     * @returns {umat33} umat33 instance
     */
    public static create(properties?: umat33$Properties): umat33;

    /**
     * Encodes the specified umat33 message. Does not implicitly {@link umat33.verify|verify} messages.
     * @param {umat33$Properties} message umat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: umat33$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified umat33 message, length delimited. Does not implicitly {@link umat33.verify|verify} messages.
     * @param {umat33$Properties} message umat33 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: umat33$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an umat33 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat33} umat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): umat33;

    /**
     * Decodes an umat33 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {umat33} umat33
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): umat33;

    /**
     * Verifies an umat33 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an umat33 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {umat33} umat33
     */
    public static fromObject(object: { [k: string]: any }): umat33;

    /**
     * Creates an umat33 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link umat33.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {umat33} umat33
     */
    public static from(object: { [k: string]: any }): umat33;

    /**
     * Creates a plain object from an umat33 message. Also converts values to other types if specified.
     * @param {umat33} message umat33
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: umat33, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this umat33 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this umat33 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type mat44$Properties = {
    x?: vec4$Properties;
    y?: vec4$Properties;
    z?: vec4$Properties;
    t?: vec4$Properties;
};

/**
 * Constructs a new mat44.
 * @exports mat44
 * @constructor
 * @param {mat44$Properties=} [properties] Properties to set
 */
export class mat44 {

    /**
     * Constructs a new mat44.
     * @exports mat44
     * @constructor
     * @param {mat44$Properties=} [properties] Properties to set
     */
    constructor(properties?: mat44$Properties);

    /**
     * mat44 x.
     * @type {(vec4$Properties|null)}
     */
    public x: (vec4$Properties|null);

    /**
     * mat44 y.
     * @type {(vec4$Properties|null)}
     */
    public y: (vec4$Properties|null);

    /**
     * mat44 z.
     * @type {(vec4$Properties|null)}
     */
    public z: (vec4$Properties|null);

    /**
     * mat44 t.
     * @type {(vec4$Properties|null)}
     */
    public t: (vec4$Properties|null);

    /**
     * Creates a new mat44 instance using the specified properties.
     * @param {mat44$Properties=} [properties] Properties to set
     * @returns {mat44} mat44 instance
     */
    public static create(properties?: mat44$Properties): mat44;

    /**
     * Encodes the specified mat44 message. Does not implicitly {@link mat44.verify|verify} messages.
     * @param {mat44$Properties} message mat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: mat44$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified mat44 message, length delimited. Does not implicitly {@link mat44.verify|verify} messages.
     * @param {mat44$Properties} message mat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: mat44$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a mat44 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {mat44} mat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): mat44;

    /**
     * Decodes a mat44 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {mat44} mat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): mat44;

    /**
     * Verifies a mat44 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a mat44 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {mat44} mat44
     */
    public static fromObject(object: { [k: string]: any }): mat44;

    /**
     * Creates a mat44 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link mat44.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {mat44} mat44
     */
    public static from(object: { [k: string]: any }): mat44;

    /**
     * Creates a plain object from a mat44 message. Also converts values to other types if specified.
     * @param {mat44} message mat44
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: mat44, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this mat44 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this mat44 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type fmat44$Properties = {
    x?: fvec4$Properties;
    y?: fvec4$Properties;
    z?: fvec4$Properties;
    t?: fvec4$Properties;
};

/**
 * Constructs a new fmat44.
 * @exports fmat44
 * @constructor
 * @param {fmat44$Properties=} [properties] Properties to set
 */
export class fmat44 {

    /**
     * Constructs a new fmat44.
     * @exports fmat44
     * @constructor
     * @param {fmat44$Properties=} [properties] Properties to set
     */
    constructor(properties?: fmat44$Properties);

    /**
     * fmat44 x.
     * @type {(fvec4$Properties|null)}
     */
    public x: (fvec4$Properties|null);

    /**
     * fmat44 y.
     * @type {(fvec4$Properties|null)}
     */
    public y: (fvec4$Properties|null);

    /**
     * fmat44 z.
     * @type {(fvec4$Properties|null)}
     */
    public z: (fvec4$Properties|null);

    /**
     * fmat44 t.
     * @type {(fvec4$Properties|null)}
     */
    public t: (fvec4$Properties|null);

    /**
     * Creates a new fmat44 instance using the specified properties.
     * @param {fmat44$Properties=} [properties] Properties to set
     * @returns {fmat44} fmat44 instance
     */
    public static create(properties?: fmat44$Properties): fmat44;

    /**
     * Encodes the specified fmat44 message. Does not implicitly {@link fmat44.verify|verify} messages.
     * @param {fmat44$Properties} message fmat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: fmat44$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified fmat44 message, length delimited. Does not implicitly {@link fmat44.verify|verify} messages.
     * @param {fmat44$Properties} message fmat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: fmat44$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a fmat44 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fmat44} fmat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): fmat44;

    /**
     * Decodes a fmat44 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fmat44} fmat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): fmat44;

    /**
     * Verifies a fmat44 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a fmat44 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat44} fmat44
     */
    public static fromObject(object: { [k: string]: any }): fmat44;

    /**
     * Creates a fmat44 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fmat44.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fmat44} fmat44
     */
    public static from(object: { [k: string]: any }): fmat44;

    /**
     * Creates a plain object from a fmat44 message. Also converts values to other types if specified.
     * @param {fmat44} message fmat44
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: fmat44, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this fmat44 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this fmat44 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type imat44$Properties = {
    x?: ivec4$Properties;
    y?: ivec4$Properties;
    z?: ivec4$Properties;
    t?: ivec4$Properties;
};

/**
 * Constructs a new imat44.
 * @exports imat44
 * @constructor
 * @param {imat44$Properties=} [properties] Properties to set
 */
export class imat44 {

    /**
     * Constructs a new imat44.
     * @exports imat44
     * @constructor
     * @param {imat44$Properties=} [properties] Properties to set
     */
    constructor(properties?: imat44$Properties);

    /**
     * imat44 x.
     * @type {(ivec4$Properties|null)}
     */
    public x: (ivec4$Properties|null);

    /**
     * imat44 y.
     * @type {(ivec4$Properties|null)}
     */
    public y: (ivec4$Properties|null);

    /**
     * imat44 z.
     * @type {(ivec4$Properties|null)}
     */
    public z: (ivec4$Properties|null);

    /**
     * imat44 t.
     * @type {(ivec4$Properties|null)}
     */
    public t: (ivec4$Properties|null);

    /**
     * Creates a new imat44 instance using the specified properties.
     * @param {imat44$Properties=} [properties] Properties to set
     * @returns {imat44} imat44 instance
     */
    public static create(properties?: imat44$Properties): imat44;

    /**
     * Encodes the specified imat44 message. Does not implicitly {@link imat44.verify|verify} messages.
     * @param {imat44$Properties} message imat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: imat44$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified imat44 message, length delimited. Does not implicitly {@link imat44.verify|verify} messages.
     * @param {imat44$Properties} message imat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: imat44$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an imat44 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {imat44} imat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): imat44;

    /**
     * Decodes an imat44 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {imat44} imat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): imat44;

    /**
     * Verifies an imat44 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an imat44 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {imat44} imat44
     */
    public static fromObject(object: { [k: string]: any }): imat44;

    /**
     * Creates an imat44 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link imat44.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {imat44} imat44
     */
    public static from(object: { [k: string]: any }): imat44;

    /**
     * Creates a plain object from an imat44 message. Also converts values to other types if specified.
     * @param {imat44} message imat44
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: imat44, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this imat44 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this imat44 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type umat44$Properties = {
    x?: uvec4$Properties;
    y?: uvec4$Properties;
    z?: uvec4$Properties;
    t?: uvec4$Properties;
};

/**
 * Constructs a new umat44.
 * @exports umat44
 * @constructor
 * @param {umat44$Properties=} [properties] Properties to set
 */
export class umat44 {

    /**
     * Constructs a new umat44.
     * @exports umat44
     * @constructor
     * @param {umat44$Properties=} [properties] Properties to set
     */
    constructor(properties?: umat44$Properties);

    /**
     * umat44 x.
     * @type {(uvec4$Properties|null)}
     */
    public x: (uvec4$Properties|null);

    /**
     * umat44 y.
     * @type {(uvec4$Properties|null)}
     */
    public y: (uvec4$Properties|null);

    /**
     * umat44 z.
     * @type {(uvec4$Properties|null)}
     */
    public z: (uvec4$Properties|null);

    /**
     * umat44 t.
     * @type {(uvec4$Properties|null)}
     */
    public t: (uvec4$Properties|null);

    /**
     * Creates a new umat44 instance using the specified properties.
     * @param {umat44$Properties=} [properties] Properties to set
     * @returns {umat44} umat44 instance
     */
    public static create(properties?: umat44$Properties): umat44;

    /**
     * Encodes the specified umat44 message. Does not implicitly {@link umat44.verify|verify} messages.
     * @param {umat44$Properties} message umat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: umat44$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified umat44 message, length delimited. Does not implicitly {@link umat44.verify|verify} messages.
     * @param {umat44$Properties} message umat44 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: umat44$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an umat44 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {umat44} umat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): umat44;

    /**
     * Decodes an umat44 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {umat44} umat44
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): umat44;

    /**
     * Verifies an umat44 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an umat44 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {umat44} umat44
     */
    public static fromObject(object: { [k: string]: any }): umat44;

    /**
     * Creates an umat44 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link umat44.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {umat44} umat44
     */
    public static from(object: { [k: string]: any }): umat44;

    /**
     * Creates a plain object from an umat44 message. Also converts values to other types if specified.
     * @param {umat44} message umat44
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: umat44, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this umat44 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this umat44 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type vec$Properties = {
    v?: number[];
};

/**
 * Constructs a new vec.
 * @exports vec
 * @constructor
 * @param {vec$Properties=} [properties] Properties to set
 */
export class vec {

    /**
     * Constructs a new vec.
     * @exports vec
     * @constructor
     * @param {vec$Properties=} [properties] Properties to set
     */
    constructor(properties?: vec$Properties);

    /**
     * vec v.
     * @type {Array.<number>}
     */
    public v: number[];

    /**
     * Creates a new vec instance using the specified properties.
     * @param {vec$Properties=} [properties] Properties to set
     * @returns {vec} vec instance
     */
    public static create(properties?: vec$Properties): vec;

    /**
     * Encodes the specified vec message. Does not implicitly {@link vec.verify|verify} messages.
     * @param {vec$Properties} message vec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: vec$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified vec message, length delimited. Does not implicitly {@link vec.verify|verify} messages.
     * @param {vec$Properties} message vec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: vec$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a vec message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec} vec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): vec;

    /**
     * Decodes a vec message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {vec} vec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): vec;

    /**
     * Verifies a vec message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a vec message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {vec} vec
     */
    public static fromObject(object: { [k: string]: any }): vec;

    /**
     * Creates a vec message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link vec.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {vec} vec
     */
    public static from(object: { [k: string]: any }): vec;

    /**
     * Creates a plain object from a vec message. Also converts values to other types if specified.
     * @param {vec} message vec
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: vec, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this vec message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this vec to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type fvec$Properties = {
    v?: number[];
};

/**
 * Constructs a new fvec.
 * @exports fvec
 * @constructor
 * @param {fvec$Properties=} [properties] Properties to set
 */
export class fvec {

    /**
     * Constructs a new fvec.
     * @exports fvec
     * @constructor
     * @param {fvec$Properties=} [properties] Properties to set
     */
    constructor(properties?: fvec$Properties);

    /**
     * fvec v.
     * @type {Array.<number>}
     */
    public v: number[];

    /**
     * Creates a new fvec instance using the specified properties.
     * @param {fvec$Properties=} [properties] Properties to set
     * @returns {fvec} fvec instance
     */
    public static create(properties?: fvec$Properties): fvec;

    /**
     * Encodes the specified fvec message. Does not implicitly {@link fvec.verify|verify} messages.
     * @param {fvec$Properties} message fvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: fvec$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified fvec message, length delimited. Does not implicitly {@link fvec.verify|verify} messages.
     * @param {fvec$Properties} message fvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: fvec$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a fvec message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec} fvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): fvec;

    /**
     * Decodes a fvec message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fvec} fvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): fvec;

    /**
     * Verifies a fvec message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a fvec message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec} fvec
     */
    public static fromObject(object: { [k: string]: any }): fvec;

    /**
     * Creates a fvec message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fvec.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec} fvec
     */
    public static from(object: { [k: string]: any }): fvec;

    /**
     * Creates a plain object from a fvec message. Also converts values to other types if specified.
     * @param {fvec} message fvec
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: fvec, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this fvec message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this fvec to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type ivec$Properties = {
    v?: number[];
};

/**
 * Constructs a new ivec.
 * @exports ivec
 * @constructor
 * @param {ivec$Properties=} [properties] Properties to set
 */
export class ivec {

    /**
     * Constructs a new ivec.
     * @exports ivec
     * @constructor
     * @param {ivec$Properties=} [properties] Properties to set
     */
    constructor(properties?: ivec$Properties);

    /**
     * ivec v.
     * @type {Array.<number>}
     */
    public v: number[];

    /**
     * Creates a new ivec instance using the specified properties.
     * @param {ivec$Properties=} [properties] Properties to set
     * @returns {ivec} ivec instance
     */
    public static create(properties?: ivec$Properties): ivec;

    /**
     * Encodes the specified ivec message. Does not implicitly {@link ivec.verify|verify} messages.
     * @param {ivec$Properties} message ivec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: ivec$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified ivec message, length delimited. Does not implicitly {@link ivec.verify|verify} messages.
     * @param {ivec$Properties} message ivec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: ivec$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an ivec message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec} ivec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ivec;

    /**
     * Decodes an ivec message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ivec} ivec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ivec;

    /**
     * Verifies an ivec message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an ivec message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec} ivec
     */
    public static fromObject(object: { [k: string]: any }): ivec;

    /**
     * Creates an ivec message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link ivec.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec} ivec
     */
    public static from(object: { [k: string]: any }): ivec;

    /**
     * Creates a plain object from an ivec message. Also converts values to other types if specified.
     * @param {ivec} message ivec
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: ivec, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this ivec message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this ivec to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type uvec$Properties = {
    v?: number[];
};

/**
 * Constructs a new uvec.
 * @exports uvec
 * @constructor
 * @param {uvec$Properties=} [properties] Properties to set
 */
export class uvec {

    /**
     * Constructs a new uvec.
     * @exports uvec
     * @constructor
     * @param {uvec$Properties=} [properties] Properties to set
     */
    constructor(properties?: uvec$Properties);

    /**
     * uvec v.
     * @type {Array.<number>}
     */
    public v: number[];

    /**
     * Creates a new uvec instance using the specified properties.
     * @param {uvec$Properties=} [properties] Properties to set
     * @returns {uvec} uvec instance
     */
    public static create(properties?: uvec$Properties): uvec;

    /**
     * Encodes the specified uvec message. Does not implicitly {@link uvec.verify|verify} messages.
     * @param {uvec$Properties} message uvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: uvec$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified uvec message, length delimited. Does not implicitly {@link uvec.verify|verify} messages.
     * @param {uvec$Properties} message uvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: uvec$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an uvec message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec} uvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): uvec;

    /**
     * Decodes an uvec message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {uvec} uvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): uvec;

    /**
     * Verifies an uvec message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an uvec message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec} uvec
     */
    public static fromObject(object: { [k: string]: any }): uvec;

    /**
     * Creates an uvec message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link uvec.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec} uvec
     */
    public static from(object: { [k: string]: any }): uvec;

    /**
     * Creates a plain object from an uvec message. Also converts values to other types if specified.
     * @param {uvec} message uvec
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: uvec, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this uvec message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this uvec to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type cvec$Properties = {
    v?: Uint8Array;
};

/**
 * Constructs a new cvec.
 * @exports cvec
 * @constructor
 * @param {cvec$Properties=} [properties] Properties to set
 */
export class cvec {

    /**
     * Constructs a new cvec.
     * @exports cvec
     * @constructor
     * @param {cvec$Properties=} [properties] Properties to set
     */
    constructor(properties?: cvec$Properties);

    /**
     * cvec v.
     * @type {Uint8Array}
     */
    public v: Uint8Array;

    /**
     * Creates a new cvec instance using the specified properties.
     * @param {cvec$Properties=} [properties] Properties to set
     * @returns {cvec} cvec instance
     */
    public static create(properties?: cvec$Properties): cvec;

    /**
     * Encodes the specified cvec message. Does not implicitly {@link cvec.verify|verify} messages.
     * @param {cvec$Properties} message cvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: cvec$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified cvec message, length delimited. Does not implicitly {@link cvec.verify|verify} messages.
     * @param {cvec$Properties} message cvec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: cvec$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a cvec message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {cvec} cvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): cvec;

    /**
     * Decodes a cvec message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {cvec} cvec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): cvec;

    /**
     * Verifies a cvec message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a cvec message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {cvec} cvec
     */
    public static fromObject(object: { [k: string]: any }): cvec;

    /**
     * Creates a cvec message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link cvec.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {cvec} cvec
     */
    public static from(object: { [k: string]: any }): cvec;

    /**
     * Creates a plain object from a cvec message. Also converts values to other types if specified.
     * @param {cvec} message cvec
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: cvec, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this cvec message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this cvec to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type vec2$Properties = {
    x?: number;
    y?: number;
};

/**
 * Constructs a new vec2.
 * @exports vec2
 * @constructor
 * @param {vec2$Properties=} [properties] Properties to set
 */
export class vec2 {

    /**
     * Constructs a new vec2.
     * @exports vec2
     * @constructor
     * @param {vec2$Properties=} [properties] Properties to set
     */
    constructor(properties?: vec2$Properties);

    /**
     * vec2 x.
     * @type {number}
     */
    public x: number;

    /**
     * vec2 y.
     * @type {number}
     */
    public y: number;

    /**
     * Creates a new vec2 instance using the specified properties.
     * @param {vec2$Properties=} [properties] Properties to set
     * @returns {vec2} vec2 instance
     */
    public static create(properties?: vec2$Properties): vec2;

    /**
     * Encodes the specified vec2 message. Does not implicitly {@link vec2.verify|verify} messages.
     * @param {vec2$Properties} message vec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: vec2$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified vec2 message, length delimited. Does not implicitly {@link vec2.verify|verify} messages.
     * @param {vec2$Properties} message vec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: vec2$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a vec2 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec2} vec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): vec2;

    /**
     * Decodes a vec2 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {vec2} vec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): vec2;

    /**
     * Verifies a vec2 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a vec2 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {vec2} vec2
     */
    public static fromObject(object: { [k: string]: any }): vec2;

    /**
     * Creates a vec2 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link vec2.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {vec2} vec2
     */
    public static from(object: { [k: string]: any }): vec2;

    /**
     * Creates a plain object from a vec2 message. Also converts values to other types if specified.
     * @param {vec2} message vec2
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: vec2, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this vec2 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this vec2 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type fvec2$Properties = {
    x?: number;
    y?: number;
};

/**
 * Constructs a new fvec2.
 * @exports fvec2
 * @constructor
 * @param {fvec2$Properties=} [properties] Properties to set
 */
export class fvec2 {

    /**
     * Constructs a new fvec2.
     * @exports fvec2
     * @constructor
     * @param {fvec2$Properties=} [properties] Properties to set
     */
    constructor(properties?: fvec2$Properties);

    /**
     * fvec2 x.
     * @type {number}
     */
    public x: number;

    /**
     * fvec2 y.
     * @type {number}
     */
    public y: number;

    /**
     * Creates a new fvec2 instance using the specified properties.
     * @param {fvec2$Properties=} [properties] Properties to set
     * @returns {fvec2} fvec2 instance
     */
    public static create(properties?: fvec2$Properties): fvec2;

    /**
     * Encodes the specified fvec2 message. Does not implicitly {@link fvec2.verify|verify} messages.
     * @param {fvec2$Properties} message fvec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: fvec2$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified fvec2 message, length delimited. Does not implicitly {@link fvec2.verify|verify} messages.
     * @param {fvec2$Properties} message fvec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: fvec2$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a fvec2 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec2} fvec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): fvec2;

    /**
     * Decodes a fvec2 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fvec2} fvec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): fvec2;

    /**
     * Verifies a fvec2 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a fvec2 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec2} fvec2
     */
    public static fromObject(object: { [k: string]: any }): fvec2;

    /**
     * Creates a fvec2 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fvec2.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec2} fvec2
     */
    public static from(object: { [k: string]: any }): fvec2;

    /**
     * Creates a plain object from a fvec2 message. Also converts values to other types if specified.
     * @param {fvec2} message fvec2
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: fvec2, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this fvec2 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this fvec2 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type ivec2$Properties = {
    x?: number;
    y?: number;
};

/**
 * Constructs a new ivec2.
 * @exports ivec2
 * @constructor
 * @param {ivec2$Properties=} [properties] Properties to set
 */
export class ivec2 {

    /**
     * Constructs a new ivec2.
     * @exports ivec2
     * @constructor
     * @param {ivec2$Properties=} [properties] Properties to set
     */
    constructor(properties?: ivec2$Properties);

    /**
     * ivec2 x.
     * @type {number}
     */
    public x: number;

    /**
     * ivec2 y.
     * @type {number}
     */
    public y: number;

    /**
     * Creates a new ivec2 instance using the specified properties.
     * @param {ivec2$Properties=} [properties] Properties to set
     * @returns {ivec2} ivec2 instance
     */
    public static create(properties?: ivec2$Properties): ivec2;

    /**
     * Encodes the specified ivec2 message. Does not implicitly {@link ivec2.verify|verify} messages.
     * @param {ivec2$Properties} message ivec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: ivec2$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified ivec2 message, length delimited. Does not implicitly {@link ivec2.verify|verify} messages.
     * @param {ivec2$Properties} message ivec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: ivec2$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an ivec2 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec2} ivec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ivec2;

    /**
     * Decodes an ivec2 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ivec2} ivec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ivec2;

    /**
     * Verifies an ivec2 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an ivec2 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec2} ivec2
     */
    public static fromObject(object: { [k: string]: any }): ivec2;

    /**
     * Creates an ivec2 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link ivec2.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec2} ivec2
     */
    public static from(object: { [k: string]: any }): ivec2;

    /**
     * Creates a plain object from an ivec2 message. Also converts values to other types if specified.
     * @param {ivec2} message ivec2
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: ivec2, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this ivec2 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this ivec2 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type uvec2$Properties = {
    x?: number;
    y?: number;
};

/**
 * Constructs a new uvec2.
 * @exports uvec2
 * @constructor
 * @param {uvec2$Properties=} [properties] Properties to set
 */
export class uvec2 {

    /**
     * Constructs a new uvec2.
     * @exports uvec2
     * @constructor
     * @param {uvec2$Properties=} [properties] Properties to set
     */
    constructor(properties?: uvec2$Properties);

    /**
     * uvec2 x.
     * @type {number}
     */
    public x: number;

    /**
     * uvec2 y.
     * @type {number}
     */
    public y: number;

    /**
     * Creates a new uvec2 instance using the specified properties.
     * @param {uvec2$Properties=} [properties] Properties to set
     * @returns {uvec2} uvec2 instance
     */
    public static create(properties?: uvec2$Properties): uvec2;

    /**
     * Encodes the specified uvec2 message. Does not implicitly {@link uvec2.verify|verify} messages.
     * @param {uvec2$Properties} message uvec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: uvec2$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified uvec2 message, length delimited. Does not implicitly {@link uvec2.verify|verify} messages.
     * @param {uvec2$Properties} message uvec2 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: uvec2$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an uvec2 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec2} uvec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): uvec2;

    /**
     * Decodes an uvec2 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {uvec2} uvec2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): uvec2;

    /**
     * Verifies an uvec2 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an uvec2 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec2} uvec2
     */
    public static fromObject(object: { [k: string]: any }): uvec2;

    /**
     * Creates an uvec2 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link uvec2.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec2} uvec2
     */
    public static from(object: { [k: string]: any }): uvec2;

    /**
     * Creates a plain object from an uvec2 message. Also converts values to other types if specified.
     * @param {uvec2} message uvec2
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: uvec2, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this uvec2 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this uvec2 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type vec3$Properties = {
    x?: number;
    y?: number;
    z?: number;
};

/**
 * Constructs a new vec3.
 * @exports vec3
 * @constructor
 * @param {vec3$Properties=} [properties] Properties to set
 */
export class vec3 {

    /**
     * Constructs a new vec3.
     * @exports vec3
     * @constructor
     * @param {vec3$Properties=} [properties] Properties to set
     */
    constructor(properties?: vec3$Properties);

    /**
     * vec3 x.
     * @type {number}
     */
    public x: number;

    /**
     * vec3 y.
     * @type {number}
     */
    public y: number;

    /**
     * vec3 z.
     * @type {number}
     */
    public z: number;

    /**
     * Creates a new vec3 instance using the specified properties.
     * @param {vec3$Properties=} [properties] Properties to set
     * @returns {vec3} vec3 instance
     */
    public static create(properties?: vec3$Properties): vec3;

    /**
     * Encodes the specified vec3 message. Does not implicitly {@link vec3.verify|verify} messages.
     * @param {vec3$Properties} message vec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: vec3$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified vec3 message, length delimited. Does not implicitly {@link vec3.verify|verify} messages.
     * @param {vec3$Properties} message vec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: vec3$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a vec3 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec3} vec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): vec3;

    /**
     * Decodes a vec3 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {vec3} vec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): vec3;

    /**
     * Verifies a vec3 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a vec3 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {vec3} vec3
     */
    public static fromObject(object: { [k: string]: any }): vec3;

    /**
     * Creates a vec3 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link vec3.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {vec3} vec3
     */
    public static from(object: { [k: string]: any }): vec3;

    /**
     * Creates a plain object from a vec3 message. Also converts values to other types if specified.
     * @param {vec3} message vec3
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: vec3, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this vec3 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this vec3 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type fvec3$Properties = {
    x?: number;
    y?: number;
    z?: number;
};

/**
 * Constructs a new fvec3.
 * @exports fvec3
 * @constructor
 * @param {fvec3$Properties=} [properties] Properties to set
 */
export class fvec3 {

    /**
     * Constructs a new fvec3.
     * @exports fvec3
     * @constructor
     * @param {fvec3$Properties=} [properties] Properties to set
     */
    constructor(properties?: fvec3$Properties);

    /**
     * fvec3 x.
     * @type {number}
     */
    public x: number;

    /**
     * fvec3 y.
     * @type {number}
     */
    public y: number;

    /**
     * fvec3 z.
     * @type {number}
     */
    public z: number;

    /**
     * Creates a new fvec3 instance using the specified properties.
     * @param {fvec3$Properties=} [properties] Properties to set
     * @returns {fvec3} fvec3 instance
     */
    public static create(properties?: fvec3$Properties): fvec3;

    /**
     * Encodes the specified fvec3 message. Does not implicitly {@link fvec3.verify|verify} messages.
     * @param {fvec3$Properties} message fvec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: fvec3$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified fvec3 message, length delimited. Does not implicitly {@link fvec3.verify|verify} messages.
     * @param {fvec3$Properties} message fvec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: fvec3$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a fvec3 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec3} fvec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): fvec3;

    /**
     * Decodes a fvec3 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fvec3} fvec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): fvec3;

    /**
     * Verifies a fvec3 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a fvec3 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec3} fvec3
     */
    public static fromObject(object: { [k: string]: any }): fvec3;

    /**
     * Creates a fvec3 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fvec3.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec3} fvec3
     */
    public static from(object: { [k: string]: any }): fvec3;

    /**
     * Creates a plain object from a fvec3 message. Also converts values to other types if specified.
     * @param {fvec3} message fvec3
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: fvec3, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this fvec3 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this fvec3 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type ivec3$Properties = {
    x?: number;
    y?: number;
    z?: number;
};

/**
 * Constructs a new ivec3.
 * @exports ivec3
 * @constructor
 * @param {ivec3$Properties=} [properties] Properties to set
 */
export class ivec3 {

    /**
     * Constructs a new ivec3.
     * @exports ivec3
     * @constructor
     * @param {ivec3$Properties=} [properties] Properties to set
     */
    constructor(properties?: ivec3$Properties);

    /**
     * ivec3 x.
     * @type {number}
     */
    public x: number;

    /**
     * ivec3 y.
     * @type {number}
     */
    public y: number;

    /**
     * ivec3 z.
     * @type {number}
     */
    public z: number;

    /**
     * Creates a new ivec3 instance using the specified properties.
     * @param {ivec3$Properties=} [properties] Properties to set
     * @returns {ivec3} ivec3 instance
     */
    public static create(properties?: ivec3$Properties): ivec3;

    /**
     * Encodes the specified ivec3 message. Does not implicitly {@link ivec3.verify|verify} messages.
     * @param {ivec3$Properties} message ivec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: ivec3$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified ivec3 message, length delimited. Does not implicitly {@link ivec3.verify|verify} messages.
     * @param {ivec3$Properties} message ivec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: ivec3$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an ivec3 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec3} ivec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ivec3;

    /**
     * Decodes an ivec3 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ivec3} ivec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ivec3;

    /**
     * Verifies an ivec3 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an ivec3 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec3} ivec3
     */
    public static fromObject(object: { [k: string]: any }): ivec3;

    /**
     * Creates an ivec3 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link ivec3.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec3} ivec3
     */
    public static from(object: { [k: string]: any }): ivec3;

    /**
     * Creates a plain object from an ivec3 message. Also converts values to other types if specified.
     * @param {ivec3} message ivec3
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: ivec3, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this ivec3 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this ivec3 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type uvec3$Properties = {
    x?: number;
    y?: number;
    z?: number;
};

/**
 * Constructs a new uvec3.
 * @exports uvec3
 * @constructor
 * @param {uvec3$Properties=} [properties] Properties to set
 */
export class uvec3 {

    /**
     * Constructs a new uvec3.
     * @exports uvec3
     * @constructor
     * @param {uvec3$Properties=} [properties] Properties to set
     */
    constructor(properties?: uvec3$Properties);

    /**
     * uvec3 x.
     * @type {number}
     */
    public x: number;

    /**
     * uvec3 y.
     * @type {number}
     */
    public y: number;

    /**
     * uvec3 z.
     * @type {number}
     */
    public z: number;

    /**
     * Creates a new uvec3 instance using the specified properties.
     * @param {uvec3$Properties=} [properties] Properties to set
     * @returns {uvec3} uvec3 instance
     */
    public static create(properties?: uvec3$Properties): uvec3;

    /**
     * Encodes the specified uvec3 message. Does not implicitly {@link uvec3.verify|verify} messages.
     * @param {uvec3$Properties} message uvec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: uvec3$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified uvec3 message, length delimited. Does not implicitly {@link uvec3.verify|verify} messages.
     * @param {uvec3$Properties} message uvec3 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: uvec3$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an uvec3 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec3} uvec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): uvec3;

    /**
     * Decodes an uvec3 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {uvec3} uvec3
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): uvec3;

    /**
     * Verifies an uvec3 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an uvec3 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec3} uvec3
     */
    public static fromObject(object: { [k: string]: any }): uvec3;

    /**
     * Creates an uvec3 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link uvec3.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec3} uvec3
     */
    public static from(object: { [k: string]: any }): uvec3;

    /**
     * Creates a plain object from an uvec3 message. Also converts values to other types if specified.
     * @param {uvec3} message uvec3
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: uvec3, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this uvec3 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this uvec3 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type vec4$Properties = {
    x?: number;
    y?: number;
    z?: number;
    t?: number;
};

/**
 * Constructs a new vec4.
 * @exports vec4
 * @constructor
 * @param {vec4$Properties=} [properties] Properties to set
 */
export class vec4 {

    /**
     * Constructs a new vec4.
     * @exports vec4
     * @constructor
     * @param {vec4$Properties=} [properties] Properties to set
     */
    constructor(properties?: vec4$Properties);

    /**
     * vec4 x.
     * @type {number}
     */
    public x: number;

    /**
     * vec4 y.
     * @type {number}
     */
    public y: number;

    /**
     * vec4 z.
     * @type {number}
     */
    public z: number;

    /**
     * vec4 t.
     * @type {number}
     */
    public t: number;

    /**
     * Creates a new vec4 instance using the specified properties.
     * @param {vec4$Properties=} [properties] Properties to set
     * @returns {vec4} vec4 instance
     */
    public static create(properties?: vec4$Properties): vec4;

    /**
     * Encodes the specified vec4 message. Does not implicitly {@link vec4.verify|verify} messages.
     * @param {vec4$Properties} message vec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: vec4$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified vec4 message, length delimited. Does not implicitly {@link vec4.verify|verify} messages.
     * @param {vec4$Properties} message vec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: vec4$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a vec4 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {vec4} vec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): vec4;

    /**
     * Decodes a vec4 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {vec4} vec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): vec4;

    /**
     * Verifies a vec4 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a vec4 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {vec4} vec4
     */
    public static fromObject(object: { [k: string]: any }): vec4;

    /**
     * Creates a vec4 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link vec4.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {vec4} vec4
     */
    public static from(object: { [k: string]: any }): vec4;

    /**
     * Creates a plain object from a vec4 message. Also converts values to other types if specified.
     * @param {vec4} message vec4
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: vec4, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this vec4 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this vec4 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type fvec4$Properties = {
    x?: number;
    y?: number;
    z?: number;
    t?: number;
};

/**
 * Constructs a new fvec4.
 * @exports fvec4
 * @constructor
 * @param {fvec4$Properties=} [properties] Properties to set
 */
export class fvec4 {

    /**
     * Constructs a new fvec4.
     * @exports fvec4
     * @constructor
     * @param {fvec4$Properties=} [properties] Properties to set
     */
    constructor(properties?: fvec4$Properties);

    /**
     * fvec4 x.
     * @type {number}
     */
    public x: number;

    /**
     * fvec4 y.
     * @type {number}
     */
    public y: number;

    /**
     * fvec4 z.
     * @type {number}
     */
    public z: number;

    /**
     * fvec4 t.
     * @type {number}
     */
    public t: number;

    /**
     * Creates a new fvec4 instance using the specified properties.
     * @param {fvec4$Properties=} [properties] Properties to set
     * @returns {fvec4} fvec4 instance
     */
    public static create(properties?: fvec4$Properties): fvec4;

    /**
     * Encodes the specified fvec4 message. Does not implicitly {@link fvec4.verify|verify} messages.
     * @param {fvec4$Properties} message fvec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: fvec4$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified fvec4 message, length delimited. Does not implicitly {@link fvec4.verify|verify} messages.
     * @param {fvec4$Properties} message fvec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: fvec4$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a fvec4 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {fvec4} fvec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): fvec4;

    /**
     * Decodes a fvec4 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {fvec4} fvec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): fvec4;

    /**
     * Verifies a fvec4 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates a fvec4 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec4} fvec4
     */
    public static fromObject(object: { [k: string]: any }): fvec4;

    /**
     * Creates a fvec4 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link fvec4.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {fvec4} fvec4
     */
    public static from(object: { [k: string]: any }): fvec4;

    /**
     * Creates a plain object from a fvec4 message. Also converts values to other types if specified.
     * @param {fvec4} message fvec4
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: fvec4, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this fvec4 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this fvec4 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type ivec4$Properties = {
    x?: number;
    y?: number;
    z?: number;
    t?: number;
};

/**
 * Constructs a new ivec4.
 * @exports ivec4
 * @constructor
 * @param {ivec4$Properties=} [properties] Properties to set
 */
export class ivec4 {

    /**
     * Constructs a new ivec4.
     * @exports ivec4
     * @constructor
     * @param {ivec4$Properties=} [properties] Properties to set
     */
    constructor(properties?: ivec4$Properties);

    /**
     * ivec4 x.
     * @type {number}
     */
    public x: number;

    /**
     * ivec4 y.
     * @type {number}
     */
    public y: number;

    /**
     * ivec4 z.
     * @type {number}
     */
    public z: number;

    /**
     * ivec4 t.
     * @type {number}
     */
    public t: number;

    /**
     * Creates a new ivec4 instance using the specified properties.
     * @param {ivec4$Properties=} [properties] Properties to set
     * @returns {ivec4} ivec4 instance
     */
    public static create(properties?: ivec4$Properties): ivec4;

    /**
     * Encodes the specified ivec4 message. Does not implicitly {@link ivec4.verify|verify} messages.
     * @param {ivec4$Properties} message ivec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: ivec4$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified ivec4 message, length delimited. Does not implicitly {@link ivec4.verify|verify} messages.
     * @param {ivec4$Properties} message ivec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: ivec4$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an ivec4 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ivec4} ivec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ivec4;

    /**
     * Decodes an ivec4 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ivec4} ivec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ivec4;

    /**
     * Verifies an ivec4 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an ivec4 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec4} ivec4
     */
    public static fromObject(object: { [k: string]: any }): ivec4;

    /**
     * Creates an ivec4 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link ivec4.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {ivec4} ivec4
     */
    public static from(object: { [k: string]: any }): ivec4;

    /**
     * Creates a plain object from an ivec4 message. Also converts values to other types if specified.
     * @param {ivec4} message ivec4
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: ivec4, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this ivec4 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this ivec4 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

type uvec4$Properties = {
    x?: number;
    y?: number;
    z?: number;
    t?: number;
};

/**
 * Constructs a new uvec4.
 * @exports uvec4
 * @constructor
 * @param {uvec4$Properties=} [properties] Properties to set
 */
export class uvec4 {

    /**
     * Constructs a new uvec4.
     * @exports uvec4
     * @constructor
     * @param {uvec4$Properties=} [properties] Properties to set
     */
    constructor(properties?: uvec4$Properties);

    /**
     * uvec4 x.
     * @type {number}
     */
    public x: number;

    /**
     * uvec4 y.
     * @type {number}
     */
    public y: number;

    /**
     * uvec4 z.
     * @type {number}
     */
    public z: number;

    /**
     * uvec4 t.
     * @type {number}
     */
    public t: number;

    /**
     * Creates a new uvec4 instance using the specified properties.
     * @param {uvec4$Properties=} [properties] Properties to set
     * @returns {uvec4} uvec4 instance
     */
    public static create(properties?: uvec4$Properties): uvec4;

    /**
     * Encodes the specified uvec4 message. Does not implicitly {@link uvec4.verify|verify} messages.
     * @param {uvec4$Properties} message uvec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encode(message: uvec4$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified uvec4 message, length delimited. Does not implicitly {@link uvec4.verify|verify} messages.
     * @param {uvec4$Properties} message uvec4 message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    public static encodeDelimited(message: uvec4$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes an uvec4 message from the specified reader or buffer.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {uvec4} uvec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): uvec4;

    /**
     * Decodes an uvec4 message from the specified reader or buffer, length delimited.
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {uvec4} uvec4
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): uvec4;

    /**
     * Verifies an uvec4 message.
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {?string} `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): string;

    /**
     * Creates an uvec4 message from a plain object. Also converts values to their respective internal types.
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec4} uvec4
     */
    public static fromObject(object: { [k: string]: any }): uvec4;

    /**
     * Creates an uvec4 message from a plain object. Also converts values to their respective internal types.
     * This is an alias of {@link uvec4.fromObject}.
     * @function
     * @param {Object.<string,*>} object Plain object
     * @returns {uvec4} uvec4
     */
    public static from(object: { [k: string]: any }): uvec4;

    /**
     * Creates a plain object from an uvec4 message. Also converts values to other types if specified.
     * @param {uvec4} message uvec4
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public static toObject(message: uvec4, options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Creates a plain object from this uvec4 message. Also converts values to other types if specified.
     * @param {$protobuf.ConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

    /**
     * Converts this uvec4 to JSON.
     * @returns {Object.<string,*>} JSON object
     */
    public toJSON(): { [k: string]: any };
}

/**
 * PointerType enum.
 * @exports PointerType
 * @enum {number}
 * @property {number} NONE=0 NONE value
 * @property {number} RAW=1 RAW value
 * @property {number} SHARED=2 SHARED value
 * @property {number} UNIQUE=3 UNIQUE value
 */
export enum PointerType {
    NONE = 0,
    RAW = 1,
    SHARED = 2,
    UNIQUE = 3
}

/**
 * Namespace google.
 * @exports google
 * @namespace
 */
export namespace google {

    /**
     * Namespace protobuf.
     * @exports google.protobuf
     * @namespace
     */
    namespace protobuf {

        type FileDescriptorSet$Properties = {
            file?: google.protobuf.FileDescriptorProto$Properties[];
        };

        /**
         * Constructs a new FileDescriptorSet.
         * @exports google.protobuf.FileDescriptorSet
         * @constructor
         * @param {google.protobuf.FileDescriptorSet$Properties=} [properties] Properties to set
         */
        class FileDescriptorSet {

            /**
             * Constructs a new FileDescriptorSet.
             * @exports google.protobuf.FileDescriptorSet
             * @constructor
             * @param {google.protobuf.FileDescriptorSet$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.FileDescriptorSet$Properties);

            /**
             * FileDescriptorSet file.
             * @type {Array.<google.protobuf.FileDescriptorProto$Properties>}
             */
            public file: google.protobuf.FileDescriptorProto$Properties[];

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @param {google.protobuf.FileDescriptorSet$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            public static create(properties?: google.protobuf.FileDescriptorSet$Properties): google.protobuf.FileDescriptorSet;

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @param {google.protobuf.FileDescriptorSet$Properties} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.FileDescriptorSet$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @param {google.protobuf.FileDescriptorSet$Properties} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.FileDescriptorSet$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.FileDescriptorSet;

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.FileDescriptorSet;

            /**
             * Verifies a FileDescriptorSet message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.FileDescriptorSet;

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FileDescriptorSet.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            public static from(object: { [k: string]: any }): google.protobuf.FileDescriptorSet;

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.FileDescriptorSet, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FileDescriptorSet message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type FileDescriptorProto$Properties = {
            name?: string;
            "package"?: string;
            dependency?: string[];
            publicDependency?: number[];
            weakDependency?: number[];
            messageType?: google.protobuf.DescriptorProto$Properties[];
            enumType?: google.protobuf.EnumDescriptorProto$Properties[];
            service?: google.protobuf.ServiceDescriptorProto$Properties[];
            extension?: google.protobuf.FieldDescriptorProto$Properties[];
            options?: google.protobuf.FileOptions$Properties;
            sourceCodeInfo?: google.protobuf.SourceCodeInfo$Properties;
            syntax?: string;
        };

        /**
         * Constructs a new FileDescriptorProto.
         * @exports google.protobuf.FileDescriptorProto
         * @constructor
         * @param {google.protobuf.FileDescriptorProto$Properties=} [properties] Properties to set
         */
        class FileDescriptorProto {

            /**
             * Constructs a new FileDescriptorProto.
             * @exports google.protobuf.FileDescriptorProto
             * @constructor
             * @param {google.protobuf.FileDescriptorProto$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.FileDescriptorProto$Properties);

            /**
             * FileDescriptorProto name.
             * @type {string}
             */
            public name: string;

            /**
             * FileDescriptorProto package.
             * @type {string}
             */
            public ["package"]: string;

            /**
             * FileDescriptorProto dependency.
             * @type {Array.<string>}
             */
            public dependency: string[];

            /**
             * FileDescriptorProto publicDependency.
             * @type {Array.<number>}
             */
            public publicDependency: number[];

            /**
             * FileDescriptorProto weakDependency.
             * @type {Array.<number>}
             */
            public weakDependency: number[];

            /**
             * FileDescriptorProto messageType.
             * @type {Array.<google.protobuf.DescriptorProto$Properties>}
             */
            public messageType: google.protobuf.DescriptorProto$Properties[];

            /**
             * FileDescriptorProto enumType.
             * @type {Array.<google.protobuf.EnumDescriptorProto$Properties>}
             */
            public enumType: google.protobuf.EnumDescriptorProto$Properties[];

            /**
             * FileDescriptorProto service.
             * @type {Array.<google.protobuf.ServiceDescriptorProto$Properties>}
             */
            public service: google.protobuf.ServiceDescriptorProto$Properties[];

            /**
             * FileDescriptorProto extension.
             * @type {Array.<google.protobuf.FieldDescriptorProto$Properties>}
             */
            public extension: google.protobuf.FieldDescriptorProto$Properties[];

            /**
             * FileDescriptorProto options.
             * @type {(google.protobuf.FileOptions$Properties|null)}
             */
            public options: (google.protobuf.FileOptions$Properties|null);

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @type {(google.protobuf.SourceCodeInfo$Properties|null)}
             */
            public sourceCodeInfo: (google.protobuf.SourceCodeInfo$Properties|null);

            /**
             * FileDescriptorProto syntax.
             * @type {string}
             */
            public syntax: string;

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @param {google.protobuf.FileDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            public static create(properties?: google.protobuf.FileDescriptorProto$Properties): google.protobuf.FileDescriptorProto;

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.FileDescriptorProto$Properties} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.FileDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.FileDescriptorProto$Properties} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.FileDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.FileDescriptorProto;

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.FileDescriptorProto;

            /**
             * Verifies a FileDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.FileDescriptorProto;

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FileDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            public static from(object: { [k: string]: any }): google.protobuf.FileDescriptorProto;

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.FileDescriptorProto, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FileDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type DescriptorProto$Properties = {
            name?: string;
            field?: google.protobuf.FieldDescriptorProto$Properties[];
            extension?: google.protobuf.FieldDescriptorProto$Properties[];
            nestedType?: google.protobuf.DescriptorProto$Properties[];
            enumType?: google.protobuf.EnumDescriptorProto$Properties[];
            extensionRange?: google.protobuf.DescriptorProto.ExtensionRange$Properties[];
            oneofDecl?: google.protobuf.OneofDescriptorProto$Properties[];
            options?: google.protobuf.MessageOptions$Properties;
            reservedRange?: google.protobuf.DescriptorProto.ReservedRange$Properties[];
            reservedName?: string[];
        };

        /**
         * Constructs a new DescriptorProto.
         * @exports google.protobuf.DescriptorProto
         * @constructor
         * @param {google.protobuf.DescriptorProto$Properties=} [properties] Properties to set
         */
        class DescriptorProto {

            /**
             * Constructs a new DescriptorProto.
             * @exports google.protobuf.DescriptorProto
             * @constructor
             * @param {google.protobuf.DescriptorProto$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.DescriptorProto$Properties);

            /**
             * DescriptorProto name.
             * @type {string}
             */
            public name: string;

            /**
             * DescriptorProto field.
             * @type {Array.<google.protobuf.FieldDescriptorProto$Properties>}
             */
            public field: google.protobuf.FieldDescriptorProto$Properties[];

            /**
             * DescriptorProto extension.
             * @type {Array.<google.protobuf.FieldDescriptorProto$Properties>}
             */
            public extension: google.protobuf.FieldDescriptorProto$Properties[];

            /**
             * DescriptorProto nestedType.
             * @type {Array.<google.protobuf.DescriptorProto$Properties>}
             */
            public nestedType: google.protobuf.DescriptorProto$Properties[];

            /**
             * DescriptorProto enumType.
             * @type {Array.<google.protobuf.EnumDescriptorProto$Properties>}
             */
            public enumType: google.protobuf.EnumDescriptorProto$Properties[];

            /**
             * DescriptorProto extensionRange.
             * @type {Array.<google.protobuf.DescriptorProto.ExtensionRange$Properties>}
             */
            public extensionRange: google.protobuf.DescriptorProto.ExtensionRange$Properties[];

            /**
             * DescriptorProto oneofDecl.
             * @type {Array.<google.protobuf.OneofDescriptorProto$Properties>}
             */
            public oneofDecl: google.protobuf.OneofDescriptorProto$Properties[];

            /**
             * DescriptorProto options.
             * @type {(google.protobuf.MessageOptions$Properties|null)}
             */
            public options: (google.protobuf.MessageOptions$Properties|null);

            /**
             * DescriptorProto reservedRange.
             * @type {Array.<google.protobuf.DescriptorProto.ReservedRange$Properties>}
             */
            public reservedRange: google.protobuf.DescriptorProto.ReservedRange$Properties[];

            /**
             * DescriptorProto reservedName.
             * @type {Array.<string>}
             */
            public reservedName: string[];

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @param {google.protobuf.DescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            public static create(properties?: google.protobuf.DescriptorProto$Properties): google.protobuf.DescriptorProto;

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @param {google.protobuf.DescriptorProto$Properties} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.DescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @param {google.protobuf.DescriptorProto$Properties} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.DescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.DescriptorProto;

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.DescriptorProto;

            /**
             * Verifies a DescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.DescriptorProto;

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.DescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            public static from(object: { [k: string]: any }): google.protobuf.DescriptorProto;

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.DescriptorProto, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this DescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this DescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace DescriptorProto {

            type ExtensionRange$Properties = {
                start?: number;
                end?: number;
            };

            /**
             * Constructs a new ExtensionRange.
             * @exports google.protobuf.DescriptorProto.ExtensionRange
             * @constructor
             * @param {google.protobuf.DescriptorProto.ExtensionRange$Properties=} [properties] Properties to set
             */
            class ExtensionRange {

                /**
                 * Constructs a new ExtensionRange.
                 * @exports google.protobuf.DescriptorProto.ExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.ExtensionRange$Properties=} [properties] Properties to set
                 */
                constructor(properties?: google.protobuf.DescriptorProto.ExtensionRange$Properties);

                /**
                 * ExtensionRange start.
                 * @type {number}
                 */
                public start: number;

                /**
                 * ExtensionRange end.
                 * @type {number}
                 */
                public end: number;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @param {google.protobuf.DescriptorProto.ExtensionRange$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                public static create(properties?: google.protobuf.DescriptorProto.ExtensionRange$Properties): google.protobuf.DescriptorProto.ExtensionRange;

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @param {google.protobuf.DescriptorProto.ExtensionRange$Properties} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: google.protobuf.DescriptorProto.ExtensionRange$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @param {google.protobuf.DescriptorProto.ExtensionRange$Properties} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: google.protobuf.DescriptorProto.ExtensionRange$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.DescriptorProto.ExtensionRange;

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.DescriptorProto.ExtensionRange;

                /**
                 * Verifies an ExtensionRange message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                public static fromObject(object: { [k: string]: any }): google.protobuf.DescriptorProto.ExtensionRange;

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.DescriptorProto.ExtensionRange.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                public static from(object: { [k: string]: any }): google.protobuf.DescriptorProto.ExtensionRange;

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: google.protobuf.DescriptorProto.ExtensionRange, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this ExtensionRange message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type ReservedRange$Properties = {
                start?: number;
                end?: number;
            };

            /**
             * Constructs a new ReservedRange.
             * @exports google.protobuf.DescriptorProto.ReservedRange
             * @constructor
             * @param {google.protobuf.DescriptorProto.ReservedRange$Properties=} [properties] Properties to set
             */
            class ReservedRange {

                /**
                 * Constructs a new ReservedRange.
                 * @exports google.protobuf.DescriptorProto.ReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.ReservedRange$Properties=} [properties] Properties to set
                 */
                constructor(properties?: google.protobuf.DescriptorProto.ReservedRange$Properties);

                /**
                 * ReservedRange start.
                 * @type {number}
                 */
                public start: number;

                /**
                 * ReservedRange end.
                 * @type {number}
                 */
                public end: number;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @param {google.protobuf.DescriptorProto.ReservedRange$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                public static create(properties?: google.protobuf.DescriptorProto.ReservedRange$Properties): google.protobuf.DescriptorProto.ReservedRange;

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @param {google.protobuf.DescriptorProto.ReservedRange$Properties} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: google.protobuf.DescriptorProto.ReservedRange$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @param {google.protobuf.DescriptorProto.ReservedRange$Properties} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: google.protobuf.DescriptorProto.ReservedRange$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.DescriptorProto.ReservedRange;

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.DescriptorProto.ReservedRange;

                /**
                 * Verifies a ReservedRange message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                public static fromObject(object: { [k: string]: any }): google.protobuf.DescriptorProto.ReservedRange;

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.DescriptorProto.ReservedRange.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                public static from(object: { [k: string]: any }): google.protobuf.DescriptorProto.ReservedRange;

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: google.protobuf.DescriptorProto.ReservedRange, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this ReservedRange message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this ReservedRange to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type FieldDescriptorProto$Properties = {
            name?: string;
            number?: number;
            label?: google.protobuf.FieldDescriptorProto.Label;
            type?: google.protobuf.FieldDescriptorProto.Type;
            typeName?: string;
            extendee?: string;
            defaultValue?: string;
            oneofIndex?: number;
            jsonName?: string;
            options?: google.protobuf.FieldOptions$Properties;
        };

        /**
         * Constructs a new FieldDescriptorProto.
         * @exports google.protobuf.FieldDescriptorProto
         * @constructor
         * @param {google.protobuf.FieldDescriptorProto$Properties=} [properties] Properties to set
         */
        class FieldDescriptorProto {

            /**
             * Constructs a new FieldDescriptorProto.
             * @exports google.protobuf.FieldDescriptorProto
             * @constructor
             * @param {google.protobuf.FieldDescriptorProto$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.FieldDescriptorProto$Properties);

            /**
             * FieldDescriptorProto name.
             * @type {string}
             */
            public name: string;

            /**
             * FieldDescriptorProto number.
             * @type {number}
             */
            public number: number;

            /**
             * FieldDescriptorProto label.
             * @type {google.protobuf.FieldDescriptorProto.Label}
             */
            public label: google.protobuf.FieldDescriptorProto.Label;

            /**
             * FieldDescriptorProto type.
             * @type {google.protobuf.FieldDescriptorProto.Type}
             */
            public type: google.protobuf.FieldDescriptorProto.Type;

            /**
             * FieldDescriptorProto typeName.
             * @type {string}
             */
            public typeName: string;

            /**
             * FieldDescriptorProto extendee.
             * @type {string}
             */
            public extendee: string;

            /**
             * FieldDescriptorProto defaultValue.
             * @type {string}
             */
            public defaultValue: string;

            /**
             * FieldDescriptorProto oneofIndex.
             * @type {number}
             */
            public oneofIndex: number;

            /**
             * FieldDescriptorProto jsonName.
             * @type {string}
             */
            public jsonName: string;

            /**
             * FieldDescriptorProto options.
             * @type {(google.protobuf.FieldOptions$Properties|null)}
             */
            public options: (google.protobuf.FieldOptions$Properties|null);

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @param {google.protobuf.FieldDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            public static create(properties?: google.protobuf.FieldDescriptorProto$Properties): google.protobuf.FieldDescriptorProto;

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.FieldDescriptorProto$Properties} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.FieldDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.FieldDescriptorProto$Properties} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.FieldDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.FieldDescriptorProto;

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.FieldDescriptorProto;

            /**
             * Verifies a FieldDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.FieldDescriptorProto;

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FieldDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            public static from(object: { [k: string]: any }): google.protobuf.FieldDescriptorProto;

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.FieldDescriptorProto, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FieldDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace FieldDescriptorProto {

            /**
             * Type enum.
             * @name Type
             * @memberof google.protobuf.FieldDescriptorProto
             * @enum {number}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            enum Type {
                TYPE_DOUBLE = 1,
                TYPE_FLOAT = 2,
                TYPE_INT64 = 3,
                TYPE_UINT64 = 4,
                TYPE_INT32 = 5,
                TYPE_FIXED64 = 6,
                TYPE_FIXED32 = 7,
                TYPE_BOOL = 8,
                TYPE_STRING = 9,
                TYPE_GROUP = 10,
                TYPE_MESSAGE = 11,
                TYPE_BYTES = 12,
                TYPE_UINT32 = 13,
                TYPE_ENUM = 14,
                TYPE_SFIXED32 = 15,
                TYPE_SFIXED64 = 16,
                TYPE_SINT32 = 17,
                TYPE_SINT64 = 18
            }

            /**
             * Label enum.
             * @name Label
             * @memberof google.protobuf.FieldDescriptorProto
             * @enum {number}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            enum Label {
                LABEL_OPTIONAL = 1,
                LABEL_REQUIRED = 2,
                LABEL_REPEATED = 3
            }
        }

        type OneofDescriptorProto$Properties = {
            name?: string;
            options?: google.protobuf.OneofOptions$Properties;
        };

        /**
         * Constructs a new OneofDescriptorProto.
         * @exports google.protobuf.OneofDescriptorProto
         * @constructor
         * @param {google.protobuf.OneofDescriptorProto$Properties=} [properties] Properties to set
         */
        class OneofDescriptorProto {

            /**
             * Constructs a new OneofDescriptorProto.
             * @exports google.protobuf.OneofDescriptorProto
             * @constructor
             * @param {google.protobuf.OneofDescriptorProto$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.OneofDescriptorProto$Properties);

            /**
             * OneofDescriptorProto name.
             * @type {string}
             */
            public name: string;

            /**
             * OneofDescriptorProto options.
             * @type {(google.protobuf.OneofOptions$Properties|null)}
             */
            public options: (google.protobuf.OneofOptions$Properties|null);

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @param {google.protobuf.OneofDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            public static create(properties?: google.protobuf.OneofDescriptorProto$Properties): google.protobuf.OneofDescriptorProto;

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.OneofDescriptorProto$Properties} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.OneofDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.OneofDescriptorProto$Properties} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.OneofDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.OneofDescriptorProto;

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.OneofDescriptorProto;

            /**
             * Verifies an OneofDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.OneofDescriptorProto;

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.OneofDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            public static from(object: { [k: string]: any }): google.protobuf.OneofDescriptorProto;

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.OneofDescriptorProto, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this OneofDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type EnumDescriptorProto$Properties = {
            name?: string;
            value?: google.protobuf.EnumValueDescriptorProto$Properties[];
            options?: google.protobuf.EnumOptions$Properties;
        };

        /**
         * Constructs a new EnumDescriptorProto.
         * @exports google.protobuf.EnumDescriptorProto
         * @constructor
         * @param {google.protobuf.EnumDescriptorProto$Properties=} [properties] Properties to set
         */
        class EnumDescriptorProto {

            /**
             * Constructs a new EnumDescriptorProto.
             * @exports google.protobuf.EnumDescriptorProto
             * @constructor
             * @param {google.protobuf.EnumDescriptorProto$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.EnumDescriptorProto$Properties);

            /**
             * EnumDescriptorProto name.
             * @type {string}
             */
            public name: string;

            /**
             * EnumDescriptorProto value.
             * @type {Array.<google.protobuf.EnumValueDescriptorProto$Properties>}
             */
            public value: google.protobuf.EnumValueDescriptorProto$Properties[];

            /**
             * EnumDescriptorProto options.
             * @type {(google.protobuf.EnumOptions$Properties|null)}
             */
            public options: (google.protobuf.EnumOptions$Properties|null);

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @param {google.protobuf.EnumDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            public static create(properties?: google.protobuf.EnumDescriptorProto$Properties): google.protobuf.EnumDescriptorProto;

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.EnumDescriptorProto$Properties} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.EnumDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.EnumDescriptorProto$Properties} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.EnumDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.EnumDescriptorProto;

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.EnumDescriptorProto;

            /**
             * Verifies an EnumDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.EnumDescriptorProto;

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.EnumDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            public static from(object: { [k: string]: any }): google.protobuf.EnumDescriptorProto;

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.EnumDescriptorProto, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this EnumDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type EnumValueDescriptorProto$Properties = {
            name?: string;
            number?: number;
            options?: google.protobuf.EnumValueOptions$Properties;
        };

        /**
         * Constructs a new EnumValueDescriptorProto.
         * @exports google.protobuf.EnumValueDescriptorProto
         * @constructor
         * @param {google.protobuf.EnumValueDescriptorProto$Properties=} [properties] Properties to set
         */
        class EnumValueDescriptorProto {

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @exports google.protobuf.EnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.EnumValueDescriptorProto$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.EnumValueDescriptorProto$Properties);

            /**
             * EnumValueDescriptorProto name.
             * @type {string}
             */
            public name: string;

            /**
             * EnumValueDescriptorProto number.
             * @type {number}
             */
            public number: number;

            /**
             * EnumValueDescriptorProto options.
             * @type {(google.protobuf.EnumValueOptions$Properties|null)}
             */
            public options: (google.protobuf.EnumValueOptions$Properties|null);

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @param {google.protobuf.EnumValueDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            public static create(properties?: google.protobuf.EnumValueDescriptorProto$Properties): google.protobuf.EnumValueDescriptorProto;

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.EnumValueDescriptorProto$Properties} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.EnumValueDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.EnumValueDescriptorProto$Properties} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.EnumValueDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.EnumValueDescriptorProto;

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.EnumValueDescriptorProto;

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.EnumValueDescriptorProto;

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.EnumValueDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            public static from(object: { [k: string]: any }): google.protobuf.EnumValueDescriptorProto;

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.EnumValueDescriptorProto, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type ServiceDescriptorProto$Properties = {
            name?: string;
            method?: google.protobuf.MethodDescriptorProto$Properties[];
            options?: google.protobuf.ServiceOptions$Properties;
        };

        /**
         * Constructs a new ServiceDescriptorProto.
         * @exports google.protobuf.ServiceDescriptorProto
         * @constructor
         * @param {google.protobuf.ServiceDescriptorProto$Properties=} [properties] Properties to set
         */
        class ServiceDescriptorProto {

            /**
             * Constructs a new ServiceDescriptorProto.
             * @exports google.protobuf.ServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.ServiceDescriptorProto$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.ServiceDescriptorProto$Properties);

            /**
             * ServiceDescriptorProto name.
             * @type {string}
             */
            public name: string;

            /**
             * ServiceDescriptorProto method.
             * @type {Array.<google.protobuf.MethodDescriptorProto$Properties>}
             */
            public method: google.protobuf.MethodDescriptorProto$Properties[];

            /**
             * ServiceDescriptorProto options.
             * @type {(google.protobuf.ServiceOptions$Properties|null)}
             */
            public options: (google.protobuf.ServiceOptions$Properties|null);

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @param {google.protobuf.ServiceDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            public static create(properties?: google.protobuf.ServiceDescriptorProto$Properties): google.protobuf.ServiceDescriptorProto;

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.ServiceDescriptorProto$Properties} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.ServiceDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.ServiceDescriptorProto$Properties} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.ServiceDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.ServiceDescriptorProto;

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.ServiceDescriptorProto;

            /**
             * Verifies a ServiceDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.ServiceDescriptorProto;

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.ServiceDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            public static from(object: { [k: string]: any }): google.protobuf.ServiceDescriptorProto;

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.ServiceDescriptorProto, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this ServiceDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type MethodDescriptorProto$Properties = {
            name?: string;
            inputType?: string;
            outputType?: string;
            options?: google.protobuf.MethodOptions$Properties;
            clientStreaming?: boolean;
            serverStreaming?: boolean;
        };

        /**
         * Constructs a new MethodDescriptorProto.
         * @exports google.protobuf.MethodDescriptorProto
         * @constructor
         * @param {google.protobuf.MethodDescriptorProto$Properties=} [properties] Properties to set
         */
        class MethodDescriptorProto {

            /**
             * Constructs a new MethodDescriptorProto.
             * @exports google.protobuf.MethodDescriptorProto
             * @constructor
             * @param {google.protobuf.MethodDescriptorProto$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.MethodDescriptorProto$Properties);

            /**
             * MethodDescriptorProto name.
             * @type {string}
             */
            public name: string;

            /**
             * MethodDescriptorProto inputType.
             * @type {string}
             */
            public inputType: string;

            /**
             * MethodDescriptorProto outputType.
             * @type {string}
             */
            public outputType: string;

            /**
             * MethodDescriptorProto options.
             * @type {(google.protobuf.MethodOptions$Properties|null)}
             */
            public options: (google.protobuf.MethodOptions$Properties|null);

            /**
             * MethodDescriptorProto clientStreaming.
             * @type {boolean}
             */
            public clientStreaming: boolean;

            /**
             * MethodDescriptorProto serverStreaming.
             * @type {boolean}
             */
            public serverStreaming: boolean;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @param {google.protobuf.MethodDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            public static create(properties?: google.protobuf.MethodDescriptorProto$Properties): google.protobuf.MethodDescriptorProto;

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.MethodDescriptorProto$Properties} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.MethodDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.MethodDescriptorProto$Properties} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.MethodDescriptorProto$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.MethodDescriptorProto;

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.MethodDescriptorProto;

            /**
             * Verifies a MethodDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.MethodDescriptorProto;

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.MethodDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            public static from(object: { [k: string]: any }): google.protobuf.MethodDescriptorProto;

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.MethodDescriptorProto, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this MethodDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type FileOptions$Properties = {
            javaPackage?: string;
            javaOuterClassname?: string;
            javaMultipleFiles?: boolean;
            javaGenerateEqualsAndHash?: boolean;
            javaStringCheckUtf8?: boolean;
            optimizeFor?: google.protobuf.FileOptions.OptimizeMode;
            goPackage?: string;
            ccGenericServices?: boolean;
            javaGenericServices?: boolean;
            pyGenericServices?: boolean;
            deprecated?: boolean;
            ccEnableArenas?: boolean;
            objcClassPrefix?: string;
            csharpNamespace?: string;
            uninterpretedOption?: google.protobuf.UninterpretedOption$Properties[];
        };

        /**
         * Constructs a new FileOptions.
         * @exports google.protobuf.FileOptions
         * @constructor
         * @param {google.protobuf.FileOptions$Properties=} [properties] Properties to set
         */
        class FileOptions {

            /**
             * Constructs a new FileOptions.
             * @exports google.protobuf.FileOptions
             * @constructor
             * @param {google.protobuf.FileOptions$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.FileOptions$Properties);

            /**
             * FileOptions javaPackage.
             * @type {string}
             */
            public javaPackage: string;

            /**
             * FileOptions javaOuterClassname.
             * @type {string}
             */
            public javaOuterClassname: string;

            /**
             * FileOptions javaMultipleFiles.
             * @type {boolean}
             */
            public javaMultipleFiles: boolean;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @type {boolean}
             */
            public javaGenerateEqualsAndHash: boolean;

            /**
             * FileOptions javaStringCheckUtf8.
             * @type {boolean}
             */
            public javaStringCheckUtf8: boolean;

            /**
             * FileOptions optimizeFor.
             * @type {google.protobuf.FileOptions.OptimizeMode}
             */
            public optimizeFor: google.protobuf.FileOptions.OptimizeMode;

            /**
             * FileOptions goPackage.
             * @type {string}
             */
            public goPackage: string;

            /**
             * FileOptions ccGenericServices.
             * @type {boolean}
             */
            public ccGenericServices: boolean;

            /**
             * FileOptions javaGenericServices.
             * @type {boolean}
             */
            public javaGenericServices: boolean;

            /**
             * FileOptions pyGenericServices.
             * @type {boolean}
             */
            public pyGenericServices: boolean;

            /**
             * FileOptions deprecated.
             * @type {boolean}
             */
            public deprecated: boolean;

            /**
             * FileOptions ccEnableArenas.
             * @type {boolean}
             */
            public ccEnableArenas: boolean;

            /**
             * FileOptions objcClassPrefix.
             * @type {string}
             */
            public objcClassPrefix: string;

            /**
             * FileOptions csharpNamespace.
             * @type {string}
             */
            public csharpNamespace: string;

            /**
             * FileOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            public uninterpretedOption: google.protobuf.UninterpretedOption$Properties[];

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @param {google.protobuf.FileOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            public static create(properties?: google.protobuf.FileOptions$Properties): google.protobuf.FileOptions;

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @param {google.protobuf.FileOptions$Properties} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.FileOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @param {google.protobuf.FileOptions$Properties} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.FileOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.FileOptions;

            /**
             * Decodes a FileOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.FileOptions;

            /**
             * Verifies a FileOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.FileOptions;

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FileOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            public static from(object: { [k: string]: any }): google.protobuf.FileOptions;

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.FileOptions, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FileOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FileOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace FileOptions {

            /**
             * OptimizeMode enum.
             * @name OptimizeMode
             * @memberof google.protobuf.FileOptions
             * @enum {number}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            enum OptimizeMode {
                SPEED = 1,
                CODE_SIZE = 2,
                LITE_RUNTIME = 3
            }
        }

        type MessageOptions$Properties = {
            messageSetWireFormat?: boolean;
            noStandardDescriptorAccessor?: boolean;
            deprecated?: boolean;
            mapEntry?: boolean;
            uninterpretedOption?: google.protobuf.UninterpretedOption$Properties[];
        };

        /**
         * Constructs a new MessageOptions.
         * @exports google.protobuf.MessageOptions
         * @constructor
         * @param {google.protobuf.MessageOptions$Properties=} [properties] Properties to set
         */
        class MessageOptions {

            /**
             * Constructs a new MessageOptions.
             * @exports google.protobuf.MessageOptions
             * @constructor
             * @param {google.protobuf.MessageOptions$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.MessageOptions$Properties);

            /**
             * MessageOptions messageSetWireFormat.
             * @type {boolean}
             */
            public messageSetWireFormat: boolean;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @type {boolean}
             */
            public noStandardDescriptorAccessor: boolean;

            /**
             * MessageOptions deprecated.
             * @type {boolean}
             */
            public deprecated: boolean;

            /**
             * MessageOptions mapEntry.
             * @type {boolean}
             */
            public mapEntry: boolean;

            /**
             * MessageOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            public uninterpretedOption: google.protobuf.UninterpretedOption$Properties[];

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @param {google.protobuf.MessageOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            public static create(properties?: google.protobuf.MessageOptions$Properties): google.protobuf.MessageOptions;

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @param {google.protobuf.MessageOptions$Properties} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.MessageOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @param {google.protobuf.MessageOptions$Properties} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.MessageOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.MessageOptions;

            /**
             * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.MessageOptions;

            /**
             * Verifies a MessageOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.MessageOptions;

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.MessageOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            public static from(object: { [k: string]: any }): google.protobuf.MessageOptions;

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.MessageOptions, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this MessageOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this MessageOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type FieldOptions$Properties = {
            ctype?: google.protobuf.FieldOptions.CType;
            packed?: boolean;
            jstype?: google.protobuf.FieldOptions.JSType;
            lazy?: boolean;
            deprecated?: boolean;
            weak?: boolean;
            uninterpretedOption?: google.protobuf.UninterpretedOption$Properties[];
            ".pointer"?: PointerType;
            ".arraySize"?: number;
        };

        /**
         * Constructs a new FieldOptions.
         * @exports google.protobuf.FieldOptions
         * @constructor
         * @param {google.protobuf.FieldOptions$Properties=} [properties] Properties to set
         */
        class FieldOptions {

            /**
             * Constructs a new FieldOptions.
             * @exports google.protobuf.FieldOptions
             * @constructor
             * @param {google.protobuf.FieldOptions$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.FieldOptions$Properties);

            /**
             * FieldOptions ctype.
             * @type {google.protobuf.FieldOptions.CType}
             */
            public ctype: google.protobuf.FieldOptions.CType;

            /**
             * FieldOptions packed.
             * @type {boolean}
             */
            public packed: boolean;

            /**
             * FieldOptions jstype.
             * @type {google.protobuf.FieldOptions.JSType}
             */
            public jstype: google.protobuf.FieldOptions.JSType;

            /**
             * FieldOptions lazy.
             * @type {boolean}
             */
            public lazy: boolean;

            /**
             * FieldOptions deprecated.
             * @type {boolean}
             */
            public deprecated: boolean;

            /**
             * FieldOptions weak.
             * @type {boolean}
             */
            public weak: boolean;

            /**
             * FieldOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            public uninterpretedOption: google.protobuf.UninterpretedOption$Properties[];

            /**
             * FieldOptions .pointer.
             * @type {PointerType}
             */
            public [".pointer"]: PointerType;

            /**
             * FieldOptions .arraySize.
             * @type {number}
             */
            public [".arraySize"]: number;

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @param {google.protobuf.FieldOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            public static create(properties?: google.protobuf.FieldOptions$Properties): google.protobuf.FieldOptions;

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @param {google.protobuf.FieldOptions$Properties} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.FieldOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @param {google.protobuf.FieldOptions$Properties} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.FieldOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.FieldOptions;

            /**
             * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.FieldOptions;

            /**
             * Verifies a FieldOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.FieldOptions;

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FieldOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            public static from(object: { [k: string]: any }): google.protobuf.FieldOptions;

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.FieldOptions, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FieldOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FieldOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace FieldOptions {

            /**
             * CType enum.
             * @name CType
             * @memberof google.protobuf.FieldOptions
             * @enum {number}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            enum CType {
                STRING = 0,
                CORD = 1,
                STRING_PIECE = 2
            }

            /**
             * JSType enum.
             * @name JSType
             * @memberof google.protobuf.FieldOptions
             * @enum {number}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            enum JSType {
                JS_NORMAL = 0,
                JS_STRING = 1,
                JS_NUMBER = 2
            }
        }

        type OneofOptions$Properties = {
            uninterpretedOption?: google.protobuf.UninterpretedOption$Properties[];
        };

        /**
         * Constructs a new OneofOptions.
         * @exports google.protobuf.OneofOptions
         * @constructor
         * @param {google.protobuf.OneofOptions$Properties=} [properties] Properties to set
         */
        class OneofOptions {

            /**
             * Constructs a new OneofOptions.
             * @exports google.protobuf.OneofOptions
             * @constructor
             * @param {google.protobuf.OneofOptions$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.OneofOptions$Properties);

            /**
             * OneofOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            public uninterpretedOption: google.protobuf.UninterpretedOption$Properties[];

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @param {google.protobuf.OneofOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            public static create(properties?: google.protobuf.OneofOptions$Properties): google.protobuf.OneofOptions;

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @param {google.protobuf.OneofOptions$Properties} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.OneofOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @param {google.protobuf.OneofOptions$Properties} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.OneofOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.OneofOptions;

            /**
             * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.OneofOptions;

            /**
             * Verifies an OneofOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.OneofOptions;

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.OneofOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            public static from(object: { [k: string]: any }): google.protobuf.OneofOptions;

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.OneofOptions, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this OneofOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this OneofOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type EnumOptions$Properties = {
            allowAlias?: boolean;
            deprecated?: boolean;
            uninterpretedOption?: google.protobuf.UninterpretedOption$Properties[];
        };

        /**
         * Constructs a new EnumOptions.
         * @exports google.protobuf.EnumOptions
         * @constructor
         * @param {google.protobuf.EnumOptions$Properties=} [properties] Properties to set
         */
        class EnumOptions {

            /**
             * Constructs a new EnumOptions.
             * @exports google.protobuf.EnumOptions
             * @constructor
             * @param {google.protobuf.EnumOptions$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.EnumOptions$Properties);

            /**
             * EnumOptions allowAlias.
             * @type {boolean}
             */
            public allowAlias: boolean;

            /**
             * EnumOptions deprecated.
             * @type {boolean}
             */
            public deprecated: boolean;

            /**
             * EnumOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            public uninterpretedOption: google.protobuf.UninterpretedOption$Properties[];

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @param {google.protobuf.EnumOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            public static create(properties?: google.protobuf.EnumOptions$Properties): google.protobuf.EnumOptions;

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @param {google.protobuf.EnumOptions$Properties} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.EnumOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @param {google.protobuf.EnumOptions$Properties} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.EnumOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.EnumOptions;

            /**
             * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.EnumOptions;

            /**
             * Verifies an EnumOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.EnumOptions;

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.EnumOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            public static from(object: { [k: string]: any }): google.protobuf.EnumOptions;

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.EnumOptions, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this EnumOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this EnumOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type EnumValueOptions$Properties = {
            deprecated?: boolean;
            uninterpretedOption?: google.protobuf.UninterpretedOption$Properties[];
        };

        /**
         * Constructs a new EnumValueOptions.
         * @exports google.protobuf.EnumValueOptions
         * @constructor
         * @param {google.protobuf.EnumValueOptions$Properties=} [properties] Properties to set
         */
        class EnumValueOptions {

            /**
             * Constructs a new EnumValueOptions.
             * @exports google.protobuf.EnumValueOptions
             * @constructor
             * @param {google.protobuf.EnumValueOptions$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.EnumValueOptions$Properties);

            /**
             * EnumValueOptions deprecated.
             * @type {boolean}
             */
            public deprecated: boolean;

            /**
             * EnumValueOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            public uninterpretedOption: google.protobuf.UninterpretedOption$Properties[];

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @param {google.protobuf.EnumValueOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            public static create(properties?: google.protobuf.EnumValueOptions$Properties): google.protobuf.EnumValueOptions;

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @param {google.protobuf.EnumValueOptions$Properties} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.EnumValueOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @param {google.protobuf.EnumValueOptions$Properties} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.EnumValueOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.EnumValueOptions;

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.EnumValueOptions;

            /**
             * Verifies an EnumValueOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.EnumValueOptions;

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.EnumValueOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            public static from(object: { [k: string]: any }): google.protobuf.EnumValueOptions;

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.EnumValueOptions, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this EnumValueOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this EnumValueOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type ServiceOptions$Properties = {
            deprecated?: boolean;
            uninterpretedOption?: google.protobuf.UninterpretedOption$Properties[];
        };

        /**
         * Constructs a new ServiceOptions.
         * @exports google.protobuf.ServiceOptions
         * @constructor
         * @param {google.protobuf.ServiceOptions$Properties=} [properties] Properties to set
         */
        class ServiceOptions {

            /**
             * Constructs a new ServiceOptions.
             * @exports google.protobuf.ServiceOptions
             * @constructor
             * @param {google.protobuf.ServiceOptions$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.ServiceOptions$Properties);

            /**
             * ServiceOptions deprecated.
             * @type {boolean}
             */
            public deprecated: boolean;

            /**
             * ServiceOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            public uninterpretedOption: google.protobuf.UninterpretedOption$Properties[];

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @param {google.protobuf.ServiceOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            public static create(properties?: google.protobuf.ServiceOptions$Properties): google.protobuf.ServiceOptions;

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @param {google.protobuf.ServiceOptions$Properties} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.ServiceOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @param {google.protobuf.ServiceOptions$Properties} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.ServiceOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.ServiceOptions;

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.ServiceOptions;

            /**
             * Verifies a ServiceOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.ServiceOptions;

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.ServiceOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            public static from(object: { [k: string]: any }): google.protobuf.ServiceOptions;

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.ServiceOptions, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this ServiceOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this ServiceOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type MethodOptions$Properties = {
            deprecated?: boolean;
            uninterpretedOption?: google.protobuf.UninterpretedOption$Properties[];
        };

        /**
         * Constructs a new MethodOptions.
         * @exports google.protobuf.MethodOptions
         * @constructor
         * @param {google.protobuf.MethodOptions$Properties=} [properties] Properties to set
         */
        class MethodOptions {

            /**
             * Constructs a new MethodOptions.
             * @exports google.protobuf.MethodOptions
             * @constructor
             * @param {google.protobuf.MethodOptions$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.MethodOptions$Properties);

            /**
             * MethodOptions deprecated.
             * @type {boolean}
             */
            public deprecated: boolean;

            /**
             * MethodOptions uninterpretedOption.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            public uninterpretedOption: google.protobuf.UninterpretedOption$Properties[];

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @param {google.protobuf.MethodOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            public static create(properties?: google.protobuf.MethodOptions$Properties): google.protobuf.MethodOptions;

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @param {google.protobuf.MethodOptions$Properties} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.MethodOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @param {google.protobuf.MethodOptions$Properties} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.MethodOptions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.MethodOptions;

            /**
             * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.MethodOptions;

            /**
             * Verifies a MethodOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.MethodOptions;

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.MethodOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            public static from(object: { [k: string]: any }): google.protobuf.MethodOptions;

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.MethodOptions, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this MethodOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this MethodOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type UninterpretedOption$Properties = {
            name?: google.protobuf.UninterpretedOption.NamePart$Properties[];
            identifierValue?: string;
            positiveIntValue?: (number|Long);
            negativeIntValue?: (number|Long);
            doubleValue?: number;
            stringValue?: Uint8Array;
            aggregateValue?: string;
        };

        /**
         * Constructs a new UninterpretedOption.
         * @exports google.protobuf.UninterpretedOption
         * @constructor
         * @param {google.protobuf.UninterpretedOption$Properties=} [properties] Properties to set
         */
        class UninterpretedOption {

            /**
             * Constructs a new UninterpretedOption.
             * @exports google.protobuf.UninterpretedOption
             * @constructor
             * @param {google.protobuf.UninterpretedOption$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.UninterpretedOption$Properties);

            /**
             * UninterpretedOption name.
             * @type {Array.<google.protobuf.UninterpretedOption.NamePart$Properties>}
             */
            public name: google.protobuf.UninterpretedOption.NamePart$Properties[];

            /**
             * UninterpretedOption identifierValue.
             * @type {string}
             */
            public identifierValue: string;

            /**
             * UninterpretedOption positiveIntValue.
             * @type {number|Long}
             */
            public positiveIntValue: (number|Long);

            /**
             * UninterpretedOption negativeIntValue.
             * @type {number|Long}
             */
            public negativeIntValue: (number|Long);

            /**
             * UninterpretedOption doubleValue.
             * @type {number}
             */
            public doubleValue: number;

            /**
             * UninterpretedOption stringValue.
             * @type {Uint8Array}
             */
            public stringValue: Uint8Array;

            /**
             * UninterpretedOption aggregateValue.
             * @type {string}
             */
            public aggregateValue: string;

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @param {google.protobuf.UninterpretedOption$Properties=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            public static create(properties?: google.protobuf.UninterpretedOption$Properties): google.protobuf.UninterpretedOption;

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @param {google.protobuf.UninterpretedOption$Properties} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.UninterpretedOption$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @param {google.protobuf.UninterpretedOption$Properties} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.UninterpretedOption$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.UninterpretedOption;

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.UninterpretedOption;

            /**
             * Verifies an UninterpretedOption message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.UninterpretedOption;

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.UninterpretedOption.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            public static from(object: { [k: string]: any }): google.protobuf.UninterpretedOption;

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.UninterpretedOption, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this UninterpretedOption message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this UninterpretedOption to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace UninterpretedOption {

            type NamePart$Properties = {
                namePart: string;
                isExtension: boolean;
            };

            /**
             * Constructs a new NamePart.
             * @exports google.protobuf.UninterpretedOption.NamePart
             * @constructor
             * @param {google.protobuf.UninterpretedOption.NamePart$Properties=} [properties] Properties to set
             */
            class NamePart {

                /**
                 * Constructs a new NamePart.
                 * @exports google.protobuf.UninterpretedOption.NamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.NamePart$Properties=} [properties] Properties to set
                 */
                constructor(properties?: google.protobuf.UninterpretedOption.NamePart$Properties);

                /**
                 * NamePart namePart.
                 * @type {string}
                 */
                public namePart: string;

                /**
                 * NamePart isExtension.
                 * @type {boolean}
                 */
                public isExtension: boolean;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @param {google.protobuf.UninterpretedOption.NamePart$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                public static create(properties?: google.protobuf.UninterpretedOption.NamePart$Properties): google.protobuf.UninterpretedOption.NamePart;

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @param {google.protobuf.UninterpretedOption.NamePart$Properties} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: google.protobuf.UninterpretedOption.NamePart$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @param {google.protobuf.UninterpretedOption.NamePart$Properties} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: google.protobuf.UninterpretedOption.NamePart$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.UninterpretedOption.NamePart;

                /**
                 * Decodes a NamePart message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.UninterpretedOption.NamePart;

                /**
                 * Verifies a NamePart message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                public static fromObject(object: { [k: string]: any }): google.protobuf.UninterpretedOption.NamePart;

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.UninterpretedOption.NamePart.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                public static from(object: { [k: string]: any }): google.protobuf.UninterpretedOption.NamePart;

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: google.protobuf.UninterpretedOption.NamePart, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this NamePart message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this NamePart to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type SourceCodeInfo$Properties = {
            location?: google.protobuf.SourceCodeInfo.Location$Properties[];
        };

        /**
         * Constructs a new SourceCodeInfo.
         * @exports google.protobuf.SourceCodeInfo
         * @constructor
         * @param {google.protobuf.SourceCodeInfo$Properties=} [properties] Properties to set
         */
        class SourceCodeInfo {

            /**
             * Constructs a new SourceCodeInfo.
             * @exports google.protobuf.SourceCodeInfo
             * @constructor
             * @param {google.protobuf.SourceCodeInfo$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.SourceCodeInfo$Properties);

            /**
             * SourceCodeInfo location.
             * @type {Array.<google.protobuf.SourceCodeInfo.Location$Properties>}
             */
            public location: google.protobuf.SourceCodeInfo.Location$Properties[];

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @param {google.protobuf.SourceCodeInfo$Properties=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            public static create(properties?: google.protobuf.SourceCodeInfo$Properties): google.protobuf.SourceCodeInfo;

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @param {google.protobuf.SourceCodeInfo$Properties} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.SourceCodeInfo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @param {google.protobuf.SourceCodeInfo$Properties} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.SourceCodeInfo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.SourceCodeInfo;

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.SourceCodeInfo;

            /**
             * Verifies a SourceCodeInfo message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.SourceCodeInfo;

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.SourceCodeInfo.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            public static from(object: { [k: string]: any }): google.protobuf.SourceCodeInfo;

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.SourceCodeInfo, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this SourceCodeInfo message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace SourceCodeInfo {

            type Location$Properties = {
                path?: number[];
                span?: number[];
                leadingComments?: string;
                trailingComments?: string;
                leadingDetachedComments?: string[];
            };

            /**
             * Constructs a new Location.
             * @exports google.protobuf.SourceCodeInfo.Location
             * @constructor
             * @param {google.protobuf.SourceCodeInfo.Location$Properties=} [properties] Properties to set
             */
            class Location {

                /**
                 * Constructs a new Location.
                 * @exports google.protobuf.SourceCodeInfo.Location
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.Location$Properties=} [properties] Properties to set
                 */
                constructor(properties?: google.protobuf.SourceCodeInfo.Location$Properties);

                /**
                 * Location path.
                 * @type {Array.<number>}
                 */
                public path: number[];

                /**
                 * Location span.
                 * @type {Array.<number>}
                 */
                public span: number[];

                /**
                 * Location leadingComments.
                 * @type {string}
                 */
                public leadingComments: string;

                /**
                 * Location trailingComments.
                 * @type {string}
                 */
                public trailingComments: string;

                /**
                 * Location leadingDetachedComments.
                 * @type {Array.<string>}
                 */
                public leadingDetachedComments: string[];

                /**
                 * Creates a new Location instance using the specified properties.
                 * @param {google.protobuf.SourceCodeInfo.Location$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                public static create(properties?: google.protobuf.SourceCodeInfo.Location$Properties): google.protobuf.SourceCodeInfo.Location;

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @param {google.protobuf.SourceCodeInfo.Location$Properties} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: google.protobuf.SourceCodeInfo.Location$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @param {google.protobuf.SourceCodeInfo.Location$Properties} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: google.protobuf.SourceCodeInfo.Location$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.SourceCodeInfo.Location;

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.SourceCodeInfo.Location;

                /**
                 * Verifies a Location message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                public static fromObject(object: { [k: string]: any }): google.protobuf.SourceCodeInfo.Location;

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.SourceCodeInfo.Location.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                public static from(object: { [k: string]: any }): google.protobuf.SourceCodeInfo.Location;

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: google.protobuf.SourceCodeInfo.Location, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Location message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Location to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type GeneratedCodeInfo$Properties = {
            annotation?: google.protobuf.GeneratedCodeInfo.Annotation$Properties[];
        };

        /**
         * Constructs a new GeneratedCodeInfo.
         * @exports google.protobuf.GeneratedCodeInfo
         * @constructor
         * @param {google.protobuf.GeneratedCodeInfo$Properties=} [properties] Properties to set
         */
        class GeneratedCodeInfo {

            /**
             * Constructs a new GeneratedCodeInfo.
             * @exports google.protobuf.GeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.GeneratedCodeInfo$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.GeneratedCodeInfo$Properties);

            /**
             * GeneratedCodeInfo annotation.
             * @type {Array.<google.protobuf.GeneratedCodeInfo.Annotation$Properties>}
             */
            public annotation: google.protobuf.GeneratedCodeInfo.Annotation$Properties[];

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @param {google.protobuf.GeneratedCodeInfo$Properties=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            public static create(properties?: google.protobuf.GeneratedCodeInfo$Properties): google.protobuf.GeneratedCodeInfo;

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @param {google.protobuf.GeneratedCodeInfo$Properties} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.GeneratedCodeInfo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @param {google.protobuf.GeneratedCodeInfo$Properties} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.GeneratedCodeInfo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.GeneratedCodeInfo;

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.GeneratedCodeInfo;

            /**
             * Verifies a GeneratedCodeInfo message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.GeneratedCodeInfo;

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.GeneratedCodeInfo.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            public static from(object: { [k: string]: any }): google.protobuf.GeneratedCodeInfo;

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.GeneratedCodeInfo, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this GeneratedCodeInfo message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace GeneratedCodeInfo {

            type Annotation$Properties = {
                path?: number[];
                sourceFile?: string;
                begin?: number;
                end?: number;
            };

            /**
             * Constructs a new Annotation.
             * @exports google.protobuf.GeneratedCodeInfo.Annotation
             * @constructor
             * @param {google.protobuf.GeneratedCodeInfo.Annotation$Properties=} [properties] Properties to set
             */
            class Annotation {

                /**
                 * Constructs a new Annotation.
                 * @exports google.protobuf.GeneratedCodeInfo.Annotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation$Properties=} [properties] Properties to set
                 */
                constructor(properties?: google.protobuf.GeneratedCodeInfo.Annotation$Properties);

                /**
                 * Annotation path.
                 * @type {Array.<number>}
                 */
                public path: number[];

                /**
                 * Annotation sourceFile.
                 * @type {string}
                 */
                public sourceFile: string;

                /**
                 * Annotation begin.
                 * @type {number}
                 */
                public begin: number;

                /**
                 * Annotation end.
                 * @type {number}
                 */
                public end: number;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                public static create(properties?: google.protobuf.GeneratedCodeInfo.Annotation$Properties): google.protobuf.GeneratedCodeInfo.Annotation;

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation$Properties} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: google.protobuf.GeneratedCodeInfo.Annotation$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation$Properties} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: google.protobuf.GeneratedCodeInfo.Annotation$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.GeneratedCodeInfo.Annotation;

                /**
                 * Decodes an Annotation message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.GeneratedCodeInfo.Annotation;

                /**
                 * Verifies an Annotation message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                public static fromObject(object: { [k: string]: any }): google.protobuf.GeneratedCodeInfo.Annotation;

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.GeneratedCodeInfo.Annotation.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                public static from(object: { [k: string]: any }): google.protobuf.GeneratedCodeInfo.Annotation;

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: google.protobuf.GeneratedCodeInfo.Annotation, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Annotation message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Annotation to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type Duration$Properties = {
            seconds?: (number|Long);
            nanos?: number;
        };

        /**
         * Constructs a new Duration.
         * @exports google.protobuf.Duration
         * @constructor
         * @param {google.protobuf.Duration$Properties=} [properties] Properties to set
         */
        class Duration {

            /**
             * Constructs a new Duration.
             * @exports google.protobuf.Duration
             * @constructor
             * @param {google.protobuf.Duration$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.Duration$Properties);

            /**
             * Duration seconds.
             * @type {number|Long}
             */
            public seconds: (number|Long);

            /**
             * Duration nanos.
             * @type {number}
             */
            public nanos: number;

            /**
             * Creates a new Duration instance using the specified properties.
             * @param {google.protobuf.Duration$Properties=} [properties] Properties to set
             * @returns {google.protobuf.Duration} Duration instance
             */
            public static create(properties?: google.protobuf.Duration$Properties): google.protobuf.Duration;

            /**
             * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @param {google.protobuf.Duration$Properties} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.Duration$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @param {google.protobuf.Duration$Properties} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.Duration$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Duration message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.Duration;

            /**
             * Decodes a Duration message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.Duration;

            /**
             * Verifies a Duration message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a Duration message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Duration} Duration
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.Duration;

            /**
             * Creates a Duration message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.Duration.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Duration} Duration
             */
            public static from(object: { [k: string]: any }): google.protobuf.Duration;

            /**
             * Creates a plain object from a Duration message. Also converts values to other types if specified.
             * @param {google.protobuf.Duration} message Duration
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.Duration, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Duration message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Duration to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type Timestamp$Properties = {
            seconds?: (number|Long);
            nanos?: number;
        };

        /**
         * Constructs a new Timestamp.
         * @exports google.protobuf.Timestamp
         * @constructor
         * @param {google.protobuf.Timestamp$Properties=} [properties] Properties to set
         */
        class Timestamp {

            /**
             * Constructs a new Timestamp.
             * @exports google.protobuf.Timestamp
             * @constructor
             * @param {google.protobuf.Timestamp$Properties=} [properties] Properties to set
             */
            constructor(properties?: google.protobuf.Timestamp$Properties);

            /**
             * Timestamp seconds.
             * @type {number|Long}
             */
            public seconds: (number|Long);

            /**
             * Timestamp nanos.
             * @type {number}
             */
            public nanos: number;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @param {google.protobuf.Timestamp$Properties=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */
            public static create(properties?: google.protobuf.Timestamp$Properties): google.protobuf.Timestamp;

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @param {google.protobuf.Timestamp$Properties} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: google.protobuf.Timestamp$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @param {google.protobuf.Timestamp$Properties} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: google.protobuf.Timestamp$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): google.protobuf.Timestamp;

            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): google.protobuf.Timestamp;

            /**
             * Verifies a Timestamp message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            public static fromObject(object: { [k: string]: any }): google.protobuf.Timestamp;

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.Timestamp.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            public static from(object: { [k: string]: any }): google.protobuf.Timestamp;

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: google.protobuf.Timestamp, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Timestamp message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Timestamp to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }
}

/**
 * Namespace message.
 * @exports message
 * @namespace
 */
export namespace message {

    type Line$Properties = {
        normal?: vec2$Properties;
        distance?: number;
    };

    /**
     * Constructs a new Line.
     * @exports message.Line
     * @constructor
     * @param {message.Line$Properties=} [properties] Properties to set
     */
    class Line {

        /**
         * Constructs a new Line.
         * @exports message.Line
         * @constructor
         * @param {message.Line$Properties=} [properties] Properties to set
         */
        constructor(properties?: message.Line$Properties);

        /**
         * Line normal.
         * @type {(vec2$Properties|null)}
         */
        public normal: (vec2$Properties|null);

        /**
         * Line distance.
         * @type {number}
         */
        public distance: number;

        /**
         * Creates a new Line instance using the specified properties.
         * @param {message.Line$Properties=} [properties] Properties to set
         * @returns {message.Line} Line instance
         */
        public static create(properties?: message.Line$Properties): message.Line;

        /**
         * Encodes the specified Line message. Does not implicitly {@link message.Line.verify|verify} messages.
         * @param {message.Line$Properties} message Line message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        public static encode(message: message.Line$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Line message, length delimited. Does not implicitly {@link message.Line.verify|verify} messages.
         * @param {message.Line$Properties} message Line message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        public static encodeDelimited(message: message.Line$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Line message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Line} Line
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.Line;

        /**
         * Decodes a Line message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {message.Line} Line
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.Line;

        /**
         * Verifies a Line message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): string;

        /**
         * Creates a Line message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Line} Line
         */
        public static fromObject(object: { [k: string]: any }): message.Line;

        /**
         * Creates a Line message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link message.Line.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Line} Line
         */
        public static from(object: { [k: string]: any }): message.Line;

        /**
         * Creates a plain object from a Line message. Also converts values to other types if specified.
         * @param {message.Line} message Line
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        public static toObject(message: message.Line, options?: $protobuf.ConversionOptions): { [k: string]: any };

        /**
         * Creates a plain object from this Line message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

        /**
         * Converts this Line to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    type Circle$Properties = {
        radius?: number;
        centre?: vec2$Properties;
    };

    /**
     * Constructs a new Circle.
     * @exports message.Circle
     * @constructor
     * @param {message.Circle$Properties=} [properties] Properties to set
     */
    class Circle {

        /**
         * Constructs a new Circle.
         * @exports message.Circle
         * @constructor
         * @param {message.Circle$Properties=} [properties] Properties to set
         */
        constructor(properties?: message.Circle$Properties);

        /**
         * Circle radius.
         * @type {number}
         */
        public radius: number;

        /**
         * Circle centre.
         * @type {(vec2$Properties|null)}
         */
        public centre: (vec2$Properties|null);

        /**
         * Creates a new Circle instance using the specified properties.
         * @param {message.Circle$Properties=} [properties] Properties to set
         * @returns {message.Circle} Circle instance
         */
        public static create(properties?: message.Circle$Properties): message.Circle;

        /**
         * Encodes the specified Circle message. Does not implicitly {@link message.Circle.verify|verify} messages.
         * @param {message.Circle$Properties} message Circle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        public static encode(message: message.Circle$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Circle message, length delimited. Does not implicitly {@link message.Circle.verify|verify} messages.
         * @param {message.Circle$Properties} message Circle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        public static encodeDelimited(message: message.Circle$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Circle message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Circle} Circle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.Circle;

        /**
         * Decodes a Circle message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {message.Circle} Circle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.Circle;

        /**
         * Verifies a Circle message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): string;

        /**
         * Creates a Circle message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Circle} Circle
         */
        public static fromObject(object: { [k: string]: any }): message.Circle;

        /**
         * Creates a Circle message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link message.Circle.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Circle} Circle
         */
        public static from(object: { [k: string]: any }): message.Circle;

        /**
         * Creates a plain object from a Circle message. Also converts values to other types if specified.
         * @param {message.Circle} message Circle
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        public static toObject(message: message.Circle, options?: $protobuf.ConversionOptions): { [k: string]: any };

        /**
         * Creates a plain object from this Circle message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

        /**
         * Converts this Circle to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    type Ellipse$Properties = {
        ellipse?: mat33$Properties;
    };

    /**
     * Constructs a new Ellipse.
     * @exports message.Ellipse
     * @constructor
     * @param {message.Ellipse$Properties=} [properties] Properties to set
     */
    class Ellipse {

        /**
         * Constructs a new Ellipse.
         * @exports message.Ellipse
         * @constructor
         * @param {message.Ellipse$Properties=} [properties] Properties to set
         */
        constructor(properties?: message.Ellipse$Properties);

        /**
         * Ellipse ellipse.
         * @type {(mat33$Properties|null)}
         */
        public ellipse: (mat33$Properties|null);

        /**
         * Creates a new Ellipse instance using the specified properties.
         * @param {message.Ellipse$Properties=} [properties] Properties to set
         * @returns {message.Ellipse} Ellipse instance
         */
        public static create(properties?: message.Ellipse$Properties): message.Ellipse;

        /**
         * Encodes the specified Ellipse message. Does not implicitly {@link message.Ellipse.verify|verify} messages.
         * @param {message.Ellipse$Properties} message Ellipse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        public static encode(message: message.Ellipse$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Ellipse message, length delimited. Does not implicitly {@link message.Ellipse.verify|verify} messages.
         * @param {message.Ellipse$Properties} message Ellipse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        public static encodeDelimited(message: message.Ellipse$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an Ellipse message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Ellipse} Ellipse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.Ellipse;

        /**
         * Decodes an Ellipse message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {message.Ellipse} Ellipse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.Ellipse;

        /**
         * Verifies an Ellipse message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): string;

        /**
         * Creates an Ellipse message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Ellipse} Ellipse
         */
        public static fromObject(object: { [k: string]: any }): message.Ellipse;

        /**
         * Creates an Ellipse message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link message.Ellipse.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Ellipse} Ellipse
         */
        public static from(object: { [k: string]: any }): message.Ellipse;

        /**
         * Creates a plain object from an Ellipse message. Also converts values to other types if specified.
         * @param {message.Ellipse} message Ellipse
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        public static toObject(message: message.Ellipse, options?: $protobuf.ConversionOptions): { [k: string]: any };

        /**
         * Creates a plain object from this Ellipse message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

        /**
         * Converts this Ellipse to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    type Quad$Properties = {
        tl?: vec2$Properties;
        tr?: vec2$Properties;
        bl?: vec2$Properties;
        br?: vec2$Properties;
    };

    /**
     * Constructs a new Quad.
     * @exports message.Quad
     * @constructor
     * @param {message.Quad$Properties=} [properties] Properties to set
     */
    class Quad {

        /**
         * Constructs a new Quad.
         * @exports message.Quad
         * @constructor
         * @param {message.Quad$Properties=} [properties] Properties to set
         */
        constructor(properties?: message.Quad$Properties);

        /**
         * Quad tl.
         * @type {(vec2$Properties|null)}
         */
        public tl: (vec2$Properties|null);

        /**
         * Quad tr.
         * @type {(vec2$Properties|null)}
         */
        public tr: (vec2$Properties|null);

        /**
         * Quad bl.
         * @type {(vec2$Properties|null)}
         */
        public bl: (vec2$Properties|null);

        /**
         * Quad br.
         * @type {(vec2$Properties|null)}
         */
        public br: (vec2$Properties|null);

        /**
         * Creates a new Quad instance using the specified properties.
         * @param {message.Quad$Properties=} [properties] Properties to set
         * @returns {message.Quad} Quad instance
         */
        public static create(properties?: message.Quad$Properties): message.Quad;

        /**
         * Encodes the specified Quad message. Does not implicitly {@link message.Quad.verify|verify} messages.
         * @param {message.Quad$Properties} message Quad message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        public static encode(message: message.Quad$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Quad message, length delimited. Does not implicitly {@link message.Quad.verify|verify} messages.
         * @param {message.Quad$Properties} message Quad message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        public static encodeDelimited(message: message.Quad$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Quad message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Quad} Quad
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.Quad;

        /**
         * Decodes a Quad message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {message.Quad} Quad
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.Quad;

        /**
         * Verifies a Quad message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): string;

        /**
         * Creates a Quad message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Quad} Quad
         */
        public static fromObject(object: { [k: string]: any }): message.Quad;

        /**
         * Creates a Quad message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link message.Quad.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Quad} Quad
         */
        public static from(object: { [k: string]: any }): message.Quad;

        /**
         * Creates a plain object from a Quad message. Also converts values to other types if specified.
         * @param {message.Quad} message Quad
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        public static toObject(message: message.Quad, options?: $protobuf.ConversionOptions): { [k: string]: any };

        /**
         * Creates a plain object from this Quad message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

        /**
         * Converts this Quad to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    type Polygon$Properties = {
        point?: vec2$Properties;
    };

    /**
     * Constructs a new Polygon.
     * @exports message.Polygon
     * @constructor
     * @param {message.Polygon$Properties=} [properties] Properties to set
     */
    class Polygon {

        /**
         * Constructs a new Polygon.
         * @exports message.Polygon
         * @constructor
         * @param {message.Polygon$Properties=} [properties] Properties to set
         */
        constructor(properties?: message.Polygon$Properties);

        /**
         * Polygon point.
         * @type {(vec2$Properties|null)}
         */
        public point: (vec2$Properties|null);

        /**
         * Creates a new Polygon instance using the specified properties.
         * @param {message.Polygon$Properties=} [properties] Properties to set
         * @returns {message.Polygon} Polygon instance
         */
        public static create(properties?: message.Polygon$Properties): message.Polygon;

        /**
         * Encodes the specified Polygon message. Does not implicitly {@link message.Polygon.verify|verify} messages.
         * @param {message.Polygon$Properties} message Polygon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        public static encode(message: message.Polygon$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Polygon message, length delimited. Does not implicitly {@link message.Polygon.verify|verify} messages.
         * @param {message.Polygon$Properties} message Polygon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        public static encodeDelimited(message: message.Polygon$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Polygon message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {message.Polygon} Polygon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.Polygon;

        /**
         * Decodes a Polygon message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {message.Polygon} Polygon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.Polygon;

        /**
         * Verifies a Polygon message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): string;

        /**
         * Creates a Polygon message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Polygon} Polygon
         */
        public static fromObject(object: { [k: string]: any }): message.Polygon;

        /**
         * Creates a Polygon message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link message.Polygon.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {message.Polygon} Polygon
         */
        public static from(object: { [k: string]: any }): message.Polygon;

        /**
         * Creates a plain object from a Polygon message. Also converts values to other types if specified.
         * @param {message.Polygon} message Polygon
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        public static toObject(message: message.Polygon, options?: $protobuf.ConversionOptions): { [k: string]: any };

        /**
         * Creates a plain object from this Polygon message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

        /**
         * Converts this Polygon to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /**
     * Namespace behaviour.
     * @exports message.behaviour
     * @namespace
     */
    namespace behaviour {

        type Behaviour$Properties = {
            state?: message.behaviour.Behaviour.State;
        };

        /**
         * Constructs a new Behaviour.
         * @exports message.behaviour.Behaviour
         * @constructor
         * @param {message.behaviour.Behaviour$Properties=} [properties] Properties to set
         */
        class Behaviour {

            /**
             * Constructs a new Behaviour.
             * @exports message.behaviour.Behaviour
             * @constructor
             * @param {message.behaviour.Behaviour$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.Behaviour$Properties);

            /**
             * Behaviour state.
             * @type {message.behaviour.Behaviour.State}
             */
            public state: message.behaviour.Behaviour.State;

            /**
             * Creates a new Behaviour instance using the specified properties.
             * @param {message.behaviour.Behaviour$Properties=} [properties] Properties to set
             * @returns {message.behaviour.Behaviour} Behaviour instance
             */
            public static create(properties?: message.behaviour.Behaviour$Properties): message.behaviour.Behaviour;

            /**
             * Encodes the specified Behaviour message. Does not implicitly {@link message.behaviour.Behaviour.verify|verify} messages.
             * @param {message.behaviour.Behaviour$Properties} message Behaviour message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.Behaviour$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Behaviour message, length delimited. Does not implicitly {@link message.behaviour.Behaviour.verify|verify} messages.
             * @param {message.behaviour.Behaviour$Properties} message Behaviour message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.Behaviour$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Behaviour message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.Behaviour} Behaviour
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.Behaviour;

            /**
             * Decodes a Behaviour message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.Behaviour} Behaviour
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.Behaviour;

            /**
             * Verifies a Behaviour message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a Behaviour message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Behaviour} Behaviour
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.Behaviour;

            /**
             * Creates a Behaviour message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.Behaviour.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Behaviour} Behaviour
             */
            public static from(object: { [k: string]: any }): message.behaviour.Behaviour;

            /**
             * Creates a plain object from a Behaviour message. Also converts values to other types if specified.
             * @param {message.behaviour.Behaviour} message Behaviour
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.Behaviour, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Behaviour message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Behaviour to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace Behaviour {

            /**
             * State enum.
             * @name State
             * @memberof message.behaviour.Behaviour
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} INIT=1 INIT value
             * @property {number} SEARCH_FOR_BALL=2 SEARCH_FOR_BALL value
             * @property {number} SEARCH_FOR_GOALS=3 SEARCH_FOR_GOALS value
             * @property {number} WALK_TO_BALL=4 WALK_TO_BALL value
             * @property {number} PICKED_UP=5 PICKED_UP value
             * @property {number} INITIAL=6 INITIAL value
             * @property {number} READY=7 READY value
             * @property {number} SET=8 SET value
             * @property {number} TIMEOUT=9 TIMEOUT value
             * @property {number} FINISHED=10 FINISHED value
             * @property {number} PENALISED=11 PENALISED value
             * @property {number} GOALIE_WALK=12 GOALIE_WALK value
             * @property {number} MOVE_TO_CENTRE=13 MOVE_TO_CENTRE value
             * @property {number} LOCALISING=14 LOCALISING value
             */
            enum State {
                UNKNOWN = 0,
                INIT = 1,
                SEARCH_FOR_BALL = 2,
                SEARCH_FOR_GOALS = 3,
                WALK_TO_BALL = 4,
                PICKED_UP = 5,
                INITIAL = 6,
                READY = 7,
                SET = 8,
                TIMEOUT = 9,
                FINISHED = 10,
                PENALISED = 11,
                GOALIE_WALK = 12,
                MOVE_TO_CENTRE = 13,
                LOCALISING = 14
            }
        }

        type FieldTarget$Properties = {
            target?: message.behaviour.FieldTarget.Target;
        };

        /**
         * Constructs a new FieldTarget.
         * @exports message.behaviour.FieldTarget
         * @constructor
         * @param {message.behaviour.FieldTarget$Properties=} [properties] Properties to set
         */
        class FieldTarget {

            /**
             * Constructs a new FieldTarget.
             * @exports message.behaviour.FieldTarget
             * @constructor
             * @param {message.behaviour.FieldTarget$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.FieldTarget$Properties);

            /**
             * FieldTarget target.
             * @type {message.behaviour.FieldTarget.Target}
             */
            public target: message.behaviour.FieldTarget.Target;

            /**
             * Creates a new FieldTarget instance using the specified properties.
             * @param {message.behaviour.FieldTarget$Properties=} [properties] Properties to set
             * @returns {message.behaviour.FieldTarget} FieldTarget instance
             */
            public static create(properties?: message.behaviour.FieldTarget$Properties): message.behaviour.FieldTarget;

            /**
             * Encodes the specified FieldTarget message. Does not implicitly {@link message.behaviour.FieldTarget.verify|verify} messages.
             * @param {message.behaviour.FieldTarget$Properties} message FieldTarget message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.FieldTarget$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FieldTarget message, length delimited. Does not implicitly {@link message.behaviour.FieldTarget.verify|verify} messages.
             * @param {message.behaviour.FieldTarget$Properties} message FieldTarget message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.FieldTarget$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FieldTarget message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.FieldTarget} FieldTarget
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.FieldTarget;

            /**
             * Decodes a FieldTarget message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.FieldTarget} FieldTarget
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.FieldTarget;

            /**
             * Verifies a FieldTarget message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FieldTarget message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.FieldTarget} FieldTarget
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.FieldTarget;

            /**
             * Creates a FieldTarget message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.FieldTarget.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.FieldTarget} FieldTarget
             */
            public static from(object: { [k: string]: any }): message.behaviour.FieldTarget;

            /**
             * Creates a plain object from a FieldTarget message. Also converts values to other types if specified.
             * @param {message.behaviour.FieldTarget} message FieldTarget
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.FieldTarget, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FieldTarget message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FieldTarget to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace FieldTarget {

            /**
             * Target enum.
             * @name Target
             * @memberof message.behaviour.FieldTarget
             * @enum {number}
             * @property {number} SELF=0 SELF value
             * @property {number} BALL=1 BALL value
             * @property {number} GOAL=2 GOAL value
             */
            enum Target {
                SELF = 0,
                BALL = 1,
                GOAL = 2
            }
        }

        type FixedWalkFinished$Properties = {};

        /**
         * Constructs a new FixedWalkFinished.
         * @exports message.behaviour.FixedWalkFinished
         * @constructor
         * @param {message.behaviour.FixedWalkFinished$Properties=} [properties] Properties to set
         */
        class FixedWalkFinished {

            /**
             * Constructs a new FixedWalkFinished.
             * @exports message.behaviour.FixedWalkFinished
             * @constructor
             * @param {message.behaviour.FixedWalkFinished$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.FixedWalkFinished$Properties);

            /**
             * Creates a new FixedWalkFinished instance using the specified properties.
             * @param {message.behaviour.FixedWalkFinished$Properties=} [properties] Properties to set
             * @returns {message.behaviour.FixedWalkFinished} FixedWalkFinished instance
             */
            public static create(properties?: message.behaviour.FixedWalkFinished$Properties): message.behaviour.FixedWalkFinished;

            /**
             * Encodes the specified FixedWalkFinished message. Does not implicitly {@link message.behaviour.FixedWalkFinished.verify|verify} messages.
             * @param {message.behaviour.FixedWalkFinished$Properties} message FixedWalkFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.FixedWalkFinished$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FixedWalkFinished message, length delimited. Does not implicitly {@link message.behaviour.FixedWalkFinished.verify|verify} messages.
             * @param {message.behaviour.FixedWalkFinished$Properties} message FixedWalkFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.FixedWalkFinished$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FixedWalkFinished message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.FixedWalkFinished} FixedWalkFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.FixedWalkFinished;

            /**
             * Decodes a FixedWalkFinished message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.FixedWalkFinished} FixedWalkFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.FixedWalkFinished;

            /**
             * Verifies a FixedWalkFinished message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FixedWalkFinished message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.FixedWalkFinished} FixedWalkFinished
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.FixedWalkFinished;

            /**
             * Creates a FixedWalkFinished message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.FixedWalkFinished.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.FixedWalkFinished} FixedWalkFinished
             */
            public static from(object: { [k: string]: any }): message.behaviour.FixedWalkFinished;

            /**
             * Creates a plain object from a FixedWalkFinished message. Also converts values to other types if specified.
             * @param {message.behaviour.FixedWalkFinished} message FixedWalkFinished
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.FixedWalkFinished, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FixedWalkFinished message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FixedWalkFinished to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type WalkConfigSaved$Properties = {};

        /**
         * Constructs a new WalkConfigSaved.
         * @exports message.behaviour.WalkConfigSaved
         * @constructor
         * @param {message.behaviour.WalkConfigSaved$Properties=} [properties] Properties to set
         */
        class WalkConfigSaved {

            /**
             * Constructs a new WalkConfigSaved.
             * @exports message.behaviour.WalkConfigSaved
             * @constructor
             * @param {message.behaviour.WalkConfigSaved$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.WalkConfigSaved$Properties);

            /**
             * Creates a new WalkConfigSaved instance using the specified properties.
             * @param {message.behaviour.WalkConfigSaved$Properties=} [properties] Properties to set
             * @returns {message.behaviour.WalkConfigSaved} WalkConfigSaved instance
             */
            public static create(properties?: message.behaviour.WalkConfigSaved$Properties): message.behaviour.WalkConfigSaved;

            /**
             * Encodes the specified WalkConfigSaved message. Does not implicitly {@link message.behaviour.WalkConfigSaved.verify|verify} messages.
             * @param {message.behaviour.WalkConfigSaved$Properties} message WalkConfigSaved message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.WalkConfigSaved$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified WalkConfigSaved message, length delimited. Does not implicitly {@link message.behaviour.WalkConfigSaved.verify|verify} messages.
             * @param {message.behaviour.WalkConfigSaved$Properties} message WalkConfigSaved message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.WalkConfigSaved$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a WalkConfigSaved message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.WalkConfigSaved} WalkConfigSaved
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.WalkConfigSaved;

            /**
             * Decodes a WalkConfigSaved message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.WalkConfigSaved} WalkConfigSaved
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.WalkConfigSaved;

            /**
             * Verifies a WalkConfigSaved message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a WalkConfigSaved message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WalkConfigSaved} WalkConfigSaved
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.WalkConfigSaved;

            /**
             * Creates a WalkConfigSaved message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.WalkConfigSaved.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WalkConfigSaved} WalkConfigSaved
             */
            public static from(object: { [k: string]: any }): message.behaviour.WalkConfigSaved;

            /**
             * Creates a plain object from a WalkConfigSaved message. Also converts values to other types if specified.
             * @param {message.behaviour.WalkConfigSaved} message WalkConfigSaved
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.WalkConfigSaved, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this WalkConfigSaved message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this WalkConfigSaved to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type CancelFixedWalk$Properties = {};

        /**
         * Constructs a new CancelFixedWalk.
         * @exports message.behaviour.CancelFixedWalk
         * @constructor
         * @param {message.behaviour.CancelFixedWalk$Properties=} [properties] Properties to set
         */
        class CancelFixedWalk {

            /**
             * Constructs a new CancelFixedWalk.
             * @exports message.behaviour.CancelFixedWalk
             * @constructor
             * @param {message.behaviour.CancelFixedWalk$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.CancelFixedWalk$Properties);

            /**
             * Creates a new CancelFixedWalk instance using the specified properties.
             * @param {message.behaviour.CancelFixedWalk$Properties=} [properties] Properties to set
             * @returns {message.behaviour.CancelFixedWalk} CancelFixedWalk instance
             */
            public static create(properties?: message.behaviour.CancelFixedWalk$Properties): message.behaviour.CancelFixedWalk;

            /**
             * Encodes the specified CancelFixedWalk message. Does not implicitly {@link message.behaviour.CancelFixedWalk.verify|verify} messages.
             * @param {message.behaviour.CancelFixedWalk$Properties} message CancelFixedWalk message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.CancelFixedWalk$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified CancelFixedWalk message, length delimited. Does not implicitly {@link message.behaviour.CancelFixedWalk.verify|verify} messages.
             * @param {message.behaviour.CancelFixedWalk$Properties} message CancelFixedWalk message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.CancelFixedWalk$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CancelFixedWalk message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.CancelFixedWalk} CancelFixedWalk
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.CancelFixedWalk;

            /**
             * Decodes a CancelFixedWalk message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.CancelFixedWalk} CancelFixedWalk
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.CancelFixedWalk;

            /**
             * Verifies a CancelFixedWalk message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a CancelFixedWalk message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.CancelFixedWalk} CancelFixedWalk
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.CancelFixedWalk;

            /**
             * Creates a CancelFixedWalk message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.CancelFixedWalk.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.CancelFixedWalk} CancelFixedWalk
             */
            public static from(object: { [k: string]: any }): message.behaviour.CancelFixedWalk;

            /**
             * Creates a plain object from a CancelFixedWalk message. Also converts values to other types if specified.
             * @param {message.behaviour.CancelFixedWalk} message CancelFixedWalk
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.CancelFixedWalk, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this CancelFixedWalk message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this CancelFixedWalk to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type WalkOptimiserCommand$Properties = {
            walkConfig?: string;
        };

        /**
         * Constructs a new WalkOptimiserCommand.
         * @exports message.behaviour.WalkOptimiserCommand
         * @constructor
         * @param {message.behaviour.WalkOptimiserCommand$Properties=} [properties] Properties to set
         */
        class WalkOptimiserCommand {

            /**
             * Constructs a new WalkOptimiserCommand.
             * @exports message.behaviour.WalkOptimiserCommand
             * @constructor
             * @param {message.behaviour.WalkOptimiserCommand$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.WalkOptimiserCommand$Properties);

            /**
             * WalkOptimiserCommand walkConfig.
             * @type {string}
             */
            public walkConfig: string;

            /**
             * Creates a new WalkOptimiserCommand instance using the specified properties.
             * @param {message.behaviour.WalkOptimiserCommand$Properties=} [properties] Properties to set
             * @returns {message.behaviour.WalkOptimiserCommand} WalkOptimiserCommand instance
             */
            public static create(properties?: message.behaviour.WalkOptimiserCommand$Properties): message.behaviour.WalkOptimiserCommand;

            /**
             * Encodes the specified WalkOptimiserCommand message. Does not implicitly {@link message.behaviour.WalkOptimiserCommand.verify|verify} messages.
             * @param {message.behaviour.WalkOptimiserCommand$Properties} message WalkOptimiserCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.WalkOptimiserCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified WalkOptimiserCommand message, length delimited. Does not implicitly {@link message.behaviour.WalkOptimiserCommand.verify|verify} messages.
             * @param {message.behaviour.WalkOptimiserCommand$Properties} message WalkOptimiserCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.WalkOptimiserCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a WalkOptimiserCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.WalkOptimiserCommand} WalkOptimiserCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.WalkOptimiserCommand;

            /**
             * Decodes a WalkOptimiserCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.WalkOptimiserCommand} WalkOptimiserCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.WalkOptimiserCommand;

            /**
             * Verifies a WalkOptimiserCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a WalkOptimiserCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WalkOptimiserCommand} WalkOptimiserCommand
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.WalkOptimiserCommand;

            /**
             * Creates a WalkOptimiserCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.WalkOptimiserCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WalkOptimiserCommand} WalkOptimiserCommand
             */
            public static from(object: { [k: string]: any }): message.behaviour.WalkOptimiserCommand;

            /**
             * Creates a plain object from a WalkOptimiserCommand message. Also converts values to other types if specified.
             * @param {message.behaviour.WalkOptimiserCommand} message WalkOptimiserCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.WalkOptimiserCommand, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this WalkOptimiserCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this WalkOptimiserCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type FixedWalkCommand$Properties = {
            segments?: message.behaviour.FixedWalkCommand.WalkSegment$Properties[];
        };

        /**
         * Constructs a new FixedWalkCommand.
         * @exports message.behaviour.FixedWalkCommand
         * @constructor
         * @param {message.behaviour.FixedWalkCommand$Properties=} [properties] Properties to set
         */
        class FixedWalkCommand {

            /**
             * Constructs a new FixedWalkCommand.
             * @exports message.behaviour.FixedWalkCommand
             * @constructor
             * @param {message.behaviour.FixedWalkCommand$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.FixedWalkCommand$Properties);

            /**
             * FixedWalkCommand segments.
             * @type {Array.<message.behaviour.FixedWalkCommand.WalkSegment$Properties>}
             */
            public segments: message.behaviour.FixedWalkCommand.WalkSegment$Properties[];

            /**
             * Creates a new FixedWalkCommand instance using the specified properties.
             * @param {message.behaviour.FixedWalkCommand$Properties=} [properties] Properties to set
             * @returns {message.behaviour.FixedWalkCommand} FixedWalkCommand instance
             */
            public static create(properties?: message.behaviour.FixedWalkCommand$Properties): message.behaviour.FixedWalkCommand;

            /**
             * Encodes the specified FixedWalkCommand message. Does not implicitly {@link message.behaviour.FixedWalkCommand.verify|verify} messages.
             * @param {message.behaviour.FixedWalkCommand$Properties} message FixedWalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.FixedWalkCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FixedWalkCommand message, length delimited. Does not implicitly {@link message.behaviour.FixedWalkCommand.verify|verify} messages.
             * @param {message.behaviour.FixedWalkCommand$Properties} message FixedWalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.FixedWalkCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FixedWalkCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.FixedWalkCommand} FixedWalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.FixedWalkCommand;

            /**
             * Decodes a FixedWalkCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.FixedWalkCommand} FixedWalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.FixedWalkCommand;

            /**
             * Verifies a FixedWalkCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FixedWalkCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.FixedWalkCommand} FixedWalkCommand
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.FixedWalkCommand;

            /**
             * Creates a FixedWalkCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.FixedWalkCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.FixedWalkCommand} FixedWalkCommand
             */
            public static from(object: { [k: string]: any }): message.behaviour.FixedWalkCommand;

            /**
             * Creates a plain object from a FixedWalkCommand message. Also converts values to other types if specified.
             * @param {message.behaviour.FixedWalkCommand} message FixedWalkCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.FixedWalkCommand, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FixedWalkCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FixedWalkCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace FixedWalkCommand {

            type WalkSegment$Properties = {
                direction?: vec2$Properties;
                curvePeriod?: number;
                normalisedVelocity?: number;
                normalisedAngularVelocity?: number;
                duration?: google.protobuf.Duration$Properties;
            };

            /**
             * Constructs a new WalkSegment.
             * @exports message.behaviour.FixedWalkCommand.WalkSegment
             * @constructor
             * @param {message.behaviour.FixedWalkCommand.WalkSegment$Properties=} [properties] Properties to set
             */
            class WalkSegment {

                /**
                 * Constructs a new WalkSegment.
                 * @exports message.behaviour.FixedWalkCommand.WalkSegment
                 * @constructor
                 * @param {message.behaviour.FixedWalkCommand.WalkSegment$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.behaviour.FixedWalkCommand.WalkSegment$Properties);

                /**
                 * WalkSegment direction.
                 * @type {(vec2$Properties|null)}
                 */
                public direction: (vec2$Properties|null);

                /**
                 * WalkSegment curvePeriod.
                 * @type {number}
                 */
                public curvePeriod: number;

                /**
                 * WalkSegment normalisedVelocity.
                 * @type {number}
                 */
                public normalisedVelocity: number;

                /**
                 * WalkSegment normalisedAngularVelocity.
                 * @type {number}
                 */
                public normalisedAngularVelocity: number;

                /**
                 * WalkSegment duration.
                 * @type {(google.protobuf.Duration$Properties|null)}
                 */
                public duration: (google.protobuf.Duration$Properties|null);

                /**
                 * Creates a new WalkSegment instance using the specified properties.
                 * @param {message.behaviour.FixedWalkCommand.WalkSegment$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.FixedWalkCommand.WalkSegment} WalkSegment instance
                 */
                public static create(properties?: message.behaviour.FixedWalkCommand.WalkSegment$Properties): message.behaviour.FixedWalkCommand.WalkSegment;

                /**
                 * Encodes the specified WalkSegment message. Does not implicitly {@link message.behaviour.FixedWalkCommand.WalkSegment.verify|verify} messages.
                 * @param {message.behaviour.FixedWalkCommand.WalkSegment$Properties} message WalkSegment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.behaviour.FixedWalkCommand.WalkSegment$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified WalkSegment message, length delimited. Does not implicitly {@link message.behaviour.FixedWalkCommand.WalkSegment.verify|verify} messages.
                 * @param {message.behaviour.FixedWalkCommand.WalkSegment$Properties} message WalkSegment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.behaviour.FixedWalkCommand.WalkSegment$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a WalkSegment message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.FixedWalkCommand.WalkSegment} WalkSegment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.FixedWalkCommand.WalkSegment;

                /**
                 * Decodes a WalkSegment message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.FixedWalkCommand.WalkSegment} WalkSegment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.FixedWalkCommand.WalkSegment;

                /**
                 * Verifies a WalkSegment message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a WalkSegment message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.FixedWalkCommand.WalkSegment} WalkSegment
                 */
                public static fromObject(object: { [k: string]: any }): message.behaviour.FixedWalkCommand.WalkSegment;

                /**
                 * Creates a WalkSegment message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.FixedWalkCommand.WalkSegment.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.FixedWalkCommand.WalkSegment} WalkSegment
                 */
                public static from(object: { [k: string]: any }): message.behaviour.FixedWalkCommand.WalkSegment;

                /**
                 * Creates a plain object from a WalkSegment message. Also converts values to other types if specified.
                 * @param {message.behaviour.FixedWalkCommand.WalkSegment} message WalkSegment
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.behaviour.FixedWalkCommand.WalkSegment, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this WalkSegment message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this WalkSegment to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type KickPlan$Properties = {
            target?: vec2$Properties;
            kickType?: message.behaviour.KickPlan.KickType;
        };

        /**
         * Constructs a new KickPlan.
         * @exports message.behaviour.KickPlan
         * @constructor
         * @param {message.behaviour.KickPlan$Properties=} [properties] Properties to set
         */
        class KickPlan {

            /**
             * Constructs a new KickPlan.
             * @exports message.behaviour.KickPlan
             * @constructor
             * @param {message.behaviour.KickPlan$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.KickPlan$Properties);

            /**
             * KickPlan target.
             * @type {(vec2$Properties|null)}
             */
            public target: (vec2$Properties|null);

            /**
             * KickPlan kickType.
             * @type {message.behaviour.KickPlan.KickType}
             */
            public kickType: message.behaviour.KickPlan.KickType;

            /**
             * Creates a new KickPlan instance using the specified properties.
             * @param {message.behaviour.KickPlan$Properties=} [properties] Properties to set
             * @returns {message.behaviour.KickPlan} KickPlan instance
             */
            public static create(properties?: message.behaviour.KickPlan$Properties): message.behaviour.KickPlan;

            /**
             * Encodes the specified KickPlan message. Does not implicitly {@link message.behaviour.KickPlan.verify|verify} messages.
             * @param {message.behaviour.KickPlan$Properties} message KickPlan message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.KickPlan$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified KickPlan message, length delimited. Does not implicitly {@link message.behaviour.KickPlan.verify|verify} messages.
             * @param {message.behaviour.KickPlan$Properties} message KickPlan message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.KickPlan$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a KickPlan message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.KickPlan} KickPlan
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.KickPlan;

            /**
             * Decodes a KickPlan message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.KickPlan} KickPlan
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.KickPlan;

            /**
             * Verifies a KickPlan message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a KickPlan message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.KickPlan} KickPlan
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.KickPlan;

            /**
             * Creates a KickPlan message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.KickPlan.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.KickPlan} KickPlan
             */
            public static from(object: { [k: string]: any }): message.behaviour.KickPlan;

            /**
             * Creates a plain object from a KickPlan message. Also converts values to other types if specified.
             * @param {message.behaviour.KickPlan} message KickPlan
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.KickPlan, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this KickPlan message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this KickPlan to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace KickPlan {

            /**
             * KickType enum.
             * @name KickType
             * @memberof message.behaviour.KickPlan
             * @enum {number}
             * @property {number} SCRIPTED=0 SCRIPTED value
             * @property {number} IK_KICK=1 IK_KICK value
             */
            enum KickType {
                SCRIPTED = 0,
                IK_KICK = 1
            }
        }

        type WantsToKick$Properties = {
            kick?: boolean;
        };

        /**
         * Constructs a new WantsToKick.
         * @exports message.behaviour.WantsToKick
         * @constructor
         * @param {message.behaviour.WantsToKick$Properties=} [properties] Properties to set
         */
        class WantsToKick {

            /**
             * Constructs a new WantsToKick.
             * @exports message.behaviour.WantsToKick
             * @constructor
             * @param {message.behaviour.WantsToKick$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.WantsToKick$Properties);

            /**
             * WantsToKick kick.
             * @type {boolean}
             */
            public kick: boolean;

            /**
             * Creates a new WantsToKick instance using the specified properties.
             * @param {message.behaviour.WantsToKick$Properties=} [properties] Properties to set
             * @returns {message.behaviour.WantsToKick} WantsToKick instance
             */
            public static create(properties?: message.behaviour.WantsToKick$Properties): message.behaviour.WantsToKick;

            /**
             * Encodes the specified WantsToKick message. Does not implicitly {@link message.behaviour.WantsToKick.verify|verify} messages.
             * @param {message.behaviour.WantsToKick$Properties} message WantsToKick message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.WantsToKick$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified WantsToKick message, length delimited. Does not implicitly {@link message.behaviour.WantsToKick.verify|verify} messages.
             * @param {message.behaviour.WantsToKick$Properties} message WantsToKick message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.WantsToKick$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a WantsToKick message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.WantsToKick} WantsToKick
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.WantsToKick;

            /**
             * Decodes a WantsToKick message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.WantsToKick} WantsToKick
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.WantsToKick;

            /**
             * Verifies a WantsToKick message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a WantsToKick message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WantsToKick} WantsToKick
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.WantsToKick;

            /**
             * Creates a WantsToKick message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.WantsToKick.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WantsToKick} WantsToKick
             */
            public static from(object: { [k: string]: any }): message.behaviour.WantsToKick;

            /**
             * Creates a plain object from a WantsToKick message. Also converts values to other types if specified.
             * @param {message.behaviour.WantsToKick} message WantsToKick
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.WantsToKick, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this WantsToKick message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this WantsToKick to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type Look$Properties = {};

        /**
         * Constructs a new Look.
         * @exports message.behaviour.Look
         * @constructor
         * @param {message.behaviour.Look$Properties=} [properties] Properties to set
         */
        class Look {

            /**
             * Constructs a new Look.
             * @exports message.behaviour.Look
             * @constructor
             * @param {message.behaviour.Look$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.Look$Properties);

            /**
             * Creates a new Look instance using the specified properties.
             * @param {message.behaviour.Look$Properties=} [properties] Properties to set
             * @returns {message.behaviour.Look} Look instance
             */
            public static create(properties?: message.behaviour.Look$Properties): message.behaviour.Look;

            /**
             * Encodes the specified Look message. Does not implicitly {@link message.behaviour.Look.verify|verify} messages.
             * @param {message.behaviour.Look$Properties} message Look message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.Look$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Look message, length delimited. Does not implicitly {@link message.behaviour.Look.verify|verify} messages.
             * @param {message.behaviour.Look$Properties} message Look message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.Look$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Look message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.Look} Look
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.Look;

            /**
             * Decodes a Look message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.Look} Look
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.Look;

            /**
             * Verifies a Look message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a Look message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Look} Look
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.Look;

            /**
             * Creates a Look message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.Look.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Look} Look
             */
            public static from(object: { [k: string]: any }): message.behaviour.Look;

            /**
             * Creates a plain object from a Look message. Also converts values to other types if specified.
             * @param {message.behaviour.Look} message Look
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.Look, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Look message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Look to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace Look {

            type Fixation$Properties = {
                angle?: vec2$Properties;
                arcSize?: vec2$Properties;
            };

            /**
             * Constructs a new Fixation.
             * @exports message.behaviour.Look.Fixation
             * @constructor
             * @param {message.behaviour.Look.Fixation$Properties=} [properties] Properties to set
             */
            class Fixation {

                /**
                 * Constructs a new Fixation.
                 * @exports message.behaviour.Look.Fixation
                 * @constructor
                 * @param {message.behaviour.Look.Fixation$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.behaviour.Look.Fixation$Properties);

                /**
                 * Fixation angle.
                 * @type {(vec2$Properties|null)}
                 */
                public angle: (vec2$Properties|null);

                /**
                 * Fixation arcSize.
                 * @type {(vec2$Properties|null)}
                 */
                public arcSize: (vec2$Properties|null);

                /**
                 * Creates a new Fixation instance using the specified properties.
                 * @param {message.behaviour.Look.Fixation$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Look.Fixation} Fixation instance
                 */
                public static create(properties?: message.behaviour.Look.Fixation$Properties): message.behaviour.Look.Fixation;

                /**
                 * Encodes the specified Fixation message. Does not implicitly {@link message.behaviour.Look.Fixation.verify|verify} messages.
                 * @param {message.behaviour.Look.Fixation$Properties} message Fixation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.behaviour.Look.Fixation$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Fixation message, length delimited. Does not implicitly {@link message.behaviour.Look.Fixation.verify|verify} messages.
                 * @param {message.behaviour.Look.Fixation$Properties} message Fixation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.behaviour.Look.Fixation$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Fixation message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Look.Fixation} Fixation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.Look.Fixation;

                /**
                 * Decodes a Fixation message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Look.Fixation} Fixation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.Look.Fixation;

                /**
                 * Verifies a Fixation message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Fixation message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.Fixation} Fixation
                 */
                public static fromObject(object: { [k: string]: any }): message.behaviour.Look.Fixation;

                /**
                 * Creates a Fixation message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Look.Fixation.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.Fixation} Fixation
                 */
                public static from(object: { [k: string]: any }): message.behaviour.Look.Fixation;

                /**
                 * Creates a plain object from a Fixation message. Also converts values to other types if specified.
                 * @param {message.behaviour.Look.Fixation} message Fixation
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.behaviour.Look.Fixation, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Fixation message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Fixation to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type Saccade$Properties = {
                dwellTime?: google.protobuf.Duration$Properties;
                angle?: vec2$Properties;
                arcSize?: vec2$Properties;
            };

            /**
             * Constructs a new Saccade.
             * @exports message.behaviour.Look.Saccade
             * @constructor
             * @param {message.behaviour.Look.Saccade$Properties=} [properties] Properties to set
             */
            class Saccade {

                /**
                 * Constructs a new Saccade.
                 * @exports message.behaviour.Look.Saccade
                 * @constructor
                 * @param {message.behaviour.Look.Saccade$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.behaviour.Look.Saccade$Properties);

                /**
                 * Saccade dwellTime.
                 * @type {(google.protobuf.Duration$Properties|null)}
                 */
                public dwellTime: (google.protobuf.Duration$Properties|null);

                /**
                 * Saccade angle.
                 * @type {(vec2$Properties|null)}
                 */
                public angle: (vec2$Properties|null);

                /**
                 * Saccade arcSize.
                 * @type {(vec2$Properties|null)}
                 */
                public arcSize: (vec2$Properties|null);

                /**
                 * Creates a new Saccade instance using the specified properties.
                 * @param {message.behaviour.Look.Saccade$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Look.Saccade} Saccade instance
                 */
                public static create(properties?: message.behaviour.Look.Saccade$Properties): message.behaviour.Look.Saccade;

                /**
                 * Encodes the specified Saccade message. Does not implicitly {@link message.behaviour.Look.Saccade.verify|verify} messages.
                 * @param {message.behaviour.Look.Saccade$Properties} message Saccade message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.behaviour.Look.Saccade$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Saccade message, length delimited. Does not implicitly {@link message.behaviour.Look.Saccade.verify|verify} messages.
                 * @param {message.behaviour.Look.Saccade$Properties} message Saccade message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.behaviour.Look.Saccade$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Saccade message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Look.Saccade} Saccade
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.Look.Saccade;

                /**
                 * Decodes a Saccade message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Look.Saccade} Saccade
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.Look.Saccade;

                /**
                 * Verifies a Saccade message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Saccade message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.Saccade} Saccade
                 */
                public static fromObject(object: { [k: string]: any }): message.behaviour.Look.Saccade;

                /**
                 * Creates a Saccade message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Look.Saccade.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.Saccade} Saccade
                 */
                public static from(object: { [k: string]: any }): message.behaviour.Look.Saccade;

                /**
                 * Creates a plain object from a Saccade message. Also converts values to other types if specified.
                 * @param {message.behaviour.Look.Saccade} message Saccade
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.behaviour.Look.Saccade, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Saccade message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Saccade to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type Pan$Properties = {
                angle?: vec2$Properties;
                arcSize?: vec2$Properties;
            };

            /**
             * Constructs a new Pan.
             * @exports message.behaviour.Look.Pan
             * @constructor
             * @param {message.behaviour.Look.Pan$Properties=} [properties] Properties to set
             */
            class Pan {

                /**
                 * Constructs a new Pan.
                 * @exports message.behaviour.Look.Pan
                 * @constructor
                 * @param {message.behaviour.Look.Pan$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.behaviour.Look.Pan$Properties);

                /**
                 * Pan angle.
                 * @type {(vec2$Properties|null)}
                 */
                public angle: (vec2$Properties|null);

                /**
                 * Pan arcSize.
                 * @type {(vec2$Properties|null)}
                 */
                public arcSize: (vec2$Properties|null);

                /**
                 * Creates a new Pan instance using the specified properties.
                 * @param {message.behaviour.Look.Pan$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Look.Pan} Pan instance
                 */
                public static create(properties?: message.behaviour.Look.Pan$Properties): message.behaviour.Look.Pan;

                /**
                 * Encodes the specified Pan message. Does not implicitly {@link message.behaviour.Look.Pan.verify|verify} messages.
                 * @param {message.behaviour.Look.Pan$Properties} message Pan message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.behaviour.Look.Pan$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Pan message, length delimited. Does not implicitly {@link message.behaviour.Look.Pan.verify|verify} messages.
                 * @param {message.behaviour.Look.Pan$Properties} message Pan message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.behaviour.Look.Pan$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Pan message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Look.Pan} Pan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.Look.Pan;

                /**
                 * Decodes a Pan message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Look.Pan} Pan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.Look.Pan;

                /**
                 * Verifies a Pan message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Pan message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.Pan} Pan
                 */
                public static fromObject(object: { [k: string]: any }): message.behaviour.Look.Pan;

                /**
                 * Creates a Pan message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Look.Pan.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.Pan} Pan
                 */
                public static from(object: { [k: string]: any }): message.behaviour.Look.Pan;

                /**
                 * Creates a plain object from a Pan message. Also converts values to other types if specified.
                 * @param {message.behaviour.Look.Pan} message Pan
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.behaviour.Look.Pan, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Pan message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Pan to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type PanSelection$Properties = {
                lookAtGoalInsteadOfBall?: boolean;
            };

            /**
             * Constructs a new PanSelection.
             * @exports message.behaviour.Look.PanSelection
             * @constructor
             * @param {message.behaviour.Look.PanSelection$Properties=} [properties] Properties to set
             */
            class PanSelection {

                /**
                 * Constructs a new PanSelection.
                 * @exports message.behaviour.Look.PanSelection
                 * @constructor
                 * @param {message.behaviour.Look.PanSelection$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.behaviour.Look.PanSelection$Properties);

                /**
                 * PanSelection lookAtGoalInsteadOfBall.
                 * @type {boolean}
                 */
                public lookAtGoalInsteadOfBall: boolean;

                /**
                 * Creates a new PanSelection instance using the specified properties.
                 * @param {message.behaviour.Look.PanSelection$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Look.PanSelection} PanSelection instance
                 */
                public static create(properties?: message.behaviour.Look.PanSelection$Properties): message.behaviour.Look.PanSelection;

                /**
                 * Encodes the specified PanSelection message. Does not implicitly {@link message.behaviour.Look.PanSelection.verify|verify} messages.
                 * @param {message.behaviour.Look.PanSelection$Properties} message PanSelection message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.behaviour.Look.PanSelection$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified PanSelection message, length delimited. Does not implicitly {@link message.behaviour.Look.PanSelection.verify|verify} messages.
                 * @param {message.behaviour.Look.PanSelection$Properties} message PanSelection message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.behaviour.Look.PanSelection$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a PanSelection message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Look.PanSelection} PanSelection
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.Look.PanSelection;

                /**
                 * Decodes a PanSelection message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Look.PanSelection} PanSelection
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.Look.PanSelection;

                /**
                 * Verifies a PanSelection message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a PanSelection message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.PanSelection} PanSelection
                 */
                public static fromObject(object: { [k: string]: any }): message.behaviour.Look.PanSelection;

                /**
                 * Creates a PanSelection message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Look.PanSelection.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Look.PanSelection} PanSelection
                 */
                public static from(object: { [k: string]: any }): message.behaviour.Look.PanSelection;

                /**
                 * Creates a plain object from a PanSelection message. Also converts values to other types if specified.
                 * @param {message.behaviour.Look.PanSelection} message PanSelection
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.behaviour.Look.PanSelection, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this PanSelection message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this PanSelection to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type MotionCommand$Properties = {
            type?: message.behaviour.MotionCommand.Type;
            goalState?: vec3$Properties;
            kickTarget?: vec2$Properties;
            walkCommand?: vec3$Properties;
        };

        /**
         * Constructs a new MotionCommand.
         * @exports message.behaviour.MotionCommand
         * @constructor
         * @param {message.behaviour.MotionCommand$Properties=} [properties] Properties to set
         */
        class MotionCommand {

            /**
             * Constructs a new MotionCommand.
             * @exports message.behaviour.MotionCommand
             * @constructor
             * @param {message.behaviour.MotionCommand$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.MotionCommand$Properties);

            /**
             * MotionCommand type.
             * @type {message.behaviour.MotionCommand.Type}
             */
            public type: message.behaviour.MotionCommand.Type;

            /**
             * MotionCommand goalState.
             * @type {(vec3$Properties|null)}
             */
            public goalState: (vec3$Properties|null);

            /**
             * MotionCommand kickTarget.
             * @type {(vec2$Properties|null)}
             */
            public kickTarget: (vec2$Properties|null);

            /**
             * MotionCommand walkCommand.
             * @type {(vec3$Properties|null)}
             */
            public walkCommand: (vec3$Properties|null);

            /**
             * Creates a new MotionCommand instance using the specified properties.
             * @param {message.behaviour.MotionCommand$Properties=} [properties] Properties to set
             * @returns {message.behaviour.MotionCommand} MotionCommand instance
             */
            public static create(properties?: message.behaviour.MotionCommand$Properties): message.behaviour.MotionCommand;

            /**
             * Encodes the specified MotionCommand message. Does not implicitly {@link message.behaviour.MotionCommand.verify|verify} messages.
             * @param {message.behaviour.MotionCommand$Properties} message MotionCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.MotionCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified MotionCommand message, length delimited. Does not implicitly {@link message.behaviour.MotionCommand.verify|verify} messages.
             * @param {message.behaviour.MotionCommand$Properties} message MotionCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.MotionCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a MotionCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.MotionCommand} MotionCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.MotionCommand;

            /**
             * Decodes a MotionCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.MotionCommand} MotionCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.MotionCommand;

            /**
             * Verifies a MotionCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a MotionCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.MotionCommand} MotionCommand
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.MotionCommand;

            /**
             * Creates a MotionCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.MotionCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.MotionCommand} MotionCommand
             */
            public static from(object: { [k: string]: any }): message.behaviour.MotionCommand;

            /**
             * Creates a plain object from a MotionCommand message. Also converts values to other types if specified.
             * @param {message.behaviour.MotionCommand} message MotionCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.MotionCommand, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this MotionCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this MotionCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace MotionCommand {

            /**
             * Type enum.
             * @name Type
             * @memberof message.behaviour.MotionCommand
             * @enum {number}
             * @property {number} StandStill=0 StandStill value
             * @property {number} WalkToState=1 WalkToState value
             * @property {number} BallApproach=2 BallApproach value
             * @property {number} DirectCommand=3 DirectCommand value
             */
            enum Type {
                StandStill = 0,
                WalkToState = 1,
                BallApproach = 2,
                DirectCommand = 3
            }
        }

        type Nod$Properties = {
            value?: boolean;
        };

        /**
         * Constructs a new Nod.
         * @exports message.behaviour.Nod
         * @constructor
         * @param {message.behaviour.Nod$Properties=} [properties] Properties to set
         */
        class Nod {

            /**
             * Constructs a new Nod.
             * @exports message.behaviour.Nod
             * @constructor
             * @param {message.behaviour.Nod$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.Nod$Properties);

            /**
             * Nod value.
             * @type {boolean}
             */
            public value: boolean;

            /**
             * Creates a new Nod instance using the specified properties.
             * @param {message.behaviour.Nod$Properties=} [properties] Properties to set
             * @returns {message.behaviour.Nod} Nod instance
             */
            public static create(properties?: message.behaviour.Nod$Properties): message.behaviour.Nod;

            /**
             * Encodes the specified Nod message. Does not implicitly {@link message.behaviour.Nod.verify|verify} messages.
             * @param {message.behaviour.Nod$Properties} message Nod message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.Nod$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Nod message, length delimited. Does not implicitly {@link message.behaviour.Nod.verify|verify} messages.
             * @param {message.behaviour.Nod$Properties} message Nod message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.Nod$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Nod message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.Nod} Nod
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.Nod;

            /**
             * Decodes a Nod message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.Nod} Nod
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.Nod;

            /**
             * Verifies a Nod message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a Nod message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Nod} Nod
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.Nod;

            /**
             * Creates a Nod message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.Nod.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Nod} Nod
             */
            public static from(object: { [k: string]: any }): message.behaviour.Nod;

            /**
             * Creates a plain object from a Nod message. Also converts values to other types if specified.
             * @param {message.behaviour.Nod} message Nod
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.Nod, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Nod message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Nod to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type ServoCommand$Properties = {
            source?: (number|Long);
            time?: google.protobuf.Timestamp$Properties;
            id?: number;
            position?: number;
            gain?: number;
            torque?: number;
        };

        /**
         * Constructs a new ServoCommand.
         * @exports message.behaviour.ServoCommand
         * @constructor
         * @param {message.behaviour.ServoCommand$Properties=} [properties] Properties to set
         */
        class ServoCommand {

            /**
             * Constructs a new ServoCommand.
             * @exports message.behaviour.ServoCommand
             * @constructor
             * @param {message.behaviour.ServoCommand$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.ServoCommand$Properties);

            /**
             * ServoCommand source.
             * @type {number|Long}
             */
            public source: (number|Long);

            /**
             * ServoCommand time.
             * @type {(google.protobuf.Timestamp$Properties|null)}
             */
            public time: (google.protobuf.Timestamp$Properties|null);

            /**
             * ServoCommand id.
             * @type {number}
             */
            public id: number;

            /**
             * ServoCommand position.
             * @type {number}
             */
            public position: number;

            /**
             * ServoCommand gain.
             * @type {number}
             */
            public gain: number;

            /**
             * ServoCommand torque.
             * @type {number}
             */
            public torque: number;

            /**
             * Creates a new ServoCommand instance using the specified properties.
             * @param {message.behaviour.ServoCommand$Properties=} [properties] Properties to set
             * @returns {message.behaviour.ServoCommand} ServoCommand instance
             */
            public static create(properties?: message.behaviour.ServoCommand$Properties): message.behaviour.ServoCommand;

            /**
             * Encodes the specified ServoCommand message. Does not implicitly {@link message.behaviour.ServoCommand.verify|verify} messages.
             * @param {message.behaviour.ServoCommand$Properties} message ServoCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.ServoCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified ServoCommand message, length delimited. Does not implicitly {@link message.behaviour.ServoCommand.verify|verify} messages.
             * @param {message.behaviour.ServoCommand$Properties} message ServoCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.ServoCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ServoCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.ServoCommand} ServoCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.ServoCommand;

            /**
             * Decodes a ServoCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.ServoCommand} ServoCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.ServoCommand;

            /**
             * Verifies a ServoCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a ServoCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.ServoCommand} ServoCommand
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.ServoCommand;

            /**
             * Creates a ServoCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.ServoCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.ServoCommand} ServoCommand
             */
            public static from(object: { [k: string]: any }): message.behaviour.ServoCommand;

            /**
             * Creates a plain object from a ServoCommand message. Also converts values to other types if specified.
             * @param {message.behaviour.ServoCommand} message ServoCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.ServoCommand, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this ServoCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this ServoCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type SoccerObjectPriority$Properties = {
            ball?: number;
            goal?: number;
            line?: number;
            searchType?: message.behaviour.SoccerObjectPriority.SearchType;
        };

        /**
         * Constructs a new SoccerObjectPriority.
         * @exports message.behaviour.SoccerObjectPriority
         * @constructor
         * @param {message.behaviour.SoccerObjectPriority$Properties=} [properties] Properties to set
         */
        class SoccerObjectPriority {

            /**
             * Constructs a new SoccerObjectPriority.
             * @exports message.behaviour.SoccerObjectPriority
             * @constructor
             * @param {message.behaviour.SoccerObjectPriority$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.SoccerObjectPriority$Properties);

            /**
             * SoccerObjectPriority ball.
             * @type {number}
             */
            public ball: number;

            /**
             * SoccerObjectPriority goal.
             * @type {number}
             */
            public goal: number;

            /**
             * SoccerObjectPriority line.
             * @type {number}
             */
            public line: number;

            /**
             * SoccerObjectPriority searchType.
             * @type {message.behaviour.SoccerObjectPriority.SearchType}
             */
            public searchType: message.behaviour.SoccerObjectPriority.SearchType;

            /**
             * Creates a new SoccerObjectPriority instance using the specified properties.
             * @param {message.behaviour.SoccerObjectPriority$Properties=} [properties] Properties to set
             * @returns {message.behaviour.SoccerObjectPriority} SoccerObjectPriority instance
             */
            public static create(properties?: message.behaviour.SoccerObjectPriority$Properties): message.behaviour.SoccerObjectPriority;

            /**
             * Encodes the specified SoccerObjectPriority message. Does not implicitly {@link message.behaviour.SoccerObjectPriority.verify|verify} messages.
             * @param {message.behaviour.SoccerObjectPriority$Properties} message SoccerObjectPriority message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.SoccerObjectPriority$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified SoccerObjectPriority message, length delimited. Does not implicitly {@link message.behaviour.SoccerObjectPriority.verify|verify} messages.
             * @param {message.behaviour.SoccerObjectPriority$Properties} message SoccerObjectPriority message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.SoccerObjectPriority$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SoccerObjectPriority message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.SoccerObjectPriority} SoccerObjectPriority
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.SoccerObjectPriority;

            /**
             * Decodes a SoccerObjectPriority message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.SoccerObjectPriority} SoccerObjectPriority
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.SoccerObjectPriority;

            /**
             * Verifies a SoccerObjectPriority message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a SoccerObjectPriority message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.SoccerObjectPriority} SoccerObjectPriority
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.SoccerObjectPriority;

            /**
             * Creates a SoccerObjectPriority message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.SoccerObjectPriority.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.SoccerObjectPriority} SoccerObjectPriority
             */
            public static from(object: { [k: string]: any }): message.behaviour.SoccerObjectPriority;

            /**
             * Creates a plain object from a SoccerObjectPriority message. Also converts values to other types if specified.
             * @param {message.behaviour.SoccerObjectPriority} message SoccerObjectPriority
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.SoccerObjectPriority, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this SoccerObjectPriority message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this SoccerObjectPriority to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace SoccerObjectPriority {

            /**
             * SearchType enum.
             * @name SearchType
             * @memberof message.behaviour.SoccerObjectPriority
             * @enum {number}
             * @property {number} LOST=0 LOST value
             * @property {number} FIND_ADDITIONAL_OBJECTS=1 FIND_ADDITIONAL_OBJECTS value
             * @property {number} GOAL_SEARCH=2 GOAL_SEARCH value
             * @property {number} GOAL_LEFT=3 GOAL_LEFT value
             * @property {number} GOAL_RIGHT=4 GOAL_RIGHT value
             * @property {number} GROUND_LEFT=5 GROUND_LEFT value
             * @property {number} GROUND_RIGHT=6 GROUND_RIGHT value
             * @property {number} OTHE=7 OTHE value
             */
            enum SearchType {
                LOST = 0,
                FIND_ADDITIONAL_OBJECTS = 1,
                GOAL_SEARCH = 2,
                GOAL_LEFT = 3,
                GOAL_RIGHT = 4,
                GROUND_LEFT = 5,
                GROUND_RIGHT = 6,
                OTHE = 7
            }
        }

        type Subsumption$Properties = {
            actionRegister?: message.behaviour.Subsumption.ActionRegister$Properties[];
            actionStateChange?: message.behaviour.Subsumption.ActionStateChange$Properties[];
            actionPriorityChange?: message.behaviour.Subsumption.ActionPriorites$Properties[];
        };

        /**
         * Constructs a new Subsumption.
         * @exports message.behaviour.Subsumption
         * @constructor
         * @param {message.behaviour.Subsumption$Properties=} [properties] Properties to set
         */
        class Subsumption {

            /**
             * Constructs a new Subsumption.
             * @exports message.behaviour.Subsumption
             * @constructor
             * @param {message.behaviour.Subsumption$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.Subsumption$Properties);

            /**
             * Subsumption actionRegister.
             * @type {Array.<message.behaviour.Subsumption.ActionRegister$Properties>}
             */
            public actionRegister: message.behaviour.Subsumption.ActionRegister$Properties[];

            /**
             * Subsumption actionStateChange.
             * @type {Array.<message.behaviour.Subsumption.ActionStateChange$Properties>}
             */
            public actionStateChange: message.behaviour.Subsumption.ActionStateChange$Properties[];

            /**
             * Subsumption actionPriorityChange.
             * @type {Array.<message.behaviour.Subsumption.ActionPriorites$Properties>}
             */
            public actionPriorityChange: message.behaviour.Subsumption.ActionPriorites$Properties[];

            /**
             * Creates a new Subsumption instance using the specified properties.
             * @param {message.behaviour.Subsumption$Properties=} [properties] Properties to set
             * @returns {message.behaviour.Subsumption} Subsumption instance
             */
            public static create(properties?: message.behaviour.Subsumption$Properties): message.behaviour.Subsumption;

            /**
             * Encodes the specified Subsumption message. Does not implicitly {@link message.behaviour.Subsumption.verify|verify} messages.
             * @param {message.behaviour.Subsumption$Properties} message Subsumption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.Subsumption$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Subsumption message, length delimited. Does not implicitly {@link message.behaviour.Subsumption.verify|verify} messages.
             * @param {message.behaviour.Subsumption$Properties} message Subsumption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.Subsumption$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Subsumption message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.Subsumption} Subsumption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.Subsumption;

            /**
             * Decodes a Subsumption message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.Subsumption} Subsumption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.Subsumption;

            /**
             * Verifies a Subsumption message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a Subsumption message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Subsumption} Subsumption
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.Subsumption;

            /**
             * Creates a Subsumption message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.Subsumption.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.Subsumption} Subsumption
             */
            public static from(object: { [k: string]: any }): message.behaviour.Subsumption;

            /**
             * Creates a plain object from a Subsumption message. Also converts values to other types if specified.
             * @param {message.behaviour.Subsumption} message Subsumption
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.Subsumption, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Subsumption message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Subsumption to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace Subsumption {

            type LimbSet$Properties = {
                priority?: number;
                limbs?: number[];
            };

            /**
             * Constructs a new LimbSet.
             * @exports message.behaviour.Subsumption.LimbSet
             * @constructor
             * @param {message.behaviour.Subsumption.LimbSet$Properties=} [properties] Properties to set
             */
            class LimbSet {

                /**
                 * Constructs a new LimbSet.
                 * @exports message.behaviour.Subsumption.LimbSet
                 * @constructor
                 * @param {message.behaviour.Subsumption.LimbSet$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.behaviour.Subsumption.LimbSet$Properties);

                /**
                 * LimbSet priority.
                 * @type {number}
                 */
                public priority: number;

                /**
                 * LimbSet limbs.
                 * @type {Array.<number>}
                 */
                public limbs: number[];

                /**
                 * Creates a new LimbSet instance using the specified properties.
                 * @param {message.behaviour.Subsumption.LimbSet$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Subsumption.LimbSet} LimbSet instance
                 */
                public static create(properties?: message.behaviour.Subsumption.LimbSet$Properties): message.behaviour.Subsumption.LimbSet;

                /**
                 * Encodes the specified LimbSet message. Does not implicitly {@link message.behaviour.Subsumption.LimbSet.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.LimbSet$Properties} message LimbSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.behaviour.Subsumption.LimbSet$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified LimbSet message, length delimited. Does not implicitly {@link message.behaviour.Subsumption.LimbSet.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.LimbSet$Properties} message LimbSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.behaviour.Subsumption.LimbSet$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a LimbSet message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Subsumption.LimbSet} LimbSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.Subsumption.LimbSet;

                /**
                 * Decodes a LimbSet message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Subsumption.LimbSet} LimbSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.Subsumption.LimbSet;

                /**
                 * Verifies a LimbSet message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a LimbSet message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.LimbSet} LimbSet
                 */
                public static fromObject(object: { [k: string]: any }): message.behaviour.Subsumption.LimbSet;

                /**
                 * Creates a LimbSet message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Subsumption.LimbSet.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.LimbSet} LimbSet
                 */
                public static from(object: { [k: string]: any }): message.behaviour.Subsumption.LimbSet;

                /**
                 * Creates a plain object from a LimbSet message. Also converts values to other types if specified.
                 * @param {message.behaviour.Subsumption.LimbSet} message LimbSet
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.behaviour.Subsumption.LimbSet, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this LimbSet message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this LimbSet to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type ActionRegister$Properties = {
                id?: number;
                name?: string;
                limbSet?: message.behaviour.Subsumption.LimbSet$Properties[];
            };

            /**
             * Constructs a new ActionRegister.
             * @exports message.behaviour.Subsumption.ActionRegister
             * @constructor
             * @param {message.behaviour.Subsumption.ActionRegister$Properties=} [properties] Properties to set
             */
            class ActionRegister {

                /**
                 * Constructs a new ActionRegister.
                 * @exports message.behaviour.Subsumption.ActionRegister
                 * @constructor
                 * @param {message.behaviour.Subsumption.ActionRegister$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.behaviour.Subsumption.ActionRegister$Properties);

                /**
                 * ActionRegister id.
                 * @type {number}
                 */
                public id: number;

                /**
                 * ActionRegister name.
                 * @type {string}
                 */
                public name: string;

                /**
                 * ActionRegister limbSet.
                 * @type {Array.<message.behaviour.Subsumption.LimbSet$Properties>}
                 */
                public limbSet: message.behaviour.Subsumption.LimbSet$Properties[];

                /**
                 * Creates a new ActionRegister instance using the specified properties.
                 * @param {message.behaviour.Subsumption.ActionRegister$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Subsumption.ActionRegister} ActionRegister instance
                 */
                public static create(properties?: message.behaviour.Subsumption.ActionRegister$Properties): message.behaviour.Subsumption.ActionRegister;

                /**
                 * Encodes the specified ActionRegister message. Does not implicitly {@link message.behaviour.Subsumption.ActionRegister.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.ActionRegister$Properties} message ActionRegister message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.behaviour.Subsumption.ActionRegister$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ActionRegister message, length delimited. Does not implicitly {@link message.behaviour.Subsumption.ActionRegister.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.ActionRegister$Properties} message ActionRegister message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.behaviour.Subsumption.ActionRegister$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an ActionRegister message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Subsumption.ActionRegister} ActionRegister
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.Subsumption.ActionRegister;

                /**
                 * Decodes an ActionRegister message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Subsumption.ActionRegister} ActionRegister
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.Subsumption.ActionRegister;

                /**
                 * Verifies an ActionRegister message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an ActionRegister message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.ActionRegister} ActionRegister
                 */
                public static fromObject(object: { [k: string]: any }): message.behaviour.Subsumption.ActionRegister;

                /**
                 * Creates an ActionRegister message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Subsumption.ActionRegister.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.ActionRegister} ActionRegister
                 */
                public static from(object: { [k: string]: any }): message.behaviour.Subsumption.ActionRegister;

                /**
                 * Creates a plain object from an ActionRegister message. Also converts values to other types if specified.
                 * @param {message.behaviour.Subsumption.ActionRegister} message ActionRegister
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.behaviour.Subsumption.ActionRegister, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this ActionRegister message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this ActionRegister to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type ActionStateChange$Properties = {
                state?: message.behaviour.Subsumption.ActionStateChange.State;
                name?: string;
                limbs?: number[];
            };

            /**
             * Constructs a new ActionStateChange.
             * @exports message.behaviour.Subsumption.ActionStateChange
             * @constructor
             * @param {message.behaviour.Subsumption.ActionStateChange$Properties=} [properties] Properties to set
             */
            class ActionStateChange {

                /**
                 * Constructs a new ActionStateChange.
                 * @exports message.behaviour.Subsumption.ActionStateChange
                 * @constructor
                 * @param {message.behaviour.Subsumption.ActionStateChange$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.behaviour.Subsumption.ActionStateChange$Properties);

                /**
                 * ActionStateChange state.
                 * @type {message.behaviour.Subsumption.ActionStateChange.State}
                 */
                public state: message.behaviour.Subsumption.ActionStateChange.State;

                /**
                 * ActionStateChange name.
                 * @type {string}
                 */
                public name: string;

                /**
                 * ActionStateChange limbs.
                 * @type {Array.<number>}
                 */
                public limbs: number[];

                /**
                 * Creates a new ActionStateChange instance using the specified properties.
                 * @param {message.behaviour.Subsumption.ActionStateChange$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Subsumption.ActionStateChange} ActionStateChange instance
                 */
                public static create(properties?: message.behaviour.Subsumption.ActionStateChange$Properties): message.behaviour.Subsumption.ActionStateChange;

                /**
                 * Encodes the specified ActionStateChange message. Does not implicitly {@link message.behaviour.Subsumption.ActionStateChange.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.ActionStateChange$Properties} message ActionStateChange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.behaviour.Subsumption.ActionStateChange$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ActionStateChange message, length delimited. Does not implicitly {@link message.behaviour.Subsumption.ActionStateChange.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.ActionStateChange$Properties} message ActionStateChange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.behaviour.Subsumption.ActionStateChange$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an ActionStateChange message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Subsumption.ActionStateChange} ActionStateChange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.Subsumption.ActionStateChange;

                /**
                 * Decodes an ActionStateChange message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Subsumption.ActionStateChange} ActionStateChange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.Subsumption.ActionStateChange;

                /**
                 * Verifies an ActionStateChange message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an ActionStateChange message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.ActionStateChange} ActionStateChange
                 */
                public static fromObject(object: { [k: string]: any }): message.behaviour.Subsumption.ActionStateChange;

                /**
                 * Creates an ActionStateChange message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Subsumption.ActionStateChange.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.ActionStateChange} ActionStateChange
                 */
                public static from(object: { [k: string]: any }): message.behaviour.Subsumption.ActionStateChange;

                /**
                 * Creates a plain object from an ActionStateChange message. Also converts values to other types if specified.
                 * @param {message.behaviour.Subsumption.ActionStateChange} message ActionStateChange
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.behaviour.Subsumption.ActionStateChange, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this ActionStateChange message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this ActionStateChange to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace ActionStateChange {

                /**
                 * State enum.
                 * @name State
                 * @memberof message.behaviour.Subsumption.ActionStateChange
                 * @enum {number}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} START=1 START value
                 * @property {number} KILL=2 KILL value
                 */
                enum State {
                    UNKNOWN = 0,
                    START = 1,
                    KILL = 2
                }
            }

            type ActionPriorites$Properties = {
                id?: number;
                priorities?: number[];
            };

            /**
             * Constructs a new ActionPriorites.
             * @exports message.behaviour.Subsumption.ActionPriorites
             * @constructor
             * @param {message.behaviour.Subsumption.ActionPriorites$Properties=} [properties] Properties to set
             */
            class ActionPriorites {

                /**
                 * Constructs a new ActionPriorites.
                 * @exports message.behaviour.Subsumption.ActionPriorites
                 * @constructor
                 * @param {message.behaviour.Subsumption.ActionPriorites$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.behaviour.Subsumption.ActionPriorites$Properties);

                /**
                 * ActionPriorites id.
                 * @type {number}
                 */
                public id: number;

                /**
                 * ActionPriorites priorities.
                 * @type {Array.<number>}
                 */
                public priorities: number[];

                /**
                 * Creates a new ActionPriorites instance using the specified properties.
                 * @param {message.behaviour.Subsumption.ActionPriorites$Properties=} [properties] Properties to set
                 * @returns {message.behaviour.Subsumption.ActionPriorites} ActionPriorites instance
                 */
                public static create(properties?: message.behaviour.Subsumption.ActionPriorites$Properties): message.behaviour.Subsumption.ActionPriorites;

                /**
                 * Encodes the specified ActionPriorites message. Does not implicitly {@link message.behaviour.Subsumption.ActionPriorites.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.ActionPriorites$Properties} message ActionPriorites message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.behaviour.Subsumption.ActionPriorites$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ActionPriorites message, length delimited. Does not implicitly {@link message.behaviour.Subsumption.ActionPriorites.verify|verify} messages.
                 * @param {message.behaviour.Subsumption.ActionPriorites$Properties} message ActionPriorites message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.behaviour.Subsumption.ActionPriorites$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an ActionPriorites message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.behaviour.Subsumption.ActionPriorites} ActionPriorites
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.Subsumption.ActionPriorites;

                /**
                 * Decodes an ActionPriorites message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.behaviour.Subsumption.ActionPriorites} ActionPriorites
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.Subsumption.ActionPriorites;

                /**
                 * Verifies an ActionPriorites message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an ActionPriorites message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.ActionPriorites} ActionPriorites
                 */
                public static fromObject(object: { [k: string]: any }): message.behaviour.Subsumption.ActionPriorites;

                /**
                 * Creates an ActionPriorites message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.behaviour.Subsumption.ActionPriorites.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.behaviour.Subsumption.ActionPriorites} ActionPriorites
                 */
                public static from(object: { [k: string]: any }): message.behaviour.Subsumption.ActionPriorites;

                /**
                 * Creates a plain object from an ActionPriorites message. Also converts values to other types if specified.
                 * @param {message.behaviour.Subsumption.ActionPriorites} message ActionPriorites
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.behaviour.Subsumption.ActionPriorites, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this ActionPriorites message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this ActionPriorites to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type WalkPath$Properties = {
            states?: vec3$Properties[];
            ballSpace?: vec3$Properties;
            start?: vec3$Properties;
            goal?: vec3$Properties;
            command?: message.behaviour.MotionCommand$Properties;
        };

        /**
         * Constructs a new WalkPath.
         * @exports message.behaviour.WalkPath
         * @constructor
         * @param {message.behaviour.WalkPath$Properties=} [properties] Properties to set
         */
        class WalkPath {

            /**
             * Constructs a new WalkPath.
             * @exports message.behaviour.WalkPath
             * @constructor
             * @param {message.behaviour.WalkPath$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.behaviour.WalkPath$Properties);

            /**
             * WalkPath states.
             * @type {Array.<vec3$Properties>}
             */
            public states: vec3$Properties[];

            /**
             * WalkPath ballSpace.
             * @type {(vec3$Properties|null)}
             */
            public ballSpace: (vec3$Properties|null);

            /**
             * WalkPath start.
             * @type {(vec3$Properties|null)}
             */
            public start: (vec3$Properties|null);

            /**
             * WalkPath goal.
             * @type {(vec3$Properties|null)}
             */
            public goal: (vec3$Properties|null);

            /**
             * WalkPath command.
             * @type {(message.behaviour.MotionCommand$Properties|null)}
             */
            public command: (message.behaviour.MotionCommand$Properties|null);

            /**
             * Creates a new WalkPath instance using the specified properties.
             * @param {message.behaviour.WalkPath$Properties=} [properties] Properties to set
             * @returns {message.behaviour.WalkPath} WalkPath instance
             */
            public static create(properties?: message.behaviour.WalkPath$Properties): message.behaviour.WalkPath;

            /**
             * Encodes the specified WalkPath message. Does not implicitly {@link message.behaviour.WalkPath.verify|verify} messages.
             * @param {message.behaviour.WalkPath$Properties} message WalkPath message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.behaviour.WalkPath$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified WalkPath message, length delimited. Does not implicitly {@link message.behaviour.WalkPath.verify|verify} messages.
             * @param {message.behaviour.WalkPath$Properties} message WalkPath message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.behaviour.WalkPath$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a WalkPath message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.behaviour.WalkPath} WalkPath
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.behaviour.WalkPath;

            /**
             * Decodes a WalkPath message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.behaviour.WalkPath} WalkPath
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.behaviour.WalkPath;

            /**
             * Verifies a WalkPath message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a WalkPath message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WalkPath} WalkPath
             */
            public static fromObject(object: { [k: string]: any }): message.behaviour.WalkPath;

            /**
             * Creates a WalkPath message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.behaviour.WalkPath.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.behaviour.WalkPath} WalkPath
             */
            public static from(object: { [k: string]: any }): message.behaviour.WalkPath;

            /**
             * Creates a plain object from a WalkPath message. Also converts values to other types if specified.
             * @param {message.behaviour.WalkPath} message WalkPath
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.behaviour.WalkPath, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this WalkPath message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this WalkPath to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }

    /**
     * Namespace input.
     * @exports message.input
     * @namespace
     */
    namespace input {

        type CameraParameters$Properties = {
            imageSizePixels?: uvec2$Properties;
            FOV?: vec2$Properties;
            pixelsToTanThetaFactor?: vec2$Properties;
            focalLengthPixels?: number;
            distortionFactor?: number;
        };

        /**
         * Constructs a new CameraParameters.
         * @exports message.input.CameraParameters
         * @constructor
         * @param {message.input.CameraParameters$Properties=} [properties] Properties to set
         */
        class CameraParameters {

            /**
             * Constructs a new CameraParameters.
             * @exports message.input.CameraParameters
             * @constructor
             * @param {message.input.CameraParameters$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.CameraParameters$Properties);

            /**
             * CameraParameters imageSizePixels.
             * @type {(uvec2$Properties|null)}
             */
            public imageSizePixels: (uvec2$Properties|null);

            /**
             * CameraParameters FOV.
             * @type {(vec2$Properties|null)}
             */
            public FOV: (vec2$Properties|null);

            /**
             * CameraParameters pixelsToTanThetaFactor.
             * @type {(vec2$Properties|null)}
             */
            public pixelsToTanThetaFactor: (vec2$Properties|null);

            /**
             * CameraParameters focalLengthPixels.
             * @type {number}
             */
            public focalLengthPixels: number;

            /**
             * CameraParameters distortionFactor.
             * @type {number}
             */
            public distortionFactor: number;

            /**
             * Creates a new CameraParameters instance using the specified properties.
             * @param {message.input.CameraParameters$Properties=} [properties] Properties to set
             * @returns {message.input.CameraParameters} CameraParameters instance
             */
            public static create(properties?: message.input.CameraParameters$Properties): message.input.CameraParameters;

            /**
             * Encodes the specified CameraParameters message. Does not implicitly {@link message.input.CameraParameters.verify|verify} messages.
             * @param {message.input.CameraParameters$Properties} message CameraParameters message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.CameraParameters$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified CameraParameters message, length delimited. Does not implicitly {@link message.input.CameraParameters.verify|verify} messages.
             * @param {message.input.CameraParameters$Properties} message CameraParameters message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.CameraParameters$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a CameraParameters message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.CameraParameters} CameraParameters
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.CameraParameters;

            /**
             * Decodes a CameraParameters message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.CameraParameters} CameraParameters
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.CameraParameters;

            /**
             * Verifies a CameraParameters message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a CameraParameters message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.CameraParameters} CameraParameters
             */
            public static fromObject(object: { [k: string]: any }): message.input.CameraParameters;

            /**
             * Creates a CameraParameters message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.CameraParameters.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.CameraParameters} CameraParameters
             */
            public static from(object: { [k: string]: any }): message.input.CameraParameters;

            /**
             * Creates a plain object from a CameraParameters message. Also converts values to other types if specified.
             * @param {message.input.CameraParameters} message CameraParameters
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.CameraParameters, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this CameraParameters message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this CameraParameters to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type GameEvents$Properties = {};

        /**
         * Constructs a new GameEvents.
         * @exports message.input.GameEvents
         * @constructor
         * @param {message.input.GameEvents$Properties=} [properties] Properties to set
         */
        class GameEvents {

            /**
             * Constructs a new GameEvents.
             * @exports message.input.GameEvents
             * @constructor
             * @param {message.input.GameEvents$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.GameEvents$Properties);

            /**
             * Creates a new GameEvents instance using the specified properties.
             * @param {message.input.GameEvents$Properties=} [properties] Properties to set
             * @returns {message.input.GameEvents} GameEvents instance
             */
            public static create(properties?: message.input.GameEvents$Properties): message.input.GameEvents;

            /**
             * Encodes the specified GameEvents message. Does not implicitly {@link message.input.GameEvents.verify|verify} messages.
             * @param {message.input.GameEvents$Properties} message GameEvents message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.GameEvents$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified GameEvents message, length delimited. Does not implicitly {@link message.input.GameEvents.verify|verify} messages.
             * @param {message.input.GameEvents$Properties} message GameEvents message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.GameEvents$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GameEvents message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.GameEvents} GameEvents
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameEvents;

            /**
             * Decodes a GameEvents message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.GameEvents} GameEvents
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameEvents;

            /**
             * Verifies a GameEvents message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a GameEvents message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.GameEvents} GameEvents
             */
            public static fromObject(object: { [k: string]: any }): message.input.GameEvents;

            /**
             * Creates a GameEvents message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.GameEvents.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.GameEvents} GameEvents
             */
            public static from(object: { [k: string]: any }): message.input.GameEvents;

            /**
             * Creates a plain object from a GameEvents message. Also converts values to other types if specified.
             * @param {message.input.GameEvents} message GameEvents
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.GameEvents, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this GameEvents message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this GameEvents to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace GameEvents {

            /**
             * Context enum.
             * @name Context
             * @memberof message.input.GameEvents
             * @enum {number}
             * @property {number} UNKNOWN_CONTEXT=0 UNKNOWN_CONTEXT value
             * @property {number} SELF=1 SELF value
             * @property {number} TEAM=2 TEAM value
             * @property {number} OPPONENT=3 OPPONENT value
             * @property {number} UNKNOWN=4 UNKNOWN value
             */
            enum Context {
                UNKNOWN_CONTEXT = 0,
                SELF = 1,
                TEAM = 2,
                OPPONENT = 3,
                UNKNOWN = 4
            }

            /**
             * TeamColour enum.
             * @name TeamColour
             * @memberof message.input.GameEvents
             * @enum {number}
             * @property {number} UNKNOWN_TEAM_COLOUR=0 UNKNOWN_TEAM_COLOUR value
             * @property {number} CYAN=1 CYAN value
             * @property {number} MAGENTA=2 MAGENTA value
             */
            enum TeamColour {
                UNKNOWN_TEAM_COLOUR = 0,
                CYAN = 1,
                MAGENTA = 2
            }

            type Score$Properties = {
                ownScore?: number;
                opponentScore?: number;
            };

            /**
             * Constructs a new Score.
             * @exports message.input.GameEvents.Score
             * @constructor
             * @param {message.input.GameEvents.Score$Properties=} [properties] Properties to set
             */
            class Score {

                /**
                 * Constructs a new Score.
                 * @exports message.input.GameEvents.Score
                 * @constructor
                 * @param {message.input.GameEvents.Score$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.GameEvents.Score$Properties);

                /**
                 * Score ownScore.
                 * @type {number}
                 */
                public ownScore: number;

                /**
                 * Score opponentScore.
                 * @type {number}
                 */
                public opponentScore: number;

                /**
                 * Creates a new Score instance using the specified properties.
                 * @param {message.input.GameEvents.Score$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.Score} Score instance
                 */
                public static create(properties?: message.input.GameEvents.Score$Properties): message.input.GameEvents.Score;

                /**
                 * Encodes the specified Score message. Does not implicitly {@link message.input.GameEvents.Score.verify|verify} messages.
                 * @param {message.input.GameEvents.Score$Properties} message Score message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.GameEvents.Score$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Score message, length delimited. Does not implicitly {@link message.input.GameEvents.Score.verify|verify} messages.
                 * @param {message.input.GameEvents.Score$Properties} message Score message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.GameEvents.Score$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Score message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.Score} Score
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameEvents.Score;

                /**
                 * Decodes a Score message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.Score} Score
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameEvents.Score;

                /**
                 * Verifies a Score message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Score message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.Score} Score
                 */
                public static fromObject(object: { [k: string]: any }): message.input.GameEvents.Score;

                /**
                 * Creates a Score message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.Score.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.Score} Score
                 */
                public static from(object: { [k: string]: any }): message.input.GameEvents.Score;

                /**
                 * Creates a plain object from a Score message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.Score} message Score
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.GameEvents.Score, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Score message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Score to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type GoalScored$Properties = {
                context?: message.input.GameEvents.Context;
                totalScore?: number;
            };

            /**
             * Constructs a new GoalScored.
             * @exports message.input.GameEvents.GoalScored
             * @constructor
             * @param {message.input.GameEvents.GoalScored$Properties=} [properties] Properties to set
             */
            class GoalScored {

                /**
                 * Constructs a new GoalScored.
                 * @exports message.input.GameEvents.GoalScored
                 * @constructor
                 * @param {message.input.GameEvents.GoalScored$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.GameEvents.GoalScored$Properties);

                /**
                 * GoalScored context.
                 * @type {message.input.GameEvents.Context}
                 */
                public context: message.input.GameEvents.Context;

                /**
                 * GoalScored totalScore.
                 * @type {number}
                 */
                public totalScore: number;

                /**
                 * Creates a new GoalScored instance using the specified properties.
                 * @param {message.input.GameEvents.GoalScored$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.GoalScored} GoalScored instance
                 */
                public static create(properties?: message.input.GameEvents.GoalScored$Properties): message.input.GameEvents.GoalScored;

                /**
                 * Encodes the specified GoalScored message. Does not implicitly {@link message.input.GameEvents.GoalScored.verify|verify} messages.
                 * @param {message.input.GameEvents.GoalScored$Properties} message GoalScored message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.GameEvents.GoalScored$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified GoalScored message, length delimited. Does not implicitly {@link message.input.GameEvents.GoalScored.verify|verify} messages.
                 * @param {message.input.GameEvents.GoalScored$Properties} message GoalScored message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.GameEvents.GoalScored$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a GoalScored message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.GoalScored} GoalScored
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameEvents.GoalScored;

                /**
                 * Decodes a GoalScored message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.GoalScored} GoalScored
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameEvents.GoalScored;

                /**
                 * Verifies a GoalScored message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a GoalScored message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.GoalScored} GoalScored
                 */
                public static fromObject(object: { [k: string]: any }): message.input.GameEvents.GoalScored;

                /**
                 * Creates a GoalScored message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.GoalScored.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.GoalScored} GoalScored
                 */
                public static from(object: { [k: string]: any }): message.input.GameEvents.GoalScored;

                /**
                 * Creates a plain object from a GoalScored message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.GoalScored} message GoalScored
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.GameEvents.GoalScored, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this GoalScored message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this GoalScored to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type Penalisation$Properties = {
                context?: message.input.GameEvents.Context;
                robotId?: number;
                ends?: google.protobuf.Timestamp$Properties;
                reason?: message.input.GameState.Data.PenaltyReason;
            };

            /**
             * Constructs a new Penalisation.
             * @exports message.input.GameEvents.Penalisation
             * @constructor
             * @param {message.input.GameEvents.Penalisation$Properties=} [properties] Properties to set
             */
            class Penalisation {

                /**
                 * Constructs a new Penalisation.
                 * @exports message.input.GameEvents.Penalisation
                 * @constructor
                 * @param {message.input.GameEvents.Penalisation$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.GameEvents.Penalisation$Properties);

                /**
                 * Penalisation context.
                 * @type {message.input.GameEvents.Context}
                 */
                public context: message.input.GameEvents.Context;

                /**
                 * Penalisation robotId.
                 * @type {number}
                 */
                public robotId: number;

                /**
                 * Penalisation ends.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public ends: (google.protobuf.Timestamp$Properties|null);

                /**
                 * Penalisation reason.
                 * @type {message.input.GameState.Data.PenaltyReason}
                 */
                public reason: message.input.GameState.Data.PenaltyReason;

                /**
                 * Creates a new Penalisation instance using the specified properties.
                 * @param {message.input.GameEvents.Penalisation$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.Penalisation} Penalisation instance
                 */
                public static create(properties?: message.input.GameEvents.Penalisation$Properties): message.input.GameEvents.Penalisation;

                /**
                 * Encodes the specified Penalisation message. Does not implicitly {@link message.input.GameEvents.Penalisation.verify|verify} messages.
                 * @param {message.input.GameEvents.Penalisation$Properties} message Penalisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.GameEvents.Penalisation$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Penalisation message, length delimited. Does not implicitly {@link message.input.GameEvents.Penalisation.verify|verify} messages.
                 * @param {message.input.GameEvents.Penalisation$Properties} message Penalisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.GameEvents.Penalisation$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Penalisation message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.Penalisation} Penalisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameEvents.Penalisation;

                /**
                 * Decodes a Penalisation message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.Penalisation} Penalisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameEvents.Penalisation;

                /**
                 * Verifies a Penalisation message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Penalisation message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.Penalisation} Penalisation
                 */
                public static fromObject(object: { [k: string]: any }): message.input.GameEvents.Penalisation;

                /**
                 * Creates a Penalisation message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.Penalisation.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.Penalisation} Penalisation
                 */
                public static from(object: { [k: string]: any }): message.input.GameEvents.Penalisation;

                /**
                 * Creates a plain object from a Penalisation message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.Penalisation} message Penalisation
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.GameEvents.Penalisation, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Penalisation message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Penalisation to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type Unpenalisation$Properties = {
                context?: message.input.GameEvents.Context;
                robotId?: number;
            };

            /**
             * Constructs a new Unpenalisation.
             * @exports message.input.GameEvents.Unpenalisation
             * @constructor
             * @param {message.input.GameEvents.Unpenalisation$Properties=} [properties] Properties to set
             */
            class Unpenalisation {

                /**
                 * Constructs a new Unpenalisation.
                 * @exports message.input.GameEvents.Unpenalisation
                 * @constructor
                 * @param {message.input.GameEvents.Unpenalisation$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.GameEvents.Unpenalisation$Properties);

                /**
                 * Unpenalisation context.
                 * @type {message.input.GameEvents.Context}
                 */
                public context: message.input.GameEvents.Context;

                /**
                 * Unpenalisation robotId.
                 * @type {number}
                 */
                public robotId: number;

                /**
                 * Creates a new Unpenalisation instance using the specified properties.
                 * @param {message.input.GameEvents.Unpenalisation$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.Unpenalisation} Unpenalisation instance
                 */
                public static create(properties?: message.input.GameEvents.Unpenalisation$Properties): message.input.GameEvents.Unpenalisation;

                /**
                 * Encodes the specified Unpenalisation message. Does not implicitly {@link message.input.GameEvents.Unpenalisation.verify|verify} messages.
                 * @param {message.input.GameEvents.Unpenalisation$Properties} message Unpenalisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.GameEvents.Unpenalisation$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Unpenalisation message, length delimited. Does not implicitly {@link message.input.GameEvents.Unpenalisation.verify|verify} messages.
                 * @param {message.input.GameEvents.Unpenalisation$Properties} message Unpenalisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.GameEvents.Unpenalisation$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Unpenalisation message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.Unpenalisation} Unpenalisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameEvents.Unpenalisation;

                /**
                 * Decodes an Unpenalisation message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.Unpenalisation} Unpenalisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameEvents.Unpenalisation;

                /**
                 * Verifies an Unpenalisation message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an Unpenalisation message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.Unpenalisation} Unpenalisation
                 */
                public static fromObject(object: { [k: string]: any }): message.input.GameEvents.Unpenalisation;

                /**
                 * Creates an Unpenalisation message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.Unpenalisation.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.Unpenalisation} Unpenalisation
                 */
                public static from(object: { [k: string]: any }): message.input.GameEvents.Unpenalisation;

                /**
                 * Creates a plain object from an Unpenalisation message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.Unpenalisation} message Unpenalisation
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.GameEvents.Unpenalisation, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Unpenalisation message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Unpenalisation to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type CoachMessage$Properties = {
                context?: message.input.GameEvents.Context;
                message?: string;
            };

            /**
             * Constructs a new CoachMessage.
             * @exports message.input.GameEvents.CoachMessage
             * @constructor
             * @param {message.input.GameEvents.CoachMessage$Properties=} [properties] Properties to set
             */
            class CoachMessage {

                /**
                 * Constructs a new CoachMessage.
                 * @exports message.input.GameEvents.CoachMessage
                 * @constructor
                 * @param {message.input.GameEvents.CoachMessage$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.GameEvents.CoachMessage$Properties);

                /**
                 * CoachMessage context.
                 * @type {message.input.GameEvents.Context}
                 */
                public context: message.input.GameEvents.Context;

                /**
                 * CoachMessage message.
                 * @type {string}
                 */
                public message: string;

                /**
                 * Creates a new CoachMessage instance using the specified properties.
                 * @param {message.input.GameEvents.CoachMessage$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.CoachMessage} CoachMessage instance
                 */
                public static create(properties?: message.input.GameEvents.CoachMessage$Properties): message.input.GameEvents.CoachMessage;

                /**
                 * Encodes the specified CoachMessage message. Does not implicitly {@link message.input.GameEvents.CoachMessage.verify|verify} messages.
                 * @param {message.input.GameEvents.CoachMessage$Properties} message CoachMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.GameEvents.CoachMessage$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified CoachMessage message, length delimited. Does not implicitly {@link message.input.GameEvents.CoachMessage.verify|verify} messages.
                 * @param {message.input.GameEvents.CoachMessage$Properties} message CoachMessage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.GameEvents.CoachMessage$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a CoachMessage message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.CoachMessage} CoachMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameEvents.CoachMessage;

                /**
                 * Decodes a CoachMessage message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.CoachMessage} CoachMessage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameEvents.CoachMessage;

                /**
                 * Verifies a CoachMessage message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a CoachMessage message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.CoachMessage} CoachMessage
                 */
                public static fromObject(object: { [k: string]: any }): message.input.GameEvents.CoachMessage;

                /**
                 * Creates a CoachMessage message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.CoachMessage.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.CoachMessage} CoachMessage
                 */
                public static from(object: { [k: string]: any }): message.input.GameEvents.CoachMessage;

                /**
                 * Creates a plain object from a CoachMessage message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.CoachMessage} message CoachMessage
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.GameEvents.CoachMessage, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this CoachMessage message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this CoachMessage to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type HalfTime$Properties = {
                firstHalf?: boolean;
            };

            /**
             * Constructs a new HalfTime.
             * @exports message.input.GameEvents.HalfTime
             * @constructor
             * @param {message.input.GameEvents.HalfTime$Properties=} [properties] Properties to set
             */
            class HalfTime {

                /**
                 * Constructs a new HalfTime.
                 * @exports message.input.GameEvents.HalfTime
                 * @constructor
                 * @param {message.input.GameEvents.HalfTime$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.GameEvents.HalfTime$Properties);

                /**
                 * HalfTime firstHalf.
                 * @type {boolean}
                 */
                public firstHalf: boolean;

                /**
                 * Creates a new HalfTime instance using the specified properties.
                 * @param {message.input.GameEvents.HalfTime$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.HalfTime} HalfTime instance
                 */
                public static create(properties?: message.input.GameEvents.HalfTime$Properties): message.input.GameEvents.HalfTime;

                /**
                 * Encodes the specified HalfTime message. Does not implicitly {@link message.input.GameEvents.HalfTime.verify|verify} messages.
                 * @param {message.input.GameEvents.HalfTime$Properties} message HalfTime message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.GameEvents.HalfTime$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified HalfTime message, length delimited. Does not implicitly {@link message.input.GameEvents.HalfTime.verify|verify} messages.
                 * @param {message.input.GameEvents.HalfTime$Properties} message HalfTime message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.GameEvents.HalfTime$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a HalfTime message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.HalfTime} HalfTime
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameEvents.HalfTime;

                /**
                 * Decodes a HalfTime message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.HalfTime} HalfTime
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameEvents.HalfTime;

                /**
                 * Verifies a HalfTime message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a HalfTime message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.HalfTime} HalfTime
                 */
                public static fromObject(object: { [k: string]: any }): message.input.GameEvents.HalfTime;

                /**
                 * Creates a HalfTime message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.HalfTime.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.HalfTime} HalfTime
                 */
                public static from(object: { [k: string]: any }): message.input.GameEvents.HalfTime;

                /**
                 * Creates a plain object from a HalfTime message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.HalfTime} message HalfTime
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.GameEvents.HalfTime, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this HalfTime message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this HalfTime to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type BallKickedOut$Properties = {
                context?: message.input.GameEvents.Context;
                time?: google.protobuf.Timestamp$Properties;
            };

            /**
             * Constructs a new BallKickedOut.
             * @exports message.input.GameEvents.BallKickedOut
             * @constructor
             * @param {message.input.GameEvents.BallKickedOut$Properties=} [properties] Properties to set
             */
            class BallKickedOut {

                /**
                 * Constructs a new BallKickedOut.
                 * @exports message.input.GameEvents.BallKickedOut
                 * @constructor
                 * @param {message.input.GameEvents.BallKickedOut$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.GameEvents.BallKickedOut$Properties);

                /**
                 * BallKickedOut context.
                 * @type {message.input.GameEvents.Context}
                 */
                public context: message.input.GameEvents.Context;

                /**
                 * BallKickedOut time.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public time: (google.protobuf.Timestamp$Properties|null);

                /**
                 * Creates a new BallKickedOut instance using the specified properties.
                 * @param {message.input.GameEvents.BallKickedOut$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.BallKickedOut} BallKickedOut instance
                 */
                public static create(properties?: message.input.GameEvents.BallKickedOut$Properties): message.input.GameEvents.BallKickedOut;

                /**
                 * Encodes the specified BallKickedOut message. Does not implicitly {@link message.input.GameEvents.BallKickedOut.verify|verify} messages.
                 * @param {message.input.GameEvents.BallKickedOut$Properties} message BallKickedOut message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.GameEvents.BallKickedOut$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified BallKickedOut message, length delimited. Does not implicitly {@link message.input.GameEvents.BallKickedOut.verify|verify} messages.
                 * @param {message.input.GameEvents.BallKickedOut$Properties} message BallKickedOut message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.GameEvents.BallKickedOut$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a BallKickedOut message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.BallKickedOut} BallKickedOut
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameEvents.BallKickedOut;

                /**
                 * Decodes a BallKickedOut message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.BallKickedOut} BallKickedOut
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameEvents.BallKickedOut;

                /**
                 * Verifies a BallKickedOut message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a BallKickedOut message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.BallKickedOut} BallKickedOut
                 */
                public static fromObject(object: { [k: string]: any }): message.input.GameEvents.BallKickedOut;

                /**
                 * Creates a BallKickedOut message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.BallKickedOut.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.BallKickedOut} BallKickedOut
                 */
                public static from(object: { [k: string]: any }): message.input.GameEvents.BallKickedOut;

                /**
                 * Creates a plain object from a BallKickedOut message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.BallKickedOut} message BallKickedOut
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.GameEvents.BallKickedOut, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this BallKickedOut message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this BallKickedOut to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type KickOffTeam$Properties = {
                context?: message.input.GameEvents.Context;
            };

            /**
             * Constructs a new KickOffTeam.
             * @exports message.input.GameEvents.KickOffTeam
             * @constructor
             * @param {message.input.GameEvents.KickOffTeam$Properties=} [properties] Properties to set
             */
            class KickOffTeam {

                /**
                 * Constructs a new KickOffTeam.
                 * @exports message.input.GameEvents.KickOffTeam
                 * @constructor
                 * @param {message.input.GameEvents.KickOffTeam$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.GameEvents.KickOffTeam$Properties);

                /**
                 * KickOffTeam context.
                 * @type {message.input.GameEvents.Context}
                 */
                public context: message.input.GameEvents.Context;

                /**
                 * Creates a new KickOffTeam instance using the specified properties.
                 * @param {message.input.GameEvents.KickOffTeam$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.KickOffTeam} KickOffTeam instance
                 */
                public static create(properties?: message.input.GameEvents.KickOffTeam$Properties): message.input.GameEvents.KickOffTeam;

                /**
                 * Encodes the specified KickOffTeam message. Does not implicitly {@link message.input.GameEvents.KickOffTeam.verify|verify} messages.
                 * @param {message.input.GameEvents.KickOffTeam$Properties} message KickOffTeam message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.GameEvents.KickOffTeam$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified KickOffTeam message, length delimited. Does not implicitly {@link message.input.GameEvents.KickOffTeam.verify|verify} messages.
                 * @param {message.input.GameEvents.KickOffTeam$Properties} message KickOffTeam message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.GameEvents.KickOffTeam$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a KickOffTeam message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.KickOffTeam} KickOffTeam
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameEvents.KickOffTeam;

                /**
                 * Decodes a KickOffTeam message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.KickOffTeam} KickOffTeam
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameEvents.KickOffTeam;

                /**
                 * Verifies a KickOffTeam message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a KickOffTeam message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.KickOffTeam} KickOffTeam
                 */
                public static fromObject(object: { [k: string]: any }): message.input.GameEvents.KickOffTeam;

                /**
                 * Creates a KickOffTeam message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.KickOffTeam.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.KickOffTeam} KickOffTeam
                 */
                public static from(object: { [k: string]: any }): message.input.GameEvents.KickOffTeam;

                /**
                 * Creates a plain object from a KickOffTeam message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.KickOffTeam} message KickOffTeam
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.GameEvents.KickOffTeam, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this KickOffTeam message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this KickOffTeam to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type GamePhase$Properties = {
                phase?: message.input.GameState.Data.Phase;
                readyTime?: google.protobuf.Timestamp$Properties;
                endHalf?: google.protobuf.Timestamp$Properties;
                ballFree?: google.protobuf.Timestamp$Properties;
                ends?: google.protobuf.Timestamp$Properties;
                nextHalf?: google.protobuf.Timestamp$Properties;
            };

            /**
             * Constructs a new GamePhase.
             * @exports message.input.GameEvents.GamePhase
             * @constructor
             * @param {message.input.GameEvents.GamePhase$Properties=} [properties] Properties to set
             */
            class GamePhase {

                /**
                 * Constructs a new GamePhase.
                 * @exports message.input.GameEvents.GamePhase
                 * @constructor
                 * @param {message.input.GameEvents.GamePhase$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.GameEvents.GamePhase$Properties);

                /**
                 * GamePhase phase.
                 * @type {message.input.GameState.Data.Phase}
                 */
                public phase: message.input.GameState.Data.Phase;

                /**
                 * GamePhase readyTime.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public readyTime: (google.protobuf.Timestamp$Properties|null);

                /**
                 * GamePhase endHalf.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public endHalf: (google.protobuf.Timestamp$Properties|null);

                /**
                 * GamePhase ballFree.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public ballFree: (google.protobuf.Timestamp$Properties|null);

                /**
                 * GamePhase ends.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public ends: (google.protobuf.Timestamp$Properties|null);

                /**
                 * GamePhase nextHalf.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public nextHalf: (google.protobuf.Timestamp$Properties|null);

                /**
                 * Creates a new GamePhase instance using the specified properties.
                 * @param {message.input.GameEvents.GamePhase$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.GamePhase} GamePhase instance
                 */
                public static create(properties?: message.input.GameEvents.GamePhase$Properties): message.input.GameEvents.GamePhase;

                /**
                 * Encodes the specified GamePhase message. Does not implicitly {@link message.input.GameEvents.GamePhase.verify|verify} messages.
                 * @param {message.input.GameEvents.GamePhase$Properties} message GamePhase message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.GameEvents.GamePhase$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified GamePhase message, length delimited. Does not implicitly {@link message.input.GameEvents.GamePhase.verify|verify} messages.
                 * @param {message.input.GameEvents.GamePhase$Properties} message GamePhase message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.GameEvents.GamePhase$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a GamePhase message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.GamePhase} GamePhase
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameEvents.GamePhase;

                /**
                 * Decodes a GamePhase message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.GamePhase} GamePhase
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameEvents.GamePhase;

                /**
                 * Verifies a GamePhase message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a GamePhase message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.GamePhase} GamePhase
                 */
                public static fromObject(object: { [k: string]: any }): message.input.GameEvents.GamePhase;

                /**
                 * Creates a GamePhase message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.GamePhase.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.GamePhase} GamePhase
                 */
                public static from(object: { [k: string]: any }): message.input.GameEvents.GamePhase;

                /**
                 * Creates a plain object from a GamePhase message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.GamePhase} message GamePhase
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.GameEvents.GamePhase, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this GamePhase message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this GamePhase to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type GameMode$Properties = {
                mode?: message.input.GameState.Data.Mode;
            };

            /**
             * Constructs a new GameMode.
             * @exports message.input.GameEvents.GameMode
             * @constructor
             * @param {message.input.GameEvents.GameMode$Properties=} [properties] Properties to set
             */
            class GameMode {

                /**
                 * Constructs a new GameMode.
                 * @exports message.input.GameEvents.GameMode
                 * @constructor
                 * @param {message.input.GameEvents.GameMode$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.GameEvents.GameMode$Properties);

                /**
                 * GameMode mode.
                 * @type {message.input.GameState.Data.Mode}
                 */
                public mode: message.input.GameState.Data.Mode;

                /**
                 * Creates a new GameMode instance using the specified properties.
                 * @param {message.input.GameEvents.GameMode$Properties=} [properties] Properties to set
                 * @returns {message.input.GameEvents.GameMode} GameMode instance
                 */
                public static create(properties?: message.input.GameEvents.GameMode$Properties): message.input.GameEvents.GameMode;

                /**
                 * Encodes the specified GameMode message. Does not implicitly {@link message.input.GameEvents.GameMode.verify|verify} messages.
                 * @param {message.input.GameEvents.GameMode$Properties} message GameMode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.GameEvents.GameMode$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified GameMode message, length delimited. Does not implicitly {@link message.input.GameEvents.GameMode.verify|verify} messages.
                 * @param {message.input.GameEvents.GameMode$Properties} message GameMode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.GameEvents.GameMode$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a GameMode message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameEvents.GameMode} GameMode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameEvents.GameMode;

                /**
                 * Decodes a GameMode message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameEvents.GameMode} GameMode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameEvents.GameMode;

                /**
                 * Verifies a GameMode message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a GameMode message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.GameMode} GameMode
                 */
                public static fromObject(object: { [k: string]: any }): message.input.GameEvents.GameMode;

                /**
                 * Creates a GameMode message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameEvents.GameMode.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameEvents.GameMode} GameMode
                 */
                public static from(object: { [k: string]: any }): message.input.GameEvents.GameMode;

                /**
                 * Creates a plain object from a GameMode message. Also converts values to other types if specified.
                 * @param {message.input.GameEvents.GameMode} message GameMode
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.GameEvents.GameMode, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this GameMode message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this GameMode to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type GameState$Properties = {
            data?: message.input.GameState.Data$Properties;
            event?: string;
        };

        /**
         * Constructs a new GameState.
         * @exports message.input.GameState
         * @constructor
         * @param {message.input.GameState$Properties=} [properties] Properties to set
         */
        class GameState {

            /**
             * Constructs a new GameState.
             * @exports message.input.GameState
             * @constructor
             * @param {message.input.GameState$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.GameState$Properties);

            /**
             * GameState data.
             * @type {(message.input.GameState.Data$Properties|null)}
             */
            public data: (message.input.GameState.Data$Properties|null);

            /**
             * GameState event.
             * @type {string}
             */
            public event: string;

            /**
             * Creates a new GameState instance using the specified properties.
             * @param {message.input.GameState$Properties=} [properties] Properties to set
             * @returns {message.input.GameState} GameState instance
             */
            public static create(properties?: message.input.GameState$Properties): message.input.GameState;

            /**
             * Encodes the specified GameState message. Does not implicitly {@link message.input.GameState.verify|verify} messages.
             * @param {message.input.GameState$Properties} message GameState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.GameState$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified GameState message, length delimited. Does not implicitly {@link message.input.GameState.verify|verify} messages.
             * @param {message.input.GameState$Properties} message GameState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.GameState$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GameState message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.GameState} GameState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameState;

            /**
             * Decodes a GameState message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.GameState} GameState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameState;

            /**
             * Verifies a GameState message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a GameState message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.GameState} GameState
             */
            public static fromObject(object: { [k: string]: any }): message.input.GameState;

            /**
             * Creates a GameState message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.GameState.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.GameState} GameState
             */
            public static from(object: { [k: string]: any }): message.input.GameState;

            /**
             * Creates a plain object from a GameState message. Also converts values to other types if specified.
             * @param {message.input.GameState} message GameState
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.GameState, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this GameState message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this GameState to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace GameState {

            type Data$Properties = {
                phase?: message.input.GameState.Data.Phase;
                mode?: message.input.GameState.Data.Mode;
                firstHalf?: boolean;
                kickedOutByUs?: boolean;
                kickedOutTime?: google.protobuf.Timestamp$Properties;
                ourKickOff?: boolean;
                primaryTime?: google.protobuf.Timestamp$Properties;
                secondaryTime?: google.protobuf.Timestamp$Properties;
                team?: message.input.GameState.Data.Team$Properties;
                opponent?: message.input.GameState.Data.Team$Properties;
                self?: message.input.GameState.Data.Robot$Properties;
            };

            /**
             * Constructs a new Data.
             * @exports message.input.GameState.Data
             * @constructor
             * @param {message.input.GameState.Data$Properties=} [properties] Properties to set
             */
            class Data {

                /**
                 * Constructs a new Data.
                 * @exports message.input.GameState.Data
                 * @constructor
                 * @param {message.input.GameState.Data$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.GameState.Data$Properties);

                /**
                 * Data phase.
                 * @type {message.input.GameState.Data.Phase}
                 */
                public phase: message.input.GameState.Data.Phase;

                /**
                 * Data mode.
                 * @type {message.input.GameState.Data.Mode}
                 */
                public mode: message.input.GameState.Data.Mode;

                /**
                 * Data firstHalf.
                 * @type {boolean}
                 */
                public firstHalf: boolean;

                /**
                 * Data kickedOutByUs.
                 * @type {boolean}
                 */
                public kickedOutByUs: boolean;

                /**
                 * Data kickedOutTime.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public kickedOutTime: (google.protobuf.Timestamp$Properties|null);

                /**
                 * Data ourKickOff.
                 * @type {boolean}
                 */
                public ourKickOff: boolean;

                /**
                 * Data primaryTime.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public primaryTime: (google.protobuf.Timestamp$Properties|null);

                /**
                 * Data secondaryTime.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public secondaryTime: (google.protobuf.Timestamp$Properties|null);

                /**
                 * Data team.
                 * @type {(message.input.GameState.Data.Team$Properties|null)}
                 */
                public team: (message.input.GameState.Data.Team$Properties|null);

                /**
                 * Data opponent.
                 * @type {(message.input.GameState.Data.Team$Properties|null)}
                 */
                public opponent: (message.input.GameState.Data.Team$Properties|null);

                /**
                 * Data self.
                 * @type {(message.input.GameState.Data.Robot$Properties|null)}
                 */
                public self: (message.input.GameState.Data.Robot$Properties|null);

                /**
                 * Creates a new Data instance using the specified properties.
                 * @param {message.input.GameState.Data$Properties=} [properties] Properties to set
                 * @returns {message.input.GameState.Data} Data instance
                 */
                public static create(properties?: message.input.GameState.Data$Properties): message.input.GameState.Data;

                /**
                 * Encodes the specified Data message. Does not implicitly {@link message.input.GameState.Data.verify|verify} messages.
                 * @param {message.input.GameState.Data$Properties} message Data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.GameState.Data$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Data message, length delimited. Does not implicitly {@link message.input.GameState.Data.verify|verify} messages.
                 * @param {message.input.GameState.Data$Properties} message Data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.GameState.Data$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Data message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.GameState.Data} Data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameState.Data;

                /**
                 * Decodes a Data message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.GameState.Data} Data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameState.Data;

                /**
                 * Verifies a Data message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Data message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameState.Data} Data
                 */
                public static fromObject(object: { [k: string]: any }): message.input.GameState.Data;

                /**
                 * Creates a Data message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.GameState.Data.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.GameState.Data} Data
                 */
                public static from(object: { [k: string]: any }): message.input.GameState.Data;

                /**
                 * Creates a plain object from a Data message. Also converts values to other types if specified.
                 * @param {message.input.GameState.Data} message Data
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.GameState.Data, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Data message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Data to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Data {

                /**
                 * Mode enum.
                 * @name Mode
                 * @memberof message.input.GameState.Data
                 * @enum {number}
                 * @property {number} UNKNOWN_MODE=0 UNKNOWN_MODE value
                 * @property {number} NORMAL=1 NORMAL value
                 * @property {number} PENALTY_SHOOTOUT=2 PENALTY_SHOOTOUT value
                 * @property {number} OVERTIME=3 OVERTIME value
                 */
                enum Mode {
                    UNKNOWN_MODE = 0,
                    NORMAL = 1,
                    PENALTY_SHOOTOUT = 2,
                    OVERTIME = 3
                }

                /**
                 * Phase enum.
                 * @name Phase
                 * @memberof message.input.GameState.Data
                 * @enum {number}
                 * @property {number} UNKNOWN_PHASE=0 UNKNOWN_PHASE value
                 * @property {number} INITIAL=1 INITIAL value
                 * @property {number} READY=2 READY value
                 * @property {number} SET=3 SET value
                 * @property {number} PLAYING=4 PLAYING value
                 * @property {number} TIMEOUT=5 TIMEOUT value
                 * @property {number} FINISHED=6 FINISHED value
                 */
                enum Phase {
                    UNKNOWN_PHASE = 0,
                    INITIAL = 1,
                    READY = 2,
                    SET = 3,
                    PLAYING = 4,
                    TIMEOUT = 5,
                    FINISHED = 6
                }

                /**
                 * PenaltyReason enum.
                 * @name PenaltyReason
                 * @memberof message.input.GameState.Data
                 * @enum {number}
                 * @property {number} UNKNOWN_PENALTY_REASON=0 UNKNOWN_PENALTY_REASON value
                 * @property {number} UNPENALISED=1 UNPENALISED value
                 * @property {number} BALL_MANIPULATION=2 BALL_MANIPULATION value
                 * @property {number} PHYSICAL_CONTACT=3 PHYSICAL_CONTACT value
                 * @property {number} ILLEGAL_ATTACK=4 ILLEGAL_ATTACK value
                 * @property {number} ILLEGAL_DEFENSE=5 ILLEGAL_DEFENSE value
                 * @property {number} REQUEST_FOR_PICKUP=6 REQUEST_FOR_PICKUP value
                 * @property {number} REQUEST_FOR_SERVICE=7 REQUEST_FOR_SERVICE value
                 * @property {number} REQUEST_FOR_PICKUP_TO_SERVICE=8 REQUEST_FOR_PICKUP_TO_SERVICE value
                 * @property {number} SUBSTITUTE=9 SUBSTITUTE value
                 * @property {number} MANUAL=10 MANUAL value
                 * @property {number} PLAYER_PUSHING=11 PLAYER_PUSHING value
                 */
                enum PenaltyReason {
                    UNKNOWN_PENALTY_REASON = 0,
                    UNPENALISED = 1,
                    BALL_MANIPULATION = 2,
                    PHYSICAL_CONTACT = 3,
                    ILLEGAL_ATTACK = 4,
                    ILLEGAL_DEFENSE = 5,
                    REQUEST_FOR_PICKUP = 6,
                    REQUEST_FOR_SERVICE = 7,
                    REQUEST_FOR_PICKUP_TO_SERVICE = 8,
                    SUBSTITUTE = 9,
                    MANUAL = 10,
                    PLAYER_PUSHING = 11
                }

                type Robot$Properties = {
                    id?: number;
                    penaltyReason?: message.input.GameState.Data.PenaltyReason;
                    unpenalised?: google.protobuf.Timestamp$Properties;
                };

                /**
                 * Constructs a new Robot.
                 * @exports message.input.GameState.Data.Robot
                 * @constructor
                 * @param {message.input.GameState.Data.Robot$Properties=} [properties] Properties to set
                 */
                class Robot {

                    /**
                     * Constructs a new Robot.
                     * @exports message.input.GameState.Data.Robot
                     * @constructor
                     * @param {message.input.GameState.Data.Robot$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.input.GameState.Data.Robot$Properties);

                    /**
                     * Robot id.
                     * @type {number}
                     */
                    public id: number;

                    /**
                     * Robot penaltyReason.
                     * @type {message.input.GameState.Data.PenaltyReason}
                     */
                    public penaltyReason: message.input.GameState.Data.PenaltyReason;

                    /**
                     * Robot unpenalised.
                     * @type {(google.protobuf.Timestamp$Properties|null)}
                     */
                    public unpenalised: (google.protobuf.Timestamp$Properties|null);

                    /**
                     * Creates a new Robot instance using the specified properties.
                     * @param {message.input.GameState.Data.Robot$Properties=} [properties] Properties to set
                     * @returns {message.input.GameState.Data.Robot} Robot instance
                     */
                    public static create(properties?: message.input.GameState.Data.Robot$Properties): message.input.GameState.Data.Robot;

                    /**
                     * Encodes the specified Robot message. Does not implicitly {@link message.input.GameState.Data.Robot.verify|verify} messages.
                     * @param {message.input.GameState.Data.Robot$Properties} message Robot message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.input.GameState.Data.Robot$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified Robot message, length delimited. Does not implicitly {@link message.input.GameState.Data.Robot.verify|verify} messages.
                     * @param {message.input.GameState.Data.Robot$Properties} message Robot message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.input.GameState.Data.Robot$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Robot message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.input.GameState.Data.Robot} Robot
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameState.Data.Robot;

                    /**
                     * Decodes a Robot message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.input.GameState.Data.Robot} Robot
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameState.Data.Robot;

                    /**
                     * Verifies a Robot message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a Robot message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.input.GameState.Data.Robot} Robot
                     */
                    public static fromObject(object: { [k: string]: any }): message.input.GameState.Data.Robot;

                    /**
                     * Creates a Robot message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.input.GameState.Data.Robot.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.input.GameState.Data.Robot} Robot
                     */
                    public static from(object: { [k: string]: any }): message.input.GameState.Data.Robot;

                    /**
                     * Creates a plain object from a Robot message. Also converts values to other types if specified.
                     * @param {message.input.GameState.Data.Robot} message Robot
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.input.GameState.Data.Robot, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this Robot message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Robot to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                type Team$Properties = {
                    teamId?: number;
                    score?: number;
                    coachMessage?: string;
                    players?: message.input.GameState.Data.Robot$Properties[];
                };

                /**
                 * Constructs a new Team.
                 * @exports message.input.GameState.Data.Team
                 * @constructor
                 * @param {message.input.GameState.Data.Team$Properties=} [properties] Properties to set
                 */
                class Team {

                    /**
                     * Constructs a new Team.
                     * @exports message.input.GameState.Data.Team
                     * @constructor
                     * @param {message.input.GameState.Data.Team$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.input.GameState.Data.Team$Properties);

                    /**
                     * Team teamId.
                     * @type {number}
                     */
                    public teamId: number;

                    /**
                     * Team score.
                     * @type {number}
                     */
                    public score: number;

                    /**
                     * Team coachMessage.
                     * @type {string}
                     */
                    public coachMessage: string;

                    /**
                     * Team players.
                     * @type {Array.<message.input.GameState.Data.Robot$Properties>}
                     */
                    public players: message.input.GameState.Data.Robot$Properties[];

                    /**
                     * Creates a new Team instance using the specified properties.
                     * @param {message.input.GameState.Data.Team$Properties=} [properties] Properties to set
                     * @returns {message.input.GameState.Data.Team} Team instance
                     */
                    public static create(properties?: message.input.GameState.Data.Team$Properties): message.input.GameState.Data.Team;

                    /**
                     * Encodes the specified Team message. Does not implicitly {@link message.input.GameState.Data.Team.verify|verify} messages.
                     * @param {message.input.GameState.Data.Team$Properties} message Team message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.input.GameState.Data.Team$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified Team message, length delimited. Does not implicitly {@link message.input.GameState.Data.Team.verify|verify} messages.
                     * @param {message.input.GameState.Data.Team$Properties} message Team message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.input.GameState.Data.Team$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Team message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.input.GameState.Data.Team} Team
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.GameState.Data.Team;

                    /**
                     * Decodes a Team message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.input.GameState.Data.Team} Team
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.GameState.Data.Team;

                    /**
                     * Verifies a Team message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a Team message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.input.GameState.Data.Team} Team
                     */
                    public static fromObject(object: { [k: string]: any }): message.input.GameState.Data.Team;

                    /**
                     * Creates a Team message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.input.GameState.Data.Team.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.input.GameState.Data.Team} Team
                     */
                    public static from(object: { [k: string]: any }): message.input.GameState.Data.Team;

                    /**
                     * Creates a plain object from a Team message. Also converts values to other types if specified.
                     * @param {message.input.GameState.Data.Team} message Team
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.input.GameState.Data.Team, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this Team message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Team to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }
        }

        type Image$Properties = {
            format?: number;
            dimensions?: uvec2$Properties;
            data?: Uint8Array;
            cameraId?: number;
            serialNumber?: string;
            timestamp?: google.protobuf.Timestamp$Properties;
            Hcw?: mat44$Properties;
        };

        /**
         * Constructs a new Image.
         * @exports message.input.Image
         * @constructor
         * @param {message.input.Image$Properties=} [properties] Properties to set
         */
        class Image {

            /**
             * Constructs a new Image.
             * @exports message.input.Image
             * @constructor
             * @param {message.input.Image$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.Image$Properties);

            /**
             * Image format.
             * @type {number}
             */
            public format: number;

            /**
             * Image dimensions.
             * @type {(uvec2$Properties|null)}
             */
            public dimensions: (uvec2$Properties|null);

            /**
             * Image data.
             * @type {Uint8Array}
             */
            public data: Uint8Array;

            /**
             * Image cameraId.
             * @type {number}
             */
            public cameraId: number;

            /**
             * Image serialNumber.
             * @type {string}
             */
            public serialNumber: string;

            /**
             * Image timestamp.
             * @type {(google.protobuf.Timestamp$Properties|null)}
             */
            public timestamp: (google.protobuf.Timestamp$Properties|null);

            /**
             * Image Hcw.
             * @type {(mat44$Properties|null)}
             */
            public Hcw: (mat44$Properties|null);

            /**
             * Creates a new Image instance using the specified properties.
             * @param {message.input.Image$Properties=} [properties] Properties to set
             * @returns {message.input.Image} Image instance
             */
            public static create(properties?: message.input.Image$Properties): message.input.Image;

            /**
             * Encodes the specified Image message. Does not implicitly {@link message.input.Image.verify|verify} messages.
             * @param {message.input.Image$Properties} message Image message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.Image$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Image message, length delimited. Does not implicitly {@link message.input.Image.verify|verify} messages.
             * @param {message.input.Image$Properties} message Image message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.Image$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an Image message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.Image} Image
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.Image;

            /**
             * Decodes an Image message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.Image} Image
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.Image;

            /**
             * Verifies an Image message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an Image message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.Image} Image
             */
            public static fromObject(object: { [k: string]: any }): message.input.Image;

            /**
             * Creates an Image message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.Image.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.Image} Image
             */
            public static from(object: { [k: string]: any }): message.input.Image;

            /**
             * Creates a plain object from an Image message. Also converts values to other types if specified.
             * @param {message.input.Image} message Image
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.Image, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Image message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Image to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type ImageFragment$Properties = {
            image?: message.input.Image$Properties;
            start?: number;
            end?: number;
            camToFeet?: fmat44$Properties;
        };

        /**
         * Constructs a new ImageFragment.
         * @exports message.input.ImageFragment
         * @constructor
         * @param {message.input.ImageFragment$Properties=} [properties] Properties to set
         */
        class ImageFragment {

            /**
             * Constructs a new ImageFragment.
             * @exports message.input.ImageFragment
             * @constructor
             * @param {message.input.ImageFragment$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.ImageFragment$Properties);

            /**
             * ImageFragment image.
             * @type {(message.input.Image$Properties|null)}
             */
            public image: (message.input.Image$Properties|null);

            /**
             * ImageFragment start.
             * @type {number}
             */
            public start: number;

            /**
             * ImageFragment end.
             * @type {number}
             */
            public end: number;

            /**
             * ImageFragment camToFeet.
             * @type {(fmat44$Properties|null)}
             */
            public camToFeet: (fmat44$Properties|null);

            /**
             * Creates a new ImageFragment instance using the specified properties.
             * @param {message.input.ImageFragment$Properties=} [properties] Properties to set
             * @returns {message.input.ImageFragment} ImageFragment instance
             */
            public static create(properties?: message.input.ImageFragment$Properties): message.input.ImageFragment;

            /**
             * Encodes the specified ImageFragment message. Does not implicitly {@link message.input.ImageFragment.verify|verify} messages.
             * @param {message.input.ImageFragment$Properties} message ImageFragment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.ImageFragment$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified ImageFragment message, length delimited. Does not implicitly {@link message.input.ImageFragment.verify|verify} messages.
             * @param {message.input.ImageFragment$Properties} message ImageFragment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.ImageFragment$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an ImageFragment message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.ImageFragment} ImageFragment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.ImageFragment;

            /**
             * Decodes an ImageFragment message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.ImageFragment} ImageFragment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.ImageFragment;

            /**
             * Verifies an ImageFragment message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an ImageFragment message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.ImageFragment} ImageFragment
             */
            public static fromObject(object: { [k: string]: any }): message.input.ImageFragment;

            /**
             * Creates an ImageFragment message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.ImageFragment.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.ImageFragment} ImageFragment
             */
            public static from(object: { [k: string]: any }): message.input.ImageFragment;

            /**
             * Creates a plain object from an ImageFragment message. Also converts values to other types if specified.
             * @param {message.input.ImageFragment} message ImageFragment
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.ImageFragment, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this ImageFragment message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this ImageFragment to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type MotionCapture$Properties = {
            frameNumber?: number;
            latency?: number;
            timecode?: number;
            timecodeSub?: number;
            timestamp?: number;
            recording?: boolean;
            trackedModelsChanged?: boolean;
            markerSets?: message.input.MotionCapture.MarkerSet$Properties[];
            markers?: message.input.MotionCapture.Marker$Properties[];
            rigidBodies?: message.input.MotionCapture.RigidBody$Properties[];
            skeletons?: message.input.MotionCapture.Skeleton$Properties[];
            labeledMarkers?: message.input.MotionCapture.LabeledMarker$Properties[];
            forcePlates?: message.input.MotionCapture.ForcePlate$Properties[];
        };

        /**
         * Constructs a new MotionCapture.
         * @exports message.input.MotionCapture
         * @constructor
         * @param {message.input.MotionCapture$Properties=} [properties] Properties to set
         */
        class MotionCapture {

            /**
             * Constructs a new MotionCapture.
             * @exports message.input.MotionCapture
             * @constructor
             * @param {message.input.MotionCapture$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.MotionCapture$Properties);

            /**
             * MotionCapture frameNumber.
             * @type {number}
             */
            public frameNumber: number;

            /**
             * MotionCapture latency.
             * @type {number}
             */
            public latency: number;

            /**
             * MotionCapture timecode.
             * @type {number}
             */
            public timecode: number;

            /**
             * MotionCapture timecodeSub.
             * @type {number}
             */
            public timecodeSub: number;

            /**
             * MotionCapture timestamp.
             * @type {number}
             */
            public timestamp: number;

            /**
             * MotionCapture recording.
             * @type {boolean}
             */
            public recording: boolean;

            /**
             * MotionCapture trackedModelsChanged.
             * @type {boolean}
             */
            public trackedModelsChanged: boolean;

            /**
             * MotionCapture markerSets.
             * @type {Array.<message.input.MotionCapture.MarkerSet$Properties>}
             */
            public markerSets: message.input.MotionCapture.MarkerSet$Properties[];

            /**
             * MotionCapture markers.
             * @type {Array.<message.input.MotionCapture.Marker$Properties>}
             */
            public markers: message.input.MotionCapture.Marker$Properties[];

            /**
             * MotionCapture rigidBodies.
             * @type {Array.<message.input.MotionCapture.RigidBody$Properties>}
             */
            public rigidBodies: message.input.MotionCapture.RigidBody$Properties[];

            /**
             * MotionCapture skeletons.
             * @type {Array.<message.input.MotionCapture.Skeleton$Properties>}
             */
            public skeletons: message.input.MotionCapture.Skeleton$Properties[];

            /**
             * MotionCapture labeledMarkers.
             * @type {Array.<message.input.MotionCapture.LabeledMarker$Properties>}
             */
            public labeledMarkers: message.input.MotionCapture.LabeledMarker$Properties[];

            /**
             * MotionCapture forcePlates.
             * @type {Array.<message.input.MotionCapture.ForcePlate$Properties>}
             */
            public forcePlates: message.input.MotionCapture.ForcePlate$Properties[];

            /**
             * Creates a new MotionCapture instance using the specified properties.
             * @param {message.input.MotionCapture$Properties=} [properties] Properties to set
             * @returns {message.input.MotionCapture} MotionCapture instance
             */
            public static create(properties?: message.input.MotionCapture$Properties): message.input.MotionCapture;

            /**
             * Encodes the specified MotionCapture message. Does not implicitly {@link message.input.MotionCapture.verify|verify} messages.
             * @param {message.input.MotionCapture$Properties} message MotionCapture message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.MotionCapture$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified MotionCapture message, length delimited. Does not implicitly {@link message.input.MotionCapture.verify|verify} messages.
             * @param {message.input.MotionCapture$Properties} message MotionCapture message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.MotionCapture$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a MotionCapture message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.MotionCapture} MotionCapture
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.MotionCapture;

            /**
             * Decodes a MotionCapture message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.MotionCapture} MotionCapture
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.MotionCapture;

            /**
             * Verifies a MotionCapture message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a MotionCapture message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.MotionCapture} MotionCapture
             */
            public static fromObject(object: { [k: string]: any }): message.input.MotionCapture;

            /**
             * Creates a MotionCapture message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.MotionCapture.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.MotionCapture} MotionCapture
             */
            public static from(object: { [k: string]: any }): message.input.MotionCapture;

            /**
             * Creates a plain object from a MotionCapture message. Also converts values to other types if specified.
             * @param {message.input.MotionCapture} message MotionCapture
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.MotionCapture, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this MotionCapture message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this MotionCapture to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace MotionCapture {

            type Marker$Properties = {
                id?: number;
                position?: fvec3$Properties;
                size?: number;
            };

            /**
             * Constructs a new Marker.
             * @exports message.input.MotionCapture.Marker
             * @constructor
             * @param {message.input.MotionCapture.Marker$Properties=} [properties] Properties to set
             */
            class Marker {

                /**
                 * Constructs a new Marker.
                 * @exports message.input.MotionCapture.Marker
                 * @constructor
                 * @param {message.input.MotionCapture.Marker$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.MotionCapture.Marker$Properties);

                /**
                 * Marker id.
                 * @type {number}
                 */
                public id: number;

                /**
                 * Marker position.
                 * @type {(fvec3$Properties|null)}
                 */
                public position: (fvec3$Properties|null);

                /**
                 * Marker size.
                 * @type {number}
                 */
                public size: number;

                /**
                 * Creates a new Marker instance using the specified properties.
                 * @param {message.input.MotionCapture.Marker$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.Marker} Marker instance
                 */
                public static create(properties?: message.input.MotionCapture.Marker$Properties): message.input.MotionCapture.Marker;

                /**
                 * Encodes the specified Marker message. Does not implicitly {@link message.input.MotionCapture.Marker.verify|verify} messages.
                 * @param {message.input.MotionCapture.Marker$Properties} message Marker message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.MotionCapture.Marker$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Marker message, length delimited. Does not implicitly {@link message.input.MotionCapture.Marker.verify|verify} messages.
                 * @param {message.input.MotionCapture.Marker$Properties} message Marker message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.MotionCapture.Marker$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Marker message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.Marker} Marker
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.MotionCapture.Marker;

                /**
                 * Decodes a Marker message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.Marker} Marker
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.MotionCapture.Marker;

                /**
                 * Verifies a Marker message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Marker message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.Marker} Marker
                 */
                public static fromObject(object: { [k: string]: any }): message.input.MotionCapture.Marker;

                /**
                 * Creates a Marker message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.Marker.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.Marker} Marker
                 */
                public static from(object: { [k: string]: any }): message.input.MotionCapture.Marker;

                /**
                 * Creates a plain object from a Marker message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.Marker} message Marker
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.MotionCapture.Marker, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Marker message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Marker to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type MarkerSet$Properties = {
                name?: string;
                markers?: message.input.MotionCapture.Marker$Properties[];
            };

            /**
             * Constructs a new MarkerSet.
             * @exports message.input.MotionCapture.MarkerSet
             * @constructor
             * @param {message.input.MotionCapture.MarkerSet$Properties=} [properties] Properties to set
             */
            class MarkerSet {

                /**
                 * Constructs a new MarkerSet.
                 * @exports message.input.MotionCapture.MarkerSet
                 * @constructor
                 * @param {message.input.MotionCapture.MarkerSet$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.MotionCapture.MarkerSet$Properties);

                /**
                 * MarkerSet name.
                 * @type {string}
                 */
                public name: string;

                /**
                 * MarkerSet markers.
                 * @type {Array.<message.input.MotionCapture.Marker$Properties>}
                 */
                public markers: message.input.MotionCapture.Marker$Properties[];

                /**
                 * Creates a new MarkerSet instance using the specified properties.
                 * @param {message.input.MotionCapture.MarkerSet$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.MarkerSet} MarkerSet instance
                 */
                public static create(properties?: message.input.MotionCapture.MarkerSet$Properties): message.input.MotionCapture.MarkerSet;

                /**
                 * Encodes the specified MarkerSet message. Does not implicitly {@link message.input.MotionCapture.MarkerSet.verify|verify} messages.
                 * @param {message.input.MotionCapture.MarkerSet$Properties} message MarkerSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.MotionCapture.MarkerSet$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified MarkerSet message, length delimited. Does not implicitly {@link message.input.MotionCapture.MarkerSet.verify|verify} messages.
                 * @param {message.input.MotionCapture.MarkerSet$Properties} message MarkerSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.MotionCapture.MarkerSet$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a MarkerSet message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.MarkerSet} MarkerSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.MotionCapture.MarkerSet;

                /**
                 * Decodes a MarkerSet message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.MarkerSet} MarkerSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.MotionCapture.MarkerSet;

                /**
                 * Verifies a MarkerSet message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a MarkerSet message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.MarkerSet} MarkerSet
                 */
                public static fromObject(object: { [k: string]: any }): message.input.MotionCapture.MarkerSet;

                /**
                 * Creates a MarkerSet message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.MarkerSet.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.MarkerSet} MarkerSet
                 */
                public static from(object: { [k: string]: any }): message.input.MotionCapture.MarkerSet;

                /**
                 * Creates a plain object from a MarkerSet message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.MarkerSet} message MarkerSet
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.MotionCapture.MarkerSet, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this MarkerSet message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this MarkerSet to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type RigidBody$Properties = {
                id?: number;
                position?: fvec3$Properties;
                rotation?: fvec4$Properties;
                markers?: message.input.MotionCapture.Marker$Properties[];
                error?: number;
                trackingValid?: boolean;
                name?: string;
                offset?: fvec3$Properties;
                parent?: number;
                children?: number[];
            };

            /**
             * Constructs a new RigidBody.
             * @exports message.input.MotionCapture.RigidBody
             * @constructor
             * @param {message.input.MotionCapture.RigidBody$Properties=} [properties] Properties to set
             */
            class RigidBody {

                /**
                 * Constructs a new RigidBody.
                 * @exports message.input.MotionCapture.RigidBody
                 * @constructor
                 * @param {message.input.MotionCapture.RigidBody$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.MotionCapture.RigidBody$Properties);

                /**
                 * RigidBody id.
                 * @type {number}
                 */
                public id: number;

                /**
                 * RigidBody position.
                 * @type {(fvec3$Properties|null)}
                 */
                public position: (fvec3$Properties|null);

                /**
                 * RigidBody rotation.
                 * @type {(fvec4$Properties|null)}
                 */
                public rotation: (fvec4$Properties|null);

                /**
                 * RigidBody markers.
                 * @type {Array.<message.input.MotionCapture.Marker$Properties>}
                 */
                public markers: message.input.MotionCapture.Marker$Properties[];

                /**
                 * RigidBody error.
                 * @type {number}
                 */
                public error: number;

                /**
                 * RigidBody trackingValid.
                 * @type {boolean}
                 */
                public trackingValid: boolean;

                /**
                 * RigidBody name.
                 * @type {string}
                 */
                public name: string;

                /**
                 * RigidBody offset.
                 * @type {(fvec3$Properties|null)}
                 */
                public offset: (fvec3$Properties|null);

                /**
                 * RigidBody parent.
                 * @type {number}
                 */
                public parent: number;

                /**
                 * RigidBody children.
                 * @type {Array.<number>}
                 */
                public children: number[];

                /**
                 * Creates a new RigidBody instance using the specified properties.
                 * @param {message.input.MotionCapture.RigidBody$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.RigidBody} RigidBody instance
                 */
                public static create(properties?: message.input.MotionCapture.RigidBody$Properties): message.input.MotionCapture.RigidBody;

                /**
                 * Encodes the specified RigidBody message. Does not implicitly {@link message.input.MotionCapture.RigidBody.verify|verify} messages.
                 * @param {message.input.MotionCapture.RigidBody$Properties} message RigidBody message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.MotionCapture.RigidBody$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified RigidBody message, length delimited. Does not implicitly {@link message.input.MotionCapture.RigidBody.verify|verify} messages.
                 * @param {message.input.MotionCapture.RigidBody$Properties} message RigidBody message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.MotionCapture.RigidBody$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a RigidBody message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.RigidBody} RigidBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.MotionCapture.RigidBody;

                /**
                 * Decodes a RigidBody message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.RigidBody} RigidBody
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.MotionCapture.RigidBody;

                /**
                 * Verifies a RigidBody message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a RigidBody message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.RigidBody} RigidBody
                 */
                public static fromObject(object: { [k: string]: any }): message.input.MotionCapture.RigidBody;

                /**
                 * Creates a RigidBody message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.RigidBody.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.RigidBody} RigidBody
                 */
                public static from(object: { [k: string]: any }): message.input.MotionCapture.RigidBody;

                /**
                 * Creates a plain object from a RigidBody message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.RigidBody} message RigidBody
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.MotionCapture.RigidBody, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this RigidBody message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this RigidBody to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type Skeleton$Properties = {
                id?: number;
                bones?: message.input.MotionCapture.RigidBody$Properties[];
                name?: string;
            };

            /**
             * Constructs a new Skeleton.
             * @exports message.input.MotionCapture.Skeleton
             * @constructor
             * @param {message.input.MotionCapture.Skeleton$Properties=} [properties] Properties to set
             */
            class Skeleton {

                /**
                 * Constructs a new Skeleton.
                 * @exports message.input.MotionCapture.Skeleton
                 * @constructor
                 * @param {message.input.MotionCapture.Skeleton$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.MotionCapture.Skeleton$Properties);

                /**
                 * Skeleton id.
                 * @type {number}
                 */
                public id: number;

                /**
                 * Skeleton bones.
                 * @type {Array.<message.input.MotionCapture.RigidBody$Properties>}
                 */
                public bones: message.input.MotionCapture.RigidBody$Properties[];

                /**
                 * Skeleton name.
                 * @type {string}
                 */
                public name: string;

                /**
                 * Creates a new Skeleton instance using the specified properties.
                 * @param {message.input.MotionCapture.Skeleton$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.Skeleton} Skeleton instance
                 */
                public static create(properties?: message.input.MotionCapture.Skeleton$Properties): message.input.MotionCapture.Skeleton;

                /**
                 * Encodes the specified Skeleton message. Does not implicitly {@link message.input.MotionCapture.Skeleton.verify|verify} messages.
                 * @param {message.input.MotionCapture.Skeleton$Properties} message Skeleton message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.MotionCapture.Skeleton$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Skeleton message, length delimited. Does not implicitly {@link message.input.MotionCapture.Skeleton.verify|verify} messages.
                 * @param {message.input.MotionCapture.Skeleton$Properties} message Skeleton message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.MotionCapture.Skeleton$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Skeleton message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.Skeleton} Skeleton
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.MotionCapture.Skeleton;

                /**
                 * Decodes a Skeleton message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.Skeleton} Skeleton
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.MotionCapture.Skeleton;

                /**
                 * Verifies a Skeleton message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Skeleton message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.Skeleton} Skeleton
                 */
                public static fromObject(object: { [k: string]: any }): message.input.MotionCapture.Skeleton;

                /**
                 * Creates a Skeleton message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.Skeleton.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.Skeleton} Skeleton
                 */
                public static from(object: { [k: string]: any }): message.input.MotionCapture.Skeleton;

                /**
                 * Creates a plain object from a Skeleton message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.Skeleton} message Skeleton
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.MotionCapture.Skeleton, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Skeleton message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Skeleton to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type LabeledMarker$Properties = {
                marker?: message.input.MotionCapture.Marker$Properties;
                occluded?: boolean;
                pointCloudSolved?: boolean;
                modelSolved?: boolean;
            };

            /**
             * Constructs a new LabeledMarker.
             * @exports message.input.MotionCapture.LabeledMarker
             * @constructor
             * @param {message.input.MotionCapture.LabeledMarker$Properties=} [properties] Properties to set
             */
            class LabeledMarker {

                /**
                 * Constructs a new LabeledMarker.
                 * @exports message.input.MotionCapture.LabeledMarker
                 * @constructor
                 * @param {message.input.MotionCapture.LabeledMarker$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.MotionCapture.LabeledMarker$Properties);

                /**
                 * LabeledMarker marker.
                 * @type {(message.input.MotionCapture.Marker$Properties|null)}
                 */
                public marker: (message.input.MotionCapture.Marker$Properties|null);

                /**
                 * LabeledMarker occluded.
                 * @type {boolean}
                 */
                public occluded: boolean;

                /**
                 * LabeledMarker pointCloudSolved.
                 * @type {boolean}
                 */
                public pointCloudSolved: boolean;

                /**
                 * LabeledMarker modelSolved.
                 * @type {boolean}
                 */
                public modelSolved: boolean;

                /**
                 * Creates a new LabeledMarker instance using the specified properties.
                 * @param {message.input.MotionCapture.LabeledMarker$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.LabeledMarker} LabeledMarker instance
                 */
                public static create(properties?: message.input.MotionCapture.LabeledMarker$Properties): message.input.MotionCapture.LabeledMarker;

                /**
                 * Encodes the specified LabeledMarker message. Does not implicitly {@link message.input.MotionCapture.LabeledMarker.verify|verify} messages.
                 * @param {message.input.MotionCapture.LabeledMarker$Properties} message LabeledMarker message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.MotionCapture.LabeledMarker$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified LabeledMarker message, length delimited. Does not implicitly {@link message.input.MotionCapture.LabeledMarker.verify|verify} messages.
                 * @param {message.input.MotionCapture.LabeledMarker$Properties} message LabeledMarker message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.MotionCapture.LabeledMarker$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a LabeledMarker message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.LabeledMarker} LabeledMarker
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.MotionCapture.LabeledMarker;

                /**
                 * Decodes a LabeledMarker message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.LabeledMarker} LabeledMarker
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.MotionCapture.LabeledMarker;

                /**
                 * Verifies a LabeledMarker message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a LabeledMarker message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.LabeledMarker} LabeledMarker
                 */
                public static fromObject(object: { [k: string]: any }): message.input.MotionCapture.LabeledMarker;

                /**
                 * Creates a LabeledMarker message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.LabeledMarker.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.LabeledMarker} LabeledMarker
                 */
                public static from(object: { [k: string]: any }): message.input.MotionCapture.LabeledMarker;

                /**
                 * Creates a plain object from a LabeledMarker message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.LabeledMarker} message LabeledMarker
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.MotionCapture.LabeledMarker, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this LabeledMarker message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this LabeledMarker to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type Channel$Properties = {
                channel?: number[];
            };

            /**
             * Constructs a new Channel.
             * @exports message.input.MotionCapture.Channel
             * @constructor
             * @param {message.input.MotionCapture.Channel$Properties=} [properties] Properties to set
             */
            class Channel {

                /**
                 * Constructs a new Channel.
                 * @exports message.input.MotionCapture.Channel
                 * @constructor
                 * @param {message.input.MotionCapture.Channel$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.MotionCapture.Channel$Properties);

                /**
                 * Channel channel.
                 * @type {Array.<number>}
                 */
                public channel: number[];

                /**
                 * Creates a new Channel instance using the specified properties.
                 * @param {message.input.MotionCapture.Channel$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.Channel} Channel instance
                 */
                public static create(properties?: message.input.MotionCapture.Channel$Properties): message.input.MotionCapture.Channel;

                /**
                 * Encodes the specified Channel message. Does not implicitly {@link message.input.MotionCapture.Channel.verify|verify} messages.
                 * @param {message.input.MotionCapture.Channel$Properties} message Channel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.MotionCapture.Channel$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Channel message, length delimited. Does not implicitly {@link message.input.MotionCapture.Channel.verify|verify} messages.
                 * @param {message.input.MotionCapture.Channel$Properties} message Channel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.MotionCapture.Channel$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Channel message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.Channel} Channel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.MotionCapture.Channel;

                /**
                 * Decodes a Channel message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.Channel} Channel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.MotionCapture.Channel;

                /**
                 * Verifies a Channel message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Channel message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.Channel} Channel
                 */
                public static fromObject(object: { [k: string]: any }): message.input.MotionCapture.Channel;

                /**
                 * Creates a Channel message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.Channel.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.Channel} Channel
                 */
                public static from(object: { [k: string]: any }): message.input.MotionCapture.Channel;

                /**
                 * Creates a plain object from a Channel message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.Channel} message Channel
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.MotionCapture.Channel, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Channel message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Channel to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type ForcePlate$Properties = {
                id?: number;
                channels?: message.input.MotionCapture.Channel$Properties[];
            };

            /**
             * Constructs a new ForcePlate.
             * @exports message.input.MotionCapture.ForcePlate
             * @constructor
             * @param {message.input.MotionCapture.ForcePlate$Properties=} [properties] Properties to set
             */
            class ForcePlate {

                /**
                 * Constructs a new ForcePlate.
                 * @exports message.input.MotionCapture.ForcePlate
                 * @constructor
                 * @param {message.input.MotionCapture.ForcePlate$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.MotionCapture.ForcePlate$Properties);

                /**
                 * ForcePlate id.
                 * @type {number}
                 */
                public id: number;

                /**
                 * ForcePlate channels.
                 * @type {Array.<message.input.MotionCapture.Channel$Properties>}
                 */
                public channels: message.input.MotionCapture.Channel$Properties[];

                /**
                 * Creates a new ForcePlate instance using the specified properties.
                 * @param {message.input.MotionCapture.ForcePlate$Properties=} [properties] Properties to set
                 * @returns {message.input.MotionCapture.ForcePlate} ForcePlate instance
                 */
                public static create(properties?: message.input.MotionCapture.ForcePlate$Properties): message.input.MotionCapture.ForcePlate;

                /**
                 * Encodes the specified ForcePlate message. Does not implicitly {@link message.input.MotionCapture.ForcePlate.verify|verify} messages.
                 * @param {message.input.MotionCapture.ForcePlate$Properties} message ForcePlate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.MotionCapture.ForcePlate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ForcePlate message, length delimited. Does not implicitly {@link message.input.MotionCapture.ForcePlate.verify|verify} messages.
                 * @param {message.input.MotionCapture.ForcePlate$Properties} message ForcePlate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.MotionCapture.ForcePlate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ForcePlate message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.MotionCapture.ForcePlate} ForcePlate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.MotionCapture.ForcePlate;

                /**
                 * Decodes a ForcePlate message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.MotionCapture.ForcePlate} ForcePlate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.MotionCapture.ForcePlate;

                /**
                 * Verifies a ForcePlate message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a ForcePlate message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.ForcePlate} ForcePlate
                 */
                public static fromObject(object: { [k: string]: any }): message.input.MotionCapture.ForcePlate;

                /**
                 * Creates a ForcePlate message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.MotionCapture.ForcePlate.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.MotionCapture.ForcePlate} ForcePlate
                 */
                public static from(object: { [k: string]: any }): message.input.MotionCapture.ForcePlate;

                /**
                 * Creates a plain object from a ForcePlate message. Also converts values to other types if specified.
                 * @param {message.input.MotionCapture.ForcePlate} message ForcePlate
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.MotionCapture.ForcePlate, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this ForcePlate message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this ForcePlate to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type WalkingDetected$Properties = {};

        /**
         * Constructs a new WalkingDetected.
         * @exports message.input.WalkingDetected
         * @constructor
         * @param {message.input.WalkingDetected$Properties=} [properties] Properties to set
         */
        class WalkingDetected {

            /**
             * Constructs a new WalkingDetected.
             * @exports message.input.WalkingDetected
             * @constructor
             * @param {message.input.WalkingDetected$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.WalkingDetected$Properties);

            /**
             * Creates a new WalkingDetected instance using the specified properties.
             * @param {message.input.WalkingDetected$Properties=} [properties] Properties to set
             * @returns {message.input.WalkingDetected} WalkingDetected instance
             */
            public static create(properties?: message.input.WalkingDetected$Properties): message.input.WalkingDetected;

            /**
             * Encodes the specified WalkingDetected message. Does not implicitly {@link message.input.WalkingDetected.verify|verify} messages.
             * @param {message.input.WalkingDetected$Properties} message WalkingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.WalkingDetected$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified WalkingDetected message, length delimited. Does not implicitly {@link message.input.WalkingDetected.verify|verify} messages.
             * @param {message.input.WalkingDetected$Properties} message WalkingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.WalkingDetected$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a WalkingDetected message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.WalkingDetected} WalkingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.WalkingDetected;

            /**
             * Decodes a WalkingDetected message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.WalkingDetected} WalkingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.WalkingDetected;

            /**
             * Verifies a WalkingDetected message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a WalkingDetected message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.WalkingDetected} WalkingDetected
             */
            public static fromObject(object: { [k: string]: any }): message.input.WalkingDetected;

            /**
             * Creates a WalkingDetected message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.WalkingDetected.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.WalkingDetected} WalkingDetected
             */
            public static from(object: { [k: string]: any }): message.input.WalkingDetected;

            /**
             * Creates a plain object from a WalkingDetected message. Also converts values to other types if specified.
             * @param {message.input.WalkingDetected} message WalkingDetected
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.WalkingDetected, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this WalkingDetected message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this WalkingDetected to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type BendingDetected$Properties = {};

        /**
         * Constructs a new BendingDetected.
         * @exports message.input.BendingDetected
         * @constructor
         * @param {message.input.BendingDetected$Properties=} [properties] Properties to set
         */
        class BendingDetected {

            /**
             * Constructs a new BendingDetected.
             * @exports message.input.BendingDetected
             * @constructor
             * @param {message.input.BendingDetected$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.BendingDetected$Properties);

            /**
             * Creates a new BendingDetected instance using the specified properties.
             * @param {message.input.BendingDetected$Properties=} [properties] Properties to set
             * @returns {message.input.BendingDetected} BendingDetected instance
             */
            public static create(properties?: message.input.BendingDetected$Properties): message.input.BendingDetected;

            /**
             * Encodes the specified BendingDetected message. Does not implicitly {@link message.input.BendingDetected.verify|verify} messages.
             * @param {message.input.BendingDetected$Properties} message BendingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.BendingDetected$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified BendingDetected message, length delimited. Does not implicitly {@link message.input.BendingDetected.verify|verify} messages.
             * @param {message.input.BendingDetected$Properties} message BendingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.BendingDetected$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a BendingDetected message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.BendingDetected} BendingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.BendingDetected;

            /**
             * Decodes a BendingDetected message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.BendingDetected} BendingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.BendingDetected;

            /**
             * Verifies a BendingDetected message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a BendingDetected message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.BendingDetected} BendingDetected
             */
            public static fromObject(object: { [k: string]: any }): message.input.BendingDetected;

            /**
             * Creates a BendingDetected message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.BendingDetected.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.BendingDetected} BendingDetected
             */
            public static from(object: { [k: string]: any }): message.input.BendingDetected;

            /**
             * Creates a plain object from a BendingDetected message. Also converts values to other types if specified.
             * @param {message.input.BendingDetected} message BendingDetected
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.BendingDetected, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this BendingDetected message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this BendingDetected to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type KickingDetected$Properties = {};

        /**
         * Constructs a new KickingDetected.
         * @exports message.input.KickingDetected
         * @constructor
         * @param {message.input.KickingDetected$Properties=} [properties] Properties to set
         */
        class KickingDetected {

            /**
             * Constructs a new KickingDetected.
             * @exports message.input.KickingDetected
             * @constructor
             * @param {message.input.KickingDetected$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.KickingDetected$Properties);

            /**
             * Creates a new KickingDetected instance using the specified properties.
             * @param {message.input.KickingDetected$Properties=} [properties] Properties to set
             * @returns {message.input.KickingDetected} KickingDetected instance
             */
            public static create(properties?: message.input.KickingDetected$Properties): message.input.KickingDetected;

            /**
             * Encodes the specified KickingDetected message. Does not implicitly {@link message.input.KickingDetected.verify|verify} messages.
             * @param {message.input.KickingDetected$Properties} message KickingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.KickingDetected$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified KickingDetected message, length delimited. Does not implicitly {@link message.input.KickingDetected.verify|verify} messages.
             * @param {message.input.KickingDetected$Properties} message KickingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.KickingDetected$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a KickingDetected message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.KickingDetected} KickingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.KickingDetected;

            /**
             * Decodes a KickingDetected message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.KickingDetected} KickingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.KickingDetected;

            /**
             * Verifies a KickingDetected message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a KickingDetected message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.KickingDetected} KickingDetected
             */
            public static fromObject(object: { [k: string]: any }): message.input.KickingDetected;

            /**
             * Creates a KickingDetected message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.KickingDetected.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.KickingDetected} KickingDetected
             */
            public static from(object: { [k: string]: any }): message.input.KickingDetected;

            /**
             * Creates a plain object from a KickingDetected message. Also converts values to other types if specified.
             * @param {message.input.KickingDetected} message KickingDetected
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.KickingDetected, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this KickingDetected message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this KickingDetected to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type SittingDetected$Properties = {};

        /**
         * Constructs a new SittingDetected.
         * @exports message.input.SittingDetected
         * @constructor
         * @param {message.input.SittingDetected$Properties=} [properties] Properties to set
         */
        class SittingDetected {

            /**
             * Constructs a new SittingDetected.
             * @exports message.input.SittingDetected
             * @constructor
             * @param {message.input.SittingDetected$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.SittingDetected$Properties);

            /**
             * Creates a new SittingDetected instance using the specified properties.
             * @param {message.input.SittingDetected$Properties=} [properties] Properties to set
             * @returns {message.input.SittingDetected} SittingDetected instance
             */
            public static create(properties?: message.input.SittingDetected$Properties): message.input.SittingDetected;

            /**
             * Encodes the specified SittingDetected message. Does not implicitly {@link message.input.SittingDetected.verify|verify} messages.
             * @param {message.input.SittingDetected$Properties} message SittingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.SittingDetected$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified SittingDetected message, length delimited. Does not implicitly {@link message.input.SittingDetected.verify|verify} messages.
             * @param {message.input.SittingDetected$Properties} message SittingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.SittingDetected$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SittingDetected message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.SittingDetected} SittingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.SittingDetected;

            /**
             * Decodes a SittingDetected message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.SittingDetected} SittingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.SittingDetected;

            /**
             * Verifies a SittingDetected message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a SittingDetected message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.SittingDetected} SittingDetected
             */
            public static fromObject(object: { [k: string]: any }): message.input.SittingDetected;

            /**
             * Creates a SittingDetected message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.SittingDetected.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.SittingDetected} SittingDetected
             */
            public static from(object: { [k: string]: any }): message.input.SittingDetected;

            /**
             * Creates a plain object from a SittingDetected message. Also converts values to other types if specified.
             * @param {message.input.SittingDetected} message SittingDetected
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.SittingDetected, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this SittingDetected message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this SittingDetected to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type StandingDetected$Properties = {};

        /**
         * Constructs a new StandingDetected.
         * @exports message.input.StandingDetected
         * @constructor
         * @param {message.input.StandingDetected$Properties=} [properties] Properties to set
         */
        class StandingDetected {

            /**
             * Constructs a new StandingDetected.
             * @exports message.input.StandingDetected
             * @constructor
             * @param {message.input.StandingDetected$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.StandingDetected$Properties);

            /**
             * Creates a new StandingDetected instance using the specified properties.
             * @param {message.input.StandingDetected$Properties=} [properties] Properties to set
             * @returns {message.input.StandingDetected} StandingDetected instance
             */
            public static create(properties?: message.input.StandingDetected$Properties): message.input.StandingDetected;

            /**
             * Encodes the specified StandingDetected message. Does not implicitly {@link message.input.StandingDetected.verify|verify} messages.
             * @param {message.input.StandingDetected$Properties} message StandingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.StandingDetected$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified StandingDetected message, length delimited. Does not implicitly {@link message.input.StandingDetected.verify|verify} messages.
             * @param {message.input.StandingDetected$Properties} message StandingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.StandingDetected$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a StandingDetected message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.StandingDetected} StandingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.StandingDetected;

            /**
             * Decodes a StandingDetected message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.StandingDetected} StandingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.StandingDetected;

            /**
             * Verifies a StandingDetected message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a StandingDetected message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.StandingDetected} StandingDetected
             */
            public static fromObject(object: { [k: string]: any }): message.input.StandingDetected;

            /**
             * Creates a StandingDetected message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.StandingDetected.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.StandingDetected} StandingDetected
             */
            public static from(object: { [k: string]: any }): message.input.StandingDetected;

            /**
             * Creates a plain object from a StandingDetected message. Also converts values to other types if specified.
             * @param {message.input.StandingDetected} message StandingDetected
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.StandingDetected, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this StandingDetected message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this StandingDetected to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type FallingDetected$Properties = {
            x?: number;
            y?: number;
            z?: number;
        };

        /**
         * Constructs a new FallingDetected.
         * @exports message.input.FallingDetected
         * @constructor
         * @param {message.input.FallingDetected$Properties=} [properties] Properties to set
         */
        class FallingDetected {

            /**
             * Constructs a new FallingDetected.
             * @exports message.input.FallingDetected
             * @constructor
             * @param {message.input.FallingDetected$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.FallingDetected$Properties);

            /**
             * FallingDetected x.
             * @type {number}
             */
            public x: number;

            /**
             * FallingDetected y.
             * @type {number}
             */
            public y: number;

            /**
             * FallingDetected z.
             * @type {number}
             */
            public z: number;

            /**
             * Creates a new FallingDetected instance using the specified properties.
             * @param {message.input.FallingDetected$Properties=} [properties] Properties to set
             * @returns {message.input.FallingDetected} FallingDetected instance
             */
            public static create(properties?: message.input.FallingDetected$Properties): message.input.FallingDetected;

            /**
             * Encodes the specified FallingDetected message. Does not implicitly {@link message.input.FallingDetected.verify|verify} messages.
             * @param {message.input.FallingDetected$Properties} message FallingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.FallingDetected$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FallingDetected message, length delimited. Does not implicitly {@link message.input.FallingDetected.verify|verify} messages.
             * @param {message.input.FallingDetected$Properties} message FallingDetected message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.FallingDetected$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FallingDetected message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.FallingDetected} FallingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.FallingDetected;

            /**
             * Decodes a FallingDetected message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.FallingDetected} FallingDetected
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.FallingDetected;

            /**
             * Verifies a FallingDetected message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FallingDetected message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.FallingDetected} FallingDetected
             */
            public static fromObject(object: { [k: string]: any }): message.input.FallingDetected;

            /**
             * Creates a FallingDetected message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.FallingDetected.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.FallingDetected} FallingDetected
             */
            public static from(object: { [k: string]: any }): message.input.FallingDetected;

            /**
             * Creates a plain object from a FallingDetected message. Also converts values to other types if specified.
             * @param {message.input.FallingDetected} message FallingDetected
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.FallingDetected, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FallingDetected message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FallingDetected to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type PresenceUserState$Properties = {
            headPose?: fmat44$Properties;
        };

        /**
         * Constructs a new PresenceUserState.
         * @exports message.input.PresenceUserState
         * @constructor
         * @param {message.input.PresenceUserState$Properties=} [properties] Properties to set
         */
        class PresenceUserState {

            /**
             * Constructs a new PresenceUserState.
             * @exports message.input.PresenceUserState
             * @constructor
             * @param {message.input.PresenceUserState$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.PresenceUserState$Properties);

            /**
             * PresenceUserState headPose.
             * @type {(fmat44$Properties|null)}
             */
            public headPose: (fmat44$Properties|null);

            /**
             * Creates a new PresenceUserState instance using the specified properties.
             * @param {message.input.PresenceUserState$Properties=} [properties] Properties to set
             * @returns {message.input.PresenceUserState} PresenceUserState instance
             */
            public static create(properties?: message.input.PresenceUserState$Properties): message.input.PresenceUserState;

            /**
             * Encodes the specified PresenceUserState message. Does not implicitly {@link message.input.PresenceUserState.verify|verify} messages.
             * @param {message.input.PresenceUserState$Properties} message PresenceUserState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.PresenceUserState$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified PresenceUserState message, length delimited. Does not implicitly {@link message.input.PresenceUserState.verify|verify} messages.
             * @param {message.input.PresenceUserState$Properties} message PresenceUserState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.PresenceUserState$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a PresenceUserState message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.PresenceUserState} PresenceUserState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.PresenceUserState;

            /**
             * Decodes a PresenceUserState message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.PresenceUserState} PresenceUserState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.PresenceUserState;

            /**
             * Verifies a PresenceUserState message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a PresenceUserState message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.PresenceUserState} PresenceUserState
             */
            public static fromObject(object: { [k: string]: any }): message.input.PresenceUserState;

            /**
             * Creates a PresenceUserState message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.PresenceUserState.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.PresenceUserState} PresenceUserState
             */
            public static from(object: { [k: string]: any }): message.input.PresenceUserState;

            /**
             * Creates a plain object from a PresenceUserState message. Also converts values to other types if specified.
             * @param {message.input.PresenceUserState} message PresenceUserState
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.PresenceUserState, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this PresenceUserState message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this PresenceUserState to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type Sensors$Properties = {
            timestamp?: google.protobuf.Timestamp$Properties;
            accelerometer?: vec3$Properties;
            gyroscope?: vec3$Properties;
            world?: mat44$Properties;
            fsr?: message.input.Sensors.FSR$Properties[];
            servo?: message.input.Sensors.Servo$Properties[];
            button?: message.input.Sensors.Button$Properties[];
            led?: message.input.Sensors.LED$Properties[];
            voltage?: number;
            battery?: number;
            centreOfPressure?: vec3$Properties;
            robotToIMU?: mat22$Properties;
            leftFootDown?: boolean;
            rightFootDown?: boolean;
            forwardKinematics?: { [k: string]: mat44$Properties };
            bodyCentreHeight?: number;
            centreOfMass?: vec4$Properties;
            bodyToGround?: mat44$Properties;
            camToGround?: mat44$Properties;
        };

        /**
         * Constructs a new Sensors.
         * @exports message.input.Sensors
         * @constructor
         * @param {message.input.Sensors$Properties=} [properties] Properties to set
         */
        class Sensors {

            /**
             * Constructs a new Sensors.
             * @exports message.input.Sensors
             * @constructor
             * @param {message.input.Sensors$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.input.Sensors$Properties);

            /**
             * Sensors timestamp.
             * @type {(google.protobuf.Timestamp$Properties|null)}
             */
            public timestamp: (google.protobuf.Timestamp$Properties|null);

            /**
             * Sensors accelerometer.
             * @type {(vec3$Properties|null)}
             */
            public accelerometer: (vec3$Properties|null);

            /**
             * Sensors gyroscope.
             * @type {(vec3$Properties|null)}
             */
            public gyroscope: (vec3$Properties|null);

            /**
             * Sensors world.
             * @type {(mat44$Properties|null)}
             */
            public world: (mat44$Properties|null);

            /**
             * Sensors fsr.
             * @type {Array.<message.input.Sensors.FSR$Properties>}
             */
            public fsr: message.input.Sensors.FSR$Properties[];

            /**
             * Sensors servo.
             * @type {Array.<message.input.Sensors.Servo$Properties>}
             */
            public servo: message.input.Sensors.Servo$Properties[];

            /**
             * Sensors button.
             * @type {Array.<message.input.Sensors.Button$Properties>}
             */
            public button: message.input.Sensors.Button$Properties[];

            /**
             * Sensors led.
             * @type {Array.<message.input.Sensors.LED$Properties>}
             */
            public led: message.input.Sensors.LED$Properties[];

            /**
             * Sensors voltage.
             * @type {number}
             */
            public voltage: number;

            /**
             * Sensors battery.
             * @type {number}
             */
            public battery: number;

            /**
             * Sensors centreOfPressure.
             * @type {(vec3$Properties|null)}
             */
            public centreOfPressure: (vec3$Properties|null);

            /**
             * Sensors robotToIMU.
             * @type {(mat22$Properties|null)}
             */
            public robotToIMU: (mat22$Properties|null);

            /**
             * Sensors leftFootDown.
             * @type {boolean}
             */
            public leftFootDown: boolean;

            /**
             * Sensors rightFootDown.
             * @type {boolean}
             */
            public rightFootDown: boolean;

            /**
             * Sensors forwardKinematics.
             * @type {Object.<string,mat44$Properties>}
             */
            public forwardKinematics: { [k: string]: mat44$Properties };

            /**
             * Sensors bodyCentreHeight.
             * @type {number}
             */
            public bodyCentreHeight: number;

            /**
             * Sensors centreOfMass.
             * @type {(vec4$Properties|null)}
             */
            public centreOfMass: (vec4$Properties|null);

            /**
             * Sensors bodyToGround.
             * @type {(mat44$Properties|null)}
             */
            public bodyToGround: (mat44$Properties|null);

            /**
             * Sensors camToGround.
             * @type {(mat44$Properties|null)}
             */
            public camToGround: (mat44$Properties|null);

            /**
             * Creates a new Sensors instance using the specified properties.
             * @param {message.input.Sensors$Properties=} [properties] Properties to set
             * @returns {message.input.Sensors} Sensors instance
             */
            public static create(properties?: message.input.Sensors$Properties): message.input.Sensors;

            /**
             * Encodes the specified Sensors message. Does not implicitly {@link message.input.Sensors.verify|verify} messages.
             * @param {message.input.Sensors$Properties} message Sensors message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.input.Sensors$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Sensors message, length delimited. Does not implicitly {@link message.input.Sensors.verify|verify} messages.
             * @param {message.input.Sensors$Properties} message Sensors message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.input.Sensors$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Sensors message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.input.Sensors} Sensors
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.Sensors;

            /**
             * Decodes a Sensors message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.input.Sensors} Sensors
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.Sensors;

            /**
             * Verifies a Sensors message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a Sensors message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.Sensors} Sensors
             */
            public static fromObject(object: { [k: string]: any }): message.input.Sensors;

            /**
             * Creates a Sensors message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.input.Sensors.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.input.Sensors} Sensors
             */
            public static from(object: { [k: string]: any }): message.input.Sensors;

            /**
             * Creates a plain object from a Sensors message. Also converts values to other types if specified.
             * @param {message.input.Sensors} message Sensors
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.input.Sensors, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Sensors message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Sensors to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace Sensors {

            type Servo$Properties = {
                errorFlags?: number;
                id?: number;
                enabled?: boolean;
                pGain?: number;
                iGain?: number;
                dGain?: number;
                goalPosition?: number;
                goalVelocity?: number;
                presentPosition?: number;
                presentVelocity?: number;
                load?: number;
                voltage?: number;
                temperature?: number;
            };

            /**
             * Constructs a new Servo.
             * @exports message.input.Sensors.Servo
             * @constructor
             * @param {message.input.Sensors.Servo$Properties=} [properties] Properties to set
             */
            class Servo {

                /**
                 * Constructs a new Servo.
                 * @exports message.input.Sensors.Servo
                 * @constructor
                 * @param {message.input.Sensors.Servo$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.Sensors.Servo$Properties);

                /**
                 * Servo errorFlags.
                 * @type {number}
                 */
                public errorFlags: number;

                /**
                 * Servo id.
                 * @type {number}
                 */
                public id: number;

                /**
                 * Servo enabled.
                 * @type {boolean}
                 */
                public enabled: boolean;

                /**
                 * Servo pGain.
                 * @type {number}
                 */
                public pGain: number;

                /**
                 * Servo iGain.
                 * @type {number}
                 */
                public iGain: number;

                /**
                 * Servo dGain.
                 * @type {number}
                 */
                public dGain: number;

                /**
                 * Servo goalPosition.
                 * @type {number}
                 */
                public goalPosition: number;

                /**
                 * Servo goalVelocity.
                 * @type {number}
                 */
                public goalVelocity: number;

                /**
                 * Servo presentPosition.
                 * @type {number}
                 */
                public presentPosition: number;

                /**
                 * Servo presentVelocity.
                 * @type {number}
                 */
                public presentVelocity: number;

                /**
                 * Servo load.
                 * @type {number}
                 */
                public load: number;

                /**
                 * Servo voltage.
                 * @type {number}
                 */
                public voltage: number;

                /**
                 * Servo temperature.
                 * @type {number}
                 */
                public temperature: number;

                /**
                 * Creates a new Servo instance using the specified properties.
                 * @param {message.input.Sensors.Servo$Properties=} [properties] Properties to set
                 * @returns {message.input.Sensors.Servo} Servo instance
                 */
                public static create(properties?: message.input.Sensors.Servo$Properties): message.input.Sensors.Servo;

                /**
                 * Encodes the specified Servo message. Does not implicitly {@link message.input.Sensors.Servo.verify|verify} messages.
                 * @param {message.input.Sensors.Servo$Properties} message Servo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.Sensors.Servo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Servo message, length delimited. Does not implicitly {@link message.input.Sensors.Servo.verify|verify} messages.
                 * @param {message.input.Sensors.Servo$Properties} message Servo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.Sensors.Servo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Servo message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.Sensors.Servo} Servo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.Sensors.Servo;

                /**
                 * Decodes a Servo message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.Sensors.Servo} Servo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.Sensors.Servo;

                /**
                 * Verifies a Servo message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Servo message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.Servo} Servo
                 */
                public static fromObject(object: { [k: string]: any }): message.input.Sensors.Servo;

                /**
                 * Creates a Servo message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.Sensors.Servo.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.Servo} Servo
                 */
                public static from(object: { [k: string]: any }): message.input.Sensors.Servo;

                /**
                 * Creates a plain object from a Servo message. Also converts values to other types if specified.
                 * @param {message.input.Sensors.Servo} message Servo
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.Sensors.Servo, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Servo message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Servo to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type Button$Properties = {
                id?: number;
                value?: boolean;
            };

            /**
             * Constructs a new Button.
             * @exports message.input.Sensors.Button
             * @constructor
             * @param {message.input.Sensors.Button$Properties=} [properties] Properties to set
             */
            class Button {

                /**
                 * Constructs a new Button.
                 * @exports message.input.Sensors.Button
                 * @constructor
                 * @param {message.input.Sensors.Button$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.Sensors.Button$Properties);

                /**
                 * Button id.
                 * @type {number}
                 */
                public id: number;

                /**
                 * Button value.
                 * @type {boolean}
                 */
                public value: boolean;

                /**
                 * Creates a new Button instance using the specified properties.
                 * @param {message.input.Sensors.Button$Properties=} [properties] Properties to set
                 * @returns {message.input.Sensors.Button} Button instance
                 */
                public static create(properties?: message.input.Sensors.Button$Properties): message.input.Sensors.Button;

                /**
                 * Encodes the specified Button message. Does not implicitly {@link message.input.Sensors.Button.verify|verify} messages.
                 * @param {message.input.Sensors.Button$Properties} message Button message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.Sensors.Button$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Button message, length delimited. Does not implicitly {@link message.input.Sensors.Button.verify|verify} messages.
                 * @param {message.input.Sensors.Button$Properties} message Button message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.Sensors.Button$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Button message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.Sensors.Button} Button
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.Sensors.Button;

                /**
                 * Decodes a Button message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.Sensors.Button} Button
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.Sensors.Button;

                /**
                 * Verifies a Button message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Button message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.Button} Button
                 */
                public static fromObject(object: { [k: string]: any }): message.input.Sensors.Button;

                /**
                 * Creates a Button message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.Sensors.Button.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.Button} Button
                 */
                public static from(object: { [k: string]: any }): message.input.Sensors.Button;

                /**
                 * Creates a plain object from a Button message. Also converts values to other types if specified.
                 * @param {message.input.Sensors.Button} message Button
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.Sensors.Button, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Button message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Button to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type LED$Properties = {
                id?: number;
                colour?: number;
            };

            /**
             * Constructs a new LED.
             * @exports message.input.Sensors.LED
             * @constructor
             * @param {message.input.Sensors.LED$Properties=} [properties] Properties to set
             */
            class LED {

                /**
                 * Constructs a new LED.
                 * @exports message.input.Sensors.LED
                 * @constructor
                 * @param {message.input.Sensors.LED$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.Sensors.LED$Properties);

                /**
                 * LED id.
                 * @type {number}
                 */
                public id: number;

                /**
                 * LED colour.
                 * @type {number}
                 */
                public colour: number;

                /**
                 * Creates a new LED instance using the specified properties.
                 * @param {message.input.Sensors.LED$Properties=} [properties] Properties to set
                 * @returns {message.input.Sensors.LED} LED instance
                 */
                public static create(properties?: message.input.Sensors.LED$Properties): message.input.Sensors.LED;

                /**
                 * Encodes the specified LED message. Does not implicitly {@link message.input.Sensors.LED.verify|verify} messages.
                 * @param {message.input.Sensors.LED$Properties} message LED message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.Sensors.LED$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified LED message, length delimited. Does not implicitly {@link message.input.Sensors.LED.verify|verify} messages.
                 * @param {message.input.Sensors.LED$Properties} message LED message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.Sensors.LED$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a LED message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.Sensors.LED} LED
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.Sensors.LED;

                /**
                 * Decodes a LED message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.Sensors.LED} LED
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.Sensors.LED;

                /**
                 * Verifies a LED message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a LED message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.LED} LED
                 */
                public static fromObject(object: { [k: string]: any }): message.input.Sensors.LED;

                /**
                 * Creates a LED message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.Sensors.LED.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.LED} LED
                 */
                public static from(object: { [k: string]: any }): message.input.Sensors.LED;

                /**
                 * Creates a plain object from a LED message. Also converts values to other types if specified.
                 * @param {message.input.Sensors.LED} message LED
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.Sensors.LED, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this LED message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this LED to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type FSR$Properties = {
                value?: number[];
                centre?: vec2$Properties;
            };

            /**
             * Constructs a new FSR.
             * @exports message.input.Sensors.FSR
             * @constructor
             * @param {message.input.Sensors.FSR$Properties=} [properties] Properties to set
             */
            class FSR {

                /**
                 * Constructs a new FSR.
                 * @exports message.input.Sensors.FSR
                 * @constructor
                 * @param {message.input.Sensors.FSR$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.input.Sensors.FSR$Properties);

                /**
                 * FSR value.
                 * @type {Array.<number>}
                 */
                public value: number[];

                /**
                 * FSR centre.
                 * @type {(vec2$Properties|null)}
                 */
                public centre: (vec2$Properties|null);

                /**
                 * Creates a new FSR instance using the specified properties.
                 * @param {message.input.Sensors.FSR$Properties=} [properties] Properties to set
                 * @returns {message.input.Sensors.FSR} FSR instance
                 */
                public static create(properties?: message.input.Sensors.FSR$Properties): message.input.Sensors.FSR;

                /**
                 * Encodes the specified FSR message. Does not implicitly {@link message.input.Sensors.FSR.verify|verify} messages.
                 * @param {message.input.Sensors.FSR$Properties} message FSR message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.input.Sensors.FSR$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified FSR message, length delimited. Does not implicitly {@link message.input.Sensors.FSR.verify|verify} messages.
                 * @param {message.input.Sensors.FSR$Properties} message FSR message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.input.Sensors.FSR$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FSR message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.input.Sensors.FSR} FSR
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.input.Sensors.FSR;

                /**
                 * Decodes a FSR message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.input.Sensors.FSR} FSR
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.input.Sensors.FSR;

                /**
                 * Verifies a FSR message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a FSR message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.FSR} FSR
                 */
                public static fromObject(object: { [k: string]: any }): message.input.Sensors.FSR;

                /**
                 * Creates a FSR message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.input.Sensors.FSR.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.input.Sensors.FSR} FSR
                 */
                public static from(object: { [k: string]: any }): message.input.Sensors.FSR;

                /**
                 * Creates a plain object from a FSR message. Also converts values to other types if specified.
                 * @param {message.input.Sensors.FSR} message FSR
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.input.Sensors.FSR, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this FSR message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this FSR to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /**
     * Namespace localisation.
     * @exports message.localisation
     * @namespace
     */
    namespace localisation {

        type Ball$Properties = {
            position?: vec2$Properties;
            covariance?: mat22$Properties;
        };

        /**
         * Constructs a new Ball.
         * @exports message.localisation.Ball
         * @constructor
         * @param {message.localisation.Ball$Properties=} [properties] Properties to set
         */
        class Ball {

            /**
             * Constructs a new Ball.
             * @exports message.localisation.Ball
             * @constructor
             * @param {message.localisation.Ball$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.localisation.Ball$Properties);

            /**
             * Ball position.
             * @type {(vec2$Properties|null)}
             */
            public position: (vec2$Properties|null);

            /**
             * Ball covariance.
             * @type {(mat22$Properties|null)}
             */
            public covariance: (mat22$Properties|null);

            /**
             * Creates a new Ball instance using the specified properties.
             * @param {message.localisation.Ball$Properties=} [properties] Properties to set
             * @returns {message.localisation.Ball} Ball instance
             */
            public static create(properties?: message.localisation.Ball$Properties): message.localisation.Ball;

            /**
             * Encodes the specified Ball message. Does not implicitly {@link message.localisation.Ball.verify|verify} messages.
             * @param {message.localisation.Ball$Properties} message Ball message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.localisation.Ball$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Ball message, length delimited. Does not implicitly {@link message.localisation.Ball.verify|verify} messages.
             * @param {message.localisation.Ball$Properties} message Ball message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.localisation.Ball$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Ball message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.localisation.Ball} Ball
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.localisation.Ball;

            /**
             * Decodes a Ball message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.localisation.Ball} Ball
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.localisation.Ball;

            /**
             * Verifies a Ball message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a Ball message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.localisation.Ball} Ball
             */
            public static fromObject(object: { [k: string]: any }): message.localisation.Ball;

            /**
             * Creates a Ball message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.localisation.Ball.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.localisation.Ball} Ball
             */
            public static from(object: { [k: string]: any }): message.localisation.Ball;

            /**
             * Creates a plain object from a Ball message. Also converts values to other types if specified.
             * @param {message.localisation.Ball} message Ball
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.localisation.Ball, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Ball message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Ball to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type Field$Properties = {
            position?: vec3$Properties;
            covariance?: mat33$Properties;
        };

        /**
         * Constructs a new Field.
         * @exports message.localisation.Field
         * @constructor
         * @param {message.localisation.Field$Properties=} [properties] Properties to set
         */
        class Field {

            /**
             * Constructs a new Field.
             * @exports message.localisation.Field
             * @constructor
             * @param {message.localisation.Field$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.localisation.Field$Properties);

            /**
             * Field position.
             * @type {(vec3$Properties|null)}
             */
            public position: (vec3$Properties|null);

            /**
             * Field covariance.
             * @type {(mat33$Properties|null)}
             */
            public covariance: (mat33$Properties|null);

            /**
             * Creates a new Field instance using the specified properties.
             * @param {message.localisation.Field$Properties=} [properties] Properties to set
             * @returns {message.localisation.Field} Field instance
             */
            public static create(properties?: message.localisation.Field$Properties): message.localisation.Field;

            /**
             * Encodes the specified Field message. Does not implicitly {@link message.localisation.Field.verify|verify} messages.
             * @param {message.localisation.Field$Properties} message Field message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.localisation.Field$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Field message, length delimited. Does not implicitly {@link message.localisation.Field.verify|verify} messages.
             * @param {message.localisation.Field$Properties} message Field message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.localisation.Field$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Field message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.localisation.Field} Field
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.localisation.Field;

            /**
             * Decodes a Field message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.localisation.Field} Field
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.localisation.Field;

            /**
             * Verifies a Field message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a Field message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.localisation.Field} Field
             */
            public static fromObject(object: { [k: string]: any }): message.localisation.Field;

            /**
             * Creates a Field message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.localisation.Field.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.localisation.Field} Field
             */
            public static from(object: { [k: string]: any }): message.localisation.Field;

            /**
             * Creates a plain object from a Field message. Also converts values to other types if specified.
             * @param {message.localisation.Field} message Field
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.localisation.Field, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Field message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Field to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type ResetRobotHypotheses$Properties = {
            hypotheses?: message.localisation.ResetRobotHypotheses.Self$Properties[];
        };

        /**
         * Constructs a new ResetRobotHypotheses.
         * @exports message.localisation.ResetRobotHypotheses
         * @constructor
         * @param {message.localisation.ResetRobotHypotheses$Properties=} [properties] Properties to set
         */
        class ResetRobotHypotheses {

            /**
             * Constructs a new ResetRobotHypotheses.
             * @exports message.localisation.ResetRobotHypotheses
             * @constructor
             * @param {message.localisation.ResetRobotHypotheses$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.localisation.ResetRobotHypotheses$Properties);

            /**
             * ResetRobotHypotheses hypotheses.
             * @type {Array.<message.localisation.ResetRobotHypotheses.Self$Properties>}
             */
            public hypotheses: message.localisation.ResetRobotHypotheses.Self$Properties[];

            /**
             * Creates a new ResetRobotHypotheses instance using the specified properties.
             * @param {message.localisation.ResetRobotHypotheses$Properties=} [properties] Properties to set
             * @returns {message.localisation.ResetRobotHypotheses} ResetRobotHypotheses instance
             */
            public static create(properties?: message.localisation.ResetRobotHypotheses$Properties): message.localisation.ResetRobotHypotheses;

            /**
             * Encodes the specified ResetRobotHypotheses message. Does not implicitly {@link message.localisation.ResetRobotHypotheses.verify|verify} messages.
             * @param {message.localisation.ResetRobotHypotheses$Properties} message ResetRobotHypotheses message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.localisation.ResetRobotHypotheses$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified ResetRobotHypotheses message, length delimited. Does not implicitly {@link message.localisation.ResetRobotHypotheses.verify|verify} messages.
             * @param {message.localisation.ResetRobotHypotheses$Properties} message ResetRobotHypotheses message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.localisation.ResetRobotHypotheses$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ResetRobotHypotheses message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.localisation.ResetRobotHypotheses} ResetRobotHypotheses
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.localisation.ResetRobotHypotheses;

            /**
             * Decodes a ResetRobotHypotheses message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.localisation.ResetRobotHypotheses} ResetRobotHypotheses
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.localisation.ResetRobotHypotheses;

            /**
             * Verifies a ResetRobotHypotheses message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a ResetRobotHypotheses message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.localisation.ResetRobotHypotheses} ResetRobotHypotheses
             */
            public static fromObject(object: { [k: string]: any }): message.localisation.ResetRobotHypotheses;

            /**
             * Creates a ResetRobotHypotheses message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.localisation.ResetRobotHypotheses.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.localisation.ResetRobotHypotheses} ResetRobotHypotheses
             */
            public static from(object: { [k: string]: any }): message.localisation.ResetRobotHypotheses;

            /**
             * Creates a plain object from a ResetRobotHypotheses message. Also converts values to other types if specified.
             * @param {message.localisation.ResetRobotHypotheses} message ResetRobotHypotheses
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.localisation.ResetRobotHypotheses, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this ResetRobotHypotheses message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this ResetRobotHypotheses to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace ResetRobotHypotheses {

            type Self$Properties = {
                position?: vec2$Properties;
                positionCov?: mat22$Properties;
                heading?: number;
                headingVar?: number;
                absoluteYaw?: boolean;
            };

            /**
             * Constructs a new Self.
             * @exports message.localisation.ResetRobotHypotheses.Self
             * @constructor
             * @param {message.localisation.ResetRobotHypotheses.Self$Properties=} [properties] Properties to set
             */
            class Self {

                /**
                 * Constructs a new Self.
                 * @exports message.localisation.ResetRobotHypotheses.Self
                 * @constructor
                 * @param {message.localisation.ResetRobotHypotheses.Self$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.localisation.ResetRobotHypotheses.Self$Properties);

                /**
                 * Self position.
                 * @type {(vec2$Properties|null)}
                 */
                public position: (vec2$Properties|null);

                /**
                 * Self positionCov.
                 * @type {(mat22$Properties|null)}
                 */
                public positionCov: (mat22$Properties|null);

                /**
                 * Self heading.
                 * @type {number}
                 */
                public heading: number;

                /**
                 * Self headingVar.
                 * @type {number}
                 */
                public headingVar: number;

                /**
                 * Self absoluteYaw.
                 * @type {boolean}
                 */
                public absoluteYaw: boolean;

                /**
                 * Creates a new Self instance using the specified properties.
                 * @param {message.localisation.ResetRobotHypotheses.Self$Properties=} [properties] Properties to set
                 * @returns {message.localisation.ResetRobotHypotheses.Self} Self instance
                 */
                public static create(properties?: message.localisation.ResetRobotHypotheses.Self$Properties): message.localisation.ResetRobotHypotheses.Self;

                /**
                 * Encodes the specified Self message. Does not implicitly {@link message.localisation.ResetRobotHypotheses.Self.verify|verify} messages.
                 * @param {message.localisation.ResetRobotHypotheses.Self$Properties} message Self message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.localisation.ResetRobotHypotheses.Self$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Self message, length delimited. Does not implicitly {@link message.localisation.ResetRobotHypotheses.Self.verify|verify} messages.
                 * @param {message.localisation.ResetRobotHypotheses.Self$Properties} message Self message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.localisation.ResetRobotHypotheses.Self$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Self message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.localisation.ResetRobotHypotheses.Self} Self
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.localisation.ResetRobotHypotheses.Self;

                /**
                 * Decodes a Self message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.localisation.ResetRobotHypotheses.Self} Self
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.localisation.ResetRobotHypotheses.Self;

                /**
                 * Verifies a Self message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Self message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.localisation.ResetRobotHypotheses.Self} Self
                 */
                public static fromObject(object: { [k: string]: any }): message.localisation.ResetRobotHypotheses.Self;

                /**
                 * Creates a Self message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.localisation.ResetRobotHypotheses.Self.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.localisation.ResetRobotHypotheses.Self} Self
                 */
                public static from(object: { [k: string]: any }): message.localisation.ResetRobotHypotheses.Self;

                /**
                 * Creates a plain object from a Self message. Also converts values to other types if specified.
                 * @param {message.localisation.ResetRobotHypotheses.Self} message Self
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.localisation.ResetRobotHypotheses.Self, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Self message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Self to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /**
     * Namespace motion.
     * @exports message.motion
     * @namespace
     */
    namespace motion {

        type BalanceBodyUpdate$Properties = {
            phase?: number;
            leftFoot?: mat44$Properties;
            rightFoot?: mat44$Properties;
            armLPosition?: vec3$Properties;
            armRPosition?: vec3$Properties;
        };

        /**
         * Constructs a new BalanceBodyUpdate.
         * @exports message.motion.BalanceBodyUpdate
         * @constructor
         * @param {message.motion.BalanceBodyUpdate$Properties=} [properties] Properties to set
         */
        class BalanceBodyUpdate {

            /**
             * Constructs a new BalanceBodyUpdate.
             * @exports message.motion.BalanceBodyUpdate
             * @constructor
             * @param {message.motion.BalanceBodyUpdate$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.BalanceBodyUpdate$Properties);

            /**
             * BalanceBodyUpdate phase.
             * @type {number}
             */
            public phase: number;

            /**
             * BalanceBodyUpdate leftFoot.
             * @type {(mat44$Properties|null)}
             */
            public leftFoot: (mat44$Properties|null);

            /**
             * BalanceBodyUpdate rightFoot.
             * @type {(mat44$Properties|null)}
             */
            public rightFoot: (mat44$Properties|null);

            /**
             * BalanceBodyUpdate armLPosition.
             * @type {(vec3$Properties|null)}
             */
            public armLPosition: (vec3$Properties|null);

            /**
             * BalanceBodyUpdate armRPosition.
             * @type {(vec3$Properties|null)}
             */
            public armRPosition: (vec3$Properties|null);

            /**
             * Creates a new BalanceBodyUpdate instance using the specified properties.
             * @param {message.motion.BalanceBodyUpdate$Properties=} [properties] Properties to set
             * @returns {message.motion.BalanceBodyUpdate} BalanceBodyUpdate instance
             */
            public static create(properties?: message.motion.BalanceBodyUpdate$Properties): message.motion.BalanceBodyUpdate;

            /**
             * Encodes the specified BalanceBodyUpdate message. Does not implicitly {@link message.motion.BalanceBodyUpdate.verify|verify} messages.
             * @param {message.motion.BalanceBodyUpdate$Properties} message BalanceBodyUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.BalanceBodyUpdate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified BalanceBodyUpdate message, length delimited. Does not implicitly {@link message.motion.BalanceBodyUpdate.verify|verify} messages.
             * @param {message.motion.BalanceBodyUpdate$Properties} message BalanceBodyUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.BalanceBodyUpdate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a BalanceBodyUpdate message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.BalanceBodyUpdate} BalanceBodyUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.BalanceBodyUpdate;

            /**
             * Decodes a BalanceBodyUpdate message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.BalanceBodyUpdate} BalanceBodyUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.BalanceBodyUpdate;

            /**
             * Verifies a BalanceBodyUpdate message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a BalanceBodyUpdate message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.BalanceBodyUpdate} BalanceBodyUpdate
             */
            public static fromObject(object: { [k: string]: any }): message.motion.BalanceBodyUpdate;

            /**
             * Creates a BalanceBodyUpdate message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.BalanceBodyUpdate.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.BalanceBodyUpdate} BalanceBodyUpdate
             */
            public static from(object: { [k: string]: any }): message.motion.BalanceBodyUpdate;

            /**
             * Creates a plain object from a BalanceBodyUpdate message. Also converts values to other types if specified.
             * @param {message.motion.BalanceBodyUpdate} message BalanceBodyUpdate
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.BalanceBodyUpdate, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this BalanceBodyUpdate message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this BalanceBodyUpdate to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type EnableBalanceResponse$Properties = {};

        /**
         * Constructs a new EnableBalanceResponse.
         * @exports message.motion.EnableBalanceResponse
         * @constructor
         * @param {message.motion.EnableBalanceResponse$Properties=} [properties] Properties to set
         */
        class EnableBalanceResponse {

            /**
             * Constructs a new EnableBalanceResponse.
             * @exports message.motion.EnableBalanceResponse
             * @constructor
             * @param {message.motion.EnableBalanceResponse$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.EnableBalanceResponse$Properties);

            /**
             * Creates a new EnableBalanceResponse instance using the specified properties.
             * @param {message.motion.EnableBalanceResponse$Properties=} [properties] Properties to set
             * @returns {message.motion.EnableBalanceResponse} EnableBalanceResponse instance
             */
            public static create(properties?: message.motion.EnableBalanceResponse$Properties): message.motion.EnableBalanceResponse;

            /**
             * Encodes the specified EnableBalanceResponse message. Does not implicitly {@link message.motion.EnableBalanceResponse.verify|verify} messages.
             * @param {message.motion.EnableBalanceResponse$Properties} message EnableBalanceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.EnableBalanceResponse$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified EnableBalanceResponse message, length delimited. Does not implicitly {@link message.motion.EnableBalanceResponse.verify|verify} messages.
             * @param {message.motion.EnableBalanceResponse$Properties} message EnableBalanceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.EnableBalanceResponse$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EnableBalanceResponse message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.EnableBalanceResponse} EnableBalanceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.EnableBalanceResponse;

            /**
             * Decodes an EnableBalanceResponse message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.EnableBalanceResponse} EnableBalanceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.EnableBalanceResponse;

            /**
             * Verifies an EnableBalanceResponse message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an EnableBalanceResponse message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableBalanceResponse} EnableBalanceResponse
             */
            public static fromObject(object: { [k: string]: any }): message.motion.EnableBalanceResponse;

            /**
             * Creates an EnableBalanceResponse message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.EnableBalanceResponse.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableBalanceResponse} EnableBalanceResponse
             */
            public static from(object: { [k: string]: any }): message.motion.EnableBalanceResponse;

            /**
             * Creates a plain object from an EnableBalanceResponse message. Also converts values to other types if specified.
             * @param {message.motion.EnableBalanceResponse} message EnableBalanceResponse
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.EnableBalanceResponse, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this EnableBalanceResponse message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this EnableBalanceResponse to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type DisableBalanceResponse$Properties = {};

        /**
         * Constructs a new DisableBalanceResponse.
         * @exports message.motion.DisableBalanceResponse
         * @constructor
         * @param {message.motion.DisableBalanceResponse$Properties=} [properties] Properties to set
         */
        class DisableBalanceResponse {

            /**
             * Constructs a new DisableBalanceResponse.
             * @exports message.motion.DisableBalanceResponse
             * @constructor
             * @param {message.motion.DisableBalanceResponse$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.DisableBalanceResponse$Properties);

            /**
             * Creates a new DisableBalanceResponse instance using the specified properties.
             * @param {message.motion.DisableBalanceResponse$Properties=} [properties] Properties to set
             * @returns {message.motion.DisableBalanceResponse} DisableBalanceResponse instance
             */
            public static create(properties?: message.motion.DisableBalanceResponse$Properties): message.motion.DisableBalanceResponse;

            /**
             * Encodes the specified DisableBalanceResponse message. Does not implicitly {@link message.motion.DisableBalanceResponse.verify|verify} messages.
             * @param {message.motion.DisableBalanceResponse$Properties} message DisableBalanceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.DisableBalanceResponse$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified DisableBalanceResponse message, length delimited. Does not implicitly {@link message.motion.DisableBalanceResponse.verify|verify} messages.
             * @param {message.motion.DisableBalanceResponse$Properties} message DisableBalanceResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.DisableBalanceResponse$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DisableBalanceResponse message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DisableBalanceResponse} DisableBalanceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.DisableBalanceResponse;

            /**
             * Decodes a DisableBalanceResponse message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DisableBalanceResponse} DisableBalanceResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.DisableBalanceResponse;

            /**
             * Verifies a DisableBalanceResponse message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a DisableBalanceResponse message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableBalanceResponse} DisableBalanceResponse
             */
            public static fromObject(object: { [k: string]: any }): message.motion.DisableBalanceResponse;

            /**
             * Creates a DisableBalanceResponse message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DisableBalanceResponse.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableBalanceResponse} DisableBalanceResponse
             */
            public static from(object: { [k: string]: any }): message.motion.DisableBalanceResponse;

            /**
             * Creates a plain object from a DisableBalanceResponse message. Also converts values to other types if specified.
             * @param {message.motion.DisableBalanceResponse} message DisableBalanceResponse
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.DisableBalanceResponse, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this DisableBalanceResponse message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this DisableBalanceResponse to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type DiveCommand$Properties = {
            direction?: vec2$Properties;
        };

        /**
         * Constructs a new DiveCommand.
         * @exports message.motion.DiveCommand
         * @constructor
         * @param {message.motion.DiveCommand$Properties=} [properties] Properties to set
         */
        class DiveCommand {

            /**
             * Constructs a new DiveCommand.
             * @exports message.motion.DiveCommand
             * @constructor
             * @param {message.motion.DiveCommand$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.DiveCommand$Properties);

            /**
             * DiveCommand direction.
             * @type {(vec2$Properties|null)}
             */
            public direction: (vec2$Properties|null);

            /**
             * Creates a new DiveCommand instance using the specified properties.
             * @param {message.motion.DiveCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.DiveCommand} DiveCommand instance
             */
            public static create(properties?: message.motion.DiveCommand$Properties): message.motion.DiveCommand;

            /**
             * Encodes the specified DiveCommand message. Does not implicitly {@link message.motion.DiveCommand.verify|verify} messages.
             * @param {message.motion.DiveCommand$Properties} message DiveCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.DiveCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified DiveCommand message, length delimited. Does not implicitly {@link message.motion.DiveCommand.verify|verify} messages.
             * @param {message.motion.DiveCommand$Properties} message DiveCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.DiveCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DiveCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DiveCommand} DiveCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.DiveCommand;

            /**
             * Decodes a DiveCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DiveCommand} DiveCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.DiveCommand;

            /**
             * Verifies a DiveCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a DiveCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DiveCommand} DiveCommand
             */
            public static fromObject(object: { [k: string]: any }): message.motion.DiveCommand;

            /**
             * Creates a DiveCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DiveCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DiveCommand} DiveCommand
             */
            public static from(object: { [k: string]: any }): message.motion.DiveCommand;

            /**
             * Creates a plain object from a DiveCommand message. Also converts values to other types if specified.
             * @param {message.motion.DiveCommand} message DiveCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.DiveCommand, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this DiveCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this DiveCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type DiveFinished$Properties = {};

        /**
         * Constructs a new DiveFinished.
         * @exports message.motion.DiveFinished
         * @constructor
         * @param {message.motion.DiveFinished$Properties=} [properties] Properties to set
         */
        class DiveFinished {

            /**
             * Constructs a new DiveFinished.
             * @exports message.motion.DiveFinished
             * @constructor
             * @param {message.motion.DiveFinished$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.DiveFinished$Properties);

            /**
             * Creates a new DiveFinished instance using the specified properties.
             * @param {message.motion.DiveFinished$Properties=} [properties] Properties to set
             * @returns {message.motion.DiveFinished} DiveFinished instance
             */
            public static create(properties?: message.motion.DiveFinished$Properties): message.motion.DiveFinished;

            /**
             * Encodes the specified DiveFinished message. Does not implicitly {@link message.motion.DiveFinished.verify|verify} messages.
             * @param {message.motion.DiveFinished$Properties} message DiveFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.DiveFinished$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified DiveFinished message, length delimited. Does not implicitly {@link message.motion.DiveFinished.verify|verify} messages.
             * @param {message.motion.DiveFinished$Properties} message DiveFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.DiveFinished$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DiveFinished message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DiveFinished} DiveFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.DiveFinished;

            /**
             * Decodes a DiveFinished message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DiveFinished} DiveFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.DiveFinished;

            /**
             * Verifies a DiveFinished message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a DiveFinished message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DiveFinished} DiveFinished
             */
            public static fromObject(object: { [k: string]: any }): message.motion.DiveFinished;

            /**
             * Creates a DiveFinished message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DiveFinished.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DiveFinished} DiveFinished
             */
            public static from(object: { [k: string]: any }): message.motion.DiveFinished;

            /**
             * Creates a plain object from a DiveFinished message. Also converts values to other types if specified.
             * @param {message.motion.DiveFinished} message DiveFinished
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.DiveFinished, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this DiveFinished message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this DiveFinished to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type FootMotionStopped$Properties = {};

        /**
         * Constructs a new FootMotionStopped.
         * @exports message.motion.FootMotionStopped
         * @constructor
         * @param {message.motion.FootMotionStopped$Properties=} [properties] Properties to set
         */
        class FootMotionStopped {

            /**
             * Constructs a new FootMotionStopped.
             * @exports message.motion.FootMotionStopped
             * @constructor
             * @param {message.motion.FootMotionStopped$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.FootMotionStopped$Properties);

            /**
             * Creates a new FootMotionStopped instance using the specified properties.
             * @param {message.motion.FootMotionStopped$Properties=} [properties] Properties to set
             * @returns {message.motion.FootMotionStopped} FootMotionStopped instance
             */
            public static create(properties?: message.motion.FootMotionStopped$Properties): message.motion.FootMotionStopped;

            /**
             * Encodes the specified FootMotionStopped message. Does not implicitly {@link message.motion.FootMotionStopped.verify|verify} messages.
             * @param {message.motion.FootMotionStopped$Properties} message FootMotionStopped message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.FootMotionStopped$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FootMotionStopped message, length delimited. Does not implicitly {@link message.motion.FootMotionStopped.verify|verify} messages.
             * @param {message.motion.FootMotionStopped$Properties} message FootMotionStopped message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.FootMotionStopped$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FootMotionStopped message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.FootMotionStopped} FootMotionStopped
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.FootMotionStopped;

            /**
             * Decodes a FootMotionStopped message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.FootMotionStopped} FootMotionStopped
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.FootMotionStopped;

            /**
             * Verifies a FootMotionStopped message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FootMotionStopped message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootMotionStopped} FootMotionStopped
             */
            public static fromObject(object: { [k: string]: any }): message.motion.FootMotionStopped;

            /**
             * Creates a FootMotionStopped message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.FootMotionStopped.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootMotionStopped} FootMotionStopped
             */
            public static from(object: { [k: string]: any }): message.motion.FootMotionStopped;

            /**
             * Creates a plain object from a FootMotionStopped message. Also converts values to other types if specified.
             * @param {message.motion.FootMotionStopped} message FootMotionStopped
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.FootMotionStopped, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FootMotionStopped message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FootMotionStopped to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type FootMotionUpdate$Properties = {
            phase?: number;
            activeForwardLimb?: number;
            leftFoot2D?: vec3$Properties;
            rightFoot2D?: vec3$Properties;
            leftFoot3D?: mat44$Properties;
            rightFoot3D?: mat44$Properties;
        };

        /**
         * Constructs a new FootMotionUpdate.
         * @exports message.motion.FootMotionUpdate
         * @constructor
         * @param {message.motion.FootMotionUpdate$Properties=} [properties] Properties to set
         */
        class FootMotionUpdate {

            /**
             * Constructs a new FootMotionUpdate.
             * @exports message.motion.FootMotionUpdate
             * @constructor
             * @param {message.motion.FootMotionUpdate$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.FootMotionUpdate$Properties);

            /**
             * FootMotionUpdate phase.
             * @type {number}
             */
            public phase: number;

            /**
             * FootMotionUpdate activeForwardLimb.
             * @type {number}
             */
            public activeForwardLimb: number;

            /**
             * FootMotionUpdate leftFoot2D.
             * @type {(vec3$Properties|null)}
             */
            public leftFoot2D: (vec3$Properties|null);

            /**
             * FootMotionUpdate rightFoot2D.
             * @type {(vec3$Properties|null)}
             */
            public rightFoot2D: (vec3$Properties|null);

            /**
             * FootMotionUpdate leftFoot3D.
             * @type {(mat44$Properties|null)}
             */
            public leftFoot3D: (mat44$Properties|null);

            /**
             * FootMotionUpdate rightFoot3D.
             * @type {(mat44$Properties|null)}
             */
            public rightFoot3D: (mat44$Properties|null);

            /**
             * Creates a new FootMotionUpdate instance using the specified properties.
             * @param {message.motion.FootMotionUpdate$Properties=} [properties] Properties to set
             * @returns {message.motion.FootMotionUpdate} FootMotionUpdate instance
             */
            public static create(properties?: message.motion.FootMotionUpdate$Properties): message.motion.FootMotionUpdate;

            /**
             * Encodes the specified FootMotionUpdate message. Does not implicitly {@link message.motion.FootMotionUpdate.verify|verify} messages.
             * @param {message.motion.FootMotionUpdate$Properties} message FootMotionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.FootMotionUpdate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FootMotionUpdate message, length delimited. Does not implicitly {@link message.motion.FootMotionUpdate.verify|verify} messages.
             * @param {message.motion.FootMotionUpdate$Properties} message FootMotionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.FootMotionUpdate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FootMotionUpdate message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.FootMotionUpdate} FootMotionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.FootMotionUpdate;

            /**
             * Decodes a FootMotionUpdate message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.FootMotionUpdate} FootMotionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.FootMotionUpdate;

            /**
             * Verifies a FootMotionUpdate message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FootMotionUpdate message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootMotionUpdate} FootMotionUpdate
             */
            public static fromObject(object: { [k: string]: any }): message.motion.FootMotionUpdate;

            /**
             * Creates a FootMotionUpdate message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.FootMotionUpdate.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootMotionUpdate} FootMotionUpdate
             */
            public static from(object: { [k: string]: any }): message.motion.FootMotionUpdate;

            /**
             * Creates a plain object from a FootMotionUpdate message. Also converts values to other types if specified.
             * @param {message.motion.FootMotionUpdate} message FootMotionUpdate
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.FootMotionUpdate, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FootMotionUpdate message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FootMotionUpdate to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type NextFootTargetInfo$Properties = {
            leftFootSource?: vec3$Properties;
            rightFootSource?: vec3$Properties;
            supportMass?: vec3$Properties;
            leftFootDestination?: vec3$Properties;
            rightFootDestination?: vec3$Properties;
        };

        /**
         * Constructs a new NextFootTargetInfo.
         * @exports message.motion.NextFootTargetInfo
         * @constructor
         * @param {message.motion.NextFootTargetInfo$Properties=} [properties] Properties to set
         */
        class NextFootTargetInfo {

            /**
             * Constructs a new NextFootTargetInfo.
             * @exports message.motion.NextFootTargetInfo
             * @constructor
             * @param {message.motion.NextFootTargetInfo$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.NextFootTargetInfo$Properties);

            /**
             * NextFootTargetInfo leftFootSource.
             * @type {(vec3$Properties|null)}
             */
            public leftFootSource: (vec3$Properties|null);

            /**
             * NextFootTargetInfo rightFootSource.
             * @type {(vec3$Properties|null)}
             */
            public rightFootSource: (vec3$Properties|null);

            /**
             * NextFootTargetInfo supportMass.
             * @type {(vec3$Properties|null)}
             */
            public supportMass: (vec3$Properties|null);

            /**
             * NextFootTargetInfo leftFootDestination.
             * @type {(vec3$Properties|null)}
             */
            public leftFootDestination: (vec3$Properties|null);

            /**
             * NextFootTargetInfo rightFootDestination.
             * @type {(vec3$Properties|null)}
             */
            public rightFootDestination: (vec3$Properties|null);

            /**
             * Creates a new NextFootTargetInfo instance using the specified properties.
             * @param {message.motion.NextFootTargetInfo$Properties=} [properties] Properties to set
             * @returns {message.motion.NextFootTargetInfo} NextFootTargetInfo instance
             */
            public static create(properties?: message.motion.NextFootTargetInfo$Properties): message.motion.NextFootTargetInfo;

            /**
             * Encodes the specified NextFootTargetInfo message. Does not implicitly {@link message.motion.NextFootTargetInfo.verify|verify} messages.
             * @param {message.motion.NextFootTargetInfo$Properties} message NextFootTargetInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.NextFootTargetInfo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified NextFootTargetInfo message, length delimited. Does not implicitly {@link message.motion.NextFootTargetInfo.verify|verify} messages.
             * @param {message.motion.NextFootTargetInfo$Properties} message NextFootTargetInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.NextFootTargetInfo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NextFootTargetInfo message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.NextFootTargetInfo} NextFootTargetInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.NextFootTargetInfo;

            /**
             * Decodes a NextFootTargetInfo message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.NextFootTargetInfo} NextFootTargetInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.NextFootTargetInfo;

            /**
             * Verifies a NextFootTargetInfo message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a NextFootTargetInfo message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NextFootTargetInfo} NextFootTargetInfo
             */
            public static fromObject(object: { [k: string]: any }): message.motion.NextFootTargetInfo;

            /**
             * Creates a NextFootTargetInfo message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.NextFootTargetInfo.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NextFootTargetInfo} NextFootTargetInfo
             */
            public static from(object: { [k: string]: any }): message.motion.NextFootTargetInfo;

            /**
             * Creates a plain object from a NextFootTargetInfo message. Also converts values to other types if specified.
             * @param {message.motion.NextFootTargetInfo} message NextFootTargetInfo
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.NextFootTargetInfo, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this NextFootTargetInfo message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this NextFootTargetInfo to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type FootStepRequested$Properties = {
            status?: boolean;
        };

        /**
         * Constructs a new FootStepRequested.
         * @exports message.motion.FootStepRequested
         * @constructor
         * @param {message.motion.FootStepRequested$Properties=} [properties] Properties to set
         */
        class FootStepRequested {

            /**
             * Constructs a new FootStepRequested.
             * @exports message.motion.FootStepRequested
             * @constructor
             * @param {message.motion.FootStepRequested$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.FootStepRequested$Properties);

            /**
             * FootStepRequested status.
             * @type {boolean}
             */
            public status: boolean;

            /**
             * Creates a new FootStepRequested instance using the specified properties.
             * @param {message.motion.FootStepRequested$Properties=} [properties] Properties to set
             * @returns {message.motion.FootStepRequested} FootStepRequested instance
             */
            public static create(properties?: message.motion.FootStepRequested$Properties): message.motion.FootStepRequested;

            /**
             * Encodes the specified FootStepRequested message. Does not implicitly {@link message.motion.FootStepRequested.verify|verify} messages.
             * @param {message.motion.FootStepRequested$Properties} message FootStepRequested message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.FootStepRequested$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FootStepRequested message, length delimited. Does not implicitly {@link message.motion.FootStepRequested.verify|verify} messages.
             * @param {message.motion.FootStepRequested$Properties} message FootStepRequested message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.FootStepRequested$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FootStepRequested message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.FootStepRequested} FootStepRequested
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.FootStepRequested;

            /**
             * Decodes a FootStepRequested message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.FootStepRequested} FootStepRequested
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.FootStepRequested;

            /**
             * Verifies a FootStepRequested message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FootStepRequested message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootStepRequested} FootStepRequested
             */
            public static fromObject(object: { [k: string]: any }): message.motion.FootStepRequested;

            /**
             * Creates a FootStepRequested message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.FootStepRequested.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootStepRequested} FootStepRequested
             */
            public static from(object: { [k: string]: any }): message.motion.FootStepRequested;

            /**
             * Creates a plain object from a FootStepRequested message. Also converts values to other types if specified.
             * @param {message.motion.FootStepRequested} message FootStepRequested
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.FootStepRequested, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FootStepRequested message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FootStepRequested to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type FootStepCompleted$Properties = {
            status?: boolean;
        };

        /**
         * Constructs a new FootStepCompleted.
         * @exports message.motion.FootStepCompleted
         * @constructor
         * @param {message.motion.FootStepCompleted$Properties=} [properties] Properties to set
         */
        class FootStepCompleted {

            /**
             * Constructs a new FootStepCompleted.
             * @exports message.motion.FootStepCompleted
             * @constructor
             * @param {message.motion.FootStepCompleted$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.FootStepCompleted$Properties);

            /**
             * FootStepCompleted status.
             * @type {boolean}
             */
            public status: boolean;

            /**
             * Creates a new FootStepCompleted instance using the specified properties.
             * @param {message.motion.FootStepCompleted$Properties=} [properties] Properties to set
             * @returns {message.motion.FootStepCompleted} FootStepCompleted instance
             */
            public static create(properties?: message.motion.FootStepCompleted$Properties): message.motion.FootStepCompleted;

            /**
             * Encodes the specified FootStepCompleted message. Does not implicitly {@link message.motion.FootStepCompleted.verify|verify} messages.
             * @param {message.motion.FootStepCompleted$Properties} message FootStepCompleted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.FootStepCompleted$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FootStepCompleted message, length delimited. Does not implicitly {@link message.motion.FootStepCompleted.verify|verify} messages.
             * @param {message.motion.FootStepCompleted$Properties} message FootStepCompleted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.FootStepCompleted$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FootStepCompleted message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.FootStepCompleted} FootStepCompleted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.FootStepCompleted;

            /**
             * Decodes a FootStepCompleted message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.FootStepCompleted} FootStepCompleted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.FootStepCompleted;

            /**
             * Verifies a FootStepCompleted message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FootStepCompleted message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootStepCompleted} FootStepCompleted
             */
            public static fromObject(object: { [k: string]: any }): message.motion.FootStepCompleted;

            /**
             * Creates a FootStepCompleted message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.FootStepCompleted.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootStepCompleted} FootStepCompleted
             */
            public static from(object: { [k: string]: any }): message.motion.FootStepCompleted;

            /**
             * Creates a plain object from a FootStepCompleted message. Also converts values to other types if specified.
             * @param {message.motion.FootStepCompleted} message FootStepCompleted
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.FootStepCompleted, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FootStepCompleted message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FootStepCompleted to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type EnableFootMotion$Properties = {};

        /**
         * Constructs a new EnableFootMotion.
         * @exports message.motion.EnableFootMotion
         * @constructor
         * @param {message.motion.EnableFootMotion$Properties=} [properties] Properties to set
         */
        class EnableFootMotion {

            /**
             * Constructs a new EnableFootMotion.
             * @exports message.motion.EnableFootMotion
             * @constructor
             * @param {message.motion.EnableFootMotion$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.EnableFootMotion$Properties);

            /**
             * Creates a new EnableFootMotion instance using the specified properties.
             * @param {message.motion.EnableFootMotion$Properties=} [properties] Properties to set
             * @returns {message.motion.EnableFootMotion} EnableFootMotion instance
             */
            public static create(properties?: message.motion.EnableFootMotion$Properties): message.motion.EnableFootMotion;

            /**
             * Encodes the specified EnableFootMotion message. Does not implicitly {@link message.motion.EnableFootMotion.verify|verify} messages.
             * @param {message.motion.EnableFootMotion$Properties} message EnableFootMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.EnableFootMotion$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified EnableFootMotion message, length delimited. Does not implicitly {@link message.motion.EnableFootMotion.verify|verify} messages.
             * @param {message.motion.EnableFootMotion$Properties} message EnableFootMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.EnableFootMotion$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EnableFootMotion message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.EnableFootMotion} EnableFootMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.EnableFootMotion;

            /**
             * Decodes an EnableFootMotion message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.EnableFootMotion} EnableFootMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.EnableFootMotion;

            /**
             * Verifies an EnableFootMotion message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an EnableFootMotion message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableFootMotion} EnableFootMotion
             */
            public static fromObject(object: { [k: string]: any }): message.motion.EnableFootMotion;

            /**
             * Creates an EnableFootMotion message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.EnableFootMotion.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableFootMotion} EnableFootMotion
             */
            public static from(object: { [k: string]: any }): message.motion.EnableFootMotion;

            /**
             * Creates a plain object from an EnableFootMotion message. Also converts values to other types if specified.
             * @param {message.motion.EnableFootMotion} message EnableFootMotion
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.EnableFootMotion, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this EnableFootMotion message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this EnableFootMotion to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type DisableFootMotion$Properties = {};

        /**
         * Constructs a new DisableFootMotion.
         * @exports message.motion.DisableFootMotion
         * @constructor
         * @param {message.motion.DisableFootMotion$Properties=} [properties] Properties to set
         */
        class DisableFootMotion {

            /**
             * Constructs a new DisableFootMotion.
             * @exports message.motion.DisableFootMotion
             * @constructor
             * @param {message.motion.DisableFootMotion$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.DisableFootMotion$Properties);

            /**
             * Creates a new DisableFootMotion instance using the specified properties.
             * @param {message.motion.DisableFootMotion$Properties=} [properties] Properties to set
             * @returns {message.motion.DisableFootMotion} DisableFootMotion instance
             */
            public static create(properties?: message.motion.DisableFootMotion$Properties): message.motion.DisableFootMotion;

            /**
             * Encodes the specified DisableFootMotion message. Does not implicitly {@link message.motion.DisableFootMotion.verify|verify} messages.
             * @param {message.motion.DisableFootMotion$Properties} message DisableFootMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.DisableFootMotion$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified DisableFootMotion message, length delimited. Does not implicitly {@link message.motion.DisableFootMotion.verify|verify} messages.
             * @param {message.motion.DisableFootMotion$Properties} message DisableFootMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.DisableFootMotion$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DisableFootMotion message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DisableFootMotion} DisableFootMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.DisableFootMotion;

            /**
             * Decodes a DisableFootMotion message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DisableFootMotion} DisableFootMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.DisableFootMotion;

            /**
             * Verifies a DisableFootMotion message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a DisableFootMotion message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableFootMotion} DisableFootMotion
             */
            public static fromObject(object: { [k: string]: any }): message.motion.DisableFootMotion;

            /**
             * Creates a DisableFootMotion message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DisableFootMotion.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableFootMotion} DisableFootMotion
             */
            public static from(object: { [k: string]: any }): message.motion.DisableFootMotion;

            /**
             * Creates a plain object from a DisableFootMotion message. Also converts values to other types if specified.
             * @param {message.motion.DisableFootMotion} message DisableFootMotion
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.DisableFootMotion, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this DisableFootMotion message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this DisableFootMotion to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type FootPlacementStopped$Properties = {};

        /**
         * Constructs a new FootPlacementStopped.
         * @exports message.motion.FootPlacementStopped
         * @constructor
         * @param {message.motion.FootPlacementStopped$Properties=} [properties] Properties to set
         */
        class FootPlacementStopped {

            /**
             * Constructs a new FootPlacementStopped.
             * @exports message.motion.FootPlacementStopped
             * @constructor
             * @param {message.motion.FootPlacementStopped$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.FootPlacementStopped$Properties);

            /**
             * Creates a new FootPlacementStopped instance using the specified properties.
             * @param {message.motion.FootPlacementStopped$Properties=} [properties] Properties to set
             * @returns {message.motion.FootPlacementStopped} FootPlacementStopped instance
             */
            public static create(properties?: message.motion.FootPlacementStopped$Properties): message.motion.FootPlacementStopped;

            /**
             * Encodes the specified FootPlacementStopped message. Does not implicitly {@link message.motion.FootPlacementStopped.verify|verify} messages.
             * @param {message.motion.FootPlacementStopped$Properties} message FootPlacementStopped message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.FootPlacementStopped$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FootPlacementStopped message, length delimited. Does not implicitly {@link message.motion.FootPlacementStopped.verify|verify} messages.
             * @param {message.motion.FootPlacementStopped$Properties} message FootPlacementStopped message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.FootPlacementStopped$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FootPlacementStopped message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.FootPlacementStopped} FootPlacementStopped
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.FootPlacementStopped;

            /**
             * Decodes a FootPlacementStopped message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.FootPlacementStopped} FootPlacementStopped
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.FootPlacementStopped;

            /**
             * Verifies a FootPlacementStopped message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FootPlacementStopped message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootPlacementStopped} FootPlacementStopped
             */
            public static fromObject(object: { [k: string]: any }): message.motion.FootPlacementStopped;

            /**
             * Creates a FootPlacementStopped message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.FootPlacementStopped.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.FootPlacementStopped} FootPlacementStopped
             */
            public static from(object: { [k: string]: any }): message.motion.FootPlacementStopped;

            /**
             * Creates a plain object from a FootPlacementStopped message. Also converts values to other types if specified.
             * @param {message.motion.FootPlacementStopped} message FootPlacementStopped
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.FootPlacementStopped, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FootPlacementStopped message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FootPlacementStopped to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type NewStepTargetInfo$Properties = {
            targetTime?: number;
            velocityCurrent?: vec3$Properties;
            activeForwardLimb?: number;
        };

        /**
         * Constructs a new NewStepTargetInfo.
         * @exports message.motion.NewStepTargetInfo
         * @constructor
         * @param {message.motion.NewStepTargetInfo$Properties=} [properties] Properties to set
         */
        class NewStepTargetInfo {

            /**
             * Constructs a new NewStepTargetInfo.
             * @exports message.motion.NewStepTargetInfo
             * @constructor
             * @param {message.motion.NewStepTargetInfo$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.NewStepTargetInfo$Properties);

            /**
             * NewStepTargetInfo targetTime.
             * @type {number}
             */
            public targetTime: number;

            /**
             * NewStepTargetInfo velocityCurrent.
             * @type {(vec3$Properties|null)}
             */
            public velocityCurrent: (vec3$Properties|null);

            /**
             * NewStepTargetInfo activeForwardLimb.
             * @type {number}
             */
            public activeForwardLimb: number;

            /**
             * Creates a new NewStepTargetInfo instance using the specified properties.
             * @param {message.motion.NewStepTargetInfo$Properties=} [properties] Properties to set
             * @returns {message.motion.NewStepTargetInfo} NewStepTargetInfo instance
             */
            public static create(properties?: message.motion.NewStepTargetInfo$Properties): message.motion.NewStepTargetInfo;

            /**
             * Encodes the specified NewStepTargetInfo message. Does not implicitly {@link message.motion.NewStepTargetInfo.verify|verify} messages.
             * @param {message.motion.NewStepTargetInfo$Properties} message NewStepTargetInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.NewStepTargetInfo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified NewStepTargetInfo message, length delimited. Does not implicitly {@link message.motion.NewStepTargetInfo.verify|verify} messages.
             * @param {message.motion.NewStepTargetInfo$Properties} message NewStepTargetInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.NewStepTargetInfo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NewStepTargetInfo message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.NewStepTargetInfo} NewStepTargetInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.NewStepTargetInfo;

            /**
             * Decodes a NewStepTargetInfo message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.NewStepTargetInfo} NewStepTargetInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.NewStepTargetInfo;

            /**
             * Verifies a NewStepTargetInfo message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a NewStepTargetInfo message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NewStepTargetInfo} NewStepTargetInfo
             */
            public static fromObject(object: { [k: string]: any }): message.motion.NewStepTargetInfo;

            /**
             * Creates a NewStepTargetInfo message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.NewStepTargetInfo.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NewStepTargetInfo} NewStepTargetInfo
             */
            public static from(object: { [k: string]: any }): message.motion.NewStepTargetInfo;

            /**
             * Creates a plain object from a NewStepTargetInfo message. Also converts values to other types if specified.
             * @param {message.motion.NewStepTargetInfo} message NewStepTargetInfo
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.NewStepTargetInfo, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this NewStepTargetInfo message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this NewStepTargetInfo to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type NewFootTargetInfo$Properties = {
            leftFootSource?: vec3$Properties;
            rightFootSource?: vec3$Properties;
            supportMass?: vec3$Properties;
            leftFootDestination?: vec3$Properties;
            rightFootDestination?: vec3$Properties;
        };

        /**
         * Constructs a new NewFootTargetInfo.
         * @exports message.motion.NewFootTargetInfo
         * @constructor
         * @param {message.motion.NewFootTargetInfo$Properties=} [properties] Properties to set
         */
        class NewFootTargetInfo {

            /**
             * Constructs a new NewFootTargetInfo.
             * @exports message.motion.NewFootTargetInfo
             * @constructor
             * @param {message.motion.NewFootTargetInfo$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.NewFootTargetInfo$Properties);

            /**
             * NewFootTargetInfo leftFootSource.
             * @type {(vec3$Properties|null)}
             */
            public leftFootSource: (vec3$Properties|null);

            /**
             * NewFootTargetInfo rightFootSource.
             * @type {(vec3$Properties|null)}
             */
            public rightFootSource: (vec3$Properties|null);

            /**
             * NewFootTargetInfo supportMass.
             * @type {(vec3$Properties|null)}
             */
            public supportMass: (vec3$Properties|null);

            /**
             * NewFootTargetInfo leftFootDestination.
             * @type {(vec3$Properties|null)}
             */
            public leftFootDestination: (vec3$Properties|null);

            /**
             * NewFootTargetInfo rightFootDestination.
             * @type {(vec3$Properties|null)}
             */
            public rightFootDestination: (vec3$Properties|null);

            /**
             * Creates a new NewFootTargetInfo instance using the specified properties.
             * @param {message.motion.NewFootTargetInfo$Properties=} [properties] Properties to set
             * @returns {message.motion.NewFootTargetInfo} NewFootTargetInfo instance
             */
            public static create(properties?: message.motion.NewFootTargetInfo$Properties): message.motion.NewFootTargetInfo;

            /**
             * Encodes the specified NewFootTargetInfo message. Does not implicitly {@link message.motion.NewFootTargetInfo.verify|verify} messages.
             * @param {message.motion.NewFootTargetInfo$Properties} message NewFootTargetInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.NewFootTargetInfo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified NewFootTargetInfo message, length delimited. Does not implicitly {@link message.motion.NewFootTargetInfo.verify|verify} messages.
             * @param {message.motion.NewFootTargetInfo$Properties} message NewFootTargetInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.NewFootTargetInfo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NewFootTargetInfo message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.NewFootTargetInfo} NewFootTargetInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.NewFootTargetInfo;

            /**
             * Decodes a NewFootTargetInfo message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.NewFootTargetInfo} NewFootTargetInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.NewFootTargetInfo;

            /**
             * Verifies a NewFootTargetInfo message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a NewFootTargetInfo message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NewFootTargetInfo} NewFootTargetInfo
             */
            public static fromObject(object: { [k: string]: any }): message.motion.NewFootTargetInfo;

            /**
             * Creates a NewFootTargetInfo message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.NewFootTargetInfo.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NewFootTargetInfo} NewFootTargetInfo
             */
            public static from(object: { [k: string]: any }): message.motion.NewFootTargetInfo;

            /**
             * Creates a plain object from a NewFootTargetInfo message. Also converts values to other types if specified.
             * @param {message.motion.NewFootTargetInfo} message NewFootTargetInfo
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.NewFootTargetInfo, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this NewFootTargetInfo message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this NewFootTargetInfo to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type EnableFootPlacement$Properties = {};

        /**
         * Constructs a new EnableFootPlacement.
         * @exports message.motion.EnableFootPlacement
         * @constructor
         * @param {message.motion.EnableFootPlacement$Properties=} [properties] Properties to set
         */
        class EnableFootPlacement {

            /**
             * Constructs a new EnableFootPlacement.
             * @exports message.motion.EnableFootPlacement
             * @constructor
             * @param {message.motion.EnableFootPlacement$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.EnableFootPlacement$Properties);

            /**
             * Creates a new EnableFootPlacement instance using the specified properties.
             * @param {message.motion.EnableFootPlacement$Properties=} [properties] Properties to set
             * @returns {message.motion.EnableFootPlacement} EnableFootPlacement instance
             */
            public static create(properties?: message.motion.EnableFootPlacement$Properties): message.motion.EnableFootPlacement;

            /**
             * Encodes the specified EnableFootPlacement message. Does not implicitly {@link message.motion.EnableFootPlacement.verify|verify} messages.
             * @param {message.motion.EnableFootPlacement$Properties} message EnableFootPlacement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.EnableFootPlacement$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified EnableFootPlacement message, length delimited. Does not implicitly {@link message.motion.EnableFootPlacement.verify|verify} messages.
             * @param {message.motion.EnableFootPlacement$Properties} message EnableFootPlacement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.EnableFootPlacement$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EnableFootPlacement message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.EnableFootPlacement} EnableFootPlacement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.EnableFootPlacement;

            /**
             * Decodes an EnableFootPlacement message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.EnableFootPlacement} EnableFootPlacement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.EnableFootPlacement;

            /**
             * Verifies an EnableFootPlacement message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an EnableFootPlacement message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableFootPlacement} EnableFootPlacement
             */
            public static fromObject(object: { [k: string]: any }): message.motion.EnableFootPlacement;

            /**
             * Creates an EnableFootPlacement message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.EnableFootPlacement.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableFootPlacement} EnableFootPlacement
             */
            public static from(object: { [k: string]: any }): message.motion.EnableFootPlacement;

            /**
             * Creates a plain object from an EnableFootPlacement message. Also converts values to other types if specified.
             * @param {message.motion.EnableFootPlacement} message EnableFootPlacement
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.EnableFootPlacement, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this EnableFootPlacement message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this EnableFootPlacement to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type DisableFootPlacement$Properties = {};

        /**
         * Constructs a new DisableFootPlacement.
         * @exports message.motion.DisableFootPlacement
         * @constructor
         * @param {message.motion.DisableFootPlacement$Properties=} [properties] Properties to set
         */
        class DisableFootPlacement {

            /**
             * Constructs a new DisableFootPlacement.
             * @exports message.motion.DisableFootPlacement
             * @constructor
             * @param {message.motion.DisableFootPlacement$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.DisableFootPlacement$Properties);

            /**
             * Creates a new DisableFootPlacement instance using the specified properties.
             * @param {message.motion.DisableFootPlacement$Properties=} [properties] Properties to set
             * @returns {message.motion.DisableFootPlacement} DisableFootPlacement instance
             */
            public static create(properties?: message.motion.DisableFootPlacement$Properties): message.motion.DisableFootPlacement;

            /**
             * Encodes the specified DisableFootPlacement message. Does not implicitly {@link message.motion.DisableFootPlacement.verify|verify} messages.
             * @param {message.motion.DisableFootPlacement$Properties} message DisableFootPlacement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.DisableFootPlacement$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified DisableFootPlacement message, length delimited. Does not implicitly {@link message.motion.DisableFootPlacement.verify|verify} messages.
             * @param {message.motion.DisableFootPlacement$Properties} message DisableFootPlacement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.DisableFootPlacement$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DisableFootPlacement message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DisableFootPlacement} DisableFootPlacement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.DisableFootPlacement;

            /**
             * Decodes a DisableFootPlacement message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DisableFootPlacement} DisableFootPlacement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.DisableFootPlacement;

            /**
             * Verifies a DisableFootPlacement message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a DisableFootPlacement message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableFootPlacement} DisableFootPlacement
             */
            public static fromObject(object: { [k: string]: any }): message.motion.DisableFootPlacement;

            /**
             * Creates a DisableFootPlacement message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DisableFootPlacement.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableFootPlacement} DisableFootPlacement
             */
            public static from(object: { [k: string]: any }): message.motion.DisableFootPlacement;

            /**
             * Creates a plain object from a DisableFootPlacement message. Also converts values to other types if specified.
             * @param {message.motion.DisableFootPlacement} message DisableFootPlacement
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.DisableFootPlacement, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this DisableFootPlacement message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this DisableFootPlacement to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type ExecuteGetup$Properties = {};

        /**
         * Constructs a new ExecuteGetup.
         * @exports message.motion.ExecuteGetup
         * @constructor
         * @param {message.motion.ExecuteGetup$Properties=} [properties] Properties to set
         */
        class ExecuteGetup {

            /**
             * Constructs a new ExecuteGetup.
             * @exports message.motion.ExecuteGetup
             * @constructor
             * @param {message.motion.ExecuteGetup$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.ExecuteGetup$Properties);

            /**
             * Creates a new ExecuteGetup instance using the specified properties.
             * @param {message.motion.ExecuteGetup$Properties=} [properties] Properties to set
             * @returns {message.motion.ExecuteGetup} ExecuteGetup instance
             */
            public static create(properties?: message.motion.ExecuteGetup$Properties): message.motion.ExecuteGetup;

            /**
             * Encodes the specified ExecuteGetup message. Does not implicitly {@link message.motion.ExecuteGetup.verify|verify} messages.
             * @param {message.motion.ExecuteGetup$Properties} message ExecuteGetup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.ExecuteGetup$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified ExecuteGetup message, length delimited. Does not implicitly {@link message.motion.ExecuteGetup.verify|verify} messages.
             * @param {message.motion.ExecuteGetup$Properties} message ExecuteGetup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.ExecuteGetup$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an ExecuteGetup message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.ExecuteGetup} ExecuteGetup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.ExecuteGetup;

            /**
             * Decodes an ExecuteGetup message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.ExecuteGetup} ExecuteGetup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.ExecuteGetup;

            /**
             * Verifies an ExecuteGetup message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an ExecuteGetup message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.ExecuteGetup} ExecuteGetup
             */
            public static fromObject(object: { [k: string]: any }): message.motion.ExecuteGetup;

            /**
             * Creates an ExecuteGetup message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.ExecuteGetup.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.ExecuteGetup} ExecuteGetup
             */
            public static from(object: { [k: string]: any }): message.motion.ExecuteGetup;

            /**
             * Creates a plain object from an ExecuteGetup message. Also converts values to other types if specified.
             * @param {message.motion.ExecuteGetup} message ExecuteGetup
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.ExecuteGetup, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this ExecuteGetup message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this ExecuteGetup to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type KillGetup$Properties = {};

        /**
         * Constructs a new KillGetup.
         * @exports message.motion.KillGetup
         * @constructor
         * @param {message.motion.KillGetup$Properties=} [properties] Properties to set
         */
        class KillGetup {

            /**
             * Constructs a new KillGetup.
             * @exports message.motion.KillGetup
             * @constructor
             * @param {message.motion.KillGetup$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.KillGetup$Properties);

            /**
             * Creates a new KillGetup instance using the specified properties.
             * @param {message.motion.KillGetup$Properties=} [properties] Properties to set
             * @returns {message.motion.KillGetup} KillGetup instance
             */
            public static create(properties?: message.motion.KillGetup$Properties): message.motion.KillGetup;

            /**
             * Encodes the specified KillGetup message. Does not implicitly {@link message.motion.KillGetup.verify|verify} messages.
             * @param {message.motion.KillGetup$Properties} message KillGetup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.KillGetup$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified KillGetup message, length delimited. Does not implicitly {@link message.motion.KillGetup.verify|verify} messages.
             * @param {message.motion.KillGetup$Properties} message KillGetup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.KillGetup$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a KillGetup message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KillGetup} KillGetup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.KillGetup;

            /**
             * Decodes a KillGetup message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.KillGetup} KillGetup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.KillGetup;

            /**
             * Verifies a KillGetup message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a KillGetup message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KillGetup} KillGetup
             */
            public static fromObject(object: { [k: string]: any }): message.motion.KillGetup;

            /**
             * Creates a KillGetup message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.KillGetup.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KillGetup} KillGetup
             */
            public static from(object: { [k: string]: any }): message.motion.KillGetup;

            /**
             * Creates a plain object from a KillGetup message. Also converts values to other types if specified.
             * @param {message.motion.KillGetup} message KillGetup
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.KillGetup, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this KillGetup message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this KillGetup to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type HeadCommand$Properties = {
            yaw?: number;
            pitch?: number;
            robotSpace?: boolean;
        };

        /**
         * Constructs a new HeadCommand.
         * @classdesc Tell the head where to look in world space.
         * This command is interpreted such that the robot will use IMU data to fixate at these angles in the world even when rotating.
         *
         * @author Jake Fountain
         * @exports message.motion.HeadCommand
         * @constructor
         * @param {message.motion.HeadCommand$Properties=} [properties] Properties to set
         */
        class HeadCommand {

            /**
             * Constructs a new HeadCommand.
             * @classdesc Tell the head where to look in world space.
             * This command is interpreted such that the robot will use IMU data to fixate at these angles in the world even when rotating.
             *
             * @author Jake Fountain
             * @exports message.motion.HeadCommand
             * @constructor
             * @param {message.motion.HeadCommand$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.HeadCommand$Properties);

            /**
             * HeadCommand yaw.
             * @type {number}
             */
            public yaw: number;

            /**
             * HeadCommand pitch.
             * @type {number}
             */
            public pitch: number;

            /**
             * HeadCommand robotSpace.
             * @type {boolean}
             */
            public robotSpace: boolean;

            /**
             * Creates a new HeadCommand instance using the specified properties.
             * @param {message.motion.HeadCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.HeadCommand} HeadCommand instance
             */
            public static create(properties?: message.motion.HeadCommand$Properties): message.motion.HeadCommand;

            /**
             * Encodes the specified HeadCommand message. Does not implicitly {@link message.motion.HeadCommand.verify|verify} messages.
             * @param {message.motion.HeadCommand$Properties} message HeadCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.HeadCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified HeadCommand message, length delimited. Does not implicitly {@link message.motion.HeadCommand.verify|verify} messages.
             * @param {message.motion.HeadCommand$Properties} message HeadCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.HeadCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a HeadCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.HeadCommand} HeadCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.HeadCommand;

            /**
             * Decodes a HeadCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.HeadCommand} HeadCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.HeadCommand;

            /**
             * Verifies a HeadCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a HeadCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.HeadCommand} HeadCommand
             */
            public static fromObject(object: { [k: string]: any }): message.motion.HeadCommand;

            /**
             * Creates a HeadCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.HeadCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.HeadCommand} HeadCommand
             */
            public static from(object: { [k: string]: any }): message.motion.HeadCommand;

            /**
             * Creates a plain object from a HeadCommand message. Also converts values to other types if specified.
             * @param {message.motion.HeadCommand} message HeadCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.HeadCommand, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this HeadCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this HeadCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type HeadMotionUpdate$Properties = {};

        /**
         * Constructs a new HeadMotionUpdate.
         * @exports message.motion.HeadMotionUpdate
         * @constructor
         * @param {message.motion.HeadMotionUpdate$Properties=} [properties] Properties to set
         */
        class HeadMotionUpdate {

            /**
             * Constructs a new HeadMotionUpdate.
             * @exports message.motion.HeadMotionUpdate
             * @constructor
             * @param {message.motion.HeadMotionUpdate$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.HeadMotionUpdate$Properties);

            /**
             * Creates a new HeadMotionUpdate instance using the specified properties.
             * @param {message.motion.HeadMotionUpdate$Properties=} [properties] Properties to set
             * @returns {message.motion.HeadMotionUpdate} HeadMotionUpdate instance
             */
            public static create(properties?: message.motion.HeadMotionUpdate$Properties): message.motion.HeadMotionUpdate;

            /**
             * Encodes the specified HeadMotionUpdate message. Does not implicitly {@link message.motion.HeadMotionUpdate.verify|verify} messages.
             * @param {message.motion.HeadMotionUpdate$Properties} message HeadMotionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.HeadMotionUpdate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified HeadMotionUpdate message, length delimited. Does not implicitly {@link message.motion.HeadMotionUpdate.verify|verify} messages.
             * @param {message.motion.HeadMotionUpdate$Properties} message HeadMotionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.HeadMotionUpdate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a HeadMotionUpdate message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.HeadMotionUpdate} HeadMotionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.HeadMotionUpdate;

            /**
             * Decodes a HeadMotionUpdate message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.HeadMotionUpdate} HeadMotionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.HeadMotionUpdate;

            /**
             * Verifies a HeadMotionUpdate message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a HeadMotionUpdate message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.HeadMotionUpdate} HeadMotionUpdate
             */
            public static fromObject(object: { [k: string]: any }): message.motion.HeadMotionUpdate;

            /**
             * Creates a HeadMotionUpdate message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.HeadMotionUpdate.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.HeadMotionUpdate} HeadMotionUpdate
             */
            public static from(object: { [k: string]: any }): message.motion.HeadMotionUpdate;

            /**
             * Creates a plain object from a HeadMotionUpdate message. Also converts values to other types if specified.
             * @param {message.motion.HeadMotionUpdate} message HeadMotionUpdate
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.HeadMotionUpdate, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this HeadMotionUpdate message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this HeadMotionUpdate to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /**
         * TODO document
         *
         * @author Trent Houliston
         * @author Brendan Annable
         * @name KickCommandType
         * @memberof message.motion
         * @enum {number}
         * @property {number} NORMAL=0 NORMAL value
         * @property {number} POWER=1 POWER value
         */
        enum KickCommandType {
            NORMAL = 0,
            POWER = 1
        }

        type KickCommand$Properties = {
            target?: vec3$Properties;
            direction?: vec3$Properties;
            kickCommandType?: message.motion.KickCommandType;
        };

        /**
         * Constructs a new KickCommand.
         * @exports message.motion.KickCommand
         * @constructor
         * @param {message.motion.KickCommand$Properties=} [properties] Properties to set
         */
        class KickCommand {

            /**
             * Constructs a new KickCommand.
             * @exports message.motion.KickCommand
             * @constructor
             * @param {message.motion.KickCommand$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.KickCommand$Properties);

            /**
             * KickCommand target.
             * @type {(vec3$Properties|null)}
             */
            public target: (vec3$Properties|null);

            /**
             * KickCommand direction.
             * @type {(vec3$Properties|null)}
             */
            public direction: (vec3$Properties|null);

            /**
             * KickCommand kickCommandType.
             * @type {message.motion.KickCommandType}
             */
            public kickCommandType: message.motion.KickCommandType;

            /**
             * Creates a new KickCommand instance using the specified properties.
             * @param {message.motion.KickCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.KickCommand} KickCommand instance
             */
            public static create(properties?: message.motion.KickCommand$Properties): message.motion.KickCommand;

            /**
             * Encodes the specified KickCommand message. Does not implicitly {@link message.motion.KickCommand.verify|verify} messages.
             * @param {message.motion.KickCommand$Properties} message KickCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.KickCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified KickCommand message, length delimited. Does not implicitly {@link message.motion.KickCommand.verify|verify} messages.
             * @param {message.motion.KickCommand$Properties} message KickCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.KickCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a KickCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KickCommand} KickCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.KickCommand;

            /**
             * Decodes a KickCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.KickCommand} KickCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.KickCommand;

            /**
             * Verifies a KickCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a KickCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickCommand} KickCommand
             */
            public static fromObject(object: { [k: string]: any }): message.motion.KickCommand;

            /**
             * Creates a KickCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.KickCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickCommand} KickCommand
             */
            public static from(object: { [k: string]: any }): message.motion.KickCommand;

            /**
             * Creates a plain object from a KickCommand message. Also converts values to other types if specified.
             * @param {message.motion.KickCommand} message KickCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.KickCommand, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this KickCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this KickCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type KickScriptCommand$Properties = {
            direction?: vec3$Properties;
            leg?: number;
        };

        /**
         * Constructs a new KickScriptCommand.
         * @classdesc TODO document
         *
         * @author Trent Houliston
         * @author Brendan Annable
         * @exports message.motion.KickScriptCommand
         * @constructor
         * @param {message.motion.KickScriptCommand$Properties=} [properties] Properties to set
         */
        class KickScriptCommand {

            /**
             * Constructs a new KickScriptCommand.
             * @classdesc TODO document
             *
             * @author Trent Houliston
             * @author Brendan Annable
             * @exports message.motion.KickScriptCommand
             * @constructor
             * @param {message.motion.KickScriptCommand$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.KickScriptCommand$Properties);

            /**
             * KickScriptCommand direction.
             * @type {(vec3$Properties|null)}
             */
            public direction: (vec3$Properties|null);

            /**
             * KickScriptCommand leg.
             * @type {number}
             */
            public leg: number;

            /**
             * Creates a new KickScriptCommand instance using the specified properties.
             * @param {message.motion.KickScriptCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.KickScriptCommand} KickScriptCommand instance
             */
            public static create(properties?: message.motion.KickScriptCommand$Properties): message.motion.KickScriptCommand;

            /**
             * Encodes the specified KickScriptCommand message. Does not implicitly {@link message.motion.KickScriptCommand.verify|verify} messages.
             * @param {message.motion.KickScriptCommand$Properties} message KickScriptCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.KickScriptCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified KickScriptCommand message, length delimited. Does not implicitly {@link message.motion.KickScriptCommand.verify|verify} messages.
             * @param {message.motion.KickScriptCommand$Properties} message KickScriptCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.KickScriptCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a KickScriptCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KickScriptCommand} KickScriptCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.KickScriptCommand;

            /**
             * Decodes a KickScriptCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.KickScriptCommand} KickScriptCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.KickScriptCommand;

            /**
             * Verifies a KickScriptCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a KickScriptCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickScriptCommand} KickScriptCommand
             */
            public static fromObject(object: { [k: string]: any }): message.motion.KickScriptCommand;

            /**
             * Creates a KickScriptCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.KickScriptCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickScriptCommand} KickScriptCommand
             */
            public static from(object: { [k: string]: any }): message.motion.KickScriptCommand;

            /**
             * Creates a plain object from a KickScriptCommand message. Also converts values to other types if specified.
             * @param {message.motion.KickScriptCommand} message KickScriptCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.KickScriptCommand, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this KickScriptCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this KickScriptCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type KickPlannerConfig$Properties = {
            maxBallDistance?: number;
            kickCorridorWidth?: number;
            secondsNotSeenLimit?: number;
            kickForwardAngleLimit?: number;
        };

        /**
         * Constructs a new KickPlannerConfig.
         * @exports message.motion.KickPlannerConfig
         * @constructor
         * @param {message.motion.KickPlannerConfig$Properties=} [properties] Properties to set
         */
        class KickPlannerConfig {

            /**
             * Constructs a new KickPlannerConfig.
             * @exports message.motion.KickPlannerConfig
             * @constructor
             * @param {message.motion.KickPlannerConfig$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.KickPlannerConfig$Properties);

            /**
             * KickPlannerConfig maxBallDistance.
             * @type {number}
             */
            public maxBallDistance: number;

            /**
             * KickPlannerConfig kickCorridorWidth.
             * @type {number}
             */
            public kickCorridorWidth: number;

            /**
             * KickPlannerConfig secondsNotSeenLimit.
             * @type {number}
             */
            public secondsNotSeenLimit: number;

            /**
             * KickPlannerConfig kickForwardAngleLimit.
             * @type {number}
             */
            public kickForwardAngleLimit: number;

            /**
             * Creates a new KickPlannerConfig instance using the specified properties.
             * @param {message.motion.KickPlannerConfig$Properties=} [properties] Properties to set
             * @returns {message.motion.KickPlannerConfig} KickPlannerConfig instance
             */
            public static create(properties?: message.motion.KickPlannerConfig$Properties): message.motion.KickPlannerConfig;

            /**
             * Encodes the specified KickPlannerConfig message. Does not implicitly {@link message.motion.KickPlannerConfig.verify|verify} messages.
             * @param {message.motion.KickPlannerConfig$Properties} message KickPlannerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.KickPlannerConfig$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified KickPlannerConfig message, length delimited. Does not implicitly {@link message.motion.KickPlannerConfig.verify|verify} messages.
             * @param {message.motion.KickPlannerConfig$Properties} message KickPlannerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.KickPlannerConfig$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a KickPlannerConfig message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KickPlannerConfig} KickPlannerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.KickPlannerConfig;

            /**
             * Decodes a KickPlannerConfig message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.KickPlannerConfig} KickPlannerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.KickPlannerConfig;

            /**
             * Verifies a KickPlannerConfig message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a KickPlannerConfig message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickPlannerConfig} KickPlannerConfig
             */
            public static fromObject(object: { [k: string]: any }): message.motion.KickPlannerConfig;

            /**
             * Creates a KickPlannerConfig message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.KickPlannerConfig.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickPlannerConfig} KickPlannerConfig
             */
            public static from(object: { [k: string]: any }): message.motion.KickPlannerConfig;

            /**
             * Creates a plain object from a KickPlannerConfig message. Also converts values to other types if specified.
             * @param {message.motion.KickPlannerConfig} message KickPlannerConfig
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.KickPlannerConfig, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this KickPlannerConfig message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this KickPlannerConfig to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type KickFinished$Properties = {};

        /**
         * Constructs a new KickFinished.
         * @exports message.motion.KickFinished
         * @constructor
         * @param {message.motion.KickFinished$Properties=} [properties] Properties to set
         */
        class KickFinished {

            /**
             * Constructs a new KickFinished.
             * @exports message.motion.KickFinished
             * @constructor
             * @param {message.motion.KickFinished$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.KickFinished$Properties);

            /**
             * Creates a new KickFinished instance using the specified properties.
             * @param {message.motion.KickFinished$Properties=} [properties] Properties to set
             * @returns {message.motion.KickFinished} KickFinished instance
             */
            public static create(properties?: message.motion.KickFinished$Properties): message.motion.KickFinished;

            /**
             * Encodes the specified KickFinished message. Does not implicitly {@link message.motion.KickFinished.verify|verify} messages.
             * @param {message.motion.KickFinished$Properties} message KickFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.KickFinished$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified KickFinished message, length delimited. Does not implicitly {@link message.motion.KickFinished.verify|verify} messages.
             * @param {message.motion.KickFinished$Properties} message KickFinished message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.KickFinished$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a KickFinished message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KickFinished} KickFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.KickFinished;

            /**
             * Decodes a KickFinished message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.KickFinished} KickFinished
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.KickFinished;

            /**
             * Verifies a KickFinished message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a KickFinished message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickFinished} KickFinished
             */
            public static fromObject(object: { [k: string]: any }): message.motion.KickFinished;

            /**
             * Creates a KickFinished message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.KickFinished.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KickFinished} KickFinished
             */
            public static from(object: { [k: string]: any }): message.motion.KickFinished;

            /**
             * Creates a plain object from a KickFinished message. Also converts values to other types if specified.
             * @param {message.motion.KickFinished} message KickFinished
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.KickFinished, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this KickFinished message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this KickFinished to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type IKKickParams$Properties = {
            standHeight?: number;
        };

        /**
         * Constructs a new IKKickParams.
         * @exports message.motion.IKKickParams
         * @constructor
         * @param {message.motion.IKKickParams$Properties=} [properties] Properties to set
         */
        class IKKickParams {

            /**
             * Constructs a new IKKickParams.
             * @exports message.motion.IKKickParams
             * @constructor
             * @param {message.motion.IKKickParams$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.IKKickParams$Properties);

            /**
             * IKKickParams standHeight.
             * @type {number}
             */
            public standHeight: number;

            /**
             * Creates a new IKKickParams instance using the specified properties.
             * @param {message.motion.IKKickParams$Properties=} [properties] Properties to set
             * @returns {message.motion.IKKickParams} IKKickParams instance
             */
            public static create(properties?: message.motion.IKKickParams$Properties): message.motion.IKKickParams;

            /**
             * Encodes the specified IKKickParams message. Does not implicitly {@link message.motion.IKKickParams.verify|verify} messages.
             * @param {message.motion.IKKickParams$Properties} message IKKickParams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.IKKickParams$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified IKKickParams message, length delimited. Does not implicitly {@link message.motion.IKKickParams.verify|verify} messages.
             * @param {message.motion.IKKickParams$Properties} message IKKickParams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.IKKickParams$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a IKKickParams message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.IKKickParams} IKKickParams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.IKKickParams;

            /**
             * Decodes a IKKickParams message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.IKKickParams} IKKickParams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.IKKickParams;

            /**
             * Verifies a IKKickParams message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a IKKickParams message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.IKKickParams} IKKickParams
             */
            public static fromObject(object: { [k: string]: any }): message.motion.IKKickParams;

            /**
             * Creates a IKKickParams message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.IKKickParams.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.IKKickParams} IKKickParams
             */
            public static from(object: { [k: string]: any }): message.motion.IKKickParams;

            /**
             * Creates a plain object from a IKKickParams message. Also converts values to other types if specified.
             * @param {message.motion.IKKickParams} message IKKickParams
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.IKKickParams, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this IKKickParams message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this IKKickParams to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /**
         * BodySide enum.
         * @name BodySide
         * @memberof message.motion
         * @enum {number}
         * @property {number} LEFT=0 LEFT value
         * @property {number} RIGHT=1 RIGHT value
         */
        enum BodySide {
            LEFT = 0,
            RIGHT = 1
        }

        type KinematicsModel$Properties = {
            leg?: message.motion.KinematicsModel.Leg$Properties;
            head?: message.motion.KinematicsModel.Head$Properties;
            arm?: message.motion.KinematicsModel.Arm$Properties;
            massModel?: message.motion.KinematicsModel.MassModel$Properties;
            TEAMDARWINCHEST_TO_ORIGIN?: number;
        };

        /**
         * Constructs a new KinematicsModel.
         * @exports message.motion.KinematicsModel
         * @constructor
         * @param {message.motion.KinematicsModel$Properties=} [properties] Properties to set
         */
        class KinematicsModel {

            /**
             * Constructs a new KinematicsModel.
             * @exports message.motion.KinematicsModel
             * @constructor
             * @param {message.motion.KinematicsModel$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.KinematicsModel$Properties);

            /**
             * KinematicsModel leg.
             * @type {(message.motion.KinematicsModel.Leg$Properties|null)}
             */
            public leg: (message.motion.KinematicsModel.Leg$Properties|null);

            /**
             * KinematicsModel head.
             * @type {(message.motion.KinematicsModel.Head$Properties|null)}
             */
            public head: (message.motion.KinematicsModel.Head$Properties|null);

            /**
             * KinematicsModel arm.
             * @type {(message.motion.KinematicsModel.Arm$Properties|null)}
             */
            public arm: (message.motion.KinematicsModel.Arm$Properties|null);

            /**
             * KinematicsModel massModel.
             * @type {(message.motion.KinematicsModel.MassModel$Properties|null)}
             */
            public massModel: (message.motion.KinematicsModel.MassModel$Properties|null);

            /**
             * KinematicsModel TEAMDARWINCHEST_TO_ORIGIN.
             * @type {number}
             */
            public TEAMDARWINCHEST_TO_ORIGIN: number;

            /**
             * Creates a new KinematicsModel instance using the specified properties.
             * @param {message.motion.KinematicsModel$Properties=} [properties] Properties to set
             * @returns {message.motion.KinematicsModel} KinematicsModel instance
             */
            public static create(properties?: message.motion.KinematicsModel$Properties): message.motion.KinematicsModel;

            /**
             * Encodes the specified KinematicsModel message. Does not implicitly {@link message.motion.KinematicsModel.verify|verify} messages.
             * @param {message.motion.KinematicsModel$Properties} message KinematicsModel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.KinematicsModel$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified KinematicsModel message, length delimited. Does not implicitly {@link message.motion.KinematicsModel.verify|verify} messages.
             * @param {message.motion.KinematicsModel$Properties} message KinematicsModel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.KinematicsModel$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a KinematicsModel message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.KinematicsModel} KinematicsModel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.KinematicsModel;

            /**
             * Decodes a KinematicsModel message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.KinematicsModel} KinematicsModel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.KinematicsModel;

            /**
             * Verifies a KinematicsModel message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a KinematicsModel message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KinematicsModel} KinematicsModel
             */
            public static fromObject(object: { [k: string]: any }): message.motion.KinematicsModel;

            /**
             * Creates a KinematicsModel message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.KinematicsModel.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.KinematicsModel} KinematicsModel
             */
            public static from(object: { [k: string]: any }): message.motion.KinematicsModel;

            /**
             * Creates a plain object from a KinematicsModel message. Also converts values to other types if specified.
             * @param {message.motion.KinematicsModel} message KinematicsModel
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.KinematicsModel, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this KinematicsModel message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this KinematicsModel to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace KinematicsModel {

            type Leg$Properties = {
                HIP_OFFSET_X?: number;
                HIP_OFFSET_Y?: number;
                HIP_OFFSET_Z?: number;
                UPPER_LEG_LENGTH?: number;
                LOWER_LEG_LENGTH?: number;
                FOOT_HEIGHT?: number;
                FOOT_LENGTH?: number;
                TOE_LENGTH?: number;
                HEEL_LENGTH?: number;
                FOOT_WIDTH?: number;
                FOOT_CENTRE_TO_ANKLE_CENTRE?: number;
                LENGTH_BETWEEN_LEGS?: number;
                LEFT_TO_RIGHT_HIP_YAW?: number;
                LEFT_TO_RIGHT_HIP_ROLL?: number;
                LEFT_TO_RIGHT_HIP_PITCH?: number;
                LEFT_TO_RIGHT_KNEE?: number;
                LEFT_TO_RIGHT_ANKLE_PITCH?: number;
                LEFT_TO_RIGHT_ANKLE_ROLL?: number;
            };

            /**
             * Constructs a new Leg.
             * @exports message.motion.KinematicsModel.Leg
             * @constructor
             * @param {message.motion.KinematicsModel.Leg$Properties=} [properties] Properties to set
             */
            class Leg {

                /**
                 * Constructs a new Leg.
                 * @exports message.motion.KinematicsModel.Leg
                 * @constructor
                 * @param {message.motion.KinematicsModel.Leg$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.motion.KinematicsModel.Leg$Properties);

                /**
                 * Leg HIP_OFFSET_X.
                 * @type {number}
                 */
                public HIP_OFFSET_X: number;

                /**
                 * Leg HIP_OFFSET_Y.
                 * @type {number}
                 */
                public HIP_OFFSET_Y: number;

                /**
                 * Leg HIP_OFFSET_Z.
                 * @type {number}
                 */
                public HIP_OFFSET_Z: number;

                /**
                 * Leg UPPER_LEG_LENGTH.
                 * @type {number}
                 */
                public UPPER_LEG_LENGTH: number;

                /**
                 * Leg LOWER_LEG_LENGTH.
                 * @type {number}
                 */
                public LOWER_LEG_LENGTH: number;

                /**
                 * Leg FOOT_HEIGHT.
                 * @type {number}
                 */
                public FOOT_HEIGHT: number;

                /**
                 * Leg FOOT_LENGTH.
                 * @type {number}
                 */
                public FOOT_LENGTH: number;

                /**
                 * Leg TOE_LENGTH.
                 * @type {number}
                 */
                public TOE_LENGTH: number;

                /**
                 * Leg HEEL_LENGTH.
                 * @type {number}
                 */
                public HEEL_LENGTH: number;

                /**
                 * Leg FOOT_WIDTH.
                 * @type {number}
                 */
                public FOOT_WIDTH: number;

                /**
                 * Leg FOOT_CENTRE_TO_ANKLE_CENTRE.
                 * @type {number}
                 */
                public FOOT_CENTRE_TO_ANKLE_CENTRE: number;

                /**
                 * Leg LENGTH_BETWEEN_LEGS.
                 * @type {number}
                 */
                public LENGTH_BETWEEN_LEGS: number;

                /**
                 * Leg LEFT_TO_RIGHT_HIP_YAW.
                 * @type {number}
                 */
                public LEFT_TO_RIGHT_HIP_YAW: number;

                /**
                 * Leg LEFT_TO_RIGHT_HIP_ROLL.
                 * @type {number}
                 */
                public LEFT_TO_RIGHT_HIP_ROLL: number;

                /**
                 * Leg LEFT_TO_RIGHT_HIP_PITCH.
                 * @type {number}
                 */
                public LEFT_TO_RIGHT_HIP_PITCH: number;

                /**
                 * Leg LEFT_TO_RIGHT_KNEE.
                 * @type {number}
                 */
                public LEFT_TO_RIGHT_KNEE: number;

                /**
                 * Leg LEFT_TO_RIGHT_ANKLE_PITCH.
                 * @type {number}
                 */
                public LEFT_TO_RIGHT_ANKLE_PITCH: number;

                /**
                 * Leg LEFT_TO_RIGHT_ANKLE_ROLL.
                 * @type {number}
                 */
                public LEFT_TO_RIGHT_ANKLE_ROLL: number;

                /**
                 * Creates a new Leg instance using the specified properties.
                 * @param {message.motion.KinematicsModel.Leg$Properties=} [properties] Properties to set
                 * @returns {message.motion.KinematicsModel.Leg} Leg instance
                 */
                public static create(properties?: message.motion.KinematicsModel.Leg$Properties): message.motion.KinematicsModel.Leg;

                /**
                 * Encodes the specified Leg message. Does not implicitly {@link message.motion.KinematicsModel.Leg.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.Leg$Properties} message Leg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.motion.KinematicsModel.Leg$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Leg message, length delimited. Does not implicitly {@link message.motion.KinematicsModel.Leg.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.Leg$Properties} message Leg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.motion.KinematicsModel.Leg$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Leg message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.motion.KinematicsModel.Leg} Leg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.KinematicsModel.Leg;

                /**
                 * Decodes a Leg message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.motion.KinematicsModel.Leg} Leg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.KinematicsModel.Leg;

                /**
                 * Verifies a Leg message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Leg message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.Leg} Leg
                 */
                public static fromObject(object: { [k: string]: any }): message.motion.KinematicsModel.Leg;

                /**
                 * Creates a Leg message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.motion.KinematicsModel.Leg.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.Leg} Leg
                 */
                public static from(object: { [k: string]: any }): message.motion.KinematicsModel.Leg;

                /**
                 * Creates a plain object from a Leg message. Also converts values to other types if specified.
                 * @param {message.motion.KinematicsModel.Leg} message Leg
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.motion.KinematicsModel.Leg, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Leg message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Leg to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type Head$Properties = {
                NECK_BASE_POS_FROM_ORIGIN_X?: number;
                NECK_BASE_POS_FROM_ORIGIN_Y?: number;
                NECK_BASE_POS_FROM_ORIGIN_Z?: number;
                NECK_LENGTH?: number;
                NECK_TO_CAMERA_X?: number;
                NECK_TO_CAMERA_Y?: number;
                NECK_TO_CAMERA_Z?: number;
                CAMERA_DECLINATION_ANGLE_OFFSET?: number;
                MAX_YAW?: number;
                MIN_YAW?: number;
                MAX_PITCH?: number;
                MIN_PITCH?: number;
            };

            /**
             * Constructs a new Head.
             * @exports message.motion.KinematicsModel.Head
             * @constructor
             * @param {message.motion.KinematicsModel.Head$Properties=} [properties] Properties to set
             */
            class Head {

                /**
                 * Constructs a new Head.
                 * @exports message.motion.KinematicsModel.Head
                 * @constructor
                 * @param {message.motion.KinematicsModel.Head$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.motion.KinematicsModel.Head$Properties);

                /**
                 * Head NECK_BASE_POS_FROM_ORIGIN_X.
                 * @type {number}
                 */
                public NECK_BASE_POS_FROM_ORIGIN_X: number;

                /**
                 * Head NECK_BASE_POS_FROM_ORIGIN_Y.
                 * @type {number}
                 */
                public NECK_BASE_POS_FROM_ORIGIN_Y: number;

                /**
                 * Head NECK_BASE_POS_FROM_ORIGIN_Z.
                 * @type {number}
                 */
                public NECK_BASE_POS_FROM_ORIGIN_Z: number;

                /**
                 * Head NECK_LENGTH.
                 * @type {number}
                 */
                public NECK_LENGTH: number;

                /**
                 * Head NECK_TO_CAMERA_X.
                 * @type {number}
                 */
                public NECK_TO_CAMERA_X: number;

                /**
                 * Head NECK_TO_CAMERA_Y.
                 * @type {number}
                 */
                public NECK_TO_CAMERA_Y: number;

                /**
                 * Head NECK_TO_CAMERA_Z.
                 * @type {number}
                 */
                public NECK_TO_CAMERA_Z: number;

                /**
                 * Head CAMERA_DECLINATION_ANGLE_OFFSET.
                 * @type {number}
                 */
                public CAMERA_DECLINATION_ANGLE_OFFSET: number;

                /**
                 * Head MAX_YAW.
                 * @type {number}
                 */
                public MAX_YAW: number;

                /**
                 * Head MIN_YAW.
                 * @type {number}
                 */
                public MIN_YAW: number;

                /**
                 * Head MAX_PITCH.
                 * @type {number}
                 */
                public MAX_PITCH: number;

                /**
                 * Head MIN_PITCH.
                 * @type {number}
                 */
                public MIN_PITCH: number;

                /**
                 * Creates a new Head instance using the specified properties.
                 * @param {message.motion.KinematicsModel.Head$Properties=} [properties] Properties to set
                 * @returns {message.motion.KinematicsModel.Head} Head instance
                 */
                public static create(properties?: message.motion.KinematicsModel.Head$Properties): message.motion.KinematicsModel.Head;

                /**
                 * Encodes the specified Head message. Does not implicitly {@link message.motion.KinematicsModel.Head.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.Head$Properties} message Head message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.motion.KinematicsModel.Head$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Head message, length delimited. Does not implicitly {@link message.motion.KinematicsModel.Head.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.Head$Properties} message Head message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.motion.KinematicsModel.Head$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Head message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.motion.KinematicsModel.Head} Head
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.KinematicsModel.Head;

                /**
                 * Decodes a Head message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.motion.KinematicsModel.Head} Head
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.KinematicsModel.Head;

                /**
                 * Verifies a Head message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Head message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.Head} Head
                 */
                public static fromObject(object: { [k: string]: any }): message.motion.KinematicsModel.Head;

                /**
                 * Creates a Head message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.motion.KinematicsModel.Head.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.Head} Head
                 */
                public static from(object: { [k: string]: any }): message.motion.KinematicsModel.Head;

                /**
                 * Creates a plain object from a Head message. Also converts values to other types if specified.
                 * @param {message.motion.KinematicsModel.Head} message Head
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.motion.KinematicsModel.Head, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Head message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Head to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type Arm$Properties = {
                DISTANCE_BETWEEN_SHOULDERS?: number;
                SHOULDER_Z_OFFSET?: number;
                SHOULDER_X_OFFSET?: number;
                SHOULDER_LENGTH?: number;
                SHOULDER_WIDTH?: number;
                SHOULDER_HEIGHT?: number;
                UPPER_ARM_LENGTH?: number;
                UPPER_ARM_Y_OFFSET?: number;
                UPPER_ARM_X_OFFSET?: number;
                LOWER_ARM_LENGTH?: number;
                LOWER_ARM_Y_OFFSET?: number;
                LOWER_ARM_Z_OFFSET?: number;
            };

            /**
             * Constructs a new Arm.
             * @exports message.motion.KinematicsModel.Arm
             * @constructor
             * @param {message.motion.KinematicsModel.Arm$Properties=} [properties] Properties to set
             */
            class Arm {

                /**
                 * Constructs a new Arm.
                 * @exports message.motion.KinematicsModel.Arm
                 * @constructor
                 * @param {message.motion.KinematicsModel.Arm$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.motion.KinematicsModel.Arm$Properties);

                /**
                 * Arm DISTANCE_BETWEEN_SHOULDERS.
                 * @type {number}
                 */
                public DISTANCE_BETWEEN_SHOULDERS: number;

                /**
                 * Arm SHOULDER_Z_OFFSET.
                 * @type {number}
                 */
                public SHOULDER_Z_OFFSET: number;

                /**
                 * Arm SHOULDER_X_OFFSET.
                 * @type {number}
                 */
                public SHOULDER_X_OFFSET: number;

                /**
                 * Arm SHOULDER_LENGTH.
                 * @type {number}
                 */
                public SHOULDER_LENGTH: number;

                /**
                 * Arm SHOULDER_WIDTH.
                 * @type {number}
                 */
                public SHOULDER_WIDTH: number;

                /**
                 * Arm SHOULDER_HEIGHT.
                 * @type {number}
                 */
                public SHOULDER_HEIGHT: number;

                /**
                 * Arm UPPER_ARM_LENGTH.
                 * @type {number}
                 */
                public UPPER_ARM_LENGTH: number;

                /**
                 * Arm UPPER_ARM_Y_OFFSET.
                 * @type {number}
                 */
                public UPPER_ARM_Y_OFFSET: number;

                /**
                 * Arm UPPER_ARM_X_OFFSET.
                 * @type {number}
                 */
                public UPPER_ARM_X_OFFSET: number;

                /**
                 * Arm LOWER_ARM_LENGTH.
                 * @type {number}
                 */
                public LOWER_ARM_LENGTH: number;

                /**
                 * Arm LOWER_ARM_Y_OFFSET.
                 * @type {number}
                 */
                public LOWER_ARM_Y_OFFSET: number;

                /**
                 * Arm LOWER_ARM_Z_OFFSET.
                 * @type {number}
                 */
                public LOWER_ARM_Z_OFFSET: number;

                /**
                 * Creates a new Arm instance using the specified properties.
                 * @param {message.motion.KinematicsModel.Arm$Properties=} [properties] Properties to set
                 * @returns {message.motion.KinematicsModel.Arm} Arm instance
                 */
                public static create(properties?: message.motion.KinematicsModel.Arm$Properties): message.motion.KinematicsModel.Arm;

                /**
                 * Encodes the specified Arm message. Does not implicitly {@link message.motion.KinematicsModel.Arm.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.Arm$Properties} message Arm message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.motion.KinematicsModel.Arm$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Arm message, length delimited. Does not implicitly {@link message.motion.KinematicsModel.Arm.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.Arm$Properties} message Arm message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.motion.KinematicsModel.Arm$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Arm message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.motion.KinematicsModel.Arm} Arm
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.KinematicsModel.Arm;

                /**
                 * Decodes an Arm message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.motion.KinematicsModel.Arm} Arm
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.KinematicsModel.Arm;

                /**
                 * Verifies an Arm message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an Arm message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.Arm} Arm
                 */
                public static fromObject(object: { [k: string]: any }): message.motion.KinematicsModel.Arm;

                /**
                 * Creates an Arm message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.motion.KinematicsModel.Arm.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.Arm} Arm
                 */
                public static from(object: { [k: string]: any }): message.motion.KinematicsModel.Arm;

                /**
                 * Creates a plain object from an Arm message. Also converts values to other types if specified.
                 * @param {message.motion.KinematicsModel.Arm} message Arm
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.motion.KinematicsModel.Arm, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Arm message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Arm to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type MassModel$Properties = {
                masses?: vec4$Properties[];
            };

            /**
             * Constructs a new MassModel.
             * @exports message.motion.KinematicsModel.MassModel
             * @constructor
             * @param {message.motion.KinematicsModel.MassModel$Properties=} [properties] Properties to set
             */
            class MassModel {

                /**
                 * Constructs a new MassModel.
                 * @exports message.motion.KinematicsModel.MassModel
                 * @constructor
                 * @param {message.motion.KinematicsModel.MassModel$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.motion.KinematicsModel.MassModel$Properties);

                /**
                 * MassModel masses.
                 * @type {Array.<vec4$Properties>}
                 */
                public masses: vec4$Properties[];

                /**
                 * Creates a new MassModel instance using the specified properties.
                 * @param {message.motion.KinematicsModel.MassModel$Properties=} [properties] Properties to set
                 * @returns {message.motion.KinematicsModel.MassModel} MassModel instance
                 */
                public static create(properties?: message.motion.KinematicsModel.MassModel$Properties): message.motion.KinematicsModel.MassModel;

                /**
                 * Encodes the specified MassModel message. Does not implicitly {@link message.motion.KinematicsModel.MassModel.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.MassModel$Properties} message MassModel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.motion.KinematicsModel.MassModel$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified MassModel message, length delimited. Does not implicitly {@link message.motion.KinematicsModel.MassModel.verify|verify} messages.
                 * @param {message.motion.KinematicsModel.MassModel$Properties} message MassModel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.motion.KinematicsModel.MassModel$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a MassModel message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.motion.KinematicsModel.MassModel} MassModel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.KinematicsModel.MassModel;

                /**
                 * Decodes a MassModel message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.motion.KinematicsModel.MassModel} MassModel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.KinematicsModel.MassModel;

                /**
                 * Verifies a MassModel message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a MassModel message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.MassModel} MassModel
                 */
                public static fromObject(object: { [k: string]: any }): message.motion.KinematicsModel.MassModel;

                /**
                 * Creates a MassModel message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.motion.KinematicsModel.MassModel.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.motion.KinematicsModel.MassModel} MassModel
                 */
                public static from(object: { [k: string]: any }): message.motion.KinematicsModel.MassModel;

                /**
                 * Creates a plain object from a MassModel message. Also converts values to other types if specified.
                 * @param {message.motion.KinematicsModel.MassModel} message MassModel
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.motion.KinematicsModel.MassModel, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this MassModel message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this MassModel to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type ServoTarget$Properties = {
            time?: google.protobuf.Timestamp$Properties;
            id?: number;
            position?: number;
            gain?: number;
            torque?: number;
        };

        /**
         * Constructs a new ServoTarget.
         * @classdesc TODO document
         *
         * @author Trent Houliston
         * @exports message.motion.ServoTarget
         * @constructor
         * @param {message.motion.ServoTarget$Properties=} [properties] Properties to set
         */
        class ServoTarget {

            /**
             * Constructs a new ServoTarget.
             * @classdesc TODO document
             *
             * @author Trent Houliston
             * @exports message.motion.ServoTarget
             * @constructor
             * @param {message.motion.ServoTarget$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.ServoTarget$Properties);

            /**
             * ServoTarget time.
             * @type {(google.protobuf.Timestamp$Properties|null)}
             */
            public time: (google.protobuf.Timestamp$Properties|null);

            /**
             * ServoTarget id.
             * @type {number}
             */
            public id: number;

            /**
             * ServoTarget position.
             * @type {number}
             */
            public position: number;

            /**
             * ServoTarget gain.
             * @type {number}
             */
            public gain: number;

            /**
             * ServoTarget torque.
             * @type {number}
             */
            public torque: number;

            /**
             * Creates a new ServoTarget instance using the specified properties.
             * @param {message.motion.ServoTarget$Properties=} [properties] Properties to set
             * @returns {message.motion.ServoTarget} ServoTarget instance
             */
            public static create(properties?: message.motion.ServoTarget$Properties): message.motion.ServoTarget;

            /**
             * Encodes the specified ServoTarget message. Does not implicitly {@link message.motion.ServoTarget.verify|verify} messages.
             * @param {message.motion.ServoTarget$Properties} message ServoTarget message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.ServoTarget$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified ServoTarget message, length delimited. Does not implicitly {@link message.motion.ServoTarget.verify|verify} messages.
             * @param {message.motion.ServoTarget$Properties} message ServoTarget message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.ServoTarget$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ServoTarget message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.ServoTarget} ServoTarget
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.ServoTarget;

            /**
             * Decodes a ServoTarget message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.ServoTarget} ServoTarget
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.ServoTarget;

            /**
             * Verifies a ServoTarget message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a ServoTarget message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.ServoTarget} ServoTarget
             */
            public static fromObject(object: { [k: string]: any }): message.motion.ServoTarget;

            /**
             * Creates a ServoTarget message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.ServoTarget.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.ServoTarget} ServoTarget
             */
            public static from(object: { [k: string]: any }): message.motion.ServoTarget;

            /**
             * Creates a plain object from a ServoTarget message. Also converts values to other types if specified.
             * @param {message.motion.ServoTarget} message ServoTarget
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.ServoTarget, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this ServoTarget message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this ServoTarget to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type TorsoMotionUpdate$Properties = {
            frameArms?: vec3$Properties;
            frameLegs?: vec3$Properties;
            frame3D?: mat44$Properties;
        };

        /**
         * Constructs a new TorsoMotionUpdate.
         * @exports message.motion.TorsoMotionUpdate
         * @constructor
         * @param {message.motion.TorsoMotionUpdate$Properties=} [properties] Properties to set
         */
        class TorsoMotionUpdate {

            /**
             * Constructs a new TorsoMotionUpdate.
             * @exports message.motion.TorsoMotionUpdate
             * @constructor
             * @param {message.motion.TorsoMotionUpdate$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.TorsoMotionUpdate$Properties);

            /**
             * TorsoMotionUpdate frameArms.
             * @type {(vec3$Properties|null)}
             */
            public frameArms: (vec3$Properties|null);

            /**
             * TorsoMotionUpdate frameLegs.
             * @type {(vec3$Properties|null)}
             */
            public frameLegs: (vec3$Properties|null);

            /**
             * TorsoMotionUpdate frame3D.
             * @type {(mat44$Properties|null)}
             */
            public frame3D: (mat44$Properties|null);

            /**
             * Creates a new TorsoMotionUpdate instance using the specified properties.
             * @param {message.motion.TorsoMotionUpdate$Properties=} [properties] Properties to set
             * @returns {message.motion.TorsoMotionUpdate} TorsoMotionUpdate instance
             */
            public static create(properties?: message.motion.TorsoMotionUpdate$Properties): message.motion.TorsoMotionUpdate;

            /**
             * Encodes the specified TorsoMotionUpdate message. Does not implicitly {@link message.motion.TorsoMotionUpdate.verify|verify} messages.
             * @param {message.motion.TorsoMotionUpdate$Properties} message TorsoMotionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.TorsoMotionUpdate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified TorsoMotionUpdate message, length delimited. Does not implicitly {@link message.motion.TorsoMotionUpdate.verify|verify} messages.
             * @param {message.motion.TorsoMotionUpdate$Properties} message TorsoMotionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.TorsoMotionUpdate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TorsoMotionUpdate message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.TorsoMotionUpdate} TorsoMotionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.TorsoMotionUpdate;

            /**
             * Decodes a TorsoMotionUpdate message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.TorsoMotionUpdate} TorsoMotionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.TorsoMotionUpdate;

            /**
             * Verifies a TorsoMotionUpdate message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a TorsoMotionUpdate message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.TorsoMotionUpdate} TorsoMotionUpdate
             */
            public static fromObject(object: { [k: string]: any }): message.motion.TorsoMotionUpdate;

            /**
             * Creates a TorsoMotionUpdate message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.TorsoMotionUpdate.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.TorsoMotionUpdate} TorsoMotionUpdate
             */
            public static from(object: { [k: string]: any }): message.motion.TorsoMotionUpdate;

            /**
             * Creates a plain object from a TorsoMotionUpdate message. Also converts values to other types if specified.
             * @param {message.motion.TorsoMotionUpdate} message TorsoMotionUpdate
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.TorsoMotionUpdate, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this TorsoMotionUpdate message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this TorsoMotionUpdate to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type TorsoPositionUpdate$Properties = {
            position?: vec3$Properties;
            destination?: vec3$Properties;
        };

        /**
         * Constructs a new TorsoPositionUpdate.
         * @exports message.motion.TorsoPositionUpdate
         * @constructor
         * @param {message.motion.TorsoPositionUpdate$Properties=} [properties] Properties to set
         */
        class TorsoPositionUpdate {

            /**
             * Constructs a new TorsoPositionUpdate.
             * @exports message.motion.TorsoPositionUpdate
             * @constructor
             * @param {message.motion.TorsoPositionUpdate$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.TorsoPositionUpdate$Properties);

            /**
             * TorsoPositionUpdate position.
             * @type {(vec3$Properties|null)}
             */
            public position: (vec3$Properties|null);

            /**
             * TorsoPositionUpdate destination.
             * @type {(vec3$Properties|null)}
             */
            public destination: (vec3$Properties|null);

            /**
             * Creates a new TorsoPositionUpdate instance using the specified properties.
             * @param {message.motion.TorsoPositionUpdate$Properties=} [properties] Properties to set
             * @returns {message.motion.TorsoPositionUpdate} TorsoPositionUpdate instance
             */
            public static create(properties?: message.motion.TorsoPositionUpdate$Properties): message.motion.TorsoPositionUpdate;

            /**
             * Encodes the specified TorsoPositionUpdate message. Does not implicitly {@link message.motion.TorsoPositionUpdate.verify|verify} messages.
             * @param {message.motion.TorsoPositionUpdate$Properties} message TorsoPositionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.TorsoPositionUpdate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified TorsoPositionUpdate message, length delimited. Does not implicitly {@link message.motion.TorsoPositionUpdate.verify|verify} messages.
             * @param {message.motion.TorsoPositionUpdate$Properties} message TorsoPositionUpdate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.TorsoPositionUpdate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a TorsoPositionUpdate message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.TorsoPositionUpdate} TorsoPositionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.TorsoPositionUpdate;

            /**
             * Decodes a TorsoPositionUpdate message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.TorsoPositionUpdate} TorsoPositionUpdate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.TorsoPositionUpdate;

            /**
             * Verifies a TorsoPositionUpdate message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a TorsoPositionUpdate message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.TorsoPositionUpdate} TorsoPositionUpdate
             */
            public static fromObject(object: { [k: string]: any }): message.motion.TorsoPositionUpdate;

            /**
             * Creates a TorsoPositionUpdate message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.TorsoPositionUpdate.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.TorsoPositionUpdate} TorsoPositionUpdate
             */
            public static from(object: { [k: string]: any }): message.motion.TorsoPositionUpdate;

            /**
             * Creates a plain object from a TorsoPositionUpdate message. Also converts values to other types if specified.
             * @param {message.motion.TorsoPositionUpdate} message TorsoPositionUpdate
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.TorsoPositionUpdate, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this TorsoPositionUpdate message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this TorsoPositionUpdate to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type EnableTorsoMotion$Properties = {};

        /**
         * Constructs a new EnableTorsoMotion.
         * @exports message.motion.EnableTorsoMotion
         * @constructor
         * @param {message.motion.EnableTorsoMotion$Properties=} [properties] Properties to set
         */
        class EnableTorsoMotion {

            /**
             * Constructs a new EnableTorsoMotion.
             * @exports message.motion.EnableTorsoMotion
             * @constructor
             * @param {message.motion.EnableTorsoMotion$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.EnableTorsoMotion$Properties);

            /**
             * Creates a new EnableTorsoMotion instance using the specified properties.
             * @param {message.motion.EnableTorsoMotion$Properties=} [properties] Properties to set
             * @returns {message.motion.EnableTorsoMotion} EnableTorsoMotion instance
             */
            public static create(properties?: message.motion.EnableTorsoMotion$Properties): message.motion.EnableTorsoMotion;

            /**
             * Encodes the specified EnableTorsoMotion message. Does not implicitly {@link message.motion.EnableTorsoMotion.verify|verify} messages.
             * @param {message.motion.EnableTorsoMotion$Properties} message EnableTorsoMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.EnableTorsoMotion$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified EnableTorsoMotion message, length delimited. Does not implicitly {@link message.motion.EnableTorsoMotion.verify|verify} messages.
             * @param {message.motion.EnableTorsoMotion$Properties} message EnableTorsoMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.EnableTorsoMotion$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EnableTorsoMotion message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.EnableTorsoMotion} EnableTorsoMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.EnableTorsoMotion;

            /**
             * Decodes an EnableTorsoMotion message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.EnableTorsoMotion} EnableTorsoMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.EnableTorsoMotion;

            /**
             * Verifies an EnableTorsoMotion message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an EnableTorsoMotion message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableTorsoMotion} EnableTorsoMotion
             */
            public static fromObject(object: { [k: string]: any }): message.motion.EnableTorsoMotion;

            /**
             * Creates an EnableTorsoMotion message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.EnableTorsoMotion.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableTorsoMotion} EnableTorsoMotion
             */
            public static from(object: { [k: string]: any }): message.motion.EnableTorsoMotion;

            /**
             * Creates a plain object from an EnableTorsoMotion message. Also converts values to other types if specified.
             * @param {message.motion.EnableTorsoMotion} message EnableTorsoMotion
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.EnableTorsoMotion, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this EnableTorsoMotion message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this EnableTorsoMotion to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type DisableTorsoMotion$Properties = {};

        /**
         * Constructs a new DisableTorsoMotion.
         * @exports message.motion.DisableTorsoMotion
         * @constructor
         * @param {message.motion.DisableTorsoMotion$Properties=} [properties] Properties to set
         */
        class DisableTorsoMotion {

            /**
             * Constructs a new DisableTorsoMotion.
             * @exports message.motion.DisableTorsoMotion
             * @constructor
             * @param {message.motion.DisableTorsoMotion$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.DisableTorsoMotion$Properties);

            /**
             * Creates a new DisableTorsoMotion instance using the specified properties.
             * @param {message.motion.DisableTorsoMotion$Properties=} [properties] Properties to set
             * @returns {message.motion.DisableTorsoMotion} DisableTorsoMotion instance
             */
            public static create(properties?: message.motion.DisableTorsoMotion$Properties): message.motion.DisableTorsoMotion;

            /**
             * Encodes the specified DisableTorsoMotion message. Does not implicitly {@link message.motion.DisableTorsoMotion.verify|verify} messages.
             * @param {message.motion.DisableTorsoMotion$Properties} message DisableTorsoMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.DisableTorsoMotion$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified DisableTorsoMotion message, length delimited. Does not implicitly {@link message.motion.DisableTorsoMotion.verify|verify} messages.
             * @param {message.motion.DisableTorsoMotion$Properties} message DisableTorsoMotion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.DisableTorsoMotion$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DisableTorsoMotion message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DisableTorsoMotion} DisableTorsoMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.DisableTorsoMotion;

            /**
             * Decodes a DisableTorsoMotion message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DisableTorsoMotion} DisableTorsoMotion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.DisableTorsoMotion;

            /**
             * Verifies a DisableTorsoMotion message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a DisableTorsoMotion message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableTorsoMotion} DisableTorsoMotion
             */
            public static fromObject(object: { [k: string]: any }): message.motion.DisableTorsoMotion;

            /**
             * Creates a DisableTorsoMotion message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DisableTorsoMotion.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableTorsoMotion} DisableTorsoMotion
             */
            public static from(object: { [k: string]: any }): message.motion.DisableTorsoMotion;

            /**
             * Creates a plain object from a DisableTorsoMotion message. Also converts values to other types if specified.
             * @param {message.motion.DisableTorsoMotion} message DisableTorsoMotion
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.DisableTorsoMotion, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this DisableTorsoMotion message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this DisableTorsoMotion to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type WalkStarted$Properties = {};

        /**
         * Constructs a new WalkStarted.
         * @exports message.motion.WalkStarted
         * @constructor
         * @param {message.motion.WalkStarted$Properties=} [properties] Properties to set
         */
        class WalkStarted {

            /**
             * Constructs a new WalkStarted.
             * @exports message.motion.WalkStarted
             * @constructor
             * @param {message.motion.WalkStarted$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.WalkStarted$Properties);

            /**
             * Creates a new WalkStarted instance using the specified properties.
             * @param {message.motion.WalkStarted$Properties=} [properties] Properties to set
             * @returns {message.motion.WalkStarted} WalkStarted instance
             */
            public static create(properties?: message.motion.WalkStarted$Properties): message.motion.WalkStarted;

            /**
             * Encodes the specified WalkStarted message. Does not implicitly {@link message.motion.WalkStarted.verify|verify} messages.
             * @param {message.motion.WalkStarted$Properties} message WalkStarted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.WalkStarted$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified WalkStarted message, length delimited. Does not implicitly {@link message.motion.WalkStarted.verify|verify} messages.
             * @param {message.motion.WalkStarted$Properties} message WalkStarted message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.WalkStarted$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a WalkStarted message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.WalkStarted} WalkStarted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.WalkStarted;

            /**
             * Decodes a WalkStarted message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.WalkStarted} WalkStarted
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.WalkStarted;

            /**
             * Verifies a WalkStarted message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a WalkStarted message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.WalkStarted} WalkStarted
             */
            public static fromObject(object: { [k: string]: any }): message.motion.WalkStarted;

            /**
             * Creates a WalkStarted message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.WalkStarted.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.WalkStarted} WalkStarted
             */
            public static from(object: { [k: string]: any }): message.motion.WalkStarted;

            /**
             * Creates a plain object from a WalkStarted message. Also converts values to other types if specified.
             * @param {message.motion.WalkStarted} message WalkStarted
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.WalkStarted, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this WalkStarted message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this WalkStarted to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type WalkStopped$Properties = {};

        /**
         * Constructs a new WalkStopped.
         * @exports message.motion.WalkStopped
         * @constructor
         * @param {message.motion.WalkStopped$Properties=} [properties] Properties to set
         */
        class WalkStopped {

            /**
             * Constructs a new WalkStopped.
             * @exports message.motion.WalkStopped
             * @constructor
             * @param {message.motion.WalkStopped$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.WalkStopped$Properties);

            /**
             * Creates a new WalkStopped instance using the specified properties.
             * @param {message.motion.WalkStopped$Properties=} [properties] Properties to set
             * @returns {message.motion.WalkStopped} WalkStopped instance
             */
            public static create(properties?: message.motion.WalkStopped$Properties): message.motion.WalkStopped;

            /**
             * Encodes the specified WalkStopped message. Does not implicitly {@link message.motion.WalkStopped.verify|verify} messages.
             * @param {message.motion.WalkStopped$Properties} message WalkStopped message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.WalkStopped$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified WalkStopped message, length delimited. Does not implicitly {@link message.motion.WalkStopped.verify|verify} messages.
             * @param {message.motion.WalkStopped$Properties} message WalkStopped message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.WalkStopped$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a WalkStopped message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.WalkStopped} WalkStopped
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.WalkStopped;

            /**
             * Decodes a WalkStopped message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.WalkStopped} WalkStopped
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.WalkStopped;

            /**
             * Verifies a WalkStopped message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a WalkStopped message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.WalkStopped} WalkStopped
             */
            public static fromObject(object: { [k: string]: any }): message.motion.WalkStopped;

            /**
             * Creates a WalkStopped message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.WalkStopped.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.WalkStopped} WalkStopped
             */
            public static from(object: { [k: string]: any }): message.motion.WalkStopped;

            /**
             * Creates a plain object from a WalkStopped message. Also converts values to other types if specified.
             * @param {message.motion.WalkStopped} message WalkStopped
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.WalkStopped, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this WalkStopped message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this WalkStopped to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type WalkCommand$Properties = {
            subsumptionId?: (number|Long);
            command?: vec3$Properties;
        };

        /**
         * Constructs a new WalkCommand.
         * @exports message.motion.WalkCommand
         * @constructor
         * @param {message.motion.WalkCommand$Properties=} [properties] Properties to set
         */
        class WalkCommand {

            /**
             * Constructs a new WalkCommand.
             * @exports message.motion.WalkCommand
             * @constructor
             * @param {message.motion.WalkCommand$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.WalkCommand$Properties);

            /**
             * WalkCommand subsumptionId.
             * @type {number|Long}
             */
            public subsumptionId: (number|Long);

            /**
             * WalkCommand command.
             * @type {(vec3$Properties|null)}
             */
            public command: (vec3$Properties|null);

            /**
             * Creates a new WalkCommand instance using the specified properties.
             * @param {message.motion.WalkCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.WalkCommand} WalkCommand instance
             */
            public static create(properties?: message.motion.WalkCommand$Properties): message.motion.WalkCommand;

            /**
             * Encodes the specified WalkCommand message. Does not implicitly {@link message.motion.WalkCommand.verify|verify} messages.
             * @param {message.motion.WalkCommand$Properties} message WalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.WalkCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified WalkCommand message, length delimited. Does not implicitly {@link message.motion.WalkCommand.verify|verify} messages.
             * @param {message.motion.WalkCommand$Properties} message WalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.WalkCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a WalkCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.WalkCommand} WalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.WalkCommand;

            /**
             * Decodes a WalkCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.WalkCommand} WalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.WalkCommand;

            /**
             * Verifies a WalkCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a WalkCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.WalkCommand} WalkCommand
             */
            public static fromObject(object: { [k: string]: any }): message.motion.WalkCommand;

            /**
             * Creates a WalkCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.WalkCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.WalkCommand} WalkCommand
             */
            public static from(object: { [k: string]: any }): message.motion.WalkCommand;

            /**
             * Creates a plain object from a WalkCommand message. Also converts values to other types if specified.
             * @param {message.motion.WalkCommand} message WalkCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.WalkCommand, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this WalkCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this WalkCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type StopCommand$Properties = {
            subsumptionId?: (number|Long);
        };

        /**
         * Constructs a new StopCommand.
         * @exports message.motion.StopCommand
         * @constructor
         * @param {message.motion.StopCommand$Properties=} [properties] Properties to set
         */
        class StopCommand {

            /**
             * Constructs a new StopCommand.
             * @exports message.motion.StopCommand
             * @constructor
             * @param {message.motion.StopCommand$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.StopCommand$Properties);

            /**
             * StopCommand subsumptionId.
             * @type {number|Long}
             */
            public subsumptionId: (number|Long);

            /**
             * Creates a new StopCommand instance using the specified properties.
             * @param {message.motion.StopCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.StopCommand} StopCommand instance
             */
            public static create(properties?: message.motion.StopCommand$Properties): message.motion.StopCommand;

            /**
             * Encodes the specified StopCommand message. Does not implicitly {@link message.motion.StopCommand.verify|verify} messages.
             * @param {message.motion.StopCommand$Properties} message StopCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.StopCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified StopCommand message, length delimited. Does not implicitly {@link message.motion.StopCommand.verify|verify} messages.
             * @param {message.motion.StopCommand$Properties} message StopCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.StopCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a StopCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.StopCommand} StopCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.StopCommand;

            /**
             * Decodes a StopCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.StopCommand} StopCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.StopCommand;

            /**
             * Verifies a StopCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a StopCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.StopCommand} StopCommand
             */
            public static fromObject(object: { [k: string]: any }): message.motion.StopCommand;

            /**
             * Creates a StopCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.StopCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.StopCommand} StopCommand
             */
            public static from(object: { [k: string]: any }): message.motion.StopCommand;

            /**
             * Creates a plain object from a StopCommand message. Also converts values to other types if specified.
             * @param {message.motion.StopCommand} message StopCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.StopCommand, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this StopCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this StopCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type NewWalkCommand$Properties = {
            velocityTarget?: vec3$Properties;
        };

        /**
         * Constructs a new NewWalkCommand.
         * @exports message.motion.NewWalkCommand
         * @constructor
         * @param {message.motion.NewWalkCommand$Properties=} [properties] Properties to set
         */
        class NewWalkCommand {

            /**
             * Constructs a new NewWalkCommand.
             * @exports message.motion.NewWalkCommand
             * @constructor
             * @param {message.motion.NewWalkCommand$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.NewWalkCommand$Properties);

            /**
             * NewWalkCommand velocityTarget.
             * @type {(vec3$Properties|null)}
             */
            public velocityTarget: (vec3$Properties|null);

            /**
             * Creates a new NewWalkCommand instance using the specified properties.
             * @param {message.motion.NewWalkCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.NewWalkCommand} NewWalkCommand instance
             */
            public static create(properties?: message.motion.NewWalkCommand$Properties): message.motion.NewWalkCommand;

            /**
             * Encodes the specified NewWalkCommand message. Does not implicitly {@link message.motion.NewWalkCommand.verify|verify} messages.
             * @param {message.motion.NewWalkCommand$Properties} message NewWalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.NewWalkCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified NewWalkCommand message, length delimited. Does not implicitly {@link message.motion.NewWalkCommand.verify|verify} messages.
             * @param {message.motion.NewWalkCommand$Properties} message NewWalkCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.NewWalkCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NewWalkCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.NewWalkCommand} NewWalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.NewWalkCommand;

            /**
             * Decodes a NewWalkCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.NewWalkCommand} NewWalkCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.NewWalkCommand;

            /**
             * Verifies a NewWalkCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a NewWalkCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NewWalkCommand} NewWalkCommand
             */
            public static fromObject(object: { [k: string]: any }): message.motion.NewWalkCommand;

            /**
             * Creates a NewWalkCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.NewWalkCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.NewWalkCommand} NewWalkCommand
             */
            public static from(object: { [k: string]: any }): message.motion.NewWalkCommand;

            /**
             * Creates a plain object from a NewWalkCommand message. Also converts values to other types if specified.
             * @param {message.motion.NewWalkCommand} message NewWalkCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.NewWalkCommand, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this NewWalkCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this NewWalkCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type EnableWalkEngineCommand$Properties = {
            subsumptionId?: (number|Long);
        };

        /**
         * Constructs a new EnableWalkEngineCommand.
         * @exports message.motion.EnableWalkEngineCommand
         * @constructor
         * @param {message.motion.EnableWalkEngineCommand$Properties=} [properties] Properties to set
         */
        class EnableWalkEngineCommand {

            /**
             * Constructs a new EnableWalkEngineCommand.
             * @exports message.motion.EnableWalkEngineCommand
             * @constructor
             * @param {message.motion.EnableWalkEngineCommand$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.EnableWalkEngineCommand$Properties);

            /**
             * EnableWalkEngineCommand subsumptionId.
             * @type {number|Long}
             */
            public subsumptionId: (number|Long);

            /**
             * Creates a new EnableWalkEngineCommand instance using the specified properties.
             * @param {message.motion.EnableWalkEngineCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.EnableWalkEngineCommand} EnableWalkEngineCommand instance
             */
            public static create(properties?: message.motion.EnableWalkEngineCommand$Properties): message.motion.EnableWalkEngineCommand;

            /**
             * Encodes the specified EnableWalkEngineCommand message. Does not implicitly {@link message.motion.EnableWalkEngineCommand.verify|verify} messages.
             * @param {message.motion.EnableWalkEngineCommand$Properties} message EnableWalkEngineCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.EnableWalkEngineCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified EnableWalkEngineCommand message, length delimited. Does not implicitly {@link message.motion.EnableWalkEngineCommand.verify|verify} messages.
             * @param {message.motion.EnableWalkEngineCommand$Properties} message EnableWalkEngineCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.EnableWalkEngineCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an EnableWalkEngineCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.EnableWalkEngineCommand} EnableWalkEngineCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.EnableWalkEngineCommand;

            /**
             * Decodes an EnableWalkEngineCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.EnableWalkEngineCommand} EnableWalkEngineCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.EnableWalkEngineCommand;

            /**
             * Verifies an EnableWalkEngineCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an EnableWalkEngineCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableWalkEngineCommand} EnableWalkEngineCommand
             */
            public static fromObject(object: { [k: string]: any }): message.motion.EnableWalkEngineCommand;

            /**
             * Creates an EnableWalkEngineCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.EnableWalkEngineCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.EnableWalkEngineCommand} EnableWalkEngineCommand
             */
            public static from(object: { [k: string]: any }): message.motion.EnableWalkEngineCommand;

            /**
             * Creates a plain object from an EnableWalkEngineCommand message. Also converts values to other types if specified.
             * @param {message.motion.EnableWalkEngineCommand} message EnableWalkEngineCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.EnableWalkEngineCommand, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this EnableWalkEngineCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this EnableWalkEngineCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type DisableWalkEngineCommand$Properties = {
            subsumptionId?: (number|Long);
        };

        /**
         * Constructs a new DisableWalkEngineCommand.
         * @exports message.motion.DisableWalkEngineCommand
         * @constructor
         * @param {message.motion.DisableWalkEngineCommand$Properties=} [properties] Properties to set
         */
        class DisableWalkEngineCommand {

            /**
             * Constructs a new DisableWalkEngineCommand.
             * @exports message.motion.DisableWalkEngineCommand
             * @constructor
             * @param {message.motion.DisableWalkEngineCommand$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.motion.DisableWalkEngineCommand$Properties);

            /**
             * DisableWalkEngineCommand subsumptionId.
             * @type {number|Long}
             */
            public subsumptionId: (number|Long);

            /**
             * Creates a new DisableWalkEngineCommand instance using the specified properties.
             * @param {message.motion.DisableWalkEngineCommand$Properties=} [properties] Properties to set
             * @returns {message.motion.DisableWalkEngineCommand} DisableWalkEngineCommand instance
             */
            public static create(properties?: message.motion.DisableWalkEngineCommand$Properties): message.motion.DisableWalkEngineCommand;

            /**
             * Encodes the specified DisableWalkEngineCommand message. Does not implicitly {@link message.motion.DisableWalkEngineCommand.verify|verify} messages.
             * @param {message.motion.DisableWalkEngineCommand$Properties} message DisableWalkEngineCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.motion.DisableWalkEngineCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified DisableWalkEngineCommand message, length delimited. Does not implicitly {@link message.motion.DisableWalkEngineCommand.verify|verify} messages.
             * @param {message.motion.DisableWalkEngineCommand$Properties} message DisableWalkEngineCommand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.motion.DisableWalkEngineCommand$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a DisableWalkEngineCommand message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.motion.DisableWalkEngineCommand} DisableWalkEngineCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.motion.DisableWalkEngineCommand;

            /**
             * Decodes a DisableWalkEngineCommand message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.motion.DisableWalkEngineCommand} DisableWalkEngineCommand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.motion.DisableWalkEngineCommand;

            /**
             * Verifies a DisableWalkEngineCommand message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a DisableWalkEngineCommand message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableWalkEngineCommand} DisableWalkEngineCommand
             */
            public static fromObject(object: { [k: string]: any }): message.motion.DisableWalkEngineCommand;

            /**
             * Creates a DisableWalkEngineCommand message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.motion.DisableWalkEngineCommand.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.motion.DisableWalkEngineCommand} DisableWalkEngineCommand
             */
            public static from(object: { [k: string]: any }): message.motion.DisableWalkEngineCommand;

            /**
             * Creates a plain object from a DisableWalkEngineCommand message. Also converts values to other types if specified.
             * @param {message.motion.DisableWalkEngineCommand} message DisableWalkEngineCommand
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.motion.DisableWalkEngineCommand, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this DisableWalkEngineCommand message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this DisableWalkEngineCommand to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }

    /**
     * Namespace output.
     * @exports message.output
     * @namespace
     */
    namespace output {

        type Say$Properties = {
            message?: string;
        };

        /**
         * Constructs a new Say.
         * @classdesc TODO document
         *
         * @author Trent Houliston
         * @exports message.output.Say
         * @constructor
         * @param {message.output.Say$Properties=} [properties] Properties to set
         */
        class Say {

            /**
             * Constructs a new Say.
             * @classdesc TODO document
             *
             * @author Trent Houliston
             * @exports message.output.Say
             * @constructor
             * @param {message.output.Say$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.output.Say$Properties);

            /**
             * Say message.
             * @type {string}
             */
            public message: string;

            /**
             * Creates a new Say instance using the specified properties.
             * @param {message.output.Say$Properties=} [properties] Properties to set
             * @returns {message.output.Say} Say instance
             */
            public static create(properties?: message.output.Say$Properties): message.output.Say;

            /**
             * Encodes the specified Say message. Does not implicitly {@link message.output.Say.verify|verify} messages.
             * @param {message.output.Say$Properties} message Say message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.output.Say$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Say message, length delimited. Does not implicitly {@link message.output.Say.verify|verify} messages.
             * @param {message.output.Say$Properties} message Say message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.output.Say$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Say message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.output.Say} Say
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.output.Say;

            /**
             * Decodes a Say message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.output.Say} Say
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.output.Say;

            /**
             * Verifies a Say message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a Say message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.output.Say} Say
             */
            public static fromObject(object: { [k: string]: any }): message.output.Say;

            /**
             * Creates a Say message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.output.Say.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.output.Say} Say
             */
            public static from(object: { [k: string]: any }): message.output.Say;

            /**
             * Creates a plain object from a Say message. Also converts values to other types if specified.
             * @param {message.output.Say} message Say
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.output.Say, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Say message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Say to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }

    /**
     * Namespace platform.
     * @exports message.platform
     * @namespace
     */
    namespace platform {

        /**
         * Namespace darwin.
         * @exports message.platform.darwin
         * @namespace
         */
        namespace darwin {

            type DarwinSensors$Properties = {
                timestamp?: google.protobuf.Timestamp$Properties;
                cm730ErrorFlags?: number;
                ledPanel?: message.platform.darwin.DarwinSensors.LEDPanel$Properties;
                headLED?: message.platform.darwin.DarwinSensors.HeadLED$Properties;
                eyeLED?: message.platform.darwin.DarwinSensors.EyeLED$Properties;
                buttons?: message.platform.darwin.DarwinSensors.Buttons$Properties;
                voltage?: number;
                accelerometer?: message.platform.darwin.DarwinSensors.Accelerometer$Properties;
                gyroscope?: message.platform.darwin.DarwinSensors.Gyroscope$Properties;
                fsr?: message.platform.darwin.DarwinSensors.FSRs$Properties;
                servo?: message.platform.darwin.DarwinSensors.Servos$Properties;
            };

            /**
             * Constructs a new DarwinSensors.
             * @classdesc TODO document
             *
             * @author Trent Houliston
             * @exports message.platform.darwin.DarwinSensors
             * @constructor
             * @param {message.platform.darwin.DarwinSensors$Properties=} [properties] Properties to set
             */
            class DarwinSensors {

                /**
                 * Constructs a new DarwinSensors.
                 * @classdesc TODO document
                 *
                 * @author Trent Houliston
                 * @exports message.platform.darwin.DarwinSensors
                 * @constructor
                 * @param {message.platform.darwin.DarwinSensors$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.platform.darwin.DarwinSensors$Properties);

                /**
                 * DarwinSensors timestamp.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public timestamp: (google.protobuf.Timestamp$Properties|null);

                /**
                 * DarwinSensors cm730ErrorFlags.
                 * @type {number}
                 */
                public cm730ErrorFlags: number;

                /**
                 * DarwinSensors ledPanel.
                 * @type {(message.platform.darwin.DarwinSensors.LEDPanel$Properties|null)}
                 */
                public ledPanel: (message.platform.darwin.DarwinSensors.LEDPanel$Properties|null);

                /**
                 * DarwinSensors headLED.
                 * @type {(message.platform.darwin.DarwinSensors.HeadLED$Properties|null)}
                 */
                public headLED: (message.platform.darwin.DarwinSensors.HeadLED$Properties|null);

                /**
                 * DarwinSensors eyeLED.
                 * @type {(message.platform.darwin.DarwinSensors.EyeLED$Properties|null)}
                 */
                public eyeLED: (message.platform.darwin.DarwinSensors.EyeLED$Properties|null);

                /**
                 * DarwinSensors buttons.
                 * @type {(message.platform.darwin.DarwinSensors.Buttons$Properties|null)}
                 */
                public buttons: (message.platform.darwin.DarwinSensors.Buttons$Properties|null);

                /**
                 * DarwinSensors voltage.
                 * @type {number}
                 */
                public voltage: number;

                /**
                 * DarwinSensors accelerometer.
                 * @type {(message.platform.darwin.DarwinSensors.Accelerometer$Properties|null)}
                 */
                public accelerometer: (message.platform.darwin.DarwinSensors.Accelerometer$Properties|null);

                /**
                 * DarwinSensors gyroscope.
                 * @type {(message.platform.darwin.DarwinSensors.Gyroscope$Properties|null)}
                 */
                public gyroscope: (message.platform.darwin.DarwinSensors.Gyroscope$Properties|null);

                /**
                 * DarwinSensors fsr.
                 * @type {(message.platform.darwin.DarwinSensors.FSRs$Properties|null)}
                 */
                public fsr: (message.platform.darwin.DarwinSensors.FSRs$Properties|null);

                /**
                 * DarwinSensors servo.
                 * @type {(message.platform.darwin.DarwinSensors.Servos$Properties|null)}
                 */
                public servo: (message.platform.darwin.DarwinSensors.Servos$Properties|null);

                /**
                 * Creates a new DarwinSensors instance using the specified properties.
                 * @param {message.platform.darwin.DarwinSensors$Properties=} [properties] Properties to set
                 * @returns {message.platform.darwin.DarwinSensors} DarwinSensors instance
                 */
                public static create(properties?: message.platform.darwin.DarwinSensors$Properties): message.platform.darwin.DarwinSensors;

                /**
                 * Encodes the specified DarwinSensors message. Does not implicitly {@link message.platform.darwin.DarwinSensors.verify|verify} messages.
                 * @param {message.platform.darwin.DarwinSensors$Properties} message DarwinSensors message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.platform.darwin.DarwinSensors$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified DarwinSensors message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.verify|verify} messages.
                 * @param {message.platform.darwin.DarwinSensors$Properties} message DarwinSensors message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.platform.darwin.DarwinSensors$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DarwinSensors message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.darwin.DarwinSensors} DarwinSensors
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.DarwinSensors;

                /**
                 * Decodes a DarwinSensors message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.platform.darwin.DarwinSensors} DarwinSensors
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.DarwinSensors;

                /**
                 * Verifies a DarwinSensors message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a DarwinSensors message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.DarwinSensors} DarwinSensors
                 */
                public static fromObject(object: { [k: string]: any }): message.platform.darwin.DarwinSensors;

                /**
                 * Creates a DarwinSensors message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.platform.darwin.DarwinSensors.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.DarwinSensors} DarwinSensors
                 */
                public static from(object: { [k: string]: any }): message.platform.darwin.DarwinSensors;

                /**
                 * Creates a plain object from a DarwinSensors message. Also converts values to other types if specified.
                 * @param {message.platform.darwin.DarwinSensors} message DarwinSensors
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.platform.darwin.DarwinSensors, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this DarwinSensors message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this DarwinSensors to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace DarwinSensors {

                /**
                 * Error enum.
                 * @name Error
                 * @memberof message.platform.darwin.DarwinSensors
                 * @enum {number}
                 * @property {number} OK=0 OK value
                 * @property {number} INPUT_VOLTAGE=1 INPUT_VOLTAGE value
                 * @property {number} ANGLE_LIMIT=2 ANGLE_LIMIT value
                 * @property {number} OVERHEATING=4 OVERHEATING value
                 * @property {number} RANGE=8 RANGE value
                 * @property {number} CHECKSUM=16 CHECKSUM value
                 * @property {number} OVERLOAD=32 OVERLOAD value
                 * @property {number} INSTRUCTION=64 INSTRUCTION value
                 * @property {number} CORRUPT_DATA=128 CORRUPT_DATA value
                 * @property {number} TIMEOUT=256 TIMEOUT value
                 * @property {number} TIMEOUT_VICTIM=512 TIMEOUT_VICTIM value
                 */
                enum Error {
                    OK = 0,
                    INPUT_VOLTAGE = 1,
                    ANGLE_LIMIT = 2,
                    OVERHEATING = 4,
                    RANGE = 8,
                    CHECKSUM = 16,
                    OVERLOAD = 32,
                    INSTRUCTION = 64,
                    CORRUPT_DATA = 128,
                    TIMEOUT = 256,
                    TIMEOUT_VICTIM = 512
                }

                type LEDPanel$Properties = {
                    led2?: boolean;
                    led3?: boolean;
                    led4?: boolean;
                };

                /**
                 * Constructs a new LEDPanel.
                 * @exports message.platform.darwin.DarwinSensors.LEDPanel
                 * @constructor
                 * @param {message.platform.darwin.DarwinSensors.LEDPanel$Properties=} [properties] Properties to set
                 */
                class LEDPanel {

                    /**
                     * Constructs a new LEDPanel.
                     * @exports message.platform.darwin.DarwinSensors.LEDPanel
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.LEDPanel$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.platform.darwin.DarwinSensors.LEDPanel$Properties);

                    /**
                     * LEDPanel led2.
                     * @type {boolean}
                     */
                    public led2: boolean;

                    /**
                     * LEDPanel led3.
                     * @type {boolean}
                     */
                    public led3: boolean;

                    /**
                     * LEDPanel led4.
                     * @type {boolean}
                     */
                    public led4: boolean;

                    /**
                     * Creates a new LEDPanel instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.LEDPanel$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.LEDPanel} LEDPanel instance
                     */
                    public static create(properties?: message.platform.darwin.DarwinSensors.LEDPanel$Properties): message.platform.darwin.DarwinSensors.LEDPanel;

                    /**
                     * Encodes the specified LEDPanel message. Does not implicitly {@link message.platform.darwin.DarwinSensors.LEDPanel.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.LEDPanel$Properties} message LEDPanel message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.platform.darwin.DarwinSensors.LEDPanel$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified LEDPanel message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.LEDPanel.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.LEDPanel$Properties} message LEDPanel message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.platform.darwin.DarwinSensors.LEDPanel$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a LEDPanel message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.LEDPanel} LEDPanel
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.DarwinSensors.LEDPanel;

                    /**
                     * Decodes a LEDPanel message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.LEDPanel} LEDPanel
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.DarwinSensors.LEDPanel;

                    /**
                     * Verifies a LEDPanel message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a LEDPanel message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.LEDPanel} LEDPanel
                     */
                    public static fromObject(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.LEDPanel;

                    /**
                     * Creates a LEDPanel message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.LEDPanel.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.LEDPanel} LEDPanel
                     */
                    public static from(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.LEDPanel;

                    /**
                     * Creates a plain object from a LEDPanel message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.LEDPanel} message LEDPanel
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.platform.darwin.DarwinSensors.LEDPanel, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this LEDPanel message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this LEDPanel to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                type HeadLED$Properties = {
                    RGB?: number;
                };

                /**
                 * Constructs a new HeadLED.
                 * @exports message.platform.darwin.DarwinSensors.HeadLED
                 * @constructor
                 * @param {message.platform.darwin.DarwinSensors.HeadLED$Properties=} [properties] Properties to set
                 */
                class HeadLED {

                    /**
                     * Constructs a new HeadLED.
                     * @exports message.platform.darwin.DarwinSensors.HeadLED
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.HeadLED$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.platform.darwin.DarwinSensors.HeadLED$Properties);

                    /**
                     * HeadLED RGB.
                     * @type {number}
                     */
                    public RGB: number;

                    /**
                     * Creates a new HeadLED instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.HeadLED$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.HeadLED} HeadLED instance
                     */
                    public static create(properties?: message.platform.darwin.DarwinSensors.HeadLED$Properties): message.platform.darwin.DarwinSensors.HeadLED;

                    /**
                     * Encodes the specified HeadLED message. Does not implicitly {@link message.platform.darwin.DarwinSensors.HeadLED.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.HeadLED$Properties} message HeadLED message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.platform.darwin.DarwinSensors.HeadLED$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified HeadLED message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.HeadLED.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.HeadLED$Properties} message HeadLED message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.platform.darwin.DarwinSensors.HeadLED$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a HeadLED message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.HeadLED} HeadLED
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.DarwinSensors.HeadLED;

                    /**
                     * Decodes a HeadLED message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.HeadLED} HeadLED
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.DarwinSensors.HeadLED;

                    /**
                     * Verifies a HeadLED message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a HeadLED message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.HeadLED} HeadLED
                     */
                    public static fromObject(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.HeadLED;

                    /**
                     * Creates a HeadLED message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.HeadLED.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.HeadLED} HeadLED
                     */
                    public static from(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.HeadLED;

                    /**
                     * Creates a plain object from a HeadLED message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.HeadLED} message HeadLED
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.platform.darwin.DarwinSensors.HeadLED, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this HeadLED message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this HeadLED to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                type EyeLED$Properties = {
                    RGB?: number;
                };

                /**
                 * Constructs a new EyeLED.
                 * @exports message.platform.darwin.DarwinSensors.EyeLED
                 * @constructor
                 * @param {message.platform.darwin.DarwinSensors.EyeLED$Properties=} [properties] Properties to set
                 */
                class EyeLED {

                    /**
                     * Constructs a new EyeLED.
                     * @exports message.platform.darwin.DarwinSensors.EyeLED
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.EyeLED$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.platform.darwin.DarwinSensors.EyeLED$Properties);

                    /**
                     * EyeLED RGB.
                     * @type {number}
                     */
                    public RGB: number;

                    /**
                     * Creates a new EyeLED instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.EyeLED$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.EyeLED} EyeLED instance
                     */
                    public static create(properties?: message.platform.darwin.DarwinSensors.EyeLED$Properties): message.platform.darwin.DarwinSensors.EyeLED;

                    /**
                     * Encodes the specified EyeLED message. Does not implicitly {@link message.platform.darwin.DarwinSensors.EyeLED.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.EyeLED$Properties} message EyeLED message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.platform.darwin.DarwinSensors.EyeLED$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified EyeLED message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.EyeLED.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.EyeLED$Properties} message EyeLED message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.platform.darwin.DarwinSensors.EyeLED$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an EyeLED message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.EyeLED} EyeLED
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.DarwinSensors.EyeLED;

                    /**
                     * Decodes an EyeLED message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.EyeLED} EyeLED
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.DarwinSensors.EyeLED;

                    /**
                     * Verifies an EyeLED message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates an EyeLED message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.EyeLED} EyeLED
                     */
                    public static fromObject(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.EyeLED;

                    /**
                     * Creates an EyeLED message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.EyeLED.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.EyeLED} EyeLED
                     */
                    public static from(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.EyeLED;

                    /**
                     * Creates a plain object from an EyeLED message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.EyeLED} message EyeLED
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.platform.darwin.DarwinSensors.EyeLED, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this EyeLED message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this EyeLED to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                type Buttons$Properties = {
                    left?: boolean;
                    middle?: boolean;
                };

                /**
                 * Constructs a new Buttons.
                 * @exports message.platform.darwin.DarwinSensors.Buttons
                 * @constructor
                 * @param {message.platform.darwin.DarwinSensors.Buttons$Properties=} [properties] Properties to set
                 */
                class Buttons {

                    /**
                     * Constructs a new Buttons.
                     * @exports message.platform.darwin.DarwinSensors.Buttons
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.Buttons$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.platform.darwin.DarwinSensors.Buttons$Properties);

                    /**
                     * Buttons left.
                     * @type {boolean}
                     */
                    public left: boolean;

                    /**
                     * Buttons middle.
                     * @type {boolean}
                     */
                    public middle: boolean;

                    /**
                     * Creates a new Buttons instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.Buttons$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.Buttons} Buttons instance
                     */
                    public static create(properties?: message.platform.darwin.DarwinSensors.Buttons$Properties): message.platform.darwin.DarwinSensors.Buttons;

                    /**
                     * Encodes the specified Buttons message. Does not implicitly {@link message.platform.darwin.DarwinSensors.Buttons.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Buttons$Properties} message Buttons message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.platform.darwin.DarwinSensors.Buttons$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified Buttons message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.Buttons.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Buttons$Properties} message Buttons message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.platform.darwin.DarwinSensors.Buttons$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Buttons message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.Buttons} Buttons
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.DarwinSensors.Buttons;

                    /**
                     * Decodes a Buttons message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.Buttons} Buttons
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.DarwinSensors.Buttons;

                    /**
                     * Verifies a Buttons message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a Buttons message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Buttons} Buttons
                     */
                    public static fromObject(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.Buttons;

                    /**
                     * Creates a Buttons message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.Buttons.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Buttons} Buttons
                     */
                    public static from(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.Buttons;

                    /**
                     * Creates a plain object from a Buttons message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.Buttons} message Buttons
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.platform.darwin.DarwinSensors.Buttons, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this Buttons message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Buttons to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                type Accelerometer$Properties = {
                    x?: number;
                    y?: number;
                    z?: number;
                };

                /**
                 * Constructs a new Accelerometer.
                 * @exports message.platform.darwin.DarwinSensors.Accelerometer
                 * @constructor
                 * @param {message.platform.darwin.DarwinSensors.Accelerometer$Properties=} [properties] Properties to set
                 */
                class Accelerometer {

                    /**
                     * Constructs a new Accelerometer.
                     * @exports message.platform.darwin.DarwinSensors.Accelerometer
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.Accelerometer$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.platform.darwin.DarwinSensors.Accelerometer$Properties);

                    /**
                     * Accelerometer x.
                     * @type {number}
                     */
                    public x: number;

                    /**
                     * Accelerometer y.
                     * @type {number}
                     */
                    public y: number;

                    /**
                     * Accelerometer z.
                     * @type {number}
                     */
                    public z: number;

                    /**
                     * Creates a new Accelerometer instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.Accelerometer$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.Accelerometer} Accelerometer instance
                     */
                    public static create(properties?: message.platform.darwin.DarwinSensors.Accelerometer$Properties): message.platform.darwin.DarwinSensors.Accelerometer;

                    /**
                     * Encodes the specified Accelerometer message. Does not implicitly {@link message.platform.darwin.DarwinSensors.Accelerometer.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Accelerometer$Properties} message Accelerometer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.platform.darwin.DarwinSensors.Accelerometer$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified Accelerometer message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.Accelerometer.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Accelerometer$Properties} message Accelerometer message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.platform.darwin.DarwinSensors.Accelerometer$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes an Accelerometer message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.Accelerometer} Accelerometer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.DarwinSensors.Accelerometer;

                    /**
                     * Decodes an Accelerometer message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.Accelerometer} Accelerometer
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.DarwinSensors.Accelerometer;

                    /**
                     * Verifies an Accelerometer message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates an Accelerometer message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Accelerometer} Accelerometer
                     */
                    public static fromObject(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.Accelerometer;

                    /**
                     * Creates an Accelerometer message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.Accelerometer.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Accelerometer} Accelerometer
                     */
                    public static from(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.Accelerometer;

                    /**
                     * Creates a plain object from an Accelerometer message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.Accelerometer} message Accelerometer
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.platform.darwin.DarwinSensors.Accelerometer, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this Accelerometer message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Accelerometer to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                type Gyroscope$Properties = {
                    x?: number;
                    y?: number;
                    z?: number;
                };

                /**
                 * Constructs a new Gyroscope.
                 * @exports message.platform.darwin.DarwinSensors.Gyroscope
                 * @constructor
                 * @param {message.platform.darwin.DarwinSensors.Gyroscope$Properties=} [properties] Properties to set
                 */
                class Gyroscope {

                    /**
                     * Constructs a new Gyroscope.
                     * @exports message.platform.darwin.DarwinSensors.Gyroscope
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.Gyroscope$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.platform.darwin.DarwinSensors.Gyroscope$Properties);

                    /**
                     * Gyroscope x.
                     * @type {number}
                     */
                    public x: number;

                    /**
                     * Gyroscope y.
                     * @type {number}
                     */
                    public y: number;

                    /**
                     * Gyroscope z.
                     * @type {number}
                     */
                    public z: number;

                    /**
                     * Creates a new Gyroscope instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.Gyroscope$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.Gyroscope} Gyroscope instance
                     */
                    public static create(properties?: message.platform.darwin.DarwinSensors.Gyroscope$Properties): message.platform.darwin.DarwinSensors.Gyroscope;

                    /**
                     * Encodes the specified Gyroscope message. Does not implicitly {@link message.platform.darwin.DarwinSensors.Gyroscope.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Gyroscope$Properties} message Gyroscope message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.platform.darwin.DarwinSensors.Gyroscope$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified Gyroscope message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.Gyroscope.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Gyroscope$Properties} message Gyroscope message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.platform.darwin.DarwinSensors.Gyroscope$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Gyroscope message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.Gyroscope} Gyroscope
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.DarwinSensors.Gyroscope;

                    /**
                     * Decodes a Gyroscope message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.Gyroscope} Gyroscope
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.DarwinSensors.Gyroscope;

                    /**
                     * Verifies a Gyroscope message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a Gyroscope message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Gyroscope} Gyroscope
                     */
                    public static fromObject(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.Gyroscope;

                    /**
                     * Creates a Gyroscope message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.Gyroscope.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Gyroscope} Gyroscope
                     */
                    public static from(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.Gyroscope;

                    /**
                     * Creates a plain object from a Gyroscope message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.Gyroscope} message Gyroscope
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.platform.darwin.DarwinSensors.Gyroscope, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this Gyroscope message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Gyroscope to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                type FSR$Properties = {
                    fsr1?: number;
                    fsr2?: number;
                    fsr3?: number;
                    fsr4?: number;
                    centreX?: number;
                    centreY?: number;
                    errorFlags?: number;
                };

                /**
                 * Constructs a new FSR.
                 * @exports message.platform.darwin.DarwinSensors.FSR
                 * @constructor
                 * @param {message.platform.darwin.DarwinSensors.FSR$Properties=} [properties] Properties to set
                 */
                class FSR {

                    /**
                     * Constructs a new FSR.
                     * @exports message.platform.darwin.DarwinSensors.FSR
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.FSR$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.platform.darwin.DarwinSensors.FSR$Properties);

                    /**
                     * FSR fsr1.
                     * @type {number}
                     */
                    public fsr1: number;

                    /**
                     * FSR fsr2.
                     * @type {number}
                     */
                    public fsr2: number;

                    /**
                     * FSR fsr3.
                     * @type {number}
                     */
                    public fsr3: number;

                    /**
                     * FSR fsr4.
                     * @type {number}
                     */
                    public fsr4: number;

                    /**
                     * FSR centreX.
                     * @type {number}
                     */
                    public centreX: number;

                    /**
                     * FSR centreY.
                     * @type {number}
                     */
                    public centreY: number;

                    /**
                     * FSR errorFlags.
                     * @type {number}
                     */
                    public errorFlags: number;

                    /**
                     * Creates a new FSR instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.FSR$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.FSR} FSR instance
                     */
                    public static create(properties?: message.platform.darwin.DarwinSensors.FSR$Properties): message.platform.darwin.DarwinSensors.FSR;

                    /**
                     * Encodes the specified FSR message. Does not implicitly {@link message.platform.darwin.DarwinSensors.FSR.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.FSR$Properties} message FSR message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.platform.darwin.DarwinSensors.FSR$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified FSR message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.FSR.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.FSR$Properties} message FSR message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.platform.darwin.DarwinSensors.FSR$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a FSR message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.FSR} FSR
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.DarwinSensors.FSR;

                    /**
                     * Decodes a FSR message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.FSR} FSR
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.DarwinSensors.FSR;

                    /**
                     * Verifies a FSR message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a FSR message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.FSR} FSR
                     */
                    public static fromObject(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.FSR;

                    /**
                     * Creates a FSR message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.FSR.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.FSR} FSR
                     */
                    public static from(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.FSR;

                    /**
                     * Creates a plain object from a FSR message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.FSR} message FSR
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.platform.darwin.DarwinSensors.FSR, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this FSR message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this FSR to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                type FSRs$Properties = {
                    left?: message.platform.darwin.DarwinSensors.FSR$Properties;
                    right?: message.platform.darwin.DarwinSensors.FSR$Properties;
                };

                /**
                 * Constructs a new FSRs.
                 * @exports message.platform.darwin.DarwinSensors.FSRs
                 * @constructor
                 * @param {message.platform.darwin.DarwinSensors.FSRs$Properties=} [properties] Properties to set
                 */
                class FSRs {

                    /**
                     * Constructs a new FSRs.
                     * @exports message.platform.darwin.DarwinSensors.FSRs
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.FSRs$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.platform.darwin.DarwinSensors.FSRs$Properties);

                    /**
                     * FSRs left.
                     * @type {(message.platform.darwin.DarwinSensors.FSR$Properties|null)}
                     */
                    public left: (message.platform.darwin.DarwinSensors.FSR$Properties|null);

                    /**
                     * FSRs right.
                     * @type {(message.platform.darwin.DarwinSensors.FSR$Properties|null)}
                     */
                    public right: (message.platform.darwin.DarwinSensors.FSR$Properties|null);

                    /**
                     * Creates a new FSRs instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.FSRs$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.FSRs} FSRs instance
                     */
                    public static create(properties?: message.platform.darwin.DarwinSensors.FSRs$Properties): message.platform.darwin.DarwinSensors.FSRs;

                    /**
                     * Encodes the specified FSRs message. Does not implicitly {@link message.platform.darwin.DarwinSensors.FSRs.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.FSRs$Properties} message FSRs message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.platform.darwin.DarwinSensors.FSRs$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified FSRs message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.FSRs.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.FSRs$Properties} message FSRs message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.platform.darwin.DarwinSensors.FSRs$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a FSRs message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.FSRs} FSRs
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.DarwinSensors.FSRs;

                    /**
                     * Decodes a FSRs message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.FSRs} FSRs
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.DarwinSensors.FSRs;

                    /**
                     * Verifies a FSRs message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a FSRs message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.FSRs} FSRs
                     */
                    public static fromObject(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.FSRs;

                    /**
                     * Creates a FSRs message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.FSRs.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.FSRs} FSRs
                     */
                    public static from(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.FSRs;

                    /**
                     * Creates a plain object from a FSRs message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.FSRs} message FSRs
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.platform.darwin.DarwinSensors.FSRs, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this FSRs message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this FSRs to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                type Servo$Properties = {
                    errorFlags?: number;
                    torqueEnabled?: boolean;
                    pGain?: number;
                    iGain?: number;
                    dGain?: number;
                    goalPosition?: number;
                    movingSpeed?: number;
                    torque?: number;
                    presentPosition?: number;
                    presentSpeed?: number;
                    load?: number;
                    voltage?: number;
                    temperature?: number;
                };

                /**
                 * Constructs a new Servo.
                 * @exports message.platform.darwin.DarwinSensors.Servo
                 * @constructor
                 * @param {message.platform.darwin.DarwinSensors.Servo$Properties=} [properties] Properties to set
                 */
                class Servo {

                    /**
                     * Constructs a new Servo.
                     * @exports message.platform.darwin.DarwinSensors.Servo
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.Servo$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.platform.darwin.DarwinSensors.Servo$Properties);

                    /**
                     * Servo errorFlags.
                     * @type {number}
                     */
                    public errorFlags: number;

                    /**
                     * Servo torqueEnabled.
                     * @type {boolean}
                     */
                    public torqueEnabled: boolean;

                    /**
                     * Servo pGain.
                     * @type {number}
                     */
                    public pGain: number;

                    /**
                     * Servo iGain.
                     * @type {number}
                     */
                    public iGain: number;

                    /**
                     * Servo dGain.
                     * @type {number}
                     */
                    public dGain: number;

                    /**
                     * Servo goalPosition.
                     * @type {number}
                     */
                    public goalPosition: number;

                    /**
                     * Servo movingSpeed.
                     * @type {number}
                     */
                    public movingSpeed: number;

                    /**
                     * Servo torque.
                     * @type {number}
                     */
                    public torque: number;

                    /**
                     * Servo presentPosition.
                     * @type {number}
                     */
                    public presentPosition: number;

                    /**
                     * Servo presentSpeed.
                     * @type {number}
                     */
                    public presentSpeed: number;

                    /**
                     * Servo load.
                     * @type {number}
                     */
                    public load: number;

                    /**
                     * Servo voltage.
                     * @type {number}
                     */
                    public voltage: number;

                    /**
                     * Servo temperature.
                     * @type {number}
                     */
                    public temperature: number;

                    /**
                     * Creates a new Servo instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.Servo$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.Servo} Servo instance
                     */
                    public static create(properties?: message.platform.darwin.DarwinSensors.Servo$Properties): message.platform.darwin.DarwinSensors.Servo;

                    /**
                     * Encodes the specified Servo message. Does not implicitly {@link message.platform.darwin.DarwinSensors.Servo.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Servo$Properties} message Servo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.platform.darwin.DarwinSensors.Servo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified Servo message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.Servo.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Servo$Properties} message Servo message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.platform.darwin.DarwinSensors.Servo$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Servo message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.Servo} Servo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.DarwinSensors.Servo;

                    /**
                     * Decodes a Servo message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.Servo} Servo
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.DarwinSensors.Servo;

                    /**
                     * Verifies a Servo message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a Servo message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Servo} Servo
                     */
                    public static fromObject(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.Servo;

                    /**
                     * Creates a Servo message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.Servo.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Servo} Servo
                     */
                    public static from(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.Servo;

                    /**
                     * Creates a plain object from a Servo message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.Servo} message Servo
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.platform.darwin.DarwinSensors.Servo, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this Servo message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Servo to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                type Servos$Properties = {
                    rShoulderPitch?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    lShoulderPitch?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    rShoulderRoll?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    lShoulderRoll?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    rElbow?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    lElbow?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    rHipYaw?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    lHipYaw?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    rHipRoll?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    lHipRoll?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    rHipPitch?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    lHipPitch?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    rKnee?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    lKnee?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    rAnklePitch?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    lAnklePitch?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    rAnkleRoll?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    lAnkleRoll?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    headPan?: message.platform.darwin.DarwinSensors.Servo$Properties;
                    headTilt?: message.platform.darwin.DarwinSensors.Servo$Properties;
                };

                /**
                 * Constructs a new Servos.
                 * @exports message.platform.darwin.DarwinSensors.Servos
                 * @constructor
                 * @param {message.platform.darwin.DarwinSensors.Servos$Properties=} [properties] Properties to set
                 */
                class Servos {

                    /**
                     * Constructs a new Servos.
                     * @exports message.platform.darwin.DarwinSensors.Servos
                     * @constructor
                     * @param {message.platform.darwin.DarwinSensors.Servos$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.platform.darwin.DarwinSensors.Servos$Properties);

                    /**
                     * Servos rShoulderPitch.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public rShoulderPitch: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos lShoulderPitch.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public lShoulderPitch: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos rShoulderRoll.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public rShoulderRoll: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos lShoulderRoll.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public lShoulderRoll: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos rElbow.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public rElbow: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos lElbow.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public lElbow: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos rHipYaw.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public rHipYaw: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos lHipYaw.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public lHipYaw: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos rHipRoll.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public rHipRoll: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos lHipRoll.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public lHipRoll: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos rHipPitch.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public rHipPitch: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos lHipPitch.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public lHipPitch: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos rKnee.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public rKnee: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos lKnee.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public lKnee: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos rAnklePitch.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public rAnklePitch: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos lAnklePitch.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public lAnklePitch: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos rAnkleRoll.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public rAnkleRoll: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos lAnkleRoll.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public lAnkleRoll: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos headPan.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public headPan: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Servos headTilt.
                     * @type {(message.platform.darwin.DarwinSensors.Servo$Properties|null)}
                     */
                    public headTilt: (message.platform.darwin.DarwinSensors.Servo$Properties|null);

                    /**
                     * Creates a new Servos instance using the specified properties.
                     * @param {message.platform.darwin.DarwinSensors.Servos$Properties=} [properties] Properties to set
                     * @returns {message.platform.darwin.DarwinSensors.Servos} Servos instance
                     */
                    public static create(properties?: message.platform.darwin.DarwinSensors.Servos$Properties): message.platform.darwin.DarwinSensors.Servos;

                    /**
                     * Encodes the specified Servos message. Does not implicitly {@link message.platform.darwin.DarwinSensors.Servos.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Servos$Properties} message Servos message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.platform.darwin.DarwinSensors.Servos$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified Servos message, length delimited. Does not implicitly {@link message.platform.darwin.DarwinSensors.Servos.verify|verify} messages.
                     * @param {message.platform.darwin.DarwinSensors.Servos$Properties} message Servos message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.platform.darwin.DarwinSensors.Servos$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Servos message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.platform.darwin.DarwinSensors.Servos} Servos
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.DarwinSensors.Servos;

                    /**
                     * Decodes a Servos message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.platform.darwin.DarwinSensors.Servos} Servos
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.DarwinSensors.Servos;

                    /**
                     * Verifies a Servos message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a Servos message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Servos} Servos
                     */
                    public static fromObject(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.Servos;

                    /**
                     * Creates a Servos message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.platform.darwin.DarwinSensors.Servos.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.platform.darwin.DarwinSensors.Servos} Servos
                     */
                    public static from(object: { [k: string]: any }): message.platform.darwin.DarwinSensors.Servos;

                    /**
                     * Creates a plain object from a Servos message. Also converts values to other types if specified.
                     * @param {message.platform.darwin.DarwinSensors.Servos} message Servos
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.platform.darwin.DarwinSensors.Servos, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this Servos message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Servos to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            type ButtonLeftDown$Properties = {};

            /**
             * Constructs a new ButtonLeftDown.
             * @exports message.platform.darwin.ButtonLeftDown
             * @constructor
             * @param {message.platform.darwin.ButtonLeftDown$Properties=} [properties] Properties to set
             */
            class ButtonLeftDown {

                /**
                 * Constructs a new ButtonLeftDown.
                 * @exports message.platform.darwin.ButtonLeftDown
                 * @constructor
                 * @param {message.platform.darwin.ButtonLeftDown$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.platform.darwin.ButtonLeftDown$Properties);

                /**
                 * Creates a new ButtonLeftDown instance using the specified properties.
                 * @param {message.platform.darwin.ButtonLeftDown$Properties=} [properties] Properties to set
                 * @returns {message.platform.darwin.ButtonLeftDown} ButtonLeftDown instance
                 */
                public static create(properties?: message.platform.darwin.ButtonLeftDown$Properties): message.platform.darwin.ButtonLeftDown;

                /**
                 * Encodes the specified ButtonLeftDown message. Does not implicitly {@link message.platform.darwin.ButtonLeftDown.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonLeftDown$Properties} message ButtonLeftDown message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.platform.darwin.ButtonLeftDown$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ButtonLeftDown message, length delimited. Does not implicitly {@link message.platform.darwin.ButtonLeftDown.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonLeftDown$Properties} message ButtonLeftDown message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.platform.darwin.ButtonLeftDown$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ButtonLeftDown message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.darwin.ButtonLeftDown} ButtonLeftDown
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.ButtonLeftDown;

                /**
                 * Decodes a ButtonLeftDown message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.platform.darwin.ButtonLeftDown} ButtonLeftDown
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.ButtonLeftDown;

                /**
                 * Verifies a ButtonLeftDown message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a ButtonLeftDown message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonLeftDown} ButtonLeftDown
                 */
                public static fromObject(object: { [k: string]: any }): message.platform.darwin.ButtonLeftDown;

                /**
                 * Creates a ButtonLeftDown message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.platform.darwin.ButtonLeftDown.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonLeftDown} ButtonLeftDown
                 */
                public static from(object: { [k: string]: any }): message.platform.darwin.ButtonLeftDown;

                /**
                 * Creates a plain object from a ButtonLeftDown message. Also converts values to other types if specified.
                 * @param {message.platform.darwin.ButtonLeftDown} message ButtonLeftDown
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.platform.darwin.ButtonLeftDown, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this ButtonLeftDown message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this ButtonLeftDown to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type ButtonLeftUp$Properties = {};

            /**
             * Constructs a new ButtonLeftUp.
             * @exports message.platform.darwin.ButtonLeftUp
             * @constructor
             * @param {message.platform.darwin.ButtonLeftUp$Properties=} [properties] Properties to set
             */
            class ButtonLeftUp {

                /**
                 * Constructs a new ButtonLeftUp.
                 * @exports message.platform.darwin.ButtonLeftUp
                 * @constructor
                 * @param {message.platform.darwin.ButtonLeftUp$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.platform.darwin.ButtonLeftUp$Properties);

                /**
                 * Creates a new ButtonLeftUp instance using the specified properties.
                 * @param {message.platform.darwin.ButtonLeftUp$Properties=} [properties] Properties to set
                 * @returns {message.platform.darwin.ButtonLeftUp} ButtonLeftUp instance
                 */
                public static create(properties?: message.platform.darwin.ButtonLeftUp$Properties): message.platform.darwin.ButtonLeftUp;

                /**
                 * Encodes the specified ButtonLeftUp message. Does not implicitly {@link message.platform.darwin.ButtonLeftUp.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonLeftUp$Properties} message ButtonLeftUp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.platform.darwin.ButtonLeftUp$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ButtonLeftUp message, length delimited. Does not implicitly {@link message.platform.darwin.ButtonLeftUp.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonLeftUp$Properties} message ButtonLeftUp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.platform.darwin.ButtonLeftUp$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ButtonLeftUp message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.darwin.ButtonLeftUp} ButtonLeftUp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.ButtonLeftUp;

                /**
                 * Decodes a ButtonLeftUp message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.platform.darwin.ButtonLeftUp} ButtonLeftUp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.ButtonLeftUp;

                /**
                 * Verifies a ButtonLeftUp message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a ButtonLeftUp message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonLeftUp} ButtonLeftUp
                 */
                public static fromObject(object: { [k: string]: any }): message.platform.darwin.ButtonLeftUp;

                /**
                 * Creates a ButtonLeftUp message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.platform.darwin.ButtonLeftUp.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonLeftUp} ButtonLeftUp
                 */
                public static from(object: { [k: string]: any }): message.platform.darwin.ButtonLeftUp;

                /**
                 * Creates a plain object from a ButtonLeftUp message. Also converts values to other types if specified.
                 * @param {message.platform.darwin.ButtonLeftUp} message ButtonLeftUp
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.platform.darwin.ButtonLeftUp, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this ButtonLeftUp message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this ButtonLeftUp to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type ButtonMiddleDown$Properties = {};

            /**
             * Constructs a new ButtonMiddleDown.
             * @exports message.platform.darwin.ButtonMiddleDown
             * @constructor
             * @param {message.platform.darwin.ButtonMiddleDown$Properties=} [properties] Properties to set
             */
            class ButtonMiddleDown {

                /**
                 * Constructs a new ButtonMiddleDown.
                 * @exports message.platform.darwin.ButtonMiddleDown
                 * @constructor
                 * @param {message.platform.darwin.ButtonMiddleDown$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.platform.darwin.ButtonMiddleDown$Properties);

                /**
                 * Creates a new ButtonMiddleDown instance using the specified properties.
                 * @param {message.platform.darwin.ButtonMiddleDown$Properties=} [properties] Properties to set
                 * @returns {message.platform.darwin.ButtonMiddleDown} ButtonMiddleDown instance
                 */
                public static create(properties?: message.platform.darwin.ButtonMiddleDown$Properties): message.platform.darwin.ButtonMiddleDown;

                /**
                 * Encodes the specified ButtonMiddleDown message. Does not implicitly {@link message.platform.darwin.ButtonMiddleDown.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonMiddleDown$Properties} message ButtonMiddleDown message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.platform.darwin.ButtonMiddleDown$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ButtonMiddleDown message, length delimited. Does not implicitly {@link message.platform.darwin.ButtonMiddleDown.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonMiddleDown$Properties} message ButtonMiddleDown message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.platform.darwin.ButtonMiddleDown$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ButtonMiddleDown message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.darwin.ButtonMiddleDown} ButtonMiddleDown
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.ButtonMiddleDown;

                /**
                 * Decodes a ButtonMiddleDown message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.platform.darwin.ButtonMiddleDown} ButtonMiddleDown
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.ButtonMiddleDown;

                /**
                 * Verifies a ButtonMiddleDown message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a ButtonMiddleDown message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonMiddleDown} ButtonMiddleDown
                 */
                public static fromObject(object: { [k: string]: any }): message.platform.darwin.ButtonMiddleDown;

                /**
                 * Creates a ButtonMiddleDown message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.platform.darwin.ButtonMiddleDown.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonMiddleDown} ButtonMiddleDown
                 */
                public static from(object: { [k: string]: any }): message.platform.darwin.ButtonMiddleDown;

                /**
                 * Creates a plain object from a ButtonMiddleDown message. Also converts values to other types if specified.
                 * @param {message.platform.darwin.ButtonMiddleDown} message ButtonMiddleDown
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.platform.darwin.ButtonMiddleDown, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this ButtonMiddleDown message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this ButtonMiddleDown to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type ButtonMiddleUp$Properties = {};

            /**
             * Constructs a new ButtonMiddleUp.
             * @exports message.platform.darwin.ButtonMiddleUp
             * @constructor
             * @param {message.platform.darwin.ButtonMiddleUp$Properties=} [properties] Properties to set
             */
            class ButtonMiddleUp {

                /**
                 * Constructs a new ButtonMiddleUp.
                 * @exports message.platform.darwin.ButtonMiddleUp
                 * @constructor
                 * @param {message.platform.darwin.ButtonMiddleUp$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.platform.darwin.ButtonMiddleUp$Properties);

                /**
                 * Creates a new ButtonMiddleUp instance using the specified properties.
                 * @param {message.platform.darwin.ButtonMiddleUp$Properties=} [properties] Properties to set
                 * @returns {message.platform.darwin.ButtonMiddleUp} ButtonMiddleUp instance
                 */
                public static create(properties?: message.platform.darwin.ButtonMiddleUp$Properties): message.platform.darwin.ButtonMiddleUp;

                /**
                 * Encodes the specified ButtonMiddleUp message. Does not implicitly {@link message.platform.darwin.ButtonMiddleUp.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonMiddleUp$Properties} message ButtonMiddleUp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.platform.darwin.ButtonMiddleUp$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ButtonMiddleUp message, length delimited. Does not implicitly {@link message.platform.darwin.ButtonMiddleUp.verify|verify} messages.
                 * @param {message.platform.darwin.ButtonMiddleUp$Properties} message ButtonMiddleUp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.platform.darwin.ButtonMiddleUp$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ButtonMiddleUp message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.platform.darwin.ButtonMiddleUp} ButtonMiddleUp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.platform.darwin.ButtonMiddleUp;

                /**
                 * Decodes a ButtonMiddleUp message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.platform.darwin.ButtonMiddleUp} ButtonMiddleUp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.platform.darwin.ButtonMiddleUp;

                /**
                 * Verifies a ButtonMiddleUp message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a ButtonMiddleUp message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonMiddleUp} ButtonMiddleUp
                 */
                public static fromObject(object: { [k: string]: any }): message.platform.darwin.ButtonMiddleUp;

                /**
                 * Creates a ButtonMiddleUp message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.platform.darwin.ButtonMiddleUp.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.platform.darwin.ButtonMiddleUp} ButtonMiddleUp
                 */
                public static from(object: { [k: string]: any }): message.platform.darwin.ButtonMiddleUp;

                /**
                 * Creates a plain object from a ButtonMiddleUp message. Also converts values to other types if specified.
                 * @param {message.platform.darwin.ButtonMiddleUp} message ButtonMiddleUp
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.platform.darwin.ButtonMiddleUp, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this ButtonMiddleUp message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this ButtonMiddleUp to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /**
     * Namespace research.
     * @exports message.research
     * @namespace
     */
    namespace research {

        type AutoClassifierPixels$Properties = {
            pixels?: number[];
            classification?: number;
        };

        /**
         * Constructs a new AutoClassifierPixels.
         * @exports message.research.AutoClassifierPixels
         * @constructor
         * @param {message.research.AutoClassifierPixels$Properties=} [properties] Properties to set
         */
        class AutoClassifierPixels {

            /**
             * Constructs a new AutoClassifierPixels.
             * @exports message.research.AutoClassifierPixels
             * @constructor
             * @param {message.research.AutoClassifierPixels$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.research.AutoClassifierPixels$Properties);

            /**
             * AutoClassifierPixels pixels.
             * @type {Array.<number>}
             */
            public pixels: number[];

            /**
             * AutoClassifierPixels classification.
             * @type {number}
             */
            public classification: number;

            /**
             * Creates a new AutoClassifierPixels instance using the specified properties.
             * @param {message.research.AutoClassifierPixels$Properties=} [properties] Properties to set
             * @returns {message.research.AutoClassifierPixels} AutoClassifierPixels instance
             */
            public static create(properties?: message.research.AutoClassifierPixels$Properties): message.research.AutoClassifierPixels;

            /**
             * Encodes the specified AutoClassifierPixels message. Does not implicitly {@link message.research.AutoClassifierPixels.verify|verify} messages.
             * @param {message.research.AutoClassifierPixels$Properties} message AutoClassifierPixels message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.research.AutoClassifierPixels$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified AutoClassifierPixels message, length delimited. Does not implicitly {@link message.research.AutoClassifierPixels.verify|verify} messages.
             * @param {message.research.AutoClassifierPixels$Properties} message AutoClassifierPixels message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.research.AutoClassifierPixels$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an AutoClassifierPixels message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.research.AutoClassifierPixels} AutoClassifierPixels
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.research.AutoClassifierPixels;

            /**
             * Decodes an AutoClassifierPixels message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.research.AutoClassifierPixels} AutoClassifierPixels
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.research.AutoClassifierPixels;

            /**
             * Verifies an AutoClassifierPixels message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an AutoClassifierPixels message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.research.AutoClassifierPixels} AutoClassifierPixels
             */
            public static fromObject(object: { [k: string]: any }): message.research.AutoClassifierPixels;

            /**
             * Creates an AutoClassifierPixels message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.research.AutoClassifierPixels.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.research.AutoClassifierPixels} AutoClassifierPixels
             */
            public static from(object: { [k: string]: any }): message.research.AutoClassifierPixels;

            /**
             * Creates a plain object from an AutoClassifierPixels message. Also converts values to other types if specified.
             * @param {message.research.AutoClassifierPixels} message AutoClassifierPixels
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.research.AutoClassifierPixels, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this AutoClassifierPixels message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this AutoClassifierPixels to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /**
         * Namespace scriptoptimizer.
         * @exports message.research.scriptoptimizer
         * @namespace
         */
        namespace scriptoptimizer {

            type OptimizeScript$Properties = {
                target?: string;
                iteration?: number;
                metadata?: string;
                frames?: message.research.scriptoptimizer.OptimizeScript.Frame$Properties[];
            };

            /**
             * Constructs a new OptimizeScript.
             * @exports message.research.scriptoptimizer.OptimizeScript
             * @constructor
             * @param {message.research.scriptoptimizer.OptimizeScript$Properties=} [properties] Properties to set
             */
            class OptimizeScript {

                /**
                 * Constructs a new OptimizeScript.
                 * @exports message.research.scriptoptimizer.OptimizeScript
                 * @constructor
                 * @param {message.research.scriptoptimizer.OptimizeScript$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.research.scriptoptimizer.OptimizeScript$Properties);

                /**
                 * OptimizeScript target.
                 * @type {string}
                 */
                public target: string;

                /**
                 * OptimizeScript iteration.
                 * @type {number}
                 */
                public iteration: number;

                /**
                 * OptimizeScript metadata.
                 * @type {string}
                 */
                public metadata: string;

                /**
                 * OptimizeScript frames.
                 * @type {Array.<message.research.scriptoptimizer.OptimizeScript.Frame$Properties>}
                 */
                public frames: message.research.scriptoptimizer.OptimizeScript.Frame$Properties[];

                /**
                 * Creates a new OptimizeScript instance using the specified properties.
                 * @param {message.research.scriptoptimizer.OptimizeScript$Properties=} [properties] Properties to set
                 * @returns {message.research.scriptoptimizer.OptimizeScript} OptimizeScript instance
                 */
                public static create(properties?: message.research.scriptoptimizer.OptimizeScript$Properties): message.research.scriptoptimizer.OptimizeScript;

                /**
                 * Encodes the specified OptimizeScript message. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScript.verify|verify} messages.
                 * @param {message.research.scriptoptimizer.OptimizeScript$Properties} message OptimizeScript message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.research.scriptoptimizer.OptimizeScript$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified OptimizeScript message, length delimited. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScript.verify|verify} messages.
                 * @param {message.research.scriptoptimizer.OptimizeScript$Properties} message OptimizeScript message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.research.scriptoptimizer.OptimizeScript$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OptimizeScript message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.research.scriptoptimizer.OptimizeScript} OptimizeScript
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.research.scriptoptimizer.OptimizeScript;

                /**
                 * Decodes an OptimizeScript message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.research.scriptoptimizer.OptimizeScript} OptimizeScript
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.research.scriptoptimizer.OptimizeScript;

                /**
                 * Verifies an OptimizeScript message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an OptimizeScript message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.research.scriptoptimizer.OptimizeScript} OptimizeScript
                 */
                public static fromObject(object: { [k: string]: any }): message.research.scriptoptimizer.OptimizeScript;

                /**
                 * Creates an OptimizeScript message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.research.scriptoptimizer.OptimizeScript.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.research.scriptoptimizer.OptimizeScript} OptimizeScript
                 */
                public static from(object: { [k: string]: any }): message.research.scriptoptimizer.OptimizeScript;

                /**
                 * Creates a plain object from an OptimizeScript message. Also converts values to other types if specified.
                 * @param {message.research.scriptoptimizer.OptimizeScript} message OptimizeScript
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.research.scriptoptimizer.OptimizeScript, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this OptimizeScript message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this OptimizeScript to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace OptimizeScript {

                type Target$Properties = {
                    id?: number;
                    position?: number;
                    gain?: number;
                };

                /**
                 * Constructs a new Target.
                 * @exports message.research.scriptoptimizer.OptimizeScript.Target
                 * @constructor
                 * @param {message.research.scriptoptimizer.OptimizeScript.Target$Properties=} [properties] Properties to set
                 */
                class Target {

                    /**
                     * Constructs a new Target.
                     * @exports message.research.scriptoptimizer.OptimizeScript.Target
                     * @constructor
                     * @param {message.research.scriptoptimizer.OptimizeScript.Target$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.research.scriptoptimizer.OptimizeScript.Target$Properties);

                    /**
                     * Target id.
                     * @type {number}
                     */
                    public id: number;

                    /**
                     * Target position.
                     * @type {number}
                     */
                    public position: number;

                    /**
                     * Target gain.
                     * @type {number}
                     */
                    public gain: number;

                    /**
                     * Creates a new Target instance using the specified properties.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Target$Properties=} [properties] Properties to set
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Target} Target instance
                     */
                    public static create(properties?: message.research.scriptoptimizer.OptimizeScript.Target$Properties): message.research.scriptoptimizer.OptimizeScript.Target;

                    /**
                     * Encodes the specified Target message. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScript.Target.verify|verify} messages.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Target$Properties} message Target message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.research.scriptoptimizer.OptimizeScript.Target$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified Target message, length delimited. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScript.Target.verify|verify} messages.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Target$Properties} message Target message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.research.scriptoptimizer.OptimizeScript.Target$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Target message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Target} Target
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.research.scriptoptimizer.OptimizeScript.Target;

                    /**
                     * Decodes a Target message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Target} Target
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.research.scriptoptimizer.OptimizeScript.Target;

                    /**
                     * Verifies a Target message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a Target message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Target} Target
                     */
                    public static fromObject(object: { [k: string]: any }): message.research.scriptoptimizer.OptimizeScript.Target;

                    /**
                     * Creates a Target message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.research.scriptoptimizer.OptimizeScript.Target.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Target} Target
                     */
                    public static from(object: { [k: string]: any }): message.research.scriptoptimizer.OptimizeScript.Target;

                    /**
                     * Creates a plain object from a Target message. Also converts values to other types if specified.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Target} message Target
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.research.scriptoptimizer.OptimizeScript.Target, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this Target message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Target to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }

                type Frame$Properties = {
                    duration?: number;
                    targets?: message.research.scriptoptimizer.OptimizeScript.Target$Properties[];
                };

                /**
                 * Constructs a new Frame.
                 * @exports message.research.scriptoptimizer.OptimizeScript.Frame
                 * @constructor
                 * @param {message.research.scriptoptimizer.OptimizeScript.Frame$Properties=} [properties] Properties to set
                 */
                class Frame {

                    /**
                     * Constructs a new Frame.
                     * @exports message.research.scriptoptimizer.OptimizeScript.Frame
                     * @constructor
                     * @param {message.research.scriptoptimizer.OptimizeScript.Frame$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.research.scriptoptimizer.OptimizeScript.Frame$Properties);

                    /**
                     * Frame duration.
                     * @type {number}
                     */
                    public duration: number;

                    /**
                     * Frame targets.
                     * @type {Array.<message.research.scriptoptimizer.OptimizeScript.Target$Properties>}
                     */
                    public targets: message.research.scriptoptimizer.OptimizeScript.Target$Properties[];

                    /**
                     * Creates a new Frame instance using the specified properties.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Frame$Properties=} [properties] Properties to set
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Frame} Frame instance
                     */
                    public static create(properties?: message.research.scriptoptimizer.OptimizeScript.Frame$Properties): message.research.scriptoptimizer.OptimizeScript.Frame;

                    /**
                     * Encodes the specified Frame message. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScript.Frame.verify|verify} messages.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Frame$Properties} message Frame message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.research.scriptoptimizer.OptimizeScript.Frame$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified Frame message, length delimited. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScript.Frame.verify|verify} messages.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Frame$Properties} message Frame message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.research.scriptoptimizer.OptimizeScript.Frame$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Frame message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Frame} Frame
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.research.scriptoptimizer.OptimizeScript.Frame;

                    /**
                     * Decodes a Frame message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Frame} Frame
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.research.scriptoptimizer.OptimizeScript.Frame;

                    /**
                     * Verifies a Frame message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a Frame message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Frame} Frame
                     */
                    public static fromObject(object: { [k: string]: any }): message.research.scriptoptimizer.OptimizeScript.Frame;

                    /**
                     * Creates a Frame message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.research.scriptoptimizer.OptimizeScript.Frame.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.research.scriptoptimizer.OptimizeScript.Frame} Frame
                     */
                    public static from(object: { [k: string]: any }): message.research.scriptoptimizer.OptimizeScript.Frame;

                    /**
                     * Creates a plain object from a Frame message. Also converts values to other types if specified.
                     * @param {message.research.scriptoptimizer.OptimizeScript.Frame} message Frame
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.research.scriptoptimizer.OptimizeScript.Frame, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this Frame message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Frame to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            type OptimizeScriptResult$Properties = {
                iteration?: number;
                metadata?: string;
                sensors?: message.input.Sensors$Properties[];
            };

            /**
             * Constructs a new OptimizeScriptResult.
             * @exports message.research.scriptoptimizer.OptimizeScriptResult
             * @constructor
             * @param {message.research.scriptoptimizer.OptimizeScriptResult$Properties=} [properties] Properties to set
             */
            class OptimizeScriptResult {

                /**
                 * Constructs a new OptimizeScriptResult.
                 * @exports message.research.scriptoptimizer.OptimizeScriptResult
                 * @constructor
                 * @param {message.research.scriptoptimizer.OptimizeScriptResult$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.research.scriptoptimizer.OptimizeScriptResult$Properties);

                /**
                 * OptimizeScriptResult iteration.
                 * @type {number}
                 */
                public iteration: number;

                /**
                 * OptimizeScriptResult metadata.
                 * @type {string}
                 */
                public metadata: string;

                /**
                 * OptimizeScriptResult sensors.
                 * @type {Array.<message.input.Sensors$Properties>}
                 */
                public sensors: message.input.Sensors$Properties[];

                /**
                 * Creates a new OptimizeScriptResult instance using the specified properties.
                 * @param {message.research.scriptoptimizer.OptimizeScriptResult$Properties=} [properties] Properties to set
                 * @returns {message.research.scriptoptimizer.OptimizeScriptResult} OptimizeScriptResult instance
                 */
                public static create(properties?: message.research.scriptoptimizer.OptimizeScriptResult$Properties): message.research.scriptoptimizer.OptimizeScriptResult;

                /**
                 * Encodes the specified OptimizeScriptResult message. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScriptResult.verify|verify} messages.
                 * @param {message.research.scriptoptimizer.OptimizeScriptResult$Properties} message OptimizeScriptResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.research.scriptoptimizer.OptimizeScriptResult$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified OptimizeScriptResult message, length delimited. Does not implicitly {@link message.research.scriptoptimizer.OptimizeScriptResult.verify|verify} messages.
                 * @param {message.research.scriptoptimizer.OptimizeScriptResult$Properties} message OptimizeScriptResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.research.scriptoptimizer.OptimizeScriptResult$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OptimizeScriptResult message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.research.scriptoptimizer.OptimizeScriptResult} OptimizeScriptResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.research.scriptoptimizer.OptimizeScriptResult;

                /**
                 * Decodes an OptimizeScriptResult message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.research.scriptoptimizer.OptimizeScriptResult} OptimizeScriptResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.research.scriptoptimizer.OptimizeScriptResult;

                /**
                 * Verifies an OptimizeScriptResult message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an OptimizeScriptResult message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.research.scriptoptimizer.OptimizeScriptResult} OptimizeScriptResult
                 */
                public static fromObject(object: { [k: string]: any }): message.research.scriptoptimizer.OptimizeScriptResult;

                /**
                 * Creates an OptimizeScriptResult message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.research.scriptoptimizer.OptimizeScriptResult.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.research.scriptoptimizer.OptimizeScriptResult} OptimizeScriptResult
                 */
                public static from(object: { [k: string]: any }): message.research.scriptoptimizer.OptimizeScriptResult;

                /**
                 * Creates a plain object from an OptimizeScriptResult message. Also converts values to other types if specified.
                 * @param {message.research.scriptoptimizer.OptimizeScriptResult} message OptimizeScriptResult
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.research.scriptoptimizer.OptimizeScriptResult, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this OptimizeScriptResult message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this OptimizeScriptResult to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /**
     * Namespace support.
     * @exports message.support
     * @namespace
     */
    namespace support {

        type FieldDescription$Properties = {
            ballRadius?: number;
            goalpostTopHeight?: number;
            penaltyRobotStart?: number;
            goalpostOwnL?: vec2$Properties;
            goalpostOwnR?: vec2$Properties;
            goalpostOppL?: vec2$Properties;
            goalpostOppR?: vec2$Properties;
            dimensions?: message.support.FieldDescription.FieldDimensions$Properties;
        };

        /**
         * Constructs a new FieldDescription.
         * @exports message.support.FieldDescription
         * @constructor
         * @param {message.support.FieldDescription$Properties=} [properties] Properties to set
         */
        class FieldDescription {

            /**
             * Constructs a new FieldDescription.
             * @exports message.support.FieldDescription
             * @constructor
             * @param {message.support.FieldDescription$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.support.FieldDescription$Properties);

            /**
             * FieldDescription ballRadius.
             * @type {number}
             */
            public ballRadius: number;

            /**
             * FieldDescription goalpostTopHeight.
             * @type {number}
             */
            public goalpostTopHeight: number;

            /**
             * FieldDescription penaltyRobotStart.
             * @type {number}
             */
            public penaltyRobotStart: number;

            /**
             * FieldDescription goalpostOwnL.
             * @type {(vec2$Properties|null)}
             */
            public goalpostOwnL: (vec2$Properties|null);

            /**
             * FieldDescription goalpostOwnR.
             * @type {(vec2$Properties|null)}
             */
            public goalpostOwnR: (vec2$Properties|null);

            /**
             * FieldDescription goalpostOppL.
             * @type {(vec2$Properties|null)}
             */
            public goalpostOppL: (vec2$Properties|null);

            /**
             * FieldDescription goalpostOppR.
             * @type {(vec2$Properties|null)}
             */
            public goalpostOppR: (vec2$Properties|null);

            /**
             * FieldDescription dimensions.
             * @type {(message.support.FieldDescription.FieldDimensions$Properties|null)}
             */
            public dimensions: (message.support.FieldDescription.FieldDimensions$Properties|null);

            /**
             * Creates a new FieldDescription instance using the specified properties.
             * @param {message.support.FieldDescription$Properties=} [properties] Properties to set
             * @returns {message.support.FieldDescription} FieldDescription instance
             */
            public static create(properties?: message.support.FieldDescription$Properties): message.support.FieldDescription;

            /**
             * Encodes the specified FieldDescription message. Does not implicitly {@link message.support.FieldDescription.verify|verify} messages.
             * @param {message.support.FieldDescription$Properties} message FieldDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.support.FieldDescription$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FieldDescription message, length delimited. Does not implicitly {@link message.support.FieldDescription.verify|verify} messages.
             * @param {message.support.FieldDescription$Properties} message FieldDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.support.FieldDescription$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FieldDescription message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.support.FieldDescription} FieldDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.FieldDescription;

            /**
             * Decodes a FieldDescription message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.support.FieldDescription} FieldDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.FieldDescription;

            /**
             * Verifies a FieldDescription message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a FieldDescription message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.FieldDescription} FieldDescription
             */
            public static fromObject(object: { [k: string]: any }): message.support.FieldDescription;

            /**
             * Creates a FieldDescription message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.support.FieldDescription.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.FieldDescription} FieldDescription
             */
            public static from(object: { [k: string]: any }): message.support.FieldDescription;

            /**
             * Creates a plain object from a FieldDescription message. Also converts values to other types if specified.
             * @param {message.support.FieldDescription} message FieldDescription
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.support.FieldDescription, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this FieldDescription message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this FieldDescription to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace FieldDescription {

            /**
             * GoalpostType enum.
             * @name GoalpostType
             * @memberof message.support.FieldDescription
             * @enum {number}
             * @property {number} RECTANGLE=0 RECTANGLE value
             * @property {number} CIRCLE=1 CIRCLE value
             */
            enum GoalpostType {
                RECTANGLE = 0,
                CIRCLE = 1
            }

            type FieldDimensions$Properties = {
                lineWidth?: number;
                markWidth?: number;
                fieldLength?: number;
                fieldWidth?: number;
                goalpostType?: message.support.FieldDescription.GoalpostType;
                goalDepth?: number;
                goalWidth?: number;
                goalAreaLength?: number;
                goalAreaWidth?: number;
                goalCrossbarHeight?: number;
                goalpostWidth?: number;
                goalpostDepth?: number;
                goalCrossbarWidth?: number;
                goalCrossbarDepth?: number;
                goalNetHeight?: number;
                penaltyMarkDistance?: number;
                centerCircleDiameter?: number;
                borderStripMinWidth?: number;
            };

            /**
             * Constructs a new FieldDimensions.
             * @exports message.support.FieldDescription.FieldDimensions
             * @constructor
             * @param {message.support.FieldDescription.FieldDimensions$Properties=} [properties] Properties to set
             */
            class FieldDimensions {

                /**
                 * Constructs a new FieldDimensions.
                 * @exports message.support.FieldDescription.FieldDimensions
                 * @constructor
                 * @param {message.support.FieldDescription.FieldDimensions$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.FieldDescription.FieldDimensions$Properties);

                /**
                 * FieldDimensions lineWidth.
                 * @type {number}
                 */
                public lineWidth: number;

                /**
                 * FieldDimensions markWidth.
                 * @type {number}
                 */
                public markWidth: number;

                /**
                 * FieldDimensions fieldLength.
                 * @type {number}
                 */
                public fieldLength: number;

                /**
                 * FieldDimensions fieldWidth.
                 * @type {number}
                 */
                public fieldWidth: number;

                /**
                 * FieldDimensions goalpostType.
                 * @type {message.support.FieldDescription.GoalpostType}
                 */
                public goalpostType: message.support.FieldDescription.GoalpostType;

                /**
                 * FieldDimensions goalDepth.
                 * @type {number}
                 */
                public goalDepth: number;

                /**
                 * FieldDimensions goalWidth.
                 * @type {number}
                 */
                public goalWidth: number;

                /**
                 * FieldDimensions goalAreaLength.
                 * @type {number}
                 */
                public goalAreaLength: number;

                /**
                 * FieldDimensions goalAreaWidth.
                 * @type {number}
                 */
                public goalAreaWidth: number;

                /**
                 * FieldDimensions goalCrossbarHeight.
                 * @type {number}
                 */
                public goalCrossbarHeight: number;

                /**
                 * FieldDimensions goalpostWidth.
                 * @type {number}
                 */
                public goalpostWidth: number;

                /**
                 * FieldDimensions goalpostDepth.
                 * @type {number}
                 */
                public goalpostDepth: number;

                /**
                 * FieldDimensions goalCrossbarWidth.
                 * @type {number}
                 */
                public goalCrossbarWidth: number;

                /**
                 * FieldDimensions goalCrossbarDepth.
                 * @type {number}
                 */
                public goalCrossbarDepth: number;

                /**
                 * FieldDimensions goalNetHeight.
                 * @type {number}
                 */
                public goalNetHeight: number;

                /**
                 * FieldDimensions penaltyMarkDistance.
                 * @type {number}
                 */
                public penaltyMarkDistance: number;

                /**
                 * FieldDimensions centerCircleDiameter.
                 * @type {number}
                 */
                public centerCircleDiameter: number;

                /**
                 * FieldDimensions borderStripMinWidth.
                 * @type {number}
                 */
                public borderStripMinWidth: number;

                /**
                 * Creates a new FieldDimensions instance using the specified properties.
                 * @param {message.support.FieldDescription.FieldDimensions$Properties=} [properties] Properties to set
                 * @returns {message.support.FieldDescription.FieldDimensions} FieldDimensions instance
                 */
                public static create(properties?: message.support.FieldDescription.FieldDimensions$Properties): message.support.FieldDescription.FieldDimensions;

                /**
                 * Encodes the specified FieldDimensions message. Does not implicitly {@link message.support.FieldDescription.FieldDimensions.verify|verify} messages.
                 * @param {message.support.FieldDescription.FieldDimensions$Properties} message FieldDimensions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.FieldDescription.FieldDimensions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified FieldDimensions message, length delimited. Does not implicitly {@link message.support.FieldDescription.FieldDimensions.verify|verify} messages.
                 * @param {message.support.FieldDescription.FieldDimensions$Properties} message FieldDimensions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.FieldDescription.FieldDimensions$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a FieldDimensions message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.FieldDescription.FieldDimensions} FieldDimensions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.FieldDescription.FieldDimensions;

                /**
                 * Decodes a FieldDimensions message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.FieldDescription.FieldDimensions} FieldDimensions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.FieldDescription.FieldDimensions;

                /**
                 * Verifies a FieldDimensions message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a FieldDimensions message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.FieldDescription.FieldDimensions} FieldDimensions
                 */
                public static fromObject(object: { [k: string]: any }): message.support.FieldDescription.FieldDimensions;

                /**
                 * Creates a FieldDimensions message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.FieldDescription.FieldDimensions.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.FieldDescription.FieldDimensions} FieldDimensions
                 */
                public static from(object: { [k: string]: any }): message.support.FieldDescription.FieldDimensions;

                /**
                 * Creates a plain object from a FieldDimensions message. Also converts values to other types if specified.
                 * @param {message.support.FieldDescription.FieldDimensions} message FieldDimensions
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.FieldDescription.FieldDimensions, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this FieldDimensions message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this FieldDimensions to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type GlobalConfig$Properties = {
            playerId?: number;
            teamId?: number;
        };

        /**
         * Constructs a new GlobalConfig.
         * @exports message.support.GlobalConfig
         * @constructor
         * @param {message.support.GlobalConfig$Properties=} [properties] Properties to set
         */
        class GlobalConfig {

            /**
             * Constructs a new GlobalConfig.
             * @exports message.support.GlobalConfig
             * @constructor
             * @param {message.support.GlobalConfig$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.support.GlobalConfig$Properties);

            /**
             * GlobalConfig playerId.
             * @type {number}
             */
            public playerId: number;

            /**
             * GlobalConfig teamId.
             * @type {number}
             */
            public teamId: number;

            /**
             * Creates a new GlobalConfig instance using the specified properties.
             * @param {message.support.GlobalConfig$Properties=} [properties] Properties to set
             * @returns {message.support.GlobalConfig} GlobalConfig instance
             */
            public static create(properties?: message.support.GlobalConfig$Properties): message.support.GlobalConfig;

            /**
             * Encodes the specified GlobalConfig message. Does not implicitly {@link message.support.GlobalConfig.verify|verify} messages.
             * @param {message.support.GlobalConfig$Properties} message GlobalConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.support.GlobalConfig$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified GlobalConfig message, length delimited. Does not implicitly {@link message.support.GlobalConfig.verify|verify} messages.
             * @param {message.support.GlobalConfig$Properties} message GlobalConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.support.GlobalConfig$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a GlobalConfig message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.support.GlobalConfig} GlobalConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.GlobalConfig;

            /**
             * Decodes a GlobalConfig message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.support.GlobalConfig} GlobalConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.GlobalConfig;

            /**
             * Verifies a GlobalConfig message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a GlobalConfig message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.GlobalConfig} GlobalConfig
             */
            public static fromObject(object: { [k: string]: any }): message.support.GlobalConfig;

            /**
             * Creates a GlobalConfig message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.support.GlobalConfig.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.GlobalConfig} GlobalConfig
             */
            public static from(object: { [k: string]: any }): message.support.GlobalConfig;

            /**
             * Creates a plain object from a GlobalConfig message. Also converts values to other types if specified.
             * @param {message.support.GlobalConfig} message GlobalConfig
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.support.GlobalConfig, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this GlobalConfig message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this GlobalConfig to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type SaveConfiguration$Properties = {
            path?: string;
            config?: string;
        };

        /**
         * Constructs a new SaveConfiguration.
         * @exports message.support.SaveConfiguration
         * @constructor
         * @param {message.support.SaveConfiguration$Properties=} [properties] Properties to set
         */
        class SaveConfiguration {

            /**
             * Constructs a new SaveConfiguration.
             * @exports message.support.SaveConfiguration
             * @constructor
             * @param {message.support.SaveConfiguration$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.support.SaveConfiguration$Properties);

            /**
             * SaveConfiguration path.
             * @type {string}
             */
            public path: string;

            /**
             * SaveConfiguration config.
             * @type {string}
             */
            public config: string;

            /**
             * Creates a new SaveConfiguration instance using the specified properties.
             * @param {message.support.SaveConfiguration$Properties=} [properties] Properties to set
             * @returns {message.support.SaveConfiguration} SaveConfiguration instance
             */
            public static create(properties?: message.support.SaveConfiguration$Properties): message.support.SaveConfiguration;

            /**
             * Encodes the specified SaveConfiguration message. Does not implicitly {@link message.support.SaveConfiguration.verify|verify} messages.
             * @param {message.support.SaveConfiguration$Properties} message SaveConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.support.SaveConfiguration$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified SaveConfiguration message, length delimited. Does not implicitly {@link message.support.SaveConfiguration.verify|verify} messages.
             * @param {message.support.SaveConfiguration$Properties} message SaveConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.support.SaveConfiguration$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SaveConfiguration message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.support.SaveConfiguration} SaveConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.SaveConfiguration;

            /**
             * Decodes a SaveConfiguration message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.support.SaveConfiguration} SaveConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.SaveConfiguration;

            /**
             * Verifies a SaveConfiguration message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a SaveConfiguration message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.SaveConfiguration} SaveConfiguration
             */
            public static fromObject(object: { [k: string]: any }): message.support.SaveConfiguration;

            /**
             * Creates a SaveConfiguration message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.support.SaveConfiguration.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.SaveConfiguration} SaveConfiguration
             */
            public static from(object: { [k: string]: any }): message.support.SaveConfiguration;

            /**
             * Creates a plain object from a SaveConfiguration message. Also converts values to other types if specified.
             * @param {message.support.SaveConfiguration} message SaveConfiguration
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.support.SaveConfiguration, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this SaveConfiguration message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this SaveConfiguration to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type ServoHealthTestData$Properties = {
            state?: message.support.ServoHealthTestData.State;
            sensors?: message.platform.darwin.DarwinSensors$Properties;
        };

        /**
         * Constructs a new ServoHealthTestData.
         * @exports message.support.ServoHealthTestData
         * @constructor
         * @param {message.support.ServoHealthTestData$Properties=} [properties] Properties to set
         */
        class ServoHealthTestData {

            /**
             * Constructs a new ServoHealthTestData.
             * @exports message.support.ServoHealthTestData
             * @constructor
             * @param {message.support.ServoHealthTestData$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.support.ServoHealthTestData$Properties);

            /**
             * ServoHealthTestData state.
             * @type {message.support.ServoHealthTestData.State}
             */
            public state: message.support.ServoHealthTestData.State;

            /**
             * ServoHealthTestData sensors.
             * @type {(message.platform.darwin.DarwinSensors$Properties|null)}
             */
            public sensors: (message.platform.darwin.DarwinSensors$Properties|null);

            /**
             * Creates a new ServoHealthTestData instance using the specified properties.
             * @param {message.support.ServoHealthTestData$Properties=} [properties] Properties to set
             * @returns {message.support.ServoHealthTestData} ServoHealthTestData instance
             */
            public static create(properties?: message.support.ServoHealthTestData$Properties): message.support.ServoHealthTestData;

            /**
             * Encodes the specified ServoHealthTestData message. Does not implicitly {@link message.support.ServoHealthTestData.verify|verify} messages.
             * @param {message.support.ServoHealthTestData$Properties} message ServoHealthTestData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.support.ServoHealthTestData$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified ServoHealthTestData message, length delimited. Does not implicitly {@link message.support.ServoHealthTestData.verify|verify} messages.
             * @param {message.support.ServoHealthTestData$Properties} message ServoHealthTestData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.support.ServoHealthTestData$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ServoHealthTestData message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.support.ServoHealthTestData} ServoHealthTestData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.ServoHealthTestData;

            /**
             * Decodes a ServoHealthTestData message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.support.ServoHealthTestData} ServoHealthTestData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.ServoHealthTestData;

            /**
             * Verifies a ServoHealthTestData message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a ServoHealthTestData message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.ServoHealthTestData} ServoHealthTestData
             */
            public static fromObject(object: { [k: string]: any }): message.support.ServoHealthTestData;

            /**
             * Creates a ServoHealthTestData message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.support.ServoHealthTestData.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.support.ServoHealthTestData} ServoHealthTestData
             */
            public static from(object: { [k: string]: any }): message.support.ServoHealthTestData;

            /**
             * Creates a plain object from a ServoHealthTestData message. Also converts values to other types if specified.
             * @param {message.support.ServoHealthTestData} message ServoHealthTestData
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.support.ServoHealthTestData, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this ServoHealthTestData message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this ServoHealthTestData to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace ServoHealthTestData {

            /**
             * State enum.
             * @name State
             * @memberof message.support.ServoHealthTestData
             * @enum {number}
             * @property {number} INITIALISE=0 INITIALISE value
             * @property {number} MOVE_1=1 MOVE_1 value
             * @property {number} ELBOW=2 ELBOW value
             * @property {number} MOVE_2=3 MOVE_2 value
             * @property {number} SHOULDER_PITCH=4 SHOULDER_PITCH value
             * @property {number} SHOULDER_MOVE_1=5 SHOULDER_MOVE_1 value
             * @property {number} SHOULDER_ROLL=6 SHOULDER_ROLL value
             * @property {number} MOVE_3=7 MOVE_3 value
             * @property {number} HEAD_PITCH=8 HEAD_PITCH value
             * @property {number} MOVE_4=9 MOVE_4 value
             * @property {number} HEAD_YAW=10 HEAD_YAW value
             * @property {number} LAYDOWN=11 LAYDOWN value
             * @property {number} HIP_ROLL=12 HIP_ROLL value
             * @property {number} HIP_MOVE_1=13 HIP_MOVE_1 value
             * @property {number} HIP_YAW=14 HIP_YAW value
             * @property {number} HIP_MOVE_2=15 HIP_MOVE_2 value
             * @property {number} ANKLE_PITCH=16 ANKLE_PITCH value
             * @property {number} ANKLE_MOVE=17 ANKLE_MOVE value
             * @property {number} ANKLE_ROLL=18 ANKLE_ROLL value
             * @property {number} KNEE_MOVE=19 KNEE_MOVE value
             * @property {number} KNEE=20 KNEE value
             * @property {number} KNEE_MOVE_2=21 KNEE_MOVE_2 value
             * @property {number} HIP_PITCH=22 HIP_PITCH value
             * @property {number} LAYDOWN_2=23 LAYDOWN_2 value
             * @property {number} FINISHED=24 FINISHED value
             */
            enum State {
                INITIALISE = 0,
                MOVE_1 = 1,
                ELBOW = 2,
                MOVE_2 = 3,
                SHOULDER_PITCH = 4,
                SHOULDER_MOVE_1 = 5,
                SHOULDER_ROLL = 6,
                MOVE_3 = 7,
                HEAD_PITCH = 8,
                MOVE_4 = 9,
                HEAD_YAW = 10,
                LAYDOWN = 11,
                HIP_ROLL = 12,
                HIP_MOVE_1 = 13,
                HIP_YAW = 14,
                HIP_MOVE_2 = 15,
                ANKLE_PITCH = 16,
                ANKLE_MOVE = 17,
                ANKLE_ROLL = 18,
                KNEE_MOVE = 19,
                KNEE = 20,
                KNEE_MOVE_2 = 21,
                HIP_PITCH = 22,
                LAYDOWN_2 = 23,
                FINISHED = 24
            }
        }

        /**
         * Namespace nubugger.
         * @exports message.support.nubugger
         * @namespace
         */
        namespace nubugger {

            type Command$Properties = {
                command?: string;
            };

            /**
             * Constructs a new Command.
             * @exports message.support.nubugger.Command
             * @constructor
             * @param {message.support.nubugger.Command$Properties=} [properties] Properties to set
             */
            class Command {

                /**
                 * Constructs a new Command.
                 * @exports message.support.nubugger.Command
                 * @constructor
                 * @param {message.support.nubugger.Command$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.nubugger.Command$Properties);

                /**
                 * Command command.
                 * @type {string}
                 */
                public command: string;

                /**
                 * Creates a new Command instance using the specified properties.
                 * @param {message.support.nubugger.Command$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.Command} Command instance
                 */
                public static create(properties?: message.support.nubugger.Command$Properties): message.support.nubugger.Command;

                /**
                 * Encodes the specified Command message. Does not implicitly {@link message.support.nubugger.Command.verify|verify} messages.
                 * @param {message.support.nubugger.Command$Properties} message Command message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.nubugger.Command$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Command message, length delimited. Does not implicitly {@link message.support.nubugger.Command.verify|verify} messages.
                 * @param {message.support.nubugger.Command$Properties} message Command message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.nubugger.Command$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Command message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.Command} Command
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.nubugger.Command;

                /**
                 * Decodes a Command message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.Command} Command
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.nubugger.Command;

                /**
                 * Verifies a Command message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Command message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.Command} Command
                 */
                public static fromObject(object: { [k: string]: any }): message.support.nubugger.Command;

                /**
                 * Creates a Command message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.Command.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.Command} Command
                 */
                public static from(object: { [k: string]: any }): message.support.nubugger.Command;

                /**
                 * Creates a plain object from a Command message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.Command} message Command
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.nubugger.Command, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Command message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Command to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type DataPoint$Properties = {
                label?: string;
                value?: number[];
                type?: message.support.nubugger.DataPoint.Type;
            };

            /**
             * Constructs a new DataPoint.
             * @exports message.support.nubugger.DataPoint
             * @constructor
             * @param {message.support.nubugger.DataPoint$Properties=} [properties] Properties to set
             */
            class DataPoint {

                /**
                 * Constructs a new DataPoint.
                 * @exports message.support.nubugger.DataPoint
                 * @constructor
                 * @param {message.support.nubugger.DataPoint$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.nubugger.DataPoint$Properties);

                /**
                 * DataPoint label.
                 * @type {string}
                 */
                public label: string;

                /**
                 * DataPoint value.
                 * @type {Array.<number>}
                 */
                public value: number[];

                /**
                 * DataPoint type.
                 * @type {message.support.nubugger.DataPoint.Type}
                 */
                public type: message.support.nubugger.DataPoint.Type;

                /**
                 * Creates a new DataPoint instance using the specified properties.
                 * @param {message.support.nubugger.DataPoint$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.DataPoint} DataPoint instance
                 */
                public static create(properties?: message.support.nubugger.DataPoint$Properties): message.support.nubugger.DataPoint;

                /**
                 * Encodes the specified DataPoint message. Does not implicitly {@link message.support.nubugger.DataPoint.verify|verify} messages.
                 * @param {message.support.nubugger.DataPoint$Properties} message DataPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.nubugger.DataPoint$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified DataPoint message, length delimited. Does not implicitly {@link message.support.nubugger.DataPoint.verify|verify} messages.
                 * @param {message.support.nubugger.DataPoint$Properties} message DataPoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.nubugger.DataPoint$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DataPoint message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.DataPoint} DataPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.nubugger.DataPoint;

                /**
                 * Decodes a DataPoint message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.DataPoint} DataPoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.nubugger.DataPoint;

                /**
                 * Verifies a DataPoint message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a DataPoint message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.DataPoint} DataPoint
                 */
                public static fromObject(object: { [k: string]: any }): message.support.nubugger.DataPoint;

                /**
                 * Creates a DataPoint message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.DataPoint.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.DataPoint} DataPoint
                 */
                public static from(object: { [k: string]: any }): message.support.nubugger.DataPoint;

                /**
                 * Creates a plain object from a DataPoint message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.DataPoint} message DataPoint
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.nubugger.DataPoint, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this DataPoint message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this DataPoint to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace DataPoint {

                /**
                 * The represents the type of data
                 * NOTE: This should not describe how to display the data, as that should be done client-side.
                 * @name Type
                 * @memberof message.support.nubugger.DataPoint
                 * @enum {number}
                 * @property {number} FLOAT_LIST=0 FLOAT_LIST value
                 * @property {number} ROTATION_3D=2 ROTATION_3D value
                 */
                enum Type {
                    FLOAT_LIST = 0,
                    ROTATION_3D = 2
                }
            }

            type DrawObject$Properties = {
                shape?: message.support.nubugger.DrawObject.Shape;
                name?: string;
                position?: vec3$Properties;
                direction?: vec3$Properties;
                target?: vec3$Properties;
                width?: number;
                height?: number;
                rotation?: vec3$Properties;
                colour?: vec3$Properties;
                radius?: number;
                topRadius?: number;
                bottomRadius?: number;
                vertices?: vec3$Properties[];
                path?: message.support.nubugger.DrawObject.Path$Properties[];
                faces?: number;
                lineWidth?: number;
                length?: number;
                depth?: number;
                fill?: boolean;
                timeout?: number;
            };

            /**
             * Constructs a new DrawObject.
             * @exports message.support.nubugger.DrawObject
             * @constructor
             * @param {message.support.nubugger.DrawObject$Properties=} [properties] Properties to set
             */
            class DrawObject {

                /**
                 * Constructs a new DrawObject.
                 * @exports message.support.nubugger.DrawObject
                 * @constructor
                 * @param {message.support.nubugger.DrawObject$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.nubugger.DrawObject$Properties);

                /**
                 * DrawObject shape.
                 * @type {message.support.nubugger.DrawObject.Shape}
                 */
                public shape: message.support.nubugger.DrawObject.Shape;

                /**
                 * DrawObject name.
                 * @type {string}
                 */
                public name: string;

                /**
                 * DrawObject position.
                 * @type {(vec3$Properties|null)}
                 */
                public position: (vec3$Properties|null);

                /**
                 * DrawObject direction.
                 * @type {(vec3$Properties|null)}
                 */
                public direction: (vec3$Properties|null);

                /**
                 * DrawObject target.
                 * @type {(vec3$Properties|null)}
                 */
                public target: (vec3$Properties|null);

                /**
                 * DrawObject width.
                 * @type {number}
                 */
                public width: number;

                /**
                 * DrawObject height.
                 * @type {number}
                 */
                public height: number;

                /**
                 * DrawObject rotation.
                 * @type {(vec3$Properties|null)}
                 */
                public rotation: (vec3$Properties|null);

                /**
                 * DrawObject colour.
                 * @type {(vec3$Properties|null)}
                 */
                public colour: (vec3$Properties|null);

                /**
                 * DrawObject radius.
                 * @type {number}
                 */
                public radius: number;

                /**
                 * DrawObject topRadius.
                 * @type {number}
                 */
                public topRadius: number;

                /**
                 * DrawObject bottomRadius.
                 * @type {number}
                 */
                public bottomRadius: number;

                /**
                 * DrawObject vertices.
                 * @type {Array.<vec3$Properties>}
                 */
                public vertices: vec3$Properties[];

                /**
                 * DrawObject path.
                 * @type {Array.<message.support.nubugger.DrawObject.Path$Properties>}
                 */
                public path: message.support.nubugger.DrawObject.Path$Properties[];

                /**
                 * DrawObject faces.
                 * @type {number}
                 */
                public faces: number;

                /**
                 * DrawObject lineWidth.
                 * @type {number}
                 */
                public lineWidth: number;

                /**
                 * DrawObject length.
                 * @type {number}
                 */
                public length: number;

                /**
                 * DrawObject depth.
                 * @type {number}
                 */
                public depth: number;

                /**
                 * DrawObject fill.
                 * @type {boolean}
                 */
                public fill: boolean;

                /**
                 * DrawObject timeout.
                 * @type {number}
                 */
                public timeout: number;

                /**
                 * Creates a new DrawObject instance using the specified properties.
                 * @param {message.support.nubugger.DrawObject$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.DrawObject} DrawObject instance
                 */
                public static create(properties?: message.support.nubugger.DrawObject$Properties): message.support.nubugger.DrawObject;

                /**
                 * Encodes the specified DrawObject message. Does not implicitly {@link message.support.nubugger.DrawObject.verify|verify} messages.
                 * @param {message.support.nubugger.DrawObject$Properties} message DrawObject message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.nubugger.DrawObject$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified DrawObject message, length delimited. Does not implicitly {@link message.support.nubugger.DrawObject.verify|verify} messages.
                 * @param {message.support.nubugger.DrawObject$Properties} message DrawObject message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.nubugger.DrawObject$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DrawObject message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.DrawObject} DrawObject
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.nubugger.DrawObject;

                /**
                 * Decodes a DrawObject message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.DrawObject} DrawObject
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.nubugger.DrawObject;

                /**
                 * Verifies a DrawObject message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a DrawObject message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.DrawObject} DrawObject
                 */
                public static fromObject(object: { [k: string]: any }): message.support.nubugger.DrawObject;

                /**
                 * Creates a DrawObject message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.DrawObject.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.DrawObject} DrawObject
                 */
                public static from(object: { [k: string]: any }): message.support.nubugger.DrawObject;

                /**
                 * Creates a plain object from a DrawObject message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.DrawObject} message DrawObject
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.nubugger.DrawObject, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this DrawObject message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this DrawObject to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace DrawObject {

                /**
                 * Shape enum.
                 * @name Shape
                 * @memberof message.support.nubugger.DrawObject
                 * @enum {number}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} ARROW=1 ARROW value
                 * @property {number} BOX=2 BOX value
                 * @property {number} CIRCLE=3 CIRCLE value
                 * @property {number} CYLINDER=4 CYLINDER value
                 * @property {number} POLYLINE=5 POLYLINE value
                 * @property {number} PYRAMID=6 PYRAMID value
                 * @property {number} RECTANGLE=7 RECTANGLE value
                 * @property {number} SPHERE=8 SPHERE value
                 */
                enum Shape {
                    UNKNOWN = 0,
                    ARROW = 1,
                    BOX = 2,
                    CIRCLE = 3,
                    CYLINDER = 4,
                    POLYLINE = 5,
                    PYRAMID = 6,
                    RECTANGLE = 7,
                    SPHERE = 8
                }

                type Path$Properties = {
                    position?: vec2$Properties;
                    parentIndex?: number;
                };

                /**
                 * Constructs a new Path.
                 * @exports message.support.nubugger.DrawObject.Path
                 * @constructor
                 * @param {message.support.nubugger.DrawObject.Path$Properties=} [properties] Properties to set
                 */
                class Path {

                    /**
                     * Constructs a new Path.
                     * @exports message.support.nubugger.DrawObject.Path
                     * @constructor
                     * @param {message.support.nubugger.DrawObject.Path$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.support.nubugger.DrawObject.Path$Properties);

                    /**
                     * Path position.
                     * @type {(vec2$Properties|null)}
                     */
                    public position: (vec2$Properties|null);

                    /**
                     * Path parentIndex.
                     * @type {number}
                     */
                    public parentIndex: number;

                    /**
                     * Creates a new Path instance using the specified properties.
                     * @param {message.support.nubugger.DrawObject.Path$Properties=} [properties] Properties to set
                     * @returns {message.support.nubugger.DrawObject.Path} Path instance
                     */
                    public static create(properties?: message.support.nubugger.DrawObject.Path$Properties): message.support.nubugger.DrawObject.Path;

                    /**
                     * Encodes the specified Path message. Does not implicitly {@link message.support.nubugger.DrawObject.Path.verify|verify} messages.
                     * @param {message.support.nubugger.DrawObject.Path$Properties} message Path message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.support.nubugger.DrawObject.Path$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified Path message, length delimited. Does not implicitly {@link message.support.nubugger.DrawObject.Path.verify|verify} messages.
                     * @param {message.support.nubugger.DrawObject.Path$Properties} message Path message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.support.nubugger.DrawObject.Path$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Path message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.support.nubugger.DrawObject.Path} Path
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.nubugger.DrawObject.Path;

                    /**
                     * Decodes a Path message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.support.nubugger.DrawObject.Path} Path
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.nubugger.DrawObject.Path;

                    /**
                     * Verifies a Path message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a Path message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.support.nubugger.DrawObject.Path} Path
                     */
                    public static fromObject(object: { [k: string]: any }): message.support.nubugger.DrawObject.Path;

                    /**
                     * Creates a Path message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.support.nubugger.DrawObject.Path.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.support.nubugger.DrawObject.Path} Path
                     */
                    public static from(object: { [k: string]: any }): message.support.nubugger.DrawObject.Path;

                    /**
                     * Creates a plain object from a Path message. Also converts values to other types if specified.
                     * @param {message.support.nubugger.DrawObject.Path} message Path
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.support.nubugger.DrawObject.Path, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this Path message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Path to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            type DrawObjects$Properties = {
                objects?: message.support.nubugger.DrawObject$Properties[];
            };

            /**
             * Constructs a new DrawObjects.
             * @exports message.support.nubugger.DrawObjects
             * @constructor
             * @param {message.support.nubugger.DrawObjects$Properties=} [properties] Properties to set
             */
            class DrawObjects {

                /**
                 * Constructs a new DrawObjects.
                 * @exports message.support.nubugger.DrawObjects
                 * @constructor
                 * @param {message.support.nubugger.DrawObjects$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.nubugger.DrawObjects$Properties);

                /**
                 * DrawObjects objects.
                 * @type {Array.<message.support.nubugger.DrawObject$Properties>}
                 */
                public objects: message.support.nubugger.DrawObject$Properties[];

                /**
                 * Creates a new DrawObjects instance using the specified properties.
                 * @param {message.support.nubugger.DrawObjects$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.DrawObjects} DrawObjects instance
                 */
                public static create(properties?: message.support.nubugger.DrawObjects$Properties): message.support.nubugger.DrawObjects;

                /**
                 * Encodes the specified DrawObjects message. Does not implicitly {@link message.support.nubugger.DrawObjects.verify|verify} messages.
                 * @param {message.support.nubugger.DrawObjects$Properties} message DrawObjects message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.nubugger.DrawObjects$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified DrawObjects message, length delimited. Does not implicitly {@link message.support.nubugger.DrawObjects.verify|verify} messages.
                 * @param {message.support.nubugger.DrawObjects$Properties} message DrawObjects message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.nubugger.DrawObjects$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a DrawObjects message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.DrawObjects} DrawObjects
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.nubugger.DrawObjects;

                /**
                 * Decodes a DrawObjects message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.DrawObjects} DrawObjects
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.nubugger.DrawObjects;

                /**
                 * Verifies a DrawObjects message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a DrawObjects message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.DrawObjects} DrawObjects
                 */
                public static fromObject(object: { [k: string]: any }): message.support.nubugger.DrawObjects;

                /**
                 * Creates a DrawObjects message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.DrawObjects.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.DrawObjects} DrawObjects
                 */
                public static from(object: { [k: string]: any }): message.support.nubugger.DrawObjects;

                /**
                 * Creates a plain object from a DrawObjects message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.DrawObjects} message DrawObjects
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.nubugger.DrawObjects, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this DrawObjects message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this DrawObjects to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type Overview$Properties = {
                timestamp?: google.protobuf.Timestamp$Properties;
                robotId?: number;
                roleName?: string;
                battery?: number;
                voltage?: number;
                behaviourState?: message.behaviour.Behaviour.State;
                robotPosition?: fvec3$Properties;
                robotPositionCovariance?: fmat33$Properties;
                ballPosition?: fvec2$Properties;
                ballPositionCovariance?: fmat22$Properties;
                kickTarget?: fvec2$Properties;
                gameMode?: message.input.GameState.Data.Mode;
                gamePhase?: message.input.GameState.Data.Phase;
                penaltyReason?: message.input.GameState.Data.PenaltyReason;
                lastCameraImage?: google.protobuf.Timestamp$Properties;
                lastSeenBall?: google.protobuf.Timestamp$Properties;
                lastSeenGoal?: google.protobuf.Timestamp$Properties;
                walkPathPlan?: fvec2$Properties[];
                walkCommand?: fvec3$Properties;
            };

            /**
             * Constructs a new Overview.
             * @exports message.support.nubugger.Overview
             * @constructor
             * @param {message.support.nubugger.Overview$Properties=} [properties] Properties to set
             */
            class Overview {

                /**
                 * Constructs a new Overview.
                 * @exports message.support.nubugger.Overview
                 * @constructor
                 * @param {message.support.nubugger.Overview$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.nubugger.Overview$Properties);

                /**
                 * Overview timestamp.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public timestamp: (google.protobuf.Timestamp$Properties|null);

                /**
                 * Overview robotId.
                 * @type {number}
                 */
                public robotId: number;

                /**
                 * Overview roleName.
                 * @type {string}
                 */
                public roleName: string;

                /**
                 * Overview battery.
                 * @type {number}
                 */
                public battery: number;

                /**
                 * Overview voltage.
                 * @type {number}
                 */
                public voltage: number;

                /**
                 * Overview behaviourState.
                 * @type {message.behaviour.Behaviour.State}
                 */
                public behaviourState: message.behaviour.Behaviour.State;

                /**
                 * Overview robotPosition.
                 * @type {(fvec3$Properties|null)}
                 */
                public robotPosition: (fvec3$Properties|null);

                /**
                 * Overview robotPositionCovariance.
                 * @type {(fmat33$Properties|null)}
                 */
                public robotPositionCovariance: (fmat33$Properties|null);

                /**
                 * Overview ballPosition.
                 * @type {(fvec2$Properties|null)}
                 */
                public ballPosition: (fvec2$Properties|null);

                /**
                 * Overview ballPositionCovariance.
                 * @type {(fmat22$Properties|null)}
                 */
                public ballPositionCovariance: (fmat22$Properties|null);

                /**
                 * Overview kickTarget.
                 * @type {(fvec2$Properties|null)}
                 */
                public kickTarget: (fvec2$Properties|null);

                /**
                 * Overview gameMode.
                 * @type {message.input.GameState.Data.Mode}
                 */
                public gameMode: message.input.GameState.Data.Mode;

                /**
                 * Overview gamePhase.
                 * @type {message.input.GameState.Data.Phase}
                 */
                public gamePhase: message.input.GameState.Data.Phase;

                /**
                 * Overview penaltyReason.
                 * @type {message.input.GameState.Data.PenaltyReason}
                 */
                public penaltyReason: message.input.GameState.Data.PenaltyReason;

                /**
                 * Overview lastCameraImage.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public lastCameraImage: (google.protobuf.Timestamp$Properties|null);

                /**
                 * Overview lastSeenBall.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public lastSeenBall: (google.protobuf.Timestamp$Properties|null);

                /**
                 * Overview lastSeenGoal.
                 * @type {(google.protobuf.Timestamp$Properties|null)}
                 */
                public lastSeenGoal: (google.protobuf.Timestamp$Properties|null);

                /**
                 * Overview walkPathPlan.
                 * @type {Array.<fvec2$Properties>}
                 */
                public walkPathPlan: fvec2$Properties[];

                /**
                 * Overview walkCommand.
                 * @type {(fvec3$Properties|null)}
                 */
                public walkCommand: (fvec3$Properties|null);

                /**
                 * Creates a new Overview instance using the specified properties.
                 * @param {message.support.nubugger.Overview$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.Overview} Overview instance
                 */
                public static create(properties?: message.support.nubugger.Overview$Properties): message.support.nubugger.Overview;

                /**
                 * Encodes the specified Overview message. Does not implicitly {@link message.support.nubugger.Overview.verify|verify} messages.
                 * @param {message.support.nubugger.Overview$Properties} message Overview message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.nubugger.Overview$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Overview message, length delimited. Does not implicitly {@link message.support.nubugger.Overview.verify|verify} messages.
                 * @param {message.support.nubugger.Overview$Properties} message Overview message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.nubugger.Overview$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Overview message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.Overview} Overview
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.nubugger.Overview;

                /**
                 * Decodes an Overview message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.Overview} Overview
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.nubugger.Overview;

                /**
                 * Verifies an Overview message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an Overview message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.Overview} Overview
                 */
                public static fromObject(object: { [k: string]: any }): message.support.nubugger.Overview;

                /**
                 * Creates an Overview message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.Overview.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.Overview} Overview
                 */
                public static from(object: { [k: string]: any }): message.support.nubugger.Overview;

                /**
                 * Creates a plain object from an Overview message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.Overview} message Overview
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.nubugger.Overview, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Overview message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Overview to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type Ping$Properties = {
                time?: (number|Long);
            };

            /**
             * Constructs a new Ping.
             * @exports message.support.nubugger.Ping
             * @constructor
             * @param {message.support.nubugger.Ping$Properties=} [properties] Properties to set
             */
            class Ping {

                /**
                 * Constructs a new Ping.
                 * @exports message.support.nubugger.Ping
                 * @constructor
                 * @param {message.support.nubugger.Ping$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.nubugger.Ping$Properties);

                /**
                 * Ping time.
                 * @type {number|Long}
                 */
                public time: (number|Long);

                /**
                 * Creates a new Ping instance using the specified properties.
                 * @param {message.support.nubugger.Ping$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.Ping} Ping instance
                 */
                public static create(properties?: message.support.nubugger.Ping$Properties): message.support.nubugger.Ping;

                /**
                 * Encodes the specified Ping message. Does not implicitly {@link message.support.nubugger.Ping.verify|verify} messages.
                 * @param {message.support.nubugger.Ping$Properties} message Ping message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.nubugger.Ping$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Ping message, length delimited. Does not implicitly {@link message.support.nubugger.Ping.verify|verify} messages.
                 * @param {message.support.nubugger.Ping$Properties} message Ping message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.nubugger.Ping$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Ping message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.Ping} Ping
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.nubugger.Ping;

                /**
                 * Decodes a Ping message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.Ping} Ping
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.nubugger.Ping;

                /**
                 * Verifies a Ping message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Ping message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.Ping} Ping
                 */
                public static fromObject(object: { [k: string]: any }): message.support.nubugger.Ping;

                /**
                 * Creates a Ping message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.Ping.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.Ping} Ping
                 */
                public static from(object: { [k: string]: any }): message.support.nubugger.Ping;

                /**
                 * Creates a plain object from a Ping message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.Ping} message Ping
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.nubugger.Ping, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Ping message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Ping to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type ReactionHandles$Properties = {
                handles?: message.support.nubugger.ReactionHandles.Handle$Properties[];
            };

            /**
             * Constructs a new ReactionHandles.
             * @exports message.support.nubugger.ReactionHandles
             * @constructor
             * @param {message.support.nubugger.ReactionHandles$Properties=} [properties] Properties to set
             */
            class ReactionHandles {

                /**
                 * Constructs a new ReactionHandles.
                 * @exports message.support.nubugger.ReactionHandles
                 * @constructor
                 * @param {message.support.nubugger.ReactionHandles$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.nubugger.ReactionHandles$Properties);

                /**
                 * ReactionHandles handles.
                 * @type {Array.<message.support.nubugger.ReactionHandles.Handle$Properties>}
                 */
                public handles: message.support.nubugger.ReactionHandles.Handle$Properties[];

                /**
                 * Creates a new ReactionHandles instance using the specified properties.
                 * @param {message.support.nubugger.ReactionHandles$Properties=} [properties] Properties to set
                 * @returns {message.support.nubugger.ReactionHandles} ReactionHandles instance
                 */
                public static create(properties?: message.support.nubugger.ReactionHandles$Properties): message.support.nubugger.ReactionHandles;

                /**
                 * Encodes the specified ReactionHandles message. Does not implicitly {@link message.support.nubugger.ReactionHandles.verify|verify} messages.
                 * @param {message.support.nubugger.ReactionHandles$Properties} message ReactionHandles message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.nubugger.ReactionHandles$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ReactionHandles message, length delimited. Does not implicitly {@link message.support.nubugger.ReactionHandles.verify|verify} messages.
                 * @param {message.support.nubugger.ReactionHandles$Properties} message ReactionHandles message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.nubugger.ReactionHandles$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ReactionHandles message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nubugger.ReactionHandles} ReactionHandles
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.nubugger.ReactionHandles;

                /**
                 * Decodes a ReactionHandles message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nubugger.ReactionHandles} ReactionHandles
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.nubugger.ReactionHandles;

                /**
                 * Verifies a ReactionHandles message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a ReactionHandles message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.ReactionHandles} ReactionHandles
                 */
                public static fromObject(object: { [k: string]: any }): message.support.nubugger.ReactionHandles;

                /**
                 * Creates a ReactionHandles message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nubugger.ReactionHandles.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nubugger.ReactionHandles} ReactionHandles
                 */
                public static from(object: { [k: string]: any }): message.support.nubugger.ReactionHandles;

                /**
                 * Creates a plain object from a ReactionHandles message. Also converts values to other types if specified.
                 * @param {message.support.nubugger.ReactionHandles} message ReactionHandles
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.nubugger.ReactionHandles, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this ReactionHandles message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this ReactionHandles to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace ReactionHandles {

                type Handle$Properties = {
                    type?: string;
                    enabled?: boolean;
                };

                /**
                 * Constructs a new Handle.
                 * @exports message.support.nubugger.ReactionHandles.Handle
                 * @constructor
                 * @param {message.support.nubugger.ReactionHandles.Handle$Properties=} [properties] Properties to set
                 */
                class Handle {

                    /**
                     * Constructs a new Handle.
                     * @exports message.support.nubugger.ReactionHandles.Handle
                     * @constructor
                     * @param {message.support.nubugger.ReactionHandles.Handle$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.support.nubugger.ReactionHandles.Handle$Properties);

                    /**
                     * Handle type.
                     * @type {string}
                     */
                    public type: string;

                    /**
                     * Handle enabled.
                     * @type {boolean}
                     */
                    public enabled: boolean;

                    /**
                     * Creates a new Handle instance using the specified properties.
                     * @param {message.support.nubugger.ReactionHandles.Handle$Properties=} [properties] Properties to set
                     * @returns {message.support.nubugger.ReactionHandles.Handle} Handle instance
                     */
                    public static create(properties?: message.support.nubugger.ReactionHandles.Handle$Properties): message.support.nubugger.ReactionHandles.Handle;

                    /**
                     * Encodes the specified Handle message. Does not implicitly {@link message.support.nubugger.ReactionHandles.Handle.verify|verify} messages.
                     * @param {message.support.nubugger.ReactionHandles.Handle$Properties} message Handle message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.support.nubugger.ReactionHandles.Handle$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified Handle message, length delimited. Does not implicitly {@link message.support.nubugger.ReactionHandles.Handle.verify|verify} messages.
                     * @param {message.support.nubugger.ReactionHandles.Handle$Properties} message Handle message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.support.nubugger.ReactionHandles.Handle$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Handle message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.support.nubugger.ReactionHandles.Handle} Handle
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.nubugger.ReactionHandles.Handle;

                    /**
                     * Decodes a Handle message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.support.nubugger.ReactionHandles.Handle} Handle
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.nubugger.ReactionHandles.Handle;

                    /**
                     * Verifies a Handle message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a Handle message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.support.nubugger.ReactionHandles.Handle} Handle
                     */
                    public static fromObject(object: { [k: string]: any }): message.support.nubugger.ReactionHandles.Handle;

                    /**
                     * Creates a Handle message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.support.nubugger.ReactionHandles.Handle.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.support.nubugger.ReactionHandles.Handle} Handle
                     */
                    public static from(object: { [k: string]: any }): message.support.nubugger.ReactionHandles.Handle;

                    /**
                     * Creates a plain object from a Handle message. Also converts values to other types if specified.
                     * @param {message.support.nubugger.ReactionHandles.Handle} message Handle
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.support.nubugger.ReactionHandles.Handle, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this Handle message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Handle to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }
        }

        /**
         * Namespace nuclear.
         * @exports message.support.nuclear
         * @namespace
         */
        namespace nuclear {

            type ReactionStatistics$Properties = {
                name?: string;
                triggerName?: string;
                functionName?: string;
                reactionId?: (number|Long);
                taskId?: (number|Long);
                causeReactionId?: (number|Long);
                causeTaskId?: (number|Long);
                emitted?: (number|Long);
                started?: (number|Long);
                finished?: (number|Long);
            };

            /**
             * Constructs a new ReactionStatistics.
             * @exports message.support.nuclear.ReactionStatistics
             * @constructor
             * @param {message.support.nuclear.ReactionStatistics$Properties=} [properties] Properties to set
             */
            class ReactionStatistics {

                /**
                 * Constructs a new ReactionStatistics.
                 * @exports message.support.nuclear.ReactionStatistics
                 * @constructor
                 * @param {message.support.nuclear.ReactionStatistics$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.nuclear.ReactionStatistics$Properties);

                /**
                 * ReactionStatistics name.
                 * @type {string}
                 */
                public name: string;

                /**
                 * ReactionStatistics triggerName.
                 * @type {string}
                 */
                public triggerName: string;

                /**
                 * ReactionStatistics functionName.
                 * @type {string}
                 */
                public functionName: string;

                /**
                 * ReactionStatistics reactionId.
                 * @type {number|Long}
                 */
                public reactionId: (number|Long);

                /**
                 * ReactionStatistics taskId.
                 * @type {number|Long}
                 */
                public taskId: (number|Long);

                /**
                 * ReactionStatistics causeReactionId.
                 * @type {number|Long}
                 */
                public causeReactionId: (number|Long);

                /**
                 * ReactionStatistics causeTaskId.
                 * @type {number|Long}
                 */
                public causeTaskId: (number|Long);

                /**
                 * ReactionStatistics emitted.
                 * @type {number|Long}
                 */
                public emitted: (number|Long);

                /**
                 * ReactionStatistics started.
                 * @type {number|Long}
                 */
                public started: (number|Long);

                /**
                 * ReactionStatistics finished.
                 * @type {number|Long}
                 */
                public finished: (number|Long);

                /**
                 * Creates a new ReactionStatistics instance using the specified properties.
                 * @param {message.support.nuclear.ReactionStatistics$Properties=} [properties] Properties to set
                 * @returns {message.support.nuclear.ReactionStatistics} ReactionStatistics instance
                 */
                public static create(properties?: message.support.nuclear.ReactionStatistics$Properties): message.support.nuclear.ReactionStatistics;

                /**
                 * Encodes the specified ReactionStatistics message. Does not implicitly {@link message.support.nuclear.ReactionStatistics.verify|verify} messages.
                 * @param {message.support.nuclear.ReactionStatistics$Properties} message ReactionStatistics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.nuclear.ReactionStatistics$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified ReactionStatistics message, length delimited. Does not implicitly {@link message.support.nuclear.ReactionStatistics.verify|verify} messages.
                 * @param {message.support.nuclear.ReactionStatistics$Properties} message ReactionStatistics message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.nuclear.ReactionStatistics$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a ReactionStatistics message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.nuclear.ReactionStatistics} ReactionStatistics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.nuclear.ReactionStatistics;

                /**
                 * Decodes a ReactionStatistics message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.nuclear.ReactionStatistics} ReactionStatistics
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.nuclear.ReactionStatistics;

                /**
                 * Verifies a ReactionStatistics message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a ReactionStatistics message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nuclear.ReactionStatistics} ReactionStatistics
                 */
                public static fromObject(object: { [k: string]: any }): message.support.nuclear.ReactionStatistics;

                /**
                 * Creates a ReactionStatistics message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.nuclear.ReactionStatistics.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.nuclear.ReactionStatistics} ReactionStatistics
                 */
                public static from(object: { [k: string]: any }): message.support.nuclear.ReactionStatistics;

                /**
                 * Creates a plain object from a ReactionStatistics message. Also converts values to other types if specified.
                 * @param {message.support.nuclear.ReactionStatistics} message ReactionStatistics
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.nuclear.ReactionStatistics, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this ReactionStatistics message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this ReactionStatistics to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        /**
         * Namespace optimisation.
         * @exports message.support.optimisation
         * @namespace
         */
        namespace optimisation {

            type RegisterOptimisation$Properties = {
                group?: string;
                network?: boolean;
                parameters?: message.support.optimisation.OptimiserParameters$Properties;
            };

            /**
             * Constructs a new RegisterOptimisation.
             * @exports message.support.optimisation.RegisterOptimisation
             * @constructor
             * @param {message.support.optimisation.RegisterOptimisation$Properties=} [properties] Properties to set
             */
            class RegisterOptimisation {

                /**
                 * Constructs a new RegisterOptimisation.
                 * @exports message.support.optimisation.RegisterOptimisation
                 * @constructor
                 * @param {message.support.optimisation.RegisterOptimisation$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.optimisation.RegisterOptimisation$Properties);

                /**
                 * RegisterOptimisation group.
                 * @type {string}
                 */
                public group: string;

                /**
                 * RegisterOptimisation network.
                 * @type {boolean}
                 */
                public network: boolean;

                /**
                 * RegisterOptimisation parameters.
                 * @type {(message.support.optimisation.OptimiserParameters$Properties|null)}
                 */
                public parameters: (message.support.optimisation.OptimiserParameters$Properties|null);

                /**
                 * Creates a new RegisterOptimisation instance using the specified properties.
                 * @param {message.support.optimisation.RegisterOptimisation$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.RegisterOptimisation} RegisterOptimisation instance
                 */
                public static create(properties?: message.support.optimisation.RegisterOptimisation$Properties): message.support.optimisation.RegisterOptimisation;

                /**
                 * Encodes the specified RegisterOptimisation message. Does not implicitly {@link message.support.optimisation.RegisterOptimisation.verify|verify} messages.
                 * @param {message.support.optimisation.RegisterOptimisation$Properties} message RegisterOptimisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.optimisation.RegisterOptimisation$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified RegisterOptimisation message, length delimited. Does not implicitly {@link message.support.optimisation.RegisterOptimisation.verify|verify} messages.
                 * @param {message.support.optimisation.RegisterOptimisation$Properties} message RegisterOptimisation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.optimisation.RegisterOptimisation$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a RegisterOptimisation message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.RegisterOptimisation} RegisterOptimisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.optimisation.RegisterOptimisation;

                /**
                 * Decodes a RegisterOptimisation message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.RegisterOptimisation} RegisterOptimisation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.optimisation.RegisterOptimisation;

                /**
                 * Verifies a RegisterOptimisation message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a RegisterOptimisation message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.RegisterOptimisation} RegisterOptimisation
                 */
                public static fromObject(object: { [k: string]: any }): message.support.optimisation.RegisterOptimisation;

                /**
                 * Creates a RegisterOptimisation message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.RegisterOptimisation.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.RegisterOptimisation} RegisterOptimisation
                 */
                public static from(object: { [k: string]: any }): message.support.optimisation.RegisterOptimisation;

                /**
                 * Creates a plain object from a RegisterOptimisation message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.RegisterOptimisation} message RegisterOptimisation
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.optimisation.RegisterOptimisation, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this RegisterOptimisation message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this RegisterOptimisation to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type RequestParameters$Properties = {
                group?: string;
                nSamples?: number;
            };

            /**
             * Constructs a new RequestParameters.
             * @exports message.support.optimisation.RequestParameters
             * @constructor
             * @param {message.support.optimisation.RequestParameters$Properties=} [properties] Properties to set
             */
            class RequestParameters {

                /**
                 * Constructs a new RequestParameters.
                 * @exports message.support.optimisation.RequestParameters
                 * @constructor
                 * @param {message.support.optimisation.RequestParameters$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.optimisation.RequestParameters$Properties);

                /**
                 * RequestParameters group.
                 * @type {string}
                 */
                public group: string;

                /**
                 * RequestParameters nSamples.
                 * @type {number}
                 */
                public nSamples: number;

                /**
                 * Creates a new RequestParameters instance using the specified properties.
                 * @param {message.support.optimisation.RequestParameters$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.RequestParameters} RequestParameters instance
                 */
                public static create(properties?: message.support.optimisation.RequestParameters$Properties): message.support.optimisation.RequestParameters;

                /**
                 * Encodes the specified RequestParameters message. Does not implicitly {@link message.support.optimisation.RequestParameters.verify|verify} messages.
                 * @param {message.support.optimisation.RequestParameters$Properties} message RequestParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.optimisation.RequestParameters$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified RequestParameters message, length delimited. Does not implicitly {@link message.support.optimisation.RequestParameters.verify|verify} messages.
                 * @param {message.support.optimisation.RequestParameters$Properties} message RequestParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.optimisation.RequestParameters$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a RequestParameters message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.RequestParameters} RequestParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.optimisation.RequestParameters;

                /**
                 * Decodes a RequestParameters message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.RequestParameters} RequestParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.optimisation.RequestParameters;

                /**
                 * Verifies a RequestParameters message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a RequestParameters message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.RequestParameters} RequestParameters
                 */
                public static fromObject(object: { [k: string]: any }): message.support.optimisation.RequestParameters;

                /**
                 * Creates a RequestParameters message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.RequestParameters.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.RequestParameters} RequestParameters
                 */
                public static from(object: { [k: string]: any }): message.support.optimisation.RequestParameters;

                /**
                 * Creates a plain object from a RequestParameters message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.RequestParameters} message RequestParameters
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.optimisation.RequestParameters, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this RequestParameters message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this RequestParameters to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type Parameters$Properties = {
                group?: string;
                generation?: number;
                samples?: mat$Properties;
                covariance?: mat$Properties;
            };

            /**
             * Constructs a new Parameters.
             * @exports message.support.optimisation.Parameters
             * @constructor
             * @param {message.support.optimisation.Parameters$Properties=} [properties] Properties to set
             */
            class Parameters {

                /**
                 * Constructs a new Parameters.
                 * @exports message.support.optimisation.Parameters
                 * @constructor
                 * @param {message.support.optimisation.Parameters$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.optimisation.Parameters$Properties);

                /**
                 * Parameters group.
                 * @type {string}
                 */
                public group: string;

                /**
                 * Parameters generation.
                 * @type {number}
                 */
                public generation: number;

                /**
                 * Parameters samples.
                 * @type {(mat$Properties|null)}
                 */
                public samples: (mat$Properties|null);

                /**
                 * Parameters covariance.
                 * @type {(mat$Properties|null)}
                 */
                public covariance: (mat$Properties|null);

                /**
                 * Creates a new Parameters instance using the specified properties.
                 * @param {message.support.optimisation.Parameters$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.Parameters} Parameters instance
                 */
                public static create(properties?: message.support.optimisation.Parameters$Properties): message.support.optimisation.Parameters;

                /**
                 * Encodes the specified Parameters message. Does not implicitly {@link message.support.optimisation.Parameters.verify|verify} messages.
                 * @param {message.support.optimisation.Parameters$Properties} message Parameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.optimisation.Parameters$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Parameters message, length delimited. Does not implicitly {@link message.support.optimisation.Parameters.verify|verify} messages.
                 * @param {message.support.optimisation.Parameters$Properties} message Parameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.optimisation.Parameters$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Parameters message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.Parameters} Parameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.optimisation.Parameters;

                /**
                 * Decodes a Parameters message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.Parameters} Parameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.optimisation.Parameters;

                /**
                 * Verifies a Parameters message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Parameters message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.Parameters} Parameters
                 */
                public static fromObject(object: { [k: string]: any }): message.support.optimisation.Parameters;

                /**
                 * Creates a Parameters message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.Parameters.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.Parameters} Parameters
                 */
                public static from(object: { [k: string]: any }): message.support.optimisation.Parameters;

                /**
                 * Creates a plain object from a Parameters message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.Parameters} message Parameters
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.optimisation.Parameters, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Parameters message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Parameters to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type Episode$Properties = {
                group?: string;
                generation?: number;
                values?: vec$Properties;
                covariance?: mat$Properties;
                fitness?: message.support.optimisation.Episode.Fitness$Properties[];
            };

            /**
             * Constructs a new Episode.
             * @exports message.support.optimisation.Episode
             * @constructor
             * @param {message.support.optimisation.Episode$Properties=} [properties] Properties to set
             */
            class Episode {

                /**
                 * Constructs a new Episode.
                 * @exports message.support.optimisation.Episode
                 * @constructor
                 * @param {message.support.optimisation.Episode$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.optimisation.Episode$Properties);

                /**
                 * Episode group.
                 * @type {string}
                 */
                public group: string;

                /**
                 * Episode generation.
                 * @type {number}
                 */
                public generation: number;

                /**
                 * Episode values.
                 * @type {(vec$Properties|null)}
                 */
                public values: (vec$Properties|null);

                /**
                 * Episode covariance.
                 * @type {(mat$Properties|null)}
                 */
                public covariance: (mat$Properties|null);

                /**
                 * Episode fitness.
                 * @type {Array.<message.support.optimisation.Episode.Fitness$Properties>}
                 */
                public fitness: message.support.optimisation.Episode.Fitness$Properties[];

                /**
                 * Creates a new Episode instance using the specified properties.
                 * @param {message.support.optimisation.Episode$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.Episode} Episode instance
                 */
                public static create(properties?: message.support.optimisation.Episode$Properties): message.support.optimisation.Episode;

                /**
                 * Encodes the specified Episode message. Does not implicitly {@link message.support.optimisation.Episode.verify|verify} messages.
                 * @param {message.support.optimisation.Episode$Properties} message Episode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.optimisation.Episode$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Episode message, length delimited. Does not implicitly {@link message.support.optimisation.Episode.verify|verify} messages.
                 * @param {message.support.optimisation.Episode$Properties} message Episode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.optimisation.Episode$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Episode message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.Episode} Episode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.optimisation.Episode;

                /**
                 * Decodes an Episode message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.Episode} Episode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.optimisation.Episode;

                /**
                 * Verifies an Episode message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an Episode message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.Episode} Episode
                 */
                public static fromObject(object: { [k: string]: any }): message.support.optimisation.Episode;

                /**
                 * Creates an Episode message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.Episode.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.Episode} Episode
                 */
                public static from(object: { [k: string]: any }): message.support.optimisation.Episode;

                /**
                 * Creates a plain object from an Episode message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.Episode} message Episode
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.optimisation.Episode, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Episode message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Episode to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            namespace Episode {

                type Fitness$Properties = {
                    fitness?: number;
                    weight?: number;
                };

                /**
                 * Constructs a new Fitness.
                 * @exports message.support.optimisation.Episode.Fitness
                 * @constructor
                 * @param {message.support.optimisation.Episode.Fitness$Properties=} [properties] Properties to set
                 */
                class Fitness {

                    /**
                     * Constructs a new Fitness.
                     * @exports message.support.optimisation.Episode.Fitness
                     * @constructor
                     * @param {message.support.optimisation.Episode.Fitness$Properties=} [properties] Properties to set
                     */
                    constructor(properties?: message.support.optimisation.Episode.Fitness$Properties);

                    /**
                     * Fitness fitness.
                     * @type {number}
                     */
                    public fitness: number;

                    /**
                     * Fitness weight.
                     * @type {number}
                     */
                    public weight: number;

                    /**
                     * Creates a new Fitness instance using the specified properties.
                     * @param {message.support.optimisation.Episode.Fitness$Properties=} [properties] Properties to set
                     * @returns {message.support.optimisation.Episode.Fitness} Fitness instance
                     */
                    public static create(properties?: message.support.optimisation.Episode.Fitness$Properties): message.support.optimisation.Episode.Fitness;

                    /**
                     * Encodes the specified Fitness message. Does not implicitly {@link message.support.optimisation.Episode.Fitness.verify|verify} messages.
                     * @param {message.support.optimisation.Episode.Fitness$Properties} message Fitness message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encode(message: message.support.optimisation.Episode.Fitness$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Encodes the specified Fitness message, length delimited. Does not implicitly {@link message.support.optimisation.Episode.Fitness.verify|verify} messages.
                     * @param {message.support.optimisation.Episode.Fitness$Properties} message Fitness message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public static encodeDelimited(message: message.support.optimisation.Episode.Fitness$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                    /**
                     * Decodes a Fitness message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {message.support.optimisation.Episode.Fitness} Fitness
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.optimisation.Episode.Fitness;

                    /**
                     * Decodes a Fitness message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {message.support.optimisation.Episode.Fitness} Fitness
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.optimisation.Episode.Fitness;

                    /**
                     * Verifies a Fitness message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    public static verify(message: { [k: string]: any }): string;

                    /**
                     * Creates a Fitness message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.support.optimisation.Episode.Fitness} Fitness
                     */
                    public static fromObject(object: { [k: string]: any }): message.support.optimisation.Episode.Fitness;

                    /**
                     * Creates a Fitness message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link message.support.optimisation.Episode.Fitness.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {message.support.optimisation.Episode.Fitness} Fitness
                     */
                    public static from(object: { [k: string]: any }): message.support.optimisation.Episode.Fitness;

                    /**
                     * Creates a plain object from a Fitness message. Also converts values to other types if specified.
                     * @param {message.support.optimisation.Episode.Fitness} message Fitness
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public static toObject(message: message.support.optimisation.Episode.Fitness, options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Creates a plain object from this Fitness message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                    /**
                     * Converts this Fitness to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    public toJSON(): { [k: string]: any };
                }
            }

            type Estimate$Properties = {
                group?: string;
                generation?: number;
                values?: vec$Properties;
                covariance?: mat$Properties;
                estimateEpisode?: message.support.optimisation.Episode$Properties[];
                episode?: message.support.optimisation.Episode$Properties[];
            };

            /**
             * Constructs a new Estimate.
             * @exports message.support.optimisation.Estimate
             * @constructor
             * @param {message.support.optimisation.Estimate$Properties=} [properties] Properties to set
             */
            class Estimate {

                /**
                 * Constructs a new Estimate.
                 * @exports message.support.optimisation.Estimate
                 * @constructor
                 * @param {message.support.optimisation.Estimate$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.optimisation.Estimate$Properties);

                /**
                 * Estimate group.
                 * @type {string}
                 */
                public group: string;

                /**
                 * Estimate generation.
                 * @type {number}
                 */
                public generation: number;

                /**
                 * Estimate values.
                 * @type {(vec$Properties|null)}
                 */
                public values: (vec$Properties|null);

                /**
                 * Estimate covariance.
                 * @type {(mat$Properties|null)}
                 */
                public covariance: (mat$Properties|null);

                /**
                 * Estimate estimateEpisode.
                 * @type {Array.<message.support.optimisation.Episode$Properties>}
                 */
                public estimateEpisode: message.support.optimisation.Episode$Properties[];

                /**
                 * Estimate episode.
                 * @type {Array.<message.support.optimisation.Episode$Properties>}
                 */
                public episode: message.support.optimisation.Episode$Properties[];

                /**
                 * Creates a new Estimate instance using the specified properties.
                 * @param {message.support.optimisation.Estimate$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.Estimate} Estimate instance
                 */
                public static create(properties?: message.support.optimisation.Estimate$Properties): message.support.optimisation.Estimate;

                /**
                 * Encodes the specified Estimate message. Does not implicitly {@link message.support.optimisation.Estimate.verify|verify} messages.
                 * @param {message.support.optimisation.Estimate$Properties} message Estimate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.optimisation.Estimate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Estimate message, length delimited. Does not implicitly {@link message.support.optimisation.Estimate.verify|verify} messages.
                 * @param {message.support.optimisation.Estimate$Properties} message Estimate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.optimisation.Estimate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an Estimate message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.Estimate} Estimate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.optimisation.Estimate;

                /**
                 * Decodes an Estimate message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.Estimate} Estimate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.optimisation.Estimate;

                /**
                 * Verifies an Estimate message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an Estimate message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.Estimate} Estimate
                 */
                public static fromObject(object: { [k: string]: any }): message.support.optimisation.Estimate;

                /**
                 * Creates an Estimate message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.Estimate.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.Estimate} Estimate
                 */
                public static from(object: { [k: string]: any }): message.support.optimisation.Estimate;

                /**
                 * Creates a plain object from an Estimate message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.Estimate} message Estimate
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.optimisation.Estimate, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Estimate message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Estimate to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type OptimiserEstimate$Properties = {
                generation?: number;
                estimate?: vec$Properties;
                covariance?: mat$Properties;
            };

            /**
             * Constructs a new OptimiserEstimate.
             * @exports message.support.optimisation.OptimiserEstimate
             * @constructor
             * @param {message.support.optimisation.OptimiserEstimate$Properties=} [properties] Properties to set
             */
            class OptimiserEstimate {

                /**
                 * Constructs a new OptimiserEstimate.
                 * @exports message.support.optimisation.OptimiserEstimate
                 * @constructor
                 * @param {message.support.optimisation.OptimiserEstimate$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.optimisation.OptimiserEstimate$Properties);

                /**
                 * OptimiserEstimate generation.
                 * @type {number}
                 */
                public generation: number;

                /**
                 * OptimiserEstimate estimate.
                 * @type {(vec$Properties|null)}
                 */
                public estimate: (vec$Properties|null);

                /**
                 * OptimiserEstimate covariance.
                 * @type {(mat$Properties|null)}
                 */
                public covariance: (mat$Properties|null);

                /**
                 * Creates a new OptimiserEstimate instance using the specified properties.
                 * @param {message.support.optimisation.OptimiserEstimate$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.OptimiserEstimate} OptimiserEstimate instance
                 */
                public static create(properties?: message.support.optimisation.OptimiserEstimate$Properties): message.support.optimisation.OptimiserEstimate;

                /**
                 * Encodes the specified OptimiserEstimate message. Does not implicitly {@link message.support.optimisation.OptimiserEstimate.verify|verify} messages.
                 * @param {message.support.optimisation.OptimiserEstimate$Properties} message OptimiserEstimate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.optimisation.OptimiserEstimate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified OptimiserEstimate message, length delimited. Does not implicitly {@link message.support.optimisation.OptimiserEstimate.verify|verify} messages.
                 * @param {message.support.optimisation.OptimiserEstimate$Properties} message OptimiserEstimate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.optimisation.OptimiserEstimate$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OptimiserEstimate message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.OptimiserEstimate} OptimiserEstimate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.optimisation.OptimiserEstimate;

                /**
                 * Decodes an OptimiserEstimate message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.OptimiserEstimate} OptimiserEstimate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.optimisation.OptimiserEstimate;

                /**
                 * Verifies an OptimiserEstimate message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an OptimiserEstimate message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.OptimiserEstimate} OptimiserEstimate
                 */
                public static fromObject(object: { [k: string]: any }): message.support.optimisation.OptimiserEstimate;

                /**
                 * Creates an OptimiserEstimate message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.OptimiserEstimate.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.OptimiserEstimate} OptimiserEstimate
                 */
                public static from(object: { [k: string]: any }): message.support.optimisation.OptimiserEstimate;

                /**
                 * Creates a plain object from an OptimiserEstimate message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.OptimiserEstimate} message OptimiserEstimate
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.optimisation.OptimiserEstimate, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this OptimiserEstimate message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this OptimiserEstimate to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type OptimiserParameters$Properties = {
                initial?: message.support.optimisation.OptimiserEstimate$Properties;
                upperBound?: vec$Properties;
                lowerBound?: vec$Properties;
                batchSize?: number;
            };

            /**
             * Constructs a new OptimiserParameters.
             * @exports message.support.optimisation.OptimiserParameters
             * @constructor
             * @param {message.support.optimisation.OptimiserParameters$Properties=} [properties] Properties to set
             */
            class OptimiserParameters {

                /**
                 * Constructs a new OptimiserParameters.
                 * @exports message.support.optimisation.OptimiserParameters
                 * @constructor
                 * @param {message.support.optimisation.OptimiserParameters$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.support.optimisation.OptimiserParameters$Properties);

                /**
                 * OptimiserParameters initial.
                 * @type {(message.support.optimisation.OptimiserEstimate$Properties|null)}
                 */
                public initial: (message.support.optimisation.OptimiserEstimate$Properties|null);

                /**
                 * OptimiserParameters upperBound.
                 * @type {(vec$Properties|null)}
                 */
                public upperBound: (vec$Properties|null);

                /**
                 * OptimiserParameters lowerBound.
                 * @type {(vec$Properties|null)}
                 */
                public lowerBound: (vec$Properties|null);

                /**
                 * OptimiserParameters batchSize.
                 * @type {number}
                 */
                public batchSize: number;

                /**
                 * Creates a new OptimiserParameters instance using the specified properties.
                 * @param {message.support.optimisation.OptimiserParameters$Properties=} [properties] Properties to set
                 * @returns {message.support.optimisation.OptimiserParameters} OptimiserParameters instance
                 */
                public static create(properties?: message.support.optimisation.OptimiserParameters$Properties): message.support.optimisation.OptimiserParameters;

                /**
                 * Encodes the specified OptimiserParameters message. Does not implicitly {@link message.support.optimisation.OptimiserParameters.verify|verify} messages.
                 * @param {message.support.optimisation.OptimiserParameters$Properties} message OptimiserParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.support.optimisation.OptimiserParameters$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified OptimiserParameters message, length delimited. Does not implicitly {@link message.support.optimisation.OptimiserParameters.verify|verify} messages.
                 * @param {message.support.optimisation.OptimiserParameters$Properties} message OptimiserParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.support.optimisation.OptimiserParameters$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes an OptimiserParameters message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.support.optimisation.OptimiserParameters} OptimiserParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.support.optimisation.OptimiserParameters;

                /**
                 * Decodes an OptimiserParameters message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.support.optimisation.OptimiserParameters} OptimiserParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.support.optimisation.OptimiserParameters;

                /**
                 * Verifies an OptimiserParameters message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates an OptimiserParameters message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.OptimiserParameters} OptimiserParameters
                 */
                public static fromObject(object: { [k: string]: any }): message.support.optimisation.OptimiserParameters;

                /**
                 * Creates an OptimiserParameters message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.support.optimisation.OptimiserParameters.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.support.optimisation.OptimiserParameters} OptimiserParameters
                 */
                public static from(object: { [k: string]: any }): message.support.optimisation.OptimiserParameters;

                /**
                 * Creates a plain object from an OptimiserParameters message. Also converts values to other types if specified.
                 * @param {message.support.optimisation.OptimiserParameters} message OptimiserParameters
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.support.optimisation.OptimiserParameters, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this OptimiserParameters message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this OptimiserParameters to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }
    }

    /**
     * Namespace vision.
     * @exports message.vision
     * @namespace
     */
    namespace vision {

        type ClassifiedImage$Properties = {
            sensors?: message.input.Sensors$Properties;
            image?: message.input.Image$Properties;
            dimensions?: uvec2$Properties;
            ballSeedPoints?: message.vision.ClassifiedImage.SeedPoints$Properties[];
            ballPoints?: ivec2$Properties[];
            horizon?: message.vision.Line$Properties;
            visualHorizon?: ivec2$Properties[];
            horizontalSegments?: message.vision.ClassifiedImage.Segment$Properties[];
            verticalSegments?: message.vision.ClassifiedImage.Segment$Properties[];
        };

        /**
         * Constructs a new ClassifiedImage.
         * @exports message.vision.ClassifiedImage
         * @constructor
         * @param {message.vision.ClassifiedImage$Properties=} [properties] Properties to set
         */
        class ClassifiedImage {

            /**
             * Constructs a new ClassifiedImage.
             * @exports message.vision.ClassifiedImage
             * @constructor
             * @param {message.vision.ClassifiedImage$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.vision.ClassifiedImage$Properties);

            /**
             * ClassifiedImage sensors.
             * @type {(message.input.Sensors$Properties|null)}
             */
            public sensors: (message.input.Sensors$Properties|null);

            /**
             * ClassifiedImage image.
             * @type {(message.input.Image$Properties|null)}
             */
            public image: (message.input.Image$Properties|null);

            /**
             * ClassifiedImage dimensions.
             * @type {(uvec2$Properties|null)}
             */
            public dimensions: (uvec2$Properties|null);

            /**
             * ClassifiedImage ballSeedPoints.
             * @type {Array.<message.vision.ClassifiedImage.SeedPoints$Properties>}
             */
            public ballSeedPoints: message.vision.ClassifiedImage.SeedPoints$Properties[];

            /**
             * ClassifiedImage ballPoints.
             * @type {Array.<ivec2$Properties>}
             */
            public ballPoints: ivec2$Properties[];

            /**
             * ClassifiedImage horizon.
             * @type {(message.vision.Line$Properties|null)}
             */
            public horizon: (message.vision.Line$Properties|null);

            /**
             * ClassifiedImage visualHorizon.
             * @type {Array.<ivec2$Properties>}
             */
            public visualHorizon: ivec2$Properties[];

            /**
             * ClassifiedImage horizontalSegments.
             * @type {Array.<message.vision.ClassifiedImage.Segment$Properties>}
             */
            public horizontalSegments: message.vision.ClassifiedImage.Segment$Properties[];

            /**
             * ClassifiedImage verticalSegments.
             * @type {Array.<message.vision.ClassifiedImage.Segment$Properties>}
             */
            public verticalSegments: message.vision.ClassifiedImage.Segment$Properties[];

            /**
             * Creates a new ClassifiedImage instance using the specified properties.
             * @param {message.vision.ClassifiedImage$Properties=} [properties] Properties to set
             * @returns {message.vision.ClassifiedImage} ClassifiedImage instance
             */
            public static create(properties?: message.vision.ClassifiedImage$Properties): message.vision.ClassifiedImage;

            /**
             * Encodes the specified ClassifiedImage message. Does not implicitly {@link message.vision.ClassifiedImage.verify|verify} messages.
             * @param {message.vision.ClassifiedImage$Properties} message ClassifiedImage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.vision.ClassifiedImage$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified ClassifiedImage message, length delimited. Does not implicitly {@link message.vision.ClassifiedImage.verify|verify} messages.
             * @param {message.vision.ClassifiedImage$Properties} message ClassifiedImage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.vision.ClassifiedImage$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ClassifiedImage message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.ClassifiedImage} ClassifiedImage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.ClassifiedImage;

            /**
             * Decodes a ClassifiedImage message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.ClassifiedImage} ClassifiedImage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.ClassifiedImage;

            /**
             * Verifies a ClassifiedImage message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a ClassifiedImage message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.ClassifiedImage} ClassifiedImage
             */
            public static fromObject(object: { [k: string]: any }): message.vision.ClassifiedImage;

            /**
             * Creates a ClassifiedImage message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.ClassifiedImage.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.ClassifiedImage} ClassifiedImage
             */
            public static from(object: { [k: string]: any }): message.vision.ClassifiedImage;

            /**
             * Creates a plain object from a ClassifiedImage message. Also converts values to other types if specified.
             * @param {message.vision.ClassifiedImage} message ClassifiedImage
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.vision.ClassifiedImage, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this ClassifiedImage message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this ClassifiedImage to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace ClassifiedImage {

            /**
             * SegmentClass enum.
             * @name SegmentClass
             * @memberof message.vision.ClassifiedImage
             * @enum {number}
             * @property {number} UNKNOWN_CLASS=0 UNKNOWN_CLASS value
             * @property {number} FIELD=1 FIELD value
             * @property {number} BALL=2 BALL value
             * @property {number} GOAL=3 GOAL value
             * @property {number} LINE=4 LINE value
             * @property {number} CYAN_TEAM=5 CYAN_TEAM value
             * @property {number} MAGENTA_TEAM=6 MAGENTA_TEAM value
             */
            enum SegmentClass {
                UNKNOWN_CLASS = 0,
                FIELD = 1,
                BALL = 2,
                GOAL = 3,
                LINE = 4,
                CYAN_TEAM = 5,
                MAGENTA_TEAM = 6
            }

            type Segment$Properties = {
                segmentClass?: message.vision.ClassifiedImage.SegmentClass;
                length?: number;
                subsample?: number;
                start?: ivec2$Properties;
                end?: ivec2$Properties;
                midpoint?: ivec2$Properties;
                previous?: number;
                next?: number;
            };

            /**
             * Constructs a new Segment.
             * @exports message.vision.ClassifiedImage.Segment
             * @constructor
             * @param {message.vision.ClassifiedImage.Segment$Properties=} [properties] Properties to set
             */
            class Segment {

                /**
                 * Constructs a new Segment.
                 * @exports message.vision.ClassifiedImage.Segment
                 * @constructor
                 * @param {message.vision.ClassifiedImage.Segment$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.vision.ClassifiedImage.Segment$Properties);

                /**
                 * Segment segmentClass.
                 * @type {message.vision.ClassifiedImage.SegmentClass}
                 */
                public segmentClass: message.vision.ClassifiedImage.SegmentClass;

                /**
                 * Segment length.
                 * @type {number}
                 */
                public length: number;

                /**
                 * Segment subsample.
                 * @type {number}
                 */
                public subsample: number;

                /**
                 * Segment start.
                 * @type {(ivec2$Properties|null)}
                 */
                public start: (ivec2$Properties|null);

                /**
                 * Segment end.
                 * @type {(ivec2$Properties|null)}
                 */
                public end: (ivec2$Properties|null);

                /**
                 * Segment midpoint.
                 * @type {(ivec2$Properties|null)}
                 */
                public midpoint: (ivec2$Properties|null);

                /**
                 * Segment previous.
                 * @type {number}
                 */
                public previous: number;

                /**
                 * Segment next.
                 * @type {number}
                 */
                public next: number;

                /**
                 * Creates a new Segment instance using the specified properties.
                 * @param {message.vision.ClassifiedImage.Segment$Properties=} [properties] Properties to set
                 * @returns {message.vision.ClassifiedImage.Segment} Segment instance
                 */
                public static create(properties?: message.vision.ClassifiedImage.Segment$Properties): message.vision.ClassifiedImage.Segment;

                /**
                 * Encodes the specified Segment message. Does not implicitly {@link message.vision.ClassifiedImage.Segment.verify|verify} messages.
                 * @param {message.vision.ClassifiedImage.Segment$Properties} message Segment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.vision.ClassifiedImage.Segment$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Segment message, length delimited. Does not implicitly {@link message.vision.ClassifiedImage.Segment.verify|verify} messages.
                 * @param {message.vision.ClassifiedImage.Segment$Properties} message Segment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.vision.ClassifiedImage.Segment$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Segment message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.vision.ClassifiedImage.Segment} Segment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.ClassifiedImage.Segment;

                /**
                 * Decodes a Segment message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.vision.ClassifiedImage.Segment} Segment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.ClassifiedImage.Segment;

                /**
                 * Verifies a Segment message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Segment message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.ClassifiedImage.Segment} Segment
                 */
                public static fromObject(object: { [k: string]: any }): message.vision.ClassifiedImage.Segment;

                /**
                 * Creates a Segment message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.vision.ClassifiedImage.Segment.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.ClassifiedImage.Segment} Segment
                 */
                public static from(object: { [k: string]: any }): message.vision.ClassifiedImage.Segment;

                /**
                 * Creates a plain object from a Segment message. Also converts values to other types if specified.
                 * @param {message.vision.ClassifiedImage.Segment} message Segment
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.vision.ClassifiedImage.Segment, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Segment message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Segment to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }

            type SeedPoints$Properties = {
                points?: ivec2$Properties[];
            };

            /**
             * Constructs a new SeedPoints.
             * @exports message.vision.ClassifiedImage.SeedPoints
             * @constructor
             * @param {message.vision.ClassifiedImage.SeedPoints$Properties=} [properties] Properties to set
             */
            class SeedPoints {

                /**
                 * Constructs a new SeedPoints.
                 * @exports message.vision.ClassifiedImage.SeedPoints
                 * @constructor
                 * @param {message.vision.ClassifiedImage.SeedPoints$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.vision.ClassifiedImage.SeedPoints$Properties);

                /**
                 * SeedPoints points.
                 * @type {Array.<ivec2$Properties>}
                 */
                public points: ivec2$Properties[];

                /**
                 * Creates a new SeedPoints instance using the specified properties.
                 * @param {message.vision.ClassifiedImage.SeedPoints$Properties=} [properties] Properties to set
                 * @returns {message.vision.ClassifiedImage.SeedPoints} SeedPoints instance
                 */
                public static create(properties?: message.vision.ClassifiedImage.SeedPoints$Properties): message.vision.ClassifiedImage.SeedPoints;

                /**
                 * Encodes the specified SeedPoints message. Does not implicitly {@link message.vision.ClassifiedImage.SeedPoints.verify|verify} messages.
                 * @param {message.vision.ClassifiedImage.SeedPoints$Properties} message SeedPoints message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.vision.ClassifiedImage.SeedPoints$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified SeedPoints message, length delimited. Does not implicitly {@link message.vision.ClassifiedImage.SeedPoints.verify|verify} messages.
                 * @param {message.vision.ClassifiedImage.SeedPoints$Properties} message SeedPoints message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.vision.ClassifiedImage.SeedPoints$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a SeedPoints message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.vision.ClassifiedImage.SeedPoints} SeedPoints
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.ClassifiedImage.SeedPoints;

                /**
                 * Decodes a SeedPoints message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.vision.ClassifiedImage.SeedPoints} SeedPoints
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.ClassifiedImage.SeedPoints;

                /**
                 * Verifies a SeedPoints message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a SeedPoints message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.ClassifiedImage.SeedPoints} SeedPoints
                 */
                public static fromObject(object: { [k: string]: any }): message.vision.ClassifiedImage.SeedPoints;

                /**
                 * Creates a SeedPoints message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.vision.ClassifiedImage.SeedPoints.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.ClassifiedImage.SeedPoints} SeedPoints
                 */
                public static from(object: { [k: string]: any }): message.vision.ClassifiedImage.SeedPoints;

                /**
                 * Creates a plain object from a SeedPoints message. Also converts values to other types if specified.
                 * @param {message.vision.ClassifiedImage.SeedPoints} message SeedPoints
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.vision.ClassifiedImage.SeedPoints, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this SeedPoints message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this SeedPoints to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type LookUpTable$Properties = {
            table?: Uint8Array;
            bitsY?: number;
            bitsCb?: number;
            bitsCr?: number;
        };

        /**
         * Constructs a new LookUpTable.
         * @exports message.vision.LookUpTable
         * @constructor
         * @param {message.vision.LookUpTable$Properties=} [properties] Properties to set
         */
        class LookUpTable {

            /**
             * Constructs a new LookUpTable.
             * @exports message.vision.LookUpTable
             * @constructor
             * @param {message.vision.LookUpTable$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.vision.LookUpTable$Properties);

            /**
             * LookUpTable table.
             * @type {Uint8Array}
             */
            public table: Uint8Array;

            /**
             * LookUpTable bitsY.
             * @type {number}
             */
            public bitsY: number;

            /**
             * LookUpTable bitsCb.
             * @type {number}
             */
            public bitsCb: number;

            /**
             * LookUpTable bitsCr.
             * @type {number}
             */
            public bitsCr: number;

            /**
             * Creates a new LookUpTable instance using the specified properties.
             * @param {message.vision.LookUpTable$Properties=} [properties] Properties to set
             * @returns {message.vision.LookUpTable} LookUpTable instance
             */
            public static create(properties?: message.vision.LookUpTable$Properties): message.vision.LookUpTable;

            /**
             * Encodes the specified LookUpTable message. Does not implicitly {@link message.vision.LookUpTable.verify|verify} messages.
             * @param {message.vision.LookUpTable$Properties} message LookUpTable message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.vision.LookUpTable$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified LookUpTable message, length delimited. Does not implicitly {@link message.vision.LookUpTable.verify|verify} messages.
             * @param {message.vision.LookUpTable$Properties} message LookUpTable message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.vision.LookUpTable$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a LookUpTable message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.LookUpTable} LookUpTable
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.LookUpTable;

            /**
             * Decodes a LookUpTable message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.LookUpTable} LookUpTable
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.LookUpTable;

            /**
             * Verifies a LookUpTable message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a LookUpTable message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.LookUpTable} LookUpTable
             */
            public static fromObject(object: { [k: string]: any }): message.vision.LookUpTable;

            /**
             * Creates a LookUpTable message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.LookUpTable.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.LookUpTable} LookUpTable
             */
            public static from(object: { [k: string]: any }): message.vision.LookUpTable;

            /**
             * Creates a plain object from a LookUpTable message. Also converts values to other types if specified.
             * @param {message.vision.LookUpTable} message LookUpTable
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.vision.LookUpTable, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this LookUpTable message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this LookUpTable to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type SaveLookUpTable$Properties = {};

        /**
         * Constructs a new SaveLookUpTable.
         * @exports message.vision.SaveLookUpTable
         * @constructor
         * @param {message.vision.SaveLookUpTable$Properties=} [properties] Properties to set
         */
        class SaveLookUpTable {

            /**
             * Constructs a new SaveLookUpTable.
             * @exports message.vision.SaveLookUpTable
             * @constructor
             * @param {message.vision.SaveLookUpTable$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.vision.SaveLookUpTable$Properties);

            /**
             * Creates a new SaveLookUpTable instance using the specified properties.
             * @param {message.vision.SaveLookUpTable$Properties=} [properties] Properties to set
             * @returns {message.vision.SaveLookUpTable} SaveLookUpTable instance
             */
            public static create(properties?: message.vision.SaveLookUpTable$Properties): message.vision.SaveLookUpTable;

            /**
             * Encodes the specified SaveLookUpTable message. Does not implicitly {@link message.vision.SaveLookUpTable.verify|verify} messages.
             * @param {message.vision.SaveLookUpTable$Properties} message SaveLookUpTable message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.vision.SaveLookUpTable$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified SaveLookUpTable message, length delimited. Does not implicitly {@link message.vision.SaveLookUpTable.verify|verify} messages.
             * @param {message.vision.SaveLookUpTable$Properties} message SaveLookUpTable message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.vision.SaveLookUpTable$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SaveLookUpTable message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.SaveLookUpTable} SaveLookUpTable
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.SaveLookUpTable;

            /**
             * Decodes a SaveLookUpTable message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.SaveLookUpTable} SaveLookUpTable
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.SaveLookUpTable;

            /**
             * Verifies a SaveLookUpTable message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a SaveLookUpTable message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.SaveLookUpTable} SaveLookUpTable
             */
            public static fromObject(object: { [k: string]: any }): message.vision.SaveLookUpTable;

            /**
             * Creates a SaveLookUpTable message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.SaveLookUpTable.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.SaveLookUpTable} SaveLookUpTable
             */
            public static from(object: { [k: string]: any }): message.vision.SaveLookUpTable;

            /**
             * Creates a plain object from a SaveLookUpTable message. Also converts values to other types if specified.
             * @param {message.vision.SaveLookUpTable} message SaveLookUpTable
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.vision.SaveLookUpTable, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this SaveLookUpTable message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this SaveLookUpTable to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type LookUpTableDiff$Properties = {
            diff?: message.vision.LookUpTableDiff.Diff$Properties[];
        };

        /**
         * Constructs a new LookUpTableDiff.
         * @exports message.vision.LookUpTableDiff
         * @constructor
         * @param {message.vision.LookUpTableDiff$Properties=} [properties] Properties to set
         */
        class LookUpTableDiff {

            /**
             * Constructs a new LookUpTableDiff.
             * @exports message.vision.LookUpTableDiff
             * @constructor
             * @param {message.vision.LookUpTableDiff$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.vision.LookUpTableDiff$Properties);

            /**
             * LookUpTableDiff diff.
             * @type {Array.<message.vision.LookUpTableDiff.Diff$Properties>}
             */
            public diff: message.vision.LookUpTableDiff.Diff$Properties[];

            /**
             * Creates a new LookUpTableDiff instance using the specified properties.
             * @param {message.vision.LookUpTableDiff$Properties=} [properties] Properties to set
             * @returns {message.vision.LookUpTableDiff} LookUpTableDiff instance
             */
            public static create(properties?: message.vision.LookUpTableDiff$Properties): message.vision.LookUpTableDiff;

            /**
             * Encodes the specified LookUpTableDiff message. Does not implicitly {@link message.vision.LookUpTableDiff.verify|verify} messages.
             * @param {message.vision.LookUpTableDiff$Properties} message LookUpTableDiff message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.vision.LookUpTableDiff$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified LookUpTableDiff message, length delimited. Does not implicitly {@link message.vision.LookUpTableDiff.verify|verify} messages.
             * @param {message.vision.LookUpTableDiff$Properties} message LookUpTableDiff message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.vision.LookUpTableDiff$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a LookUpTableDiff message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.LookUpTableDiff} LookUpTableDiff
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.LookUpTableDiff;

            /**
             * Decodes a LookUpTableDiff message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.LookUpTableDiff} LookUpTableDiff
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.LookUpTableDiff;

            /**
             * Verifies a LookUpTableDiff message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a LookUpTableDiff message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.LookUpTableDiff} LookUpTableDiff
             */
            public static fromObject(object: { [k: string]: any }): message.vision.LookUpTableDiff;

            /**
             * Creates a LookUpTableDiff message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.LookUpTableDiff.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.LookUpTableDiff} LookUpTableDiff
             */
            public static from(object: { [k: string]: any }): message.vision.LookUpTableDiff;

            /**
             * Creates a plain object from a LookUpTableDiff message. Also converts values to other types if specified.
             * @param {message.vision.LookUpTableDiff} message LookUpTableDiff
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.vision.LookUpTableDiff, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this LookUpTableDiff message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this LookUpTableDiff to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace LookUpTableDiff {

            type Diff$Properties = {
                lutIndex?: number;
                classification?: number;
            };

            /**
             * Constructs a new Diff.
             * @exports message.vision.LookUpTableDiff.Diff
             * @constructor
             * @param {message.vision.LookUpTableDiff.Diff$Properties=} [properties] Properties to set
             */
            class Diff {

                /**
                 * Constructs a new Diff.
                 * @exports message.vision.LookUpTableDiff.Diff
                 * @constructor
                 * @param {message.vision.LookUpTableDiff.Diff$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.vision.LookUpTableDiff.Diff$Properties);

                /**
                 * Diff lutIndex.
                 * @type {number}
                 */
                public lutIndex: number;

                /**
                 * Diff classification.
                 * @type {number}
                 */
                public classification: number;

                /**
                 * Creates a new Diff instance using the specified properties.
                 * @param {message.vision.LookUpTableDiff.Diff$Properties=} [properties] Properties to set
                 * @returns {message.vision.LookUpTableDiff.Diff} Diff instance
                 */
                public static create(properties?: message.vision.LookUpTableDiff.Diff$Properties): message.vision.LookUpTableDiff.Diff;

                /**
                 * Encodes the specified Diff message. Does not implicitly {@link message.vision.LookUpTableDiff.Diff.verify|verify} messages.
                 * @param {message.vision.LookUpTableDiff.Diff$Properties} message Diff message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.vision.LookUpTableDiff.Diff$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Diff message, length delimited. Does not implicitly {@link message.vision.LookUpTableDiff.Diff.verify|verify} messages.
                 * @param {message.vision.LookUpTableDiff.Diff$Properties} message Diff message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.vision.LookUpTableDiff.Diff$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Diff message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.vision.LookUpTableDiff.Diff} Diff
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.LookUpTableDiff.Diff;

                /**
                 * Decodes a Diff message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.vision.LookUpTableDiff.Diff} Diff
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.LookUpTableDiff.Diff;

                /**
                 * Verifies a Diff message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Diff message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.LookUpTableDiff.Diff} Diff
                 */
                public static fromObject(object: { [k: string]: any }): message.vision.LookUpTableDiff.Diff;

                /**
                 * Creates a Diff message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.vision.LookUpTableDiff.Diff.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.LookUpTableDiff.Diff} Diff
                 */
                public static from(object: { [k: string]: any }): message.vision.LookUpTableDiff.Diff;

                /**
                 * Creates a plain object from a Diff message. Also converts values to other types if specified.
                 * @param {message.vision.LookUpTableDiff.Diff} message Diff
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.vision.LookUpTableDiff.Diff, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Diff message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Diff to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type VisionObject$Properties = {
            timestamp?: google.protobuf.Timestamp$Properties;
            screenAngular?: vec2$Properties;
            angularSize?: vec2$Properties;
            sensors?: message.input.Sensors$Properties;
            classifiedImage?: message.vision.ClassifiedImage$Properties;
            cameraId?: number;
        };

        /**
         * Constructs a new VisionObject.
         * @exports message.vision.VisionObject
         * @constructor
         * @param {message.vision.VisionObject$Properties=} [properties] Properties to set
         */
        class VisionObject {

            /**
             * Constructs a new VisionObject.
             * @exports message.vision.VisionObject
             * @constructor
             * @param {message.vision.VisionObject$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.vision.VisionObject$Properties);

            /**
             * VisionObject timestamp.
             * @type {(google.protobuf.Timestamp$Properties|null)}
             */
            public timestamp: (google.protobuf.Timestamp$Properties|null);

            /**
             * VisionObject screenAngular.
             * @type {(vec2$Properties|null)}
             */
            public screenAngular: (vec2$Properties|null);

            /**
             * VisionObject angularSize.
             * @type {(vec2$Properties|null)}
             */
            public angularSize: (vec2$Properties|null);

            /**
             * VisionObject sensors.
             * @type {(message.input.Sensors$Properties|null)}
             */
            public sensors: (message.input.Sensors$Properties|null);

            /**
             * VisionObject classifiedImage.
             * @type {(message.vision.ClassifiedImage$Properties|null)}
             */
            public classifiedImage: (message.vision.ClassifiedImage$Properties|null);

            /**
             * VisionObject cameraId.
             * @type {number}
             */
            public cameraId: number;

            /**
             * Creates a new VisionObject instance using the specified properties.
             * @param {message.vision.VisionObject$Properties=} [properties] Properties to set
             * @returns {message.vision.VisionObject} VisionObject instance
             */
            public static create(properties?: message.vision.VisionObject$Properties): message.vision.VisionObject;

            /**
             * Encodes the specified VisionObject message. Does not implicitly {@link message.vision.VisionObject.verify|verify} messages.
             * @param {message.vision.VisionObject$Properties} message VisionObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.vision.VisionObject$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified VisionObject message, length delimited. Does not implicitly {@link message.vision.VisionObject.verify|verify} messages.
             * @param {message.vision.VisionObject$Properties} message VisionObject message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.vision.VisionObject$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a VisionObject message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.VisionObject} VisionObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.VisionObject;

            /**
             * Decodes a VisionObject message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.VisionObject} VisionObject
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.VisionObject;

            /**
             * Verifies a VisionObject message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a VisionObject message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.VisionObject} VisionObject
             */
            public static fromObject(object: { [k: string]: any }): message.vision.VisionObject;

            /**
             * Creates a VisionObject message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.VisionObject.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.VisionObject} VisionObject
             */
            public static from(object: { [k: string]: any }): message.vision.VisionObject;

            /**
             * Creates a plain object from a VisionObject message. Also converts values to other types if specified.
             * @param {message.vision.VisionObject} message VisionObject
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.vision.VisionObject, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this VisionObject message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this VisionObject to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type Ball$Properties = {
            visObject?: message.vision.VisionObject$Properties;
            measurements?: message.vision.Ball.Measurement$Properties[];
            edgePoints?: vec3$Properties[];
            circle?: message.Circle$Properties;
        };

        /**
         * Constructs a new Ball.
         * @exports message.vision.Ball
         * @constructor
         * @param {message.vision.Ball$Properties=} [properties] Properties to set
         */
        class Ball {

            /**
             * Constructs a new Ball.
             * @exports message.vision.Ball
             * @constructor
             * @param {message.vision.Ball$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.vision.Ball$Properties);

            /**
             * Ball visObject.
             * @type {(message.vision.VisionObject$Properties|null)}
             */
            public visObject: (message.vision.VisionObject$Properties|null);

            /**
             * Ball measurements.
             * @type {Array.<message.vision.Ball.Measurement$Properties>}
             */
            public measurements: message.vision.Ball.Measurement$Properties[];

            /**
             * Ball edgePoints.
             * @type {Array.<vec3$Properties>}
             */
            public edgePoints: vec3$Properties[];

            /**
             * Ball circle.
             * @type {(message.Circle$Properties|null)}
             */
            public circle: (message.Circle$Properties|null);

            /**
             * Creates a new Ball instance using the specified properties.
             * @param {message.vision.Ball$Properties=} [properties] Properties to set
             * @returns {message.vision.Ball} Ball instance
             */
            public static create(properties?: message.vision.Ball$Properties): message.vision.Ball;

            /**
             * Encodes the specified Ball message. Does not implicitly {@link message.vision.Ball.verify|verify} messages.
             * @param {message.vision.Ball$Properties} message Ball message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.vision.Ball$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Ball message, length delimited. Does not implicitly {@link message.vision.Ball.verify|verify} messages.
             * @param {message.vision.Ball$Properties} message Ball message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.vision.Ball$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Ball message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Ball} Ball
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.Ball;

            /**
             * Decodes a Ball message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.Ball} Ball
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.Ball;

            /**
             * Verifies a Ball message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a Ball message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Ball} Ball
             */
            public static fromObject(object: { [k: string]: any }): message.vision.Ball;

            /**
             * Creates a Ball message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.Ball.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Ball} Ball
             */
            public static from(object: { [k: string]: any }): message.vision.Ball;

            /**
             * Creates a plain object from a Ball message. Also converts values to other types if specified.
             * @param {message.vision.Ball} message Ball
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.vision.Ball, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Ball message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Ball to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace Ball {

            /**
             * MeasurementType enum.
             * @name MeasurementType
             * @memberof message.vision.Ball
             * @enum {number}
             * @property {number} REPROJECTION=0 REPROJECTION value
             * @property {number} WIDTH_BASED=1 WIDTH_BASED value
             */
            enum MeasurementType {
                REPROJECTION = 0,
                WIDTH_BASED = 1
            }

            type Measurement$Properties = {
                type?: message.vision.Ball.MeasurementType;
                rBCc?: vec3$Properties;
                covariance?: mat33$Properties;
            };

            /**
             * Constructs a new Measurement.
             * @exports message.vision.Ball.Measurement
             * @constructor
             * @param {message.vision.Ball.Measurement$Properties=} [properties] Properties to set
             */
            class Measurement {

                /**
                 * Constructs a new Measurement.
                 * @exports message.vision.Ball.Measurement
                 * @constructor
                 * @param {message.vision.Ball.Measurement$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.vision.Ball.Measurement$Properties);

                /**
                 * Measurement type.
                 * @type {message.vision.Ball.MeasurementType}
                 */
                public type: message.vision.Ball.MeasurementType;

                /**
                 * Measurement rBCc.
                 * @type {(vec3$Properties|null)}
                 */
                public rBCc: (vec3$Properties|null);

                /**
                 * Measurement covariance.
                 * @type {(mat33$Properties|null)}
                 */
                public covariance: (mat33$Properties|null);

                /**
                 * Creates a new Measurement instance using the specified properties.
                 * @param {message.vision.Ball.Measurement$Properties=} [properties] Properties to set
                 * @returns {message.vision.Ball.Measurement} Measurement instance
                 */
                public static create(properties?: message.vision.Ball.Measurement$Properties): message.vision.Ball.Measurement;

                /**
                 * Encodes the specified Measurement message. Does not implicitly {@link message.vision.Ball.Measurement.verify|verify} messages.
                 * @param {message.vision.Ball.Measurement$Properties} message Measurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.vision.Ball.Measurement$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Measurement message, length delimited. Does not implicitly {@link message.vision.Ball.Measurement.verify|verify} messages.
                 * @param {message.vision.Ball.Measurement$Properties} message Measurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.vision.Ball.Measurement$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Measurement message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.vision.Ball.Measurement} Measurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.Ball.Measurement;

                /**
                 * Decodes a Measurement message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.vision.Ball.Measurement} Measurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.Ball.Measurement;

                /**
                 * Verifies a Measurement message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Measurement message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.Ball.Measurement} Measurement
                 */
                public static fromObject(object: { [k: string]: any }): message.vision.Ball.Measurement;

                /**
                 * Creates a Measurement message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.vision.Ball.Measurement.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.Ball.Measurement} Measurement
                 */
                public static from(object: { [k: string]: any }): message.vision.Ball.Measurement;

                /**
                 * Creates a plain object from a Measurement message. Also converts values to other types if specified.
                 * @param {message.vision.Ball.Measurement} message Measurement
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.vision.Ball.Measurement, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Measurement message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Measurement to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type Goal$Properties = {
            visObject?: message.vision.VisionObject$Properties;
            side?: message.vision.Goal.Side;
            team?: message.vision.Goal.Team;
            quad?: message.Quad$Properties;
            measurement?: message.vision.Goal.Measurement$Properties[];
        };

        /**
         * Constructs a new Goal.
         * @exports message.vision.Goal
         * @constructor
         * @param {message.vision.Goal$Properties=} [properties] Properties to set
         */
        class Goal {

            /**
             * Constructs a new Goal.
             * @exports message.vision.Goal
             * @constructor
             * @param {message.vision.Goal$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.vision.Goal$Properties);

            /**
             * Goal visObject.
             * @type {(message.vision.VisionObject$Properties|null)}
             */
            public visObject: (message.vision.VisionObject$Properties|null);

            /**
             * Goal side.
             * @type {message.vision.Goal.Side}
             */
            public side: message.vision.Goal.Side;

            /**
             * Goal team.
             * @type {message.vision.Goal.Team}
             */
            public team: message.vision.Goal.Team;

            /**
             * Goal quad.
             * @type {(message.Quad$Properties|null)}
             */
            public quad: (message.Quad$Properties|null);

            /**
             * Goal measurement.
             * @type {Array.<message.vision.Goal.Measurement$Properties>}
             */
            public measurement: message.vision.Goal.Measurement$Properties[];

            /**
             * Creates a new Goal instance using the specified properties.
             * @param {message.vision.Goal$Properties=} [properties] Properties to set
             * @returns {message.vision.Goal} Goal instance
             */
            public static create(properties?: message.vision.Goal$Properties): message.vision.Goal;

            /**
             * Encodes the specified Goal message. Does not implicitly {@link message.vision.Goal.verify|verify} messages.
             * @param {message.vision.Goal$Properties} message Goal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.vision.Goal$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Goal message, length delimited. Does not implicitly {@link message.vision.Goal.verify|verify} messages.
             * @param {message.vision.Goal$Properties} message Goal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.vision.Goal$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Goal message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Goal} Goal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.Goal;

            /**
             * Decodes a Goal message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.Goal} Goal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.Goal;

            /**
             * Verifies a Goal message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a Goal message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Goal} Goal
             */
            public static fromObject(object: { [k: string]: any }): message.vision.Goal;

            /**
             * Creates a Goal message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.Goal.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Goal} Goal
             */
            public static from(object: { [k: string]: any }): message.vision.Goal;

            /**
             * Creates a plain object from a Goal message. Also converts values to other types if specified.
             * @param {message.vision.Goal} message Goal
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.vision.Goal, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Goal message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Goal to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace Goal {

            /**
             * Side enum.
             * @name Side
             * @memberof message.vision.Goal
             * @enum {number}
             * @property {number} UNKNOWN_SIDE=0 UNKNOWN_SIDE value
             * @property {number} LEFT=1 LEFT value
             * @property {number} RIGHT=2 RIGHT value
             */
            enum Side {
                UNKNOWN_SIDE = 0,
                LEFT = 1,
                RIGHT = 2
            }

            /**
             * Team enum.
             * @name Team
             * @memberof message.vision.Goal
             * @enum {number}
             * @property {number} UNKNOWN_TEAM=0 UNKNOWN_TEAM value
             * @property {number} OWN=1 OWN value
             * @property {number} OPPONENT=2 OPPONENT value
             */
            enum Team {
                UNKNOWN_TEAM = 0,
                OWN = 1,
                OPPONENT = 2
            }

            /**
             * MeasurementType enum.
             * @name MeasurementType
             * @memberof message.vision.Goal
             * @enum {number}
             * @property {number} UNKNOWN_MEASUREMENT=0 UNKNOWN_MEASUREMENT value
             * @property {number} LEFT_NORMAL=1 LEFT_NORMAL value
             * @property {number} RIGHT_NORMAL=2 RIGHT_NORMAL value
             * @property {number} TOP_NORMAL=3 TOP_NORMAL value
             * @property {number} BASE_NORMAL=4 BASE_NORMAL value
             * @property {number} CENTRE=5 CENTRE value
             */
            enum MeasurementType {
                UNKNOWN_MEASUREMENT = 0,
                LEFT_NORMAL = 1,
                RIGHT_NORMAL = 2,
                TOP_NORMAL = 3,
                BASE_NORMAL = 4,
                CENTRE = 5
            }

            type Measurement$Properties = {
                type?: message.vision.Goal.MeasurementType;
                position?: vec3$Properties;
                covariance?: mat33$Properties;
                normalAngles?: vec2$Properties;
                normAngCov?: mat22$Properties;
            };

            /**
             * Constructs a new Measurement.
             * @exports message.vision.Goal.Measurement
             * @constructor
             * @param {message.vision.Goal.Measurement$Properties=} [properties] Properties to set
             */
            class Measurement {

                /**
                 * Constructs a new Measurement.
                 * @exports message.vision.Goal.Measurement
                 * @constructor
                 * @param {message.vision.Goal.Measurement$Properties=} [properties] Properties to set
                 */
                constructor(properties?: message.vision.Goal.Measurement$Properties);

                /**
                 * Measurement type.
                 * @type {message.vision.Goal.MeasurementType}
                 */
                public type: message.vision.Goal.MeasurementType;

                /**
                 * Measurement position.
                 * @type {(vec3$Properties|null)}
                 */
                public position: (vec3$Properties|null);

                /**
                 * Measurement covariance.
                 * @type {(mat33$Properties|null)}
                 */
                public covariance: (mat33$Properties|null);

                /**
                 * Measurement normalAngles.
                 * @type {(vec2$Properties|null)}
                 */
                public normalAngles: (vec2$Properties|null);

                /**
                 * Measurement normAngCov.
                 * @type {(mat22$Properties|null)}
                 */
                public normAngCov: (mat22$Properties|null);

                /**
                 * Creates a new Measurement instance using the specified properties.
                 * @param {message.vision.Goal.Measurement$Properties=} [properties] Properties to set
                 * @returns {message.vision.Goal.Measurement} Measurement instance
                 */
                public static create(properties?: message.vision.Goal.Measurement$Properties): message.vision.Goal.Measurement;

                /**
                 * Encodes the specified Measurement message. Does not implicitly {@link message.vision.Goal.Measurement.verify|verify} messages.
                 * @param {message.vision.Goal.Measurement$Properties} message Measurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encode(message: message.vision.Goal.Measurement$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Encodes the specified Measurement message, length delimited. Does not implicitly {@link message.vision.Goal.Measurement.verify|verify} messages.
                 * @param {message.vision.Goal.Measurement$Properties} message Measurement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                public static encodeDelimited(message: message.vision.Goal.Measurement$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

                /**
                 * Decodes a Measurement message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {message.vision.Goal.Measurement} Measurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.Goal.Measurement;

                /**
                 * Decodes a Measurement message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {message.vision.Goal.Measurement} Measurement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.Goal.Measurement;

                /**
                 * Verifies a Measurement message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                public static verify(message: { [k: string]: any }): string;

                /**
                 * Creates a Measurement message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.Goal.Measurement} Measurement
                 */
                public static fromObject(object: { [k: string]: any }): message.vision.Goal.Measurement;

                /**
                 * Creates a Measurement message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link message.vision.Goal.Measurement.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {message.vision.Goal.Measurement} Measurement
                 */
                public static from(object: { [k: string]: any }): message.vision.Goal.Measurement;

                /**
                 * Creates a plain object from a Measurement message. Also converts values to other types if specified.
                 * @param {message.vision.Goal.Measurement} message Measurement
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public static toObject(message: message.vision.Goal.Measurement, options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Creates a plain object from this Measurement message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

                /**
                 * Converts this Measurement to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                public toJSON(): { [k: string]: any };
            }
        }

        type Obstacle$Properties = {
            visObject?: message.vision.VisionObject$Properties;
            shape?: message.Polygon$Properties;
            team?: message.vision.Obstacle.Team;
        };

        /**
         * Constructs a new Obstacle.
         * @exports message.vision.Obstacle
         * @constructor
         * @param {message.vision.Obstacle$Properties=} [properties] Properties to set
         */
        class Obstacle {

            /**
             * Constructs a new Obstacle.
             * @exports message.vision.Obstacle
             * @constructor
             * @param {message.vision.Obstacle$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.vision.Obstacle$Properties);

            /**
             * Obstacle visObject.
             * @type {(message.vision.VisionObject$Properties|null)}
             */
            public visObject: (message.vision.VisionObject$Properties|null);

            /**
             * Obstacle shape.
             * @type {(message.Polygon$Properties|null)}
             */
            public shape: (message.Polygon$Properties|null);

            /**
             * Obstacle team.
             * @type {message.vision.Obstacle.Team}
             */
            public team: message.vision.Obstacle.Team;

            /**
             * Creates a new Obstacle instance using the specified properties.
             * @param {message.vision.Obstacle$Properties=} [properties] Properties to set
             * @returns {message.vision.Obstacle} Obstacle instance
             */
            public static create(properties?: message.vision.Obstacle$Properties): message.vision.Obstacle;

            /**
             * Encodes the specified Obstacle message. Does not implicitly {@link message.vision.Obstacle.verify|verify} messages.
             * @param {message.vision.Obstacle$Properties} message Obstacle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.vision.Obstacle$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Obstacle message, length delimited. Does not implicitly {@link message.vision.Obstacle.verify|verify} messages.
             * @param {message.vision.Obstacle$Properties} message Obstacle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.vision.Obstacle$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes an Obstacle message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Obstacle} Obstacle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.Obstacle;

            /**
             * Decodes an Obstacle message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.Obstacle} Obstacle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.Obstacle;

            /**
             * Verifies an Obstacle message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates an Obstacle message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Obstacle} Obstacle
             */
            public static fromObject(object: { [k: string]: any }): message.vision.Obstacle;

            /**
             * Creates an Obstacle message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.Obstacle.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Obstacle} Obstacle
             */
            public static from(object: { [k: string]: any }): message.vision.Obstacle;

            /**
             * Creates a plain object from an Obstacle message. Also converts values to other types if specified.
             * @param {message.vision.Obstacle} message Obstacle
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.vision.Obstacle, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Obstacle message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Obstacle to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        namespace Obstacle {

            /**
             * Team enum.
             * @name Team
             * @memberof message.vision.Obstacle
             * @enum {number}
             * @property {number} UNKNOWN_TEAM=0 UNKNOWN_TEAM value
             * @property {number} MAGENTA=1 MAGENTA value
             * @property {number} CYAN=2 CYAN value
             */
            enum Team {
                UNKNOWN_TEAM = 0,
                MAGENTA = 1,
                CYAN = 2
            }
        }

        type Line$Properties = {
            visObject?: message.vision.VisionObject$Properties;
            start?: ivec2$Properties;
            end?: ivec2$Properties;
            colour?: vec4$Properties;
        };

        /**
         * Constructs a new Line.
         * @exports message.vision.Line
         * @constructor
         * @param {message.vision.Line$Properties=} [properties] Properties to set
         */
        class Line {

            /**
             * Constructs a new Line.
             * @exports message.vision.Line
             * @constructor
             * @param {message.vision.Line$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.vision.Line$Properties);

            /**
             * Line visObject.
             * @type {(message.vision.VisionObject$Properties|null)}
             */
            public visObject: (message.vision.VisionObject$Properties|null);

            /**
             * Line start.
             * @type {(ivec2$Properties|null)}
             */
            public start: (ivec2$Properties|null);

            /**
             * Line end.
             * @type {(ivec2$Properties|null)}
             */
            public end: (ivec2$Properties|null);

            /**
             * Line colour.
             * @type {(vec4$Properties|null)}
             */
            public colour: (vec4$Properties|null);

            /**
             * Creates a new Line instance using the specified properties.
             * @param {message.vision.Line$Properties=} [properties] Properties to set
             * @returns {message.vision.Line} Line instance
             */
            public static create(properties?: message.vision.Line$Properties): message.vision.Line;

            /**
             * Encodes the specified Line message. Does not implicitly {@link message.vision.Line.verify|verify} messages.
             * @param {message.vision.Line$Properties} message Line message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.vision.Line$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Line message, length delimited. Does not implicitly {@link message.vision.Line.verify|verify} messages.
             * @param {message.vision.Line$Properties} message Line message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.vision.Line$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Line message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.Line} Line
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.Line;

            /**
             * Decodes a Line message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.Line} Line
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.Line;

            /**
             * Verifies a Line message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a Line message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Line} Line
             */
            public static fromObject(object: { [k: string]: any }): message.vision.Line;

            /**
             * Creates a Line message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.Line.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.Line} Line
             */
            public static from(object: { [k: string]: any }): message.vision.Line;

            /**
             * Creates a plain object from a Line message. Also converts values to other types if specified.
             * @param {message.vision.Line} message Line
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.vision.Line, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this Line message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this Line to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type NUsightBalls$Properties = {
            balls?: message.vision.Ball$Properties[];
        };

        /**
         * Constructs a new NUsightBalls.
         * @exports message.vision.NUsightBalls
         * @constructor
         * @param {message.vision.NUsightBalls$Properties=} [properties] Properties to set
         */
        class NUsightBalls {

            /**
             * Constructs a new NUsightBalls.
             * @exports message.vision.NUsightBalls
             * @constructor
             * @param {message.vision.NUsightBalls$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.vision.NUsightBalls$Properties);

            /**
             * NUsightBalls balls.
             * @type {Array.<message.vision.Ball$Properties>}
             */
            public balls: message.vision.Ball$Properties[];

            /**
             * Creates a new NUsightBalls instance using the specified properties.
             * @param {message.vision.NUsightBalls$Properties=} [properties] Properties to set
             * @returns {message.vision.NUsightBalls} NUsightBalls instance
             */
            public static create(properties?: message.vision.NUsightBalls$Properties): message.vision.NUsightBalls;

            /**
             * Encodes the specified NUsightBalls message. Does not implicitly {@link message.vision.NUsightBalls.verify|verify} messages.
             * @param {message.vision.NUsightBalls$Properties} message NUsightBalls message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.vision.NUsightBalls$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified NUsightBalls message, length delimited. Does not implicitly {@link message.vision.NUsightBalls.verify|verify} messages.
             * @param {message.vision.NUsightBalls$Properties} message NUsightBalls message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.vision.NUsightBalls$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NUsightBalls message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.NUsightBalls} NUsightBalls
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.NUsightBalls;

            /**
             * Decodes a NUsightBalls message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.NUsightBalls} NUsightBalls
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.NUsightBalls;

            /**
             * Verifies a NUsightBalls message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a NUsightBalls message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightBalls} NUsightBalls
             */
            public static fromObject(object: { [k: string]: any }): message.vision.NUsightBalls;

            /**
             * Creates a NUsightBalls message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.NUsightBalls.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightBalls} NUsightBalls
             */
            public static from(object: { [k: string]: any }): message.vision.NUsightBalls;

            /**
             * Creates a plain object from a NUsightBalls message. Also converts values to other types if specified.
             * @param {message.vision.NUsightBalls} message NUsightBalls
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.vision.NUsightBalls, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this NUsightBalls message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this NUsightBalls to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type NUsightGoals$Properties = {
            goals?: message.vision.Goal$Properties[];
        };

        /**
         * Constructs a new NUsightGoals.
         * @exports message.vision.NUsightGoals
         * @constructor
         * @param {message.vision.NUsightGoals$Properties=} [properties] Properties to set
         */
        class NUsightGoals {

            /**
             * Constructs a new NUsightGoals.
             * @exports message.vision.NUsightGoals
             * @constructor
             * @param {message.vision.NUsightGoals$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.vision.NUsightGoals$Properties);

            /**
             * NUsightGoals goals.
             * @type {Array.<message.vision.Goal$Properties>}
             */
            public goals: message.vision.Goal$Properties[];

            /**
             * Creates a new NUsightGoals instance using the specified properties.
             * @param {message.vision.NUsightGoals$Properties=} [properties] Properties to set
             * @returns {message.vision.NUsightGoals} NUsightGoals instance
             */
            public static create(properties?: message.vision.NUsightGoals$Properties): message.vision.NUsightGoals;

            /**
             * Encodes the specified NUsightGoals message. Does not implicitly {@link message.vision.NUsightGoals.verify|verify} messages.
             * @param {message.vision.NUsightGoals$Properties} message NUsightGoals message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.vision.NUsightGoals$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified NUsightGoals message, length delimited. Does not implicitly {@link message.vision.NUsightGoals.verify|verify} messages.
             * @param {message.vision.NUsightGoals$Properties} message NUsightGoals message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.vision.NUsightGoals$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NUsightGoals message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.NUsightGoals} NUsightGoals
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.NUsightGoals;

            /**
             * Decodes a NUsightGoals message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.NUsightGoals} NUsightGoals
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.NUsightGoals;

            /**
             * Verifies a NUsightGoals message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a NUsightGoals message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightGoals} NUsightGoals
             */
            public static fromObject(object: { [k: string]: any }): message.vision.NUsightGoals;

            /**
             * Creates a NUsightGoals message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.NUsightGoals.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightGoals} NUsightGoals
             */
            public static from(object: { [k: string]: any }): message.vision.NUsightGoals;

            /**
             * Creates a plain object from a NUsightGoals message. Also converts values to other types if specified.
             * @param {message.vision.NUsightGoals} message NUsightGoals
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.vision.NUsightGoals, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this NUsightGoals message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this NUsightGoals to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type NUsightObstacles$Properties = {
            obstacles?: message.vision.Obstacle$Properties[];
        };

        /**
         * Constructs a new NUsightObstacles.
         * @exports message.vision.NUsightObstacles
         * @constructor
         * @param {message.vision.NUsightObstacles$Properties=} [properties] Properties to set
         */
        class NUsightObstacles {

            /**
             * Constructs a new NUsightObstacles.
             * @exports message.vision.NUsightObstacles
             * @constructor
             * @param {message.vision.NUsightObstacles$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.vision.NUsightObstacles$Properties);

            /**
             * NUsightObstacles obstacles.
             * @type {Array.<message.vision.Obstacle$Properties>}
             */
            public obstacles: message.vision.Obstacle$Properties[];

            /**
             * Creates a new NUsightObstacles instance using the specified properties.
             * @param {message.vision.NUsightObstacles$Properties=} [properties] Properties to set
             * @returns {message.vision.NUsightObstacles} NUsightObstacles instance
             */
            public static create(properties?: message.vision.NUsightObstacles$Properties): message.vision.NUsightObstacles;

            /**
             * Encodes the specified NUsightObstacles message. Does not implicitly {@link message.vision.NUsightObstacles.verify|verify} messages.
             * @param {message.vision.NUsightObstacles$Properties} message NUsightObstacles message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.vision.NUsightObstacles$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified NUsightObstacles message, length delimited. Does not implicitly {@link message.vision.NUsightObstacles.verify|verify} messages.
             * @param {message.vision.NUsightObstacles$Properties} message NUsightObstacles message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.vision.NUsightObstacles$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NUsightObstacles message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.NUsightObstacles} NUsightObstacles
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.NUsightObstacles;

            /**
             * Decodes a NUsightObstacles message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.NUsightObstacles} NUsightObstacles
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.NUsightObstacles;

            /**
             * Verifies a NUsightObstacles message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a NUsightObstacles message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightObstacles} NUsightObstacles
             */
            public static fromObject(object: { [k: string]: any }): message.vision.NUsightObstacles;

            /**
             * Creates a NUsightObstacles message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.NUsightObstacles.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightObstacles} NUsightObstacles
             */
            public static from(object: { [k: string]: any }): message.vision.NUsightObstacles;

            /**
             * Creates a plain object from a NUsightObstacles message. Also converts values to other types if specified.
             * @param {message.vision.NUsightObstacles} message NUsightObstacles
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.vision.NUsightObstacles, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this NUsightObstacles message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this NUsightObstacles to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        type NUsightLines$Properties = {
            lines?: message.vision.Line$Properties[];
        };

        /**
         * Constructs a new NUsightLines.
         * @exports message.vision.NUsightLines
         * @constructor
         * @param {message.vision.NUsightLines$Properties=} [properties] Properties to set
         */
        class NUsightLines {

            /**
             * Constructs a new NUsightLines.
             * @exports message.vision.NUsightLines
             * @constructor
             * @param {message.vision.NUsightLines$Properties=} [properties] Properties to set
             */
            constructor(properties?: message.vision.NUsightLines$Properties);

            /**
             * NUsightLines lines.
             * @type {Array.<message.vision.Line$Properties>}
             */
            public lines: message.vision.Line$Properties[];

            /**
             * Creates a new NUsightLines instance using the specified properties.
             * @param {message.vision.NUsightLines$Properties=} [properties] Properties to set
             * @returns {message.vision.NUsightLines} NUsightLines instance
             */
            public static create(properties?: message.vision.NUsightLines$Properties): message.vision.NUsightLines;

            /**
             * Encodes the specified NUsightLines message. Does not implicitly {@link message.vision.NUsightLines.verify|verify} messages.
             * @param {message.vision.NUsightLines$Properties} message NUsightLines message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encode(message: message.vision.NUsightLines$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified NUsightLines message, length delimited. Does not implicitly {@link message.vision.NUsightLines.verify|verify} messages.
             * @param {message.vision.NUsightLines$Properties} message NUsightLines message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            public static encodeDelimited(message: message.vision.NUsightLines$Properties, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a NUsightLines message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {message.vision.NUsightLines} NUsightLines
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): message.vision.NUsightLines;

            /**
             * Decodes a NUsightLines message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {message.vision.NUsightLines} NUsightLines
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): message.vision.NUsightLines;

            /**
             * Verifies a NUsightLines message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): string;

            /**
             * Creates a NUsightLines message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightLines} NUsightLines
             */
            public static fromObject(object: { [k: string]: any }): message.vision.NUsightLines;

            /**
             * Creates a NUsightLines message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link message.vision.NUsightLines.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {message.vision.NUsightLines} NUsightLines
             */
            public static from(object: { [k: string]: any }): message.vision.NUsightLines;

            /**
             * Creates a plain object from a NUsightLines message. Also converts values to other types if specified.
             * @param {message.vision.NUsightLines} message NUsightLines
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public static toObject(message: message.vision.NUsightLines, options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Creates a plain object from this NUsightLines message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            public toObject(options?: $protobuf.ConversionOptions): { [k: string]: any };

            /**
             * Converts this NUsightLines to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }
}
